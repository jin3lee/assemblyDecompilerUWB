00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 11:52:35 AM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001058             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010AA             38              JSR     END_ADDR
00001016  43F9 00003B86             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 00001268             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 000036A4             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036                            53  
00001036                            54  
00001036  C693                      55              AND.L  (A3),D3
00001038  C89C                      56              AND.L  (A4)+,D4
0000103A  CAA5                      57              AND.L  -(A5),D5
0000103C  CCB8 3331                 58              AND.L  $3331,D6
00001040  CEB9 44444441             59              AND.L  $44444441,D7
00001046                            60              
00001046                            61  
00001046  C793                      62              AND.L  D3,(A3)
00001048  C99C                      63              AND.L  D4,(A4)+
0000104A  CBA5                      64              AND.L  D5,-(A5)
0000104C  CDB8 3331                 65              AND.L  D6,$3331
00001050  CFB9 44444441             66              AND.L  D7,$44444441
00001056                            67  
00001056                            68  
00001056                            69  
00001056                            70  
00001056                            71              
00001056  4E75                      72              RTS
00001058                            73  *---------------------------------------------------------------------------*
00001058                            74  * START_ADDR: Compute the starting address
00001058                            75  *---------------------------------------------------------------------------*
00001058                            76  START_ADDR
00001058                            77              * Output
00001058  43F9 00003979             78              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000105E  103C 000E                 79              MOVE.B  #14,D0                  * Display PROMPT_START
00001062  4E4F                      80              TRAP    #15
00001064                            81      
00001064                            82              * Input
00001064  43F9 00003ADE             83              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000106A  103C 0002                 84              MOVE.B  #2,D0                   * Ask user for input
0000106E  4E4F                      85              TRAP    #15
00001070                            86              
00001070                            87              * Error Checking (length)
00001070  0C01 0000                 88              CMPI.B  #0, D1                  * Check if input length <= 0
00001074  6F00 0098                 89              BLE     ERROR_1
00001078  0C01 0008                 90              CMPI.B  #8, D1                  * Check if input length > 8
0000107C  6E00 0090                 91              BGT     ERROR_1
00001080                            92              
00001080                            93              * Conversion & Storage
00001080  4EB9 0000115E             94              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001086  0C07 0001                 95              CMPI.B  #1, D7                  * Check for error
0000108A  6700 0082                 96              BEQ     ERROR_1                 
0000108E  23C1 00003B7E             97              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001094                            98              
00001094                            99              * Error Checking (Odd)
00001094  43F9 00003B7E            100              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000109A  4EB9 0000124C            101              JSR     IS_ODD                  * Check if the input address is odd
000010A0  0C07 0001                102              CMPI.B  #1, D7                  * Check for error
000010A4  6700 0088                103              BEQ     ERROR_3
000010A8                           104              
000010A8                           105              * Return
000010A8  4E75                     106              RTS     
000010AA                           107  *---------------------------------------------------------------------------*
000010AA                           108  * END_ADDR: Compute the ending address
000010AA                           109  *---------------------------------------------------------------------------*
000010AA                           110  END_ADDR
000010AA                           111              * Output
000010AA  43F9 000039A8            112              LEA     PROMPT_END,A1           * Load PROMPT_END
000010B0  103C 000E                113              MOVE.B  #14,D0                  * Display PROMPT_END
000010B4  4E4F                     114              TRAP    #15
000010B6                           115  
000010B6                           116              * Input
000010B6  43F9 00003B2E            117              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010BC  103C 0002                118              MOVE.B  #2,D0                   * Ask user for input
000010C0  4E4F                     119              TRAP    #15
000010C2                           120              
000010C2                           121              * Error Checking (length)
000010C2  0C01 0000                122              CMPI.B  #0, D1                  * Check if input length <= 0
000010C6  6F00 0056                123              BLE     ERROR_2
000010CA  0C01 0008                124              CMPI.B  #8, D1                  * Check if input length > 8
000010CE  6E00 004E                125              BGT     ERROR_2
000010D2                           126              
000010D2                           127              * Conversion & Storage
000010D2  4EB9 0000115E            128              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010D8  0C07 0001                129              CMPI.B  #1, D7                  * Check for error
000010DC  6700 0040                130              BEQ     ERROR_2
000010E0  23C1 00003B82            131              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010E6                           132              
000010E6                           133              * Error Checking (start > end case)
000010E6  2439 00003B7E            134              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010EC  B282                     135              CMP.L   D2, D1                  * Compare starting and ending address
000010EE  6300 005E                136              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010F2                           137              
000010F2                           138              * Error Checking (Odd case)
000010F2  43F9 00003B82            139              LEA     E_ADDR_HX, A1           * Move the ending address
000010F8  4EB9 0000124C            140              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010FE  0C07 0001                141              CMPI.B  #1, D7                  * Check for an error flag
00001102  6700 003A                142              BEQ     ERROR_4
00001106                           143              
00001106                           144              * Inputs are valid
00001106  2A79 00003B7E            145              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
0000110C                           146              
0000110C  4E75                     147              RTS
0000110E                           148              
0000110E                           149  *---------------------------------------------------------------------------*
0000110E                           150  * ERROR_1: Address error (Invalid starting address)
0000110E                           151  *---------------------------------------------------------------------------*
0000110E                           152  ERROR_1
0000110E  43F9 00003A6D            153              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001114  103C 000E                154              MOVE.B  #14, D0                 * Display ERRMSG_1
00001118  4E4F                     155              TRAP    #15
0000111A  4EF8 1058                156              JMP     START_ADDR              * Jump to START_ADDR
0000111E                           157      
0000111E                           158  *---------------------------------------------------------------------------*
0000111E                           159  * ERROR_2: Address error (Invalid ending address)
0000111E                           160  *---------------------------------------------------------------------------*
0000111E                           161  ERROR_2
0000111E  43F9 00003A6D            162              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001124  103C 000E                163              MOVE.B  #14, D0                 * Display ERRMSG_1
00001128  4E4F                     164              TRAP    #15
0000112A  4EF8 10AA                165              JMP     END_ADDR                * Jump to END_ADDR
0000112E                           166  
0000112E                           167  *---------------------------------------------------------------------------*
0000112E                           168  * ERROR_3: Address error (Odd starting address)
0000112E                           169  *---------------------------------------------------------------------------*
0000112E                           170  ERROR_3
0000112E  43F9 00003A8C            171              LEA     ERRMSG_3, A1
00001134  103C 000E                172              MOVE.B  #14, D0
00001138  4E4F                     173              TRAP    #15
0000113A  4EF8 1058                174              JMP     START_ADDR
0000113E                           175     
0000113E                           176  *---------------------------------------------------------------------------*
0000113E                           177  * ERROR_4: Address error (Odd ending address)
0000113E                           178  *---------------------------------------------------------------------------*         
0000113E                           179  ERROR_4
0000113E  43F9 00003A8C            180              LEA     ERRMSG_3, A1
00001144  103C 000E                181              MOVE.B  #14, D0
00001148  4E4F                     182              TRAP    #15
0000114A  4EF8 10AA                183              JMP     END_ADDR
0000114E                           184            
0000114E                           185  *---------------------------------------------------------------------------*
0000114E                           186  * ERROR_3: Address error (Ending address is less than starting address)
0000114E                           187  *---------------------------------------------------------------------------*
0000114E                           188  ERROR_5
0000114E  43F9 00003AB1            189              LEA     ERRMSG_5, A1
00001154  103C 000E                190              MOVE.B  #14, D0
00001158  4E4F                     191              TRAP    #15
0000115A  4EF8 10AA                192              JMP     END_ADDR
0000115E                           193    
0000115E                           194  *---------------------------------------------------------------------------*
0000115E                           195  * ASCII2HEX: Convert ASCii to Hexadecimal
0000115E                           196  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000115E                           197  *---------------------------------------------------------------------------*
0000115E  4281                     198  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001160  4287                     199              CLR.L   D7                      * Set the error flag to 0
00001162  4282                     200              CLR.L   D2                      * Clear D2 for temp storage
00001164                           201              
00001164  1419                     202  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001166  0C02 0000                203              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000116A  6700 0058                204              BEQ     RETURN                  * If it's NULL, go to return
0000116E  0C02 0066                205              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001172  6E00 004C                206              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001176  0C02 0061                207              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000117A  6C00 0026                208              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000117E  0C02 0046                209              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001182  6E00 003C                210              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001186  0C02 0041                211              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000118A  6C00 001E                212              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000118E  0C02 0039                213              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001192  6E00 002C                214              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001196  0C02 0030                215              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000119A  6C00 0016                216              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000119E  6000 0020                217              BRA     ASC_ERR                 * Invalid input
000011A2                           218  
000011A2  0442 0057                219  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011A6  6000 0012                220              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AA                           221              
000011AA  0442 0037                222  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011AE  6000 000A                223              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011B2                           224              
000011B2  0442 0030                225  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011B6  6000 0002                226              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011BA                           227              
000011BA  E981                     228  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011BC  D202                     229              ADD.B   D2, D1                  * Add the converted input to D1
000011BE  60A4                     230              BRA     ASC2HXLP                * Loop
000011C0                           231  
000011C0  1E3C 0001                232  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011C4  4E75                     233  RETURN      RTS     
000011C6                           234  
000011C6                           235  *---------------------------------------------------------------------------*
000011C6                           236  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011C6                           237  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011C6                           238  *---------------------------------------------------------------------------*
000011C6  0C02 0008                239  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011CA  6700 000E                240              BEQ     HEX_LOOP
000011CE  4841                     241              SWAP    D1
000011D0  0C02 0002                242              CMPI.B  #2,D2
000011D4  6600 0004                243              BNE     HEX_LOOP
000011D8  E189                     244              LSL.L   #8,D1
000011DA                           245             
000011DA  E999                     246  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011DC  2601                     247              MOVE.L  D1, D3                  * Move D1 to D3
000011DE  0283 0000000F            248              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011E4  0C03 0009                249              CMPI.B  #9, D3                  * Compare te digit
000011E8  6E00 000A                250              BGT     HEX_CHAR              
000011EC  0603 0030                251              ADDI.B  #48,D3                  * Add 48 for numerical output
000011F0  6000 0006                252              BRA     HEX_CONT
000011F4                           253              
000011F4  0603 0037                254  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011F8                           255  
000011F8  12C3                     256  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011FA  5342                     257              SUBI    #1, D2                  * Decrement the size
000011FC  0C02 0000                258              CMPI.B  #0, D2                  * Check if D2 is 0
00001200  66D8                     259              BNE     HEX_LOOP                * Loop
00001202  12BC 0000                260              MOVE.B  #$0,(A1)                * Null terminator
00001206  4E75                     261              RTS
00001208                           262  *---------------------------------------------------------------------------*
00001208                           263  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001208                           264  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001208                           265  *---------------------------------------------------------------------------*
00001208                           266  HEX2ASCII2STACK
00001208  0C02 0008                267              CMPI.B  #8, D2                  * Check to see if the size is long
0000120C  6700 000E                268              BEQ     STACK_HEX_LOOP
00001210  4841                     269              SWAP    D1
00001212  0C02 0002                270              CMPI.B  #2,D2
00001216  6600 0004                271              BNE     STACK_HEX_LOOP
0000121A  E189                     272              LSL.L   #8,D1
0000121C                           273             
0000121C                           274  STACK_HEX_LOOP    
0000121C  E999                     275              ROL.L   #4, D1                  * Roll D1 to left
0000121E  2601                     276              MOVE.L  D1, D3                  * Move D1 to D3
00001220  0283 0000000F            277              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001226  0C03 0009                278              CMPI.B  #9, D3                  * Compare te digit
0000122A  6E00 000A                279              BGT     STACK_HEX_CHAR              
0000122E  0603 0030                280              ADDI.B  #48,D3                  * Add 48 for numerical output
00001232  6000 0006                281              BRA     STACK_HEX_CONT
00001236                           282              
00001236                           283  STACK_HEX_CHAR    
00001236  0603 0037                284              ADDI.B  #55,D3                  * Add 55 for character output
0000123A                           285  
0000123A                           286  STACK_HEX_CONT    
0000123A  6100 23D8                287              BSR     PUSH_STACK              *PLACE INTO STACK
0000123E  5342                     288              SUBI    #1, D2                  * Decrement the size
00001240  0C02 0000                289              CMPI.B  #0, D2                  * Check if D2 is 0
00001244  66D6                     290              BNE     STACK_HEX_LOOP                * Loop
00001246  12BC 0000                291              MOVE.B  #$0,(A1)                * Null terminator
0000124A  4E75                     292              RTS
0000124C                           293  
0000124C                           294  
0000124C                           295  *---------------------------------------------------------------------------*
0000124C                           296  * IS_ODD: Check whether the source address is odd
0000124C                           297  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000124C                           298  *---------------------------------------------------------------------------*
0000124C  4281                     299  IS_ODD      CLR.L   D1                      * Clear the result
0000124E  4287                     300              CLR.L   D7                      * Set the error flag to 0
00001250  2211                     301              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001252  82FC 0002                302              DIVU    #2, D1                  * Divide the result by 2
00001256  4841                     303              SWAP    D1                      * Swap remainder with quotient
00001258  0C01 0001                304              CMPI.B  #1, D1                  * Check for error
0000125C  6700 0004                305              BEQ     IS_ODD_ERR
00001260  4E75                     306              RTS
00001262                           307              
00001262  1E3C 0001                308  IS_ODD_ERR  MOVE.B  #1, D7
00001266  4E75                     309              RTS
00001268                           310  
00001268                           311  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
00001268                           312  * MAIN                    
00001268                           313  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
00001268                           314  * A5: Processing address
00001268                           315  *
00001268                           316  * D3: USED FOR PUSHING INTO STACK
00001268                           317  *     To push into stack => MOVE.W #DATA,D3 
00001268                           318  *                           BSR    PUSH_STACK
00001268                           319  *     To print stack     => BSR    PRINT_STACK 
00001268                           320  *     To clear stack     => BSR    CLEAR_STACK
00001268                           321  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
00001268                           322  MAIN        
00001268                           323              *initialize stack pointer
00001268  33FC 0000 00003F36       324              MOVE.W  #0,COUNTER
00001270  347C 7000                325              MOVEA.W #STACK,A2
00001274  163C 0020                326              MOVE.B  #' ',D3
00001278  6100 239A                327              BSR     PUSH_STACK
0000127C  6100 2396                328              BSR     PUSH_STACK
00001280  6100 2392                329              BSR     PUSH_STACK
00001284                           330              
00001284                           331              * clear registers for temp storage
00001284  4280                     332              CLR.L   D0                   
00001286  4281                     333              CLR.L   D1                   
00001288  227C 00000000            334              MOVEA.L #0, A1                
0000128E                           335              
0000128E  220D                     336              MOVE.L  A5,D1                   * check to see if the address is fully read
00001290  23CD 00003B7E            337              MOVE.L  A5,S_ADDR_HX
00001296  B2B9 00003B82            338              CMP.L   E_ADDR_HX,D1
0000129C  6C00 1A96                339              BGE     REPEAT                  * go to repeat for user action
000012A0                           340  
000012A0  43F9 00003BD9            341              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012A6  143C 0008                342              MOVE.B  #8,D2                   * set the output size
000012AA  4EB8 11C6                343              JSR     HEX2ASCII               
000012AE  43F9 00003BD9            344              LEA     TMPOUTPUT,A1
000012B4  103C 000E                345              MOVE.B  #14,D0
000012B8  4E4F                     346              TRAP    #15
000012BA                           347              
000012BA  4285                     348              CLR.L    D5                      * clear the processing data
000012BC  3A1D                     349              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012BE                           350                                               * advance the current instruction pointer to the next
000012BE                           351                                               * instruction in memory
000012BE                           352  *----------------------------------------*
000012BE                           353  * Registers          
000012BE                           354  * [D1] - COPY OF D5
000012BE                           355  * [D5] - DATA TO BE PROCESSED
000012BE                           356  * [D6] - COUNTER FOR LINES PROCESSED
000012BE                           357  *
000012BE                           358  * [D4]      - ERROR FLAG BEFORE PRINTING
000012BE                           359  * [STACK]   - PRINTS PROCESS DATA
000012BE                           360  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012BE                           361  *
000012BE                           362  * [A1] - USED FOR JUMPING/PRINTING
000012BE                           363  *
000012BE                           364  *----------------------------------------*
000012BE                           365  
000012BE                           366              
000012BE                           367              *Processing the first 4 most significant bits 
000012BE  2205                     368              MOVE.L  D5,D1                    * copy the current processing data to D1
000012C0  143C 000C                369              MOVE.B  #12,D2                   * shift to right by 12 bits
000012C4  E469                     370              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012C6  C2FC 0006                371              MULU    #6,D1                    * form offset
000012CA  43F9 00001338            372              LEA     JMPTABLE,A1              * index into table
000012D0  4EB1 1000                373              JSR     0(A1,D1)                 * jump indirect with index
000012D4                           374              
000012D4                           375              *SECURED EA*
000012D4  B83C 0001                376              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012D8  6600 0012                377              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012DC  6100 01E8                378              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012E0  6100 239E                379              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012E4  183C 0000                380              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012E8  6000 0022                381              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012EC                           382             
000012EC                           383  OUTPUT_PROCESSED_DATA       
000012EC  163C 000D                384              MOVE.B  #$D,D3                  *carriage return
000012F0  6100 2322                385              BSR     PUSH_STACK
000012F4  163C 000A                386              MOVE.B  #$A,D3                  *new line feed
000012F8  6100 231A                387              BSR     PUSH_STACK
000012FC  163C 0000                388              MOVE.B  #$0,D3                  *null
00001300  6100 2312                389              BSR     PUSH_STACK
00001304                           390       
00001304  6100 22EA                391              BSR     PRINT_QUEUE
00001308  183C 0000                392              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000130C                           393  DISPLAY_30_LINES
0000130C                           394              * display 30 lines per page
0000130C  5206                     395              ADDI.B  #1,D6
0000130E  0C06 001E                396              CMPI.B  #30,D6
00001312  6C00 0006                397              BGE     NEXTLINES
00001316  6000 FF50                398              BRA     MAIN
0000131A                           399            
0000131A                           400  *---------------------------------------------------------------------------*
0000131A                           401  * NEXTLINES: receive input from user to print the next 30 lines
0000131A                           402  *---------------------------------------------------------------------------*  
0000131A  4206                     403  NEXTLINES   CLR.B   D6
0000131C  43F9 000039D5            404              LEA     DISP_NEXT,A1
00001322  103C 000E                405              MOVE.B  #14,D0
00001326  4E4F                     406              TRAP    #15
00001328  43F9 00003B89            407              LEA     TMPINPUT,A1
0000132E  103C 0002                408              MOVE.B  #2,D0
00001332  4E4F                     409              TRAP    #15
00001334  4EF8 1268                410              JMP     MAIN
00001338                           411    
00001338                           412  *---------------------------------------------------------------------------*
00001338                           413  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001338                           414  *---------------------------------------------------------------------------*  
00001338  4EF9 00001398            415  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
0000133E  4EF9 000015BE            416              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001344  4EF9 0000162C            417              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000134A  4EF9 0000172A            418              JMP     OP0011  * MOVE.W/MOVEA.W
00001350  4EF9 00001826            419              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS
00001356  4EF9 000019C0            420              JMP     OP0101  * ADDQ  
0000135C  4EF9 00001A3C            421              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)
00001362  4EF9 00001ACA            422              JMP     OP0111  * MOVEQ (unassigned)
00001368  4EF9 00001ACE            423              JMP     OP1000  * DIVS
0000136E  4EF9 00001B0A            424              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001374  4EF9 00001EC6            425              JMP     OP1010  * Unassigned 
0000137A  4EF9 00001ECA            426              JMP     OP1011  * CMP/EOR/CMPA
00001380  4EF9 00001FC6            427              JMP     OP1100  * MULS/AND                                      *WORKING ON "AND" - JOSEPH
00001386  4EF9 00002238            428              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000138C  4EF9 00002614            429              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001392  4EF9 000028C2            430              JMP     OP1111  * Special/Reserved
00001398                           431              
00001398                           432  *---------------------------------------------------------------------------*
00001398                           433  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
00001398                           434  *---------------------------------------------------------------------------*           
00001398                           435  OP0000                                                                                  
00001398  4281                     436              CLR.L   D1          * to temporarily store the address to process
0000139A  4280                     437              CLR.L   D0  
0000139C  4284                     438              CLR.L   D4                 
0000139E  227C 00000000            439              MOVEA.L #0, A1                
000013A4                           440              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013A4                           441              * Check if bit 11,10,9,8 are 0000)
000013A4  2205                     442              MOVE.L  D5,D1
000013A6  0281 00000F00            443              ANDI.L  #$0F00,D1
000013AC  0C81 00000000            444              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013B2  6700 01B4                445              BEQ     OP_ORI
000013B6                           446  
000013B6                           447              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013B6                           448              * check if bit 11,10,9,8 are 1100
000013B6  4281                     449              CLR.L   D1
000013B8  2205                     450              MOVE.L  D5,D1
000013BA  0281 00000F00            451              ANDI.L  #$0F00,D1
000013C0  0C81 00000C00            452              CMPI.L  #$0C00,D1
000013C6  6700 014A                453              BEQ     OP_CMPI
000013CA                           454              
000013CA                           455              * check for SUBI
000013CA  4281                     456              CLR.L   D1
000013CC  2205                     457              MOVE.L  D5,D1
000013CE  0281 00000F00            458              ANDI.L  #$0F00,D1
000013D4  0C81 00000400            459              CMPI.L  #$0400,D1
000013DA  6700 0094                460              BEQ     OP_SUBI
000013DE                           461              
000013DE                           462              * check for EORI
000013DE  4281                     463              CLR.L   D1
000013E0  2205                     464              MOVE.L  D5,D1
000013E2  0281 00000F00            465              ANDI.L  #$0F00,D1
000013E8  0C81 00000A00            466              CMPI.L  #$0A00,D1
000013EE  6700 002A                467              BEQ     OP_EORI
000013F2                           468              
000013F2                           469              * check for BTST
000013F2  4281                     470              CLR.L   D1
000013F4  2205                     471              MOVE.L  D5,D1
000013F6  EA99                     472              ROR.L   #5,D1
000013F8  0281 00000008            473              ANDI.L  #$8,D1
000013FE  0C01 0008                474              CMPI.B  #8,D1
00001402  6700 0008                475              BEQ     OP_BTST
00001406                           476  
00001406                           477              * OP0000 series other than ORI/CMPI/BTST/EORI
00001406  4EF9 000014C6            478              JMP     OP_DATA
0000140C                           479              
0000140C                           480  *---------------------------------------------------------------------------*
0000140C                           481  * OP_BTST: display BTST
0000140C                           482  *---------------------------------------------------------------------------* 
0000140C  43F9 00003C62            483  OP_BTST     LEA     DISP_BTST,A1
00001412  103C 000E                484              MOVE.B  #14,D0
00001416  4E4F                     485              TRAP    #15
00001418  4E75                     486              RTS
0000141A                           487  
0000141A                           488  *---------------------------------------------------------------------------*
0000141A                           489  * OP_EORI: decode and display EORI
0000141A                           490  *---------------------------------------------------------------------------* 
0000141A                           491  OP_EORI
0000141A  4281                     492              CLR.L   D1
0000141C  4284                     493              CLR.L   D4
0000141E  2205                     494              MOVE.L  D5,D1
00001420  EC99                     495              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001422  0C01 0000                496              CMPI.B  #0,D1
00001426  6700 0012                497              BEQ     OP_EORI_B    * size is byte
0000142A  0C01 0001                498              CMPI.B  #1,D1
0000142E  6700 001C                499              BEQ     OP_EORI_W    * size is word
00001432  0C01 0002                500              CMPI.B  #2,D1
00001436  6700 0026                501              BEQ     OP_EORI_L    * size is long
0000143A                           502  
0000143A                           503  OP_EORI_B    * size is byte    
0000143A  183C 0000                504              MOVE.B  #0,D4
0000143E  43F9 00003C44            505              LEA     DISP_EORI_B,A1
00001444  103C 000E                506              MOVE.B  #14,D0
00001448  4E4F                     507              TRAP    #15
0000144A  4E75                     508              RTS
0000144C                           509              
0000144C                           510  OP_EORI_W    * size is word
0000144C  183C 0001                511              MOVE.B  #1,D4
00001450  43F9 00003C4E            512              LEA     DISP_EORI_W,A1
00001456  103C 000E                513              MOVE.B  #14,D0
0000145A  4E4F                     514              TRAP    #15
0000145C  4E75                     515              RTS
0000145E                           516              
0000145E                           517  OP_EORI_L    * size is long
0000145E  183C 0002                518              MOVE.B  #2,D4
00001462  43F9 00003C58            519              LEA     DISP_EORI_L,A1
00001468  103C 000E                520              MOVE.B  #14,D0
0000146C  4E4F                     521              TRAP    #15
0000146E  4E75                     522              RTS
00001470                           523              
00001470                           524  *---------------------------------------------------------------------------*
00001470                           525  * OP_SUBI: decode SUBI.B/.W/.L
00001470                           526  *---------------------------------------------------------------------------* 
00001470                           527  OP_SUBI
00001470  4281                     528              CLR.L   D1
00001472  4284                     529              CLR.L   D4
00001474  2205                     530              MOVE.L  D5,D1
00001476  EC99                     531              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001478  0C01 0000                532              CMPI.B  #0,D1
0000147C  6700 0012                533              BEQ     OP_SUBI_B    * size is byte
00001480  0C01 0001                534              CMPI.B  #1,D1
00001484  6700 001C                535              BEQ     OP_SUBI_W    * size is word
00001488  0C01 0002                536              CMPI.B  #2,D1
0000148C  6700 0026                537              BEQ     OP_SUBI_L    * size is long
00001490                           538  
00001490                           539  OP_SUBI_B    * size is byte    
00001490  183C 0000                540              MOVE.B  #0,D4
00001494  43F9 00003D50            541              LEA     DISP_SUBI_B,A1
0000149A  103C 000E                542              MOVE.B  #14,D0
0000149E  4E4F                     543              TRAP    #15
000014A0  4E75                     544              RTS
000014A2                           545              
000014A2                           546  OP_SUBI_W    * size is word
000014A2  183C 0001                547              MOVE.B  #1,D4
000014A6  43F9 00003D5A            548              LEA     DISP_SUBI_W,A1
000014AC  103C 000E                549              MOVE.B  #14,D0
000014B0  4E4F                     550              TRAP    #15
000014B2  4E75                     551              RTS
000014B4                           552              
000014B4                           553  OP_SUBI_L    * size is long
000014B4  183C 0002                554              MOVE.B  #2,D4
000014B8  43F9 00003D64            555              LEA     DISP_SUBI_L,A1
000014BE  103C 000E                556              MOVE.B  #14,D0
000014C2  4E4F                     557              TRAP    #15
000014C4  4E75                     558              RTS
000014C6                           559              
000014C6                           560  *---------------------------------------------------------------------------*
000014C6                           561  * OP_DATA : unidentified opcode
000014C6                           562  *---------------------------------------------------------------------------* 
000014C6                           563  OP_DATA
000014C6  4280                     564              CLR.L   D0                   
000014C8  4281                     565              CLR.L   D1     
000014CA  4284                     566              CLR.L   D4                    
000014CC  227C 00000000            567              MOVEA.L #0, A1             
000014D2  4287                     568              CLR.L   D7
000014D4  1E3C 0001                569              MOVE.B  #1,D7                   * error flag is true
000014D8                           570              
000014D8  43F9 00003C88            571              LEA     DISP_DATA,A1
000014DE  103C 000E                572              MOVE.B  #14,D0
000014E2  4E4F                     573              TRAP    #15
000014E4                           574              
000014E4  4EF9 000014EA            575              JMP     EA_DATA
000014EA                           576             
000014EA                           577             
000014EA                           578  *---------------------------------------------------------------------------*
000014EA                           579  * EA_DATA
000014EA                           580  *---------------------------------------------------------------------------*       
000014EA  43F9 00003BD9            581  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014F0  2205                     582              MOVE.L  D5,D1           * transfer the processing data to D1
000014F2  7404                     583              MOVE.L  #4,D2           * set to word size
000014F4  4EB8 11C6                584              JSR     HEX2ASCII       * prepare output in ascii
000014F8  43F9 00003EFB            585              LEA     DISP_HEX,A1     * display $ symbol
000014FE  103C 000E                586              MOVE.B  #14,D0      
00001502  4E4F                     587              TRAP    #15
00001504  43F9 00003BD9            588              LEA     TMPOUTPUT,A1    * display with a new line
0000150A  103C 000D                589              MOVE.B  #13,D0
0000150E  4E4F                     590              TRAP    #15
00001510                           591  
00001510  4E75                     592              RTS
00001512                           593              
00001512                           594  *---------------------------------------------------------------------------*
00001512                           595  * OP_CMPI : decode CMPI and its size
00001512                           596  *---------------------------------------------------------------------------*          
00001512                           597  OP_CMPI
00001512  4281                     598              CLR.L   D1
00001514  4284                     599              CLR.L   D4
00001516  2205                     600              MOVE.L  D5,D1
00001518  EC99                     601              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000151A  0C01 0000                602              CMPI.B  #0,D1
0000151E  6700 0012                603              BEQ     OP_CMPI_B    * size is byte
00001522  0C01 0001                604              CMPI.B  #1,D1
00001526  6700 001C                605              BEQ     OP_CMPI_W    * size is word
0000152A  0C01 0002                606              CMPI.B  #2,D1
0000152E  6700 0026                607              BEQ     OP_CMPI_L    * size is long
00001532                           608  
00001532                           609  OP_CMPI_B    * size is byte    
00001532  183C 0000                610              MOVE.B  #0,D4
00001536  43F9 00003C6A            611              LEA     DISP_CMPI_B,A1
0000153C  103C 000E                612              MOVE.B  #14,D0
00001540  4E4F                     613              TRAP    #15
00001542  4E75                     614              RTS
00001544                           615              
00001544                           616  OP_CMPI_W    * size is word
00001544  183C 0001                617              MOVE.B  #1,D4
00001548  43F9 00003C74            618              LEA     DISP_CMPI_W,A1
0000154E  103C 000E                619              MOVE.B  #14,D0
00001552  4E4F                     620              TRAP    #15
00001554  4E75                     621              RTS
00001556                           622              
00001556                           623  OP_CMPI_L    * size is long
00001556  183C 0002                624              MOVE.B  #2,D4
0000155A  43F9 00003C7E            625              LEA     DISP_CMPI_L,A1
00001560  103C 000E                626              MOVE.B  #14,D0
00001564  4E4F                     627              TRAP    #15
00001566  4E75                     628              RTS
00001568                           629   
00001568                           630  *---------------------------------------------------------------------------*
00001568                           631  * OP_ORI : decode ORI and its size
00001568                           632  *---------------------------------------------------------------------------* 
00001568                           633  OP_ORI      
00001568  4281                     634              CLR.L   D1
0000156A  4284                     635              CLR.L   D4
0000156C  2205                     636              MOVE.L  D5,D1
0000156E  EC99                     637              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001570  0C01 0000                638              CMPI.B  #0,D1
00001574  6700 0012                639              BEQ     OP_ORI_B    * size is byte
00001578  0C01 0001                640              CMPI.B  #1,D1
0000157C  6700 001C                641              BEQ     OP_ORI_W    * size is word
00001580  0C01 0002                642              CMPI.B  #2,D1
00001584  6700 0026                643              BEQ     OP_ORI_L    * size is long
00001588                           644  
00001588                           645  OP_ORI_B    * size is byte    
00001588  183C 0000                646              MOVE.B  #0,D4
0000158C  43F9 00003C29            647              LEA     DISP_ORI_B,A1
00001592  103C 000E                648              MOVE.B  #14,D0
00001596  4E4F                     649              TRAP    #15
00001598  4E75                     650              RTS
0000159A                           651              
0000159A                           652  OP_ORI_W    * size is word
0000159A  183C 0001                653              MOVE.B  #1,D4
0000159E  43F9 00003C32            654              LEA     DISP_ORI_W,A1
000015A4  103C 000E                655              MOVE.B  #14,D0
000015A8  4E4F                     656              TRAP    #15
000015AA  4E75                     657              RTS
000015AC                           658              
000015AC                           659  OP_ORI_L    * size is long
000015AC  183C 0002                660              MOVE.B  #2,D4
000015B0  43F9 00003C3B            661              LEA     DISP_ORI_L,A1
000015B6  103C 000E                662              MOVE.B  #14,D0
000015BA  4E4F                     663              TRAP    #15
000015BC  4E75                     664              RTS
000015BE                           665          
000015BE                           666  *---------------------------------------------------------------------------*
000015BE                           667  * OP0001: MOVE.B
000015BE                           668  *---------------------------------------------------------------------------*
000015BE                           669  OP0001      
000015BE  4EF9 000015C4            670              JMP     OP_MOVE_B   * display MOVE.B
000015C4                           671              
000015C4                           672  *---------------------------------------------------------------------------*
000015C4                           673  * OP_MOVE_B: display MOVE_B and proceed to EA
000015C4                           674  *---------------------------------------------------------------------------*
000015C4                           675  OP_MOVE_B                                                                       
000015C4                           676             
000015C4                           677             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015C4  13FC 0082 00003F3A       678             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015CC  13FC 0000 00003F3B       679             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015D4                           680             
000015D4                           681             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015D4  13FC 00B9 00003F3D       682             MOVE.B   #$B9,GET_DST_START_END
000015DC  13FC 0020 00003F3E       683             MOVE.B   #$20,GET_SRC_START_END
000015E4                           684             
000015E4                           685              *CLEAR D3
000015E4  4283                     686              CLR.L   D3
000015E6                           687              *LOAD STACK WITH THIS OPMODE
000015E6  6100 202C                688              BSR     PUSH_STACK
000015EA  163C 004D                689              MOVE.B  #'M',D3
000015EE  6100 2024                690              BSR     PUSH_STACK
000015F2  163C 004F                691              MOVE.B  #'O',D3
000015F6  6100 201C                692              BSR     PUSH_STACK
000015FA  163C 0056                693              MOVE.B  #'V',D3
000015FE  6100 2014                694              BSR     PUSH_STACK
00001602  163C 0045                695              MOVE.B  #'E',D3
00001606  6100 200C                696              BSR     PUSH_STACK
0000160A  163C 002E                697              MOVE.B  #'.',D3
0000160E  6100 2004                698              BSR     PUSH_STACK
00001612  163C 0042                699              MOVE.B  #'B',D3
00001616  6100 1FFC                700              BSR     PUSH_STACK
0000161A                           701              
0000161A  6100 175A                702              BSR     GET_EA_EA_SRC
0000161E  163C 002C                703              MOVE.B  #',',D3
00001622  6100 1FF0                704              BSR     PUSH_STACK
00001626  6100 1B7E                705              BSR     GET_EA_EA_DEST
0000162A                           706              
0000162A  4E75                     707              RTS
0000162C                           708              
0000162C                           709             
0000162C                           710  *---------------------------------------------------------------------------*
0000162C                           711  * OP0010: decode MOVE.L/MOVEA.L
0000162C                           712  *---------------------------------------------------------------------------*
0000162C                           713  OP0010      
0000162C  183C 0002                714              MOVE.B  #2,D4
00001630  4280                     715              CLR.L   D0                     
00001632  4281                     716              CLR.L   D1                      
00001634  227C 00000000            717              MOVEA.L #0, A1                 
0000163A                           718              
0000163A  2205                     719              MOVE.L  D5,D1
0000163C  EA99                     720              ROR.L   #5,D1
0000163E  0281 0000000E            721              ANDI.L  #$E,D1
00001644  0C01 0002                722              CMPI.B  #2,D1
00001648  6700 0070                723              BEQ     OP_MOVEA_L
0000164C                           724  
0000164C  4EF9 00001652            725              JMP     OP_MOVE_L
00001652                           726             
00001652                           727  
00001652                           728  *---------------------------------------------------------------------------*
00001652                           729  * OP_MOVE_L: display MOVE_L and proceed to EA
00001652                           730  *---------------------------------------------------------------------------*
00001652                           731  OP_MOVE_L   
00001652                           732             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001652  13FC 0082 00003F3A       733             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000165A  13FC 0000 00003F3B       734             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001662                           735             
00001662                           736             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001662  13FC 00B9 00003F3D       737             MOVE.B   #$B9,GET_DST_START_END
0000166A  13FC 0020 00003F3E       738             MOVE.B   #$20,GET_SRC_START_END
00001672                           739             
00001672                           740              *CLEAR D3
00001672  4283                     741              CLR.L   D3
00001674                           742              *LOAD STACK WITH THIS OPMODE
00001674  6100 1F9E                743              BSR     PUSH_STACK
00001678  163C 004D                744              MOVE.B  #'M',D3
0000167C  6100 1F96                745              BSR     PUSH_STACK
00001680  163C 004F                746              MOVE.B  #'O',D3
00001684  6100 1F8E                747              BSR     PUSH_STACK
00001688  163C 0056                748              MOVE.B  #'V',D3
0000168C  6100 1F86                749              BSR     PUSH_STACK
00001690  163C 0045                750              MOVE.B  #'E',D3
00001694  6100 1F7E                751              BSR     PUSH_STACK
00001698  163C 002E                752              MOVE.B  #'.',D3
0000169C  6100 1F76                753              BSR     PUSH_STACK
000016A0  163C 004C                754              MOVE.B  #'L',D3
000016A4  6100 1F6E                755              BSR     PUSH_STACK
000016A8                           756              
000016A8  6100 16CC                757              BSR     GET_EA_EA_SRC
000016AC  163C 002C                758              MOVE.B  #',',D3
000016B0  6100 1F62                759              BSR     PUSH_STACK
000016B4  6100 1AF0                760              BSR     GET_EA_EA_DEST
000016B8                           761              
000016B8  4E75                     762              RTS
000016BA                           763  
000016BA                           764  
000016BA                           765  *---------------------------------------------------------------------------*
000016BA                           766  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000016BA                           767  *---------------------------------------------------------------------------*
000016BA                           768  OP_MOVEA_L 
000016BA                           769             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016BA  13FC 00FD 00003F3A       770             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016C2  13FC 0000 00003F3B       771             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016CA                           772             
000016CA                           773             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016CA  13FC 00B9 00003F3D       774             MOVE.B   #$B9,GET_DST_START_END
000016D2  13FC 0020 00003F3E       775             MOVE.B   #$20,GET_SRC_START_END
000016DA                           776             
000016DA                           777              *CLEAR D3
000016DA  4283                     778              CLR.L   D3
000016DC                           779              *LOAD STACK WITH THIS OPMODE
000016DC  6100 1F36                780              BSR     PUSH_STACK
000016E0  163C 004D                781              MOVE.B  #'M',D3
000016E4  6100 1F2E                782              BSR     PUSH_STACK
000016E8  163C 004F                783              MOVE.B  #'O',D3
000016EC  6100 1F26                784              BSR     PUSH_STACK
000016F0  163C 0056                785              MOVE.B  #'V',D3
000016F4  6100 1F1E                786              BSR     PUSH_STACK
000016F8  163C 0045                787              MOVE.B  #'E',D3
000016FC  6100 1F16                788              BSR     PUSH_STACK           
00001700  163C 0041                789              MOVE.B  #'A',D3
00001704  6100 1F0E                790              BSR     PUSH_STACK
00001708  163C 002E                791              MOVE.B  #'.',D3
0000170C  6100 1F06                792              BSR     PUSH_STACK
00001710  163C 004C                793              MOVE.B  #'L',D3
00001714  6100 1EFE                794              BSR     PUSH_STACK
00001718                           795              
00001718  6100 165C                796              BSR     GET_EA_EA_SRC
0000171C  163C 002C                797              MOVE.B  #',',D3
00001720  6100 1EF2                798              BSR     PUSH_STACK
00001724  6100 1A80                799              BSR     GET_EA_EA_DEST
00001728                           800              
00001728  4E75                     801              RTS
0000172A                           802  
0000172A                           803              
0000172A                           804  *---------------------------------------------------------------------------*
0000172A                           805  * OP0011: decode MOVE.W/MOVEA.W
0000172A                           806  *---------------------------------------------------------------------------*
0000172A                           807  OP0011      
0000172A  4280                     808              CLR.L   D0                      
0000172C  4281                     809              CLR.L   D1  
0000172E  4284                     810              CLR.L   D4                   
00001730  227C 00000000            811              MOVEA.L #0, A1 
00001736                           812                
00001736  2205                     813              MOVE.L  D5,D1
00001738  EC99                     814              ROR.L   #6,D1
0000173A  0281 00000007            815              ANDI.L  #$07,D1
00001740  0C01 0001                816              CMPI.B  #1,D1
00001744  6700 0070                817              BEQ     OP_MOVEA_W
00001748                           818              
00001748  4EF9 0000174E            819              JMP     OP_MOVE_W
0000174E                           820            
0000174E                           821  *---------------------------------------------------------------------------*
0000174E                           822  * OP_MOVE_W: display MOVE_W and proceed to EA
0000174E                           823  *---------------------------------------------------------------------------*
0000174E                           824  OP_MOVE_W   
0000174E                           825             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000174E  13FC 0082 00003F3A       826             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001756  13FC 0000 00003F3B       827             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000175E                           828             
0000175E                           829             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000175E  13FC 00B9 00003F3D       830             MOVE.B   #$B9,GET_DST_START_END
00001766  13FC 0020 00003F3E       831             MOVE.B   #$20,GET_SRC_START_END
0000176E                           832             
0000176E                           833              *CLEAR D3
0000176E  4283                     834              CLR.L   D3
00001770                           835              *LOAD STACK WITH THIS OPMODE
00001770  6100 1EA2                836              BSR     PUSH_STACK
00001774  163C 004D                837              MOVE.B  #'M',D3
00001778  6100 1E9A                838              BSR     PUSH_STACK
0000177C  163C 004F                839              MOVE.B  #'O',D3
00001780  6100 1E92                840              BSR     PUSH_STACK
00001784  163C 0056                841              MOVE.B  #'V',D3
00001788  6100 1E8A                842              BSR     PUSH_STACK
0000178C  163C 0045                843              MOVE.B  #'E',D3
00001790  6100 1E82                844              BSR     PUSH_STACK
00001794  163C 002E                845              MOVE.B  #'.',D3
00001798  6100 1E7A                846              BSR     PUSH_STACK
0000179C  163C 0057                847              MOVE.B  #'W',D3
000017A0  6100 1E72                848              BSR     PUSH_STACK
000017A4                           849              
000017A4  6100 15D0                850              BSR     GET_EA_EA_SRC
000017A8  163C 002C                851              MOVE.B  #',',D3
000017AC  6100 1E66                852              BSR     PUSH_STACK
000017B0  6100 19F4                853              BSR     GET_EA_EA_DEST
000017B4                           854              
000017B4  4E75                     855              RTS
000017B6                           856  
000017B6                           857  *---------------------------------------------------------------------------*
000017B6                           858  * OP_MOVEA_W: display MOVEA and proceed to EA
000017B6                           859  *---------------------------------------------------------------------------*
000017B6                           860  OP_MOVEA_W 
000017B6                           861             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017B6  13FC 00FD 00003F3A       862             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000017BE  13FC 0000 00003F3B       863             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017C6                           864             
000017C6                           865             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017C6  13FC 00B9 00003F3D       866             MOVE.B   #$B9,GET_DST_START_END
000017CE  13FC 0020 00003F3E       867             MOVE.B   #$20,GET_SRC_START_END
000017D6                           868             
000017D6                           869              *CLEAR D3
000017D6  4283                     870              CLR.L   D3
000017D8                           871              *LOAD STACK WITH THIS OPMODE
000017D8  6100 1E3A                872              BSR     PUSH_STACK
000017DC  163C 004D                873              MOVE.B  #'M',D3
000017E0  6100 1E32                874              BSR     PUSH_STACK
000017E4  163C 004F                875              MOVE.B  #'O',D3
000017E8  6100 1E2A                876              BSR     PUSH_STACK
000017EC  163C 0056                877              MOVE.B  #'V',D3
000017F0  6100 1E22                878              BSR     PUSH_STACK
000017F4  163C 0045                879              MOVE.B  #'E',D3
000017F8  6100 1E1A                880              BSR     PUSH_STACK           
000017FC  163C 0041                881              MOVE.B  #'A',D3
00001800  6100 1E12                882              BSR     PUSH_STACK
00001804  163C 002E                883              MOVE.B  #'.',D3
00001808  6100 1E0A                884              BSR     PUSH_STACK
0000180C  163C 0057                885              MOVE.B  #'W',D3
00001810  6100 1E02                886              BSR     PUSH_STACK
00001814                           887              
00001814  6100 1560                888              BSR     GET_EA_EA_SRC
00001818  163C 002C                889              MOVE.B  #',',D3
0000181C  6100 1DF6                890              BSR     PUSH_STACK
00001820  6100 1984                891              BSR     GET_EA_EA_DEST
00001824                           892            
00001824  4E75                     893              RTS
00001826                           894  *---------------------------------------------------------------------------*
00001826                           895  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001826                           896  *---------------------------------------------------------------------------*
00001826                           897  OP0100
00001826  4280                     898              CLR.L   D0                      
00001828  4281                     899              CLR.L   D1  
0000182A  4284                     900              CLR.L   D4                      
0000182C  227C 00000000            901              MOVEA.L #0, A1                  
00001832  2205                     902              MOVE.L  D5,D1  
00001834                           903              
00001834                           904              * check for RTS
00001834  0C41 4E75                905              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001838  6700 0178                906              BEQ     OP_RTS
0000183C                           907              
0000183C                           908              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
0000183C  4281                     909              CLR.L   D1 
0000183E  2205                     910              MOVE.L  D5,D1  
00001840  0241 0F00                911              ANDI.W  #$0F00,D1
00001844  0C41 0E00                912              CMPI.W  #$0E00,D1
00001848  6700 0154                913              BEQ     OP_JSR
0000184C                           914  
0000184C                           915              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000184C  4281                     916              CLR.L   D1 
0000184E  2205                     917              MOVE.L  D5,D1  
00001850  0241 0F00                918              ANDI.W  #$0F00,D1
00001854  0C41 0400                919              CMPI.W  #$0400,D1
00001858  6700 0086                920              BEQ     OP_NEG
0000185C                           921              
0000185C                           922              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
0000185C  4281                     923              CLR.L   D1 
0000185E  2205                     924              MOVE.L  D5,D1  
00001860  0241 0F00                925              ANDI.W  #$0F00,D1
00001864  0C41 0600                926              CMPI.W  #$0600,D1
00001868  6700 00DE                927              BEQ     OP_NOT
0000186C                           928              
0000186C                           929              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
0000186C  4281                     930              CLR.L   D1 
0000186E  2205                     931              MOVE.L  D5,D1  
00001870  E099                     932              ROR.L   #8,D1
00001872  0C01 0001                933              CMPI.B  #1,D1
00001876  6700 0054                934              BEQ     OP_LEA
0000187A                           935              
0000187A                           936              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
0000187A  4281                     937              CLR.L   D1 
0000187C  2205                     938              MOVE.L  D5,D1  
0000187E  EB59                     939              ROL.W   #5,D1
00001880  0C01 0001                940              CMPI.B  #1,D1
00001884  6600 FC40                941              BNE     OP_DATA
00001888  E959                     942              ROL.W   #4,D1
0000188A  0C01 0001                943              CMPI.B  #1,D1
0000188E  6600 FC36                944              BNE     OP_DATA
00001892  E359                     945              ROL.W   #1,D1
00001894  0C01 0000                946              CMPI.B  #0,D1
00001898  6700 000E                947              BEQ     OP_MOVEM_W
0000189C  0C01 0001                948              CMPI.B  #1,D1
000018A0  6700 0018                949              BEQ     OP_MOVEM_L
000018A4  4EF8 14C6                950              JMP     OP_DATA
000018A8                           951  
000018A8                           952  *---------------------------------------------------------------------------*
000018A8                           953  * OP_MOVEM_W: display MOVEM_W
000018A8                           954  *---------------------------------------------------------------------------*    
000018A8                           955  OP_MOVEM_W  
000018A8  183C 0001                956              MOVE.B  #1,D4
000018AC  43F9 00003CF9            957              LEA     DISP_MOVEM_W,A1
000018B2  103C 000E                958              MOVE.B  #14,D0
000018B6  4E4F                     959              TRAP    #15
000018B8  4E75                     960              RTS
000018BA                           961  
000018BA                           962  *---------------------------------------------------------------------------*
000018BA                           963  * OP_MOVEM_L: display MOVEM_L
000018BA                           964  *---------------------------------------------------------------------------*
000018BA                           965  OP_MOVEM_L  
000018BA  183C 0002                966              MOVE.B  #2,D4
000018BE  43F9 00003D04            967              LEA     DISP_MOVEM_L,A1
000018C4  103C 000E                968              MOVE.B  #14,D0
000018C8  4E4F                     969              TRAP    #15
000018CA  4E75                     970              RTS
000018CC                           971     
000018CC                           972  *---------------------------------------------------------------------------*
000018CC                           973  * OP_LEA: decode and display LEA
000018CC                           974  *---------------------------------------------------------------------------*
000018CC                           975  OP_LEA      
000018CC  43F9 00003CF2            976              LEA     DISP_LEA,A1
000018D2  103C 000E                977              MOVE.B  #14,D0
000018D6  4E4F                     978              TRAP    #15
000018D8  4EF9 00002900            979              JMP     EA_MOVEA
000018DE                           980  
000018DE  4E75                     981              RTS
000018E0                           982  
000018E0                           983  *---------------------------------------------------------------------------*
000018E0                           984  * OP_NEG: decode and display NEG 
000018E0                           985  *---------------------------------------------------------------------------*
000018E0                           986  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
000018E0  4281                     987              CLR.L   D1
000018E2  4284                     988              CLR.L   D4
000018E4  2205                     989              MOVE.L  D5,D1
000018E6  EC99                     990              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000018E8  0C01 0000                991              CMPI.B  #0,D1
000018EC  6700 0012                992              BEQ     OP_NEG_B    * size is byte
000018F0  0C01 0001                993              CMPI.B  #1,D1
000018F4  6700 0022                994              BEQ     OP_NEG_W    * size is word
000018F8  0C01 0002                995              CMPI.B  #2,D1
000018FC  6700 0032                996              BEQ     OP_NEG_L    * size is long
00001900                           997                         
00001900                           998  OP_NEG_B    * size is byte   
00001900  183C 0000                999              MOVE.B  #0,D4 
00001904  43F9 00003CBC           1000              LEA     DISP_NEG_B,A1
0000190A  103C 000E               1001              MOVE.B  #14,D0
0000190E  4E4F                    1002              TRAP    #15
00001910                          1003              
00001910  4EB9 000028C6           1004              JSR     EA_NOSRC
00001916  4E75                    1005              RTS
00001918                          1006              
00001918                          1007  OP_NEG_W    * size is word
00001918  183C 0001               1008              MOVE.B  #1,D4
0000191C  43F9 00003CC5           1009              LEA     DISP_NEG_W,A1
00001922  103C 000E               1010              MOVE.B  #14,D0
00001926  4E4F                    1011              TRAP    #15
00001928  4EB9 000028C6           1012              JSR     EA_NOSRC
0000192E  4E75                    1013              RTS
00001930                          1014              
00001930                          1015  OP_NEG_L    * size is long
00001930  183C 0002               1016              MOVE.B  #2,D4
00001934  43F9 00003CCE           1017              LEA     DISP_NEG_L,A1
0000193A  103C 000E               1018              MOVE.B  #14,D0
0000193E  4E4F                    1019              TRAP    #15
00001940  4EB9 000028C6           1020              JSR     EA_NOSRC
00001946                          1021              
00001946  4E75                    1022              RTS
00001948                          1023  
00001948                          1024  *---------------------------------------------------------------------------*
00001948                          1025  * OP_NOT: decode and display NOT 
00001948                          1026  *---------------------------------------------------------------------------*
00001948                          1027  OP_NOT
00001948  4281                    1028              CLR.L   D1
0000194A  4284                    1029              CLR.L   D4
0000194C  2205                    1030              MOVE.L  D5,D1
0000194E  EC99                    1031              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001950  0C01 0000               1032              CMPI.B  #0,D1
00001954  6700 0012               1033              BEQ     OP_NOT_B    * size is byte
00001958  0C01 0001               1034              CMPI.B  #1,D1
0000195C  6700 001C               1035              BEQ     OP_NOT_W    * size is word
00001960  0C01 0002               1036              CMPI.B  #2,D1
00001964  6700 0026               1037              BEQ     OP_NOT_L    * size is long
00001968                          1038                         
00001968                          1039  OP_NOT_B    * size is byte   
00001968  183C 0000               1040              MOVE.B  #0,D4 
0000196C  43F9 00003CD7           1041              LEA     DISP_NOT_B,A1
00001972  103C 000E               1042              MOVE.B  #14,D0
00001976  4E4F                    1043              TRAP    #15
00001978  4E75                    1044              RTS
0000197A                          1045              
0000197A                          1046  OP_NOT_W    * size is word
0000197A  183C 0001               1047              MOVE.B  #1,D4
0000197E  43F9 00003CE0           1048              LEA     DISP_NOT_W,A1
00001984  103C 000E               1049              MOVE.B  #14,D0
00001988  4E4F                    1050              TRAP    #15
0000198A  4E75                    1051              RTS
0000198C                          1052              
0000198C                          1053  OP_NOT_L    * size is long
0000198C  183C 0002               1054              MOVE.B  #2,D4
00001990  43F9 00003CE9           1055              LEA     DISP_NOT_L,A1
00001996  103C 000E               1056              MOVE.B  #14,D0
0000199A  4E4F                    1057              TRAP    #15
0000199C  4E75                    1058              RTS
0000199E                          1059  
0000199E                          1060  *---------------------------------------------------------------------------*
0000199E                          1061  * OP_JSR: display JSR     
0000199E                          1062  *---------------------------------------------------------------------------*
0000199E  43F9 00003CB5           1063  OP_JSR      LEA     DISP_JSR,A1
000019A4  103C 000E               1064              MOVE.B  #14,D0
000019A8  4E4F                    1065              TRAP    #15
000019AA  4EB9 000028C6           1066              JSR     EA_NOSRC
000019B0                          1067  
000019B0  4E75                    1068              RTS
000019B2                          1069  
000019B2                          1070  *---------------------------------------------------------------------------*
000019B2                          1071  * OP_RTS: display RTS     
000019B2                          1072  *---------------------------------------------------------------------------* 
000019B2  43F9 00003CAE           1073  OP_RTS      LEA     DISP_RTS,A1
000019B8  103C 000E               1074              MOVE.B  #14,D0
000019BC  4E4F                    1075              TRAP    #15
000019BE  4E75                    1076              RTS
000019C0                          1077  
000019C0                          1078  *---------------------------------------------------------------------------*
000019C0                          1079  * OP0101: decode ADDQ
000019C0                          1080  *---------------------------------------------------------------------------* 
000019C0  4280                    1081  OP0101      CLR.L   D0               * clear registers for temp storage       
000019C2  4281                    1082              CLR.L   D1
000019C4  4284                    1083              CLR.L   D4                  
000019C6  227C 00000000           1084              MOVEA.L #0, A1  
000019CC                          1085              
000019CC  2205                    1086              MOVE.L  D5,D1           * copy the processing data 
000019CE  E089                    1087              LSR.L   #8,D1           * shift to right by 8 bits to check the value of bit 8
000019D0  0201 0001               1088              ANDI.B  #$1,D1          * mask all bits except the last 2 bits
000019D4  0C01 0000               1089              CMPI.B  #0,D1           * if the value is 0, it's ADDQ
000019D8  6700 0006               1090              BEQ     OP_ADDQ
000019DC                          1091              
000019DC  4EF8 14C6               1092              JMP     OP_DATA
000019E0                          1093       
000019E0  4281                    1094  OP_ADDQ     CLR.L   D1
000019E2  2205                    1095              MOVE.L  D5,D1
000019E4  EC99                    1096              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000019E6  0281 00000003           1097              ANDI.L  #$3,D1
000019EC  0C01 0000               1098              CMPI.B  #0,D1
000019F0  6700 0014               1099              BEQ     OP_ADDQ_B    * size is byte
000019F4  0C41 0001               1100              CMPI.W  #1,D1
000019F8  6700 001E               1101              BEQ     OP_ADDQ_W    * size is word
000019FC  0C81 00000002           1102              CMPI.L  #2,D1
00001A02  6700 0026               1103              BEQ     OP_ADDQ_L    * size is long
00001A06                          1104              
00001A06                          1105  *---------------------------------------------------------------------------*
00001A06                          1106  * OP_ADDQ: display ADDQ
00001A06                          1107  *---------------------------------------------------------------------------*              
00001A06                          1108  OP_ADDQ_B    * size is byte   
00001A06  183C 0000               1109              MOVE.B  #0,D4 
00001A0A  43F9 00003D0F           1110              LEA     DISP_ADDQ_B,A1
00001A10  103C 000E               1111              MOVE.B  #14,D0
00001A14  4E4F                    1112              TRAP    #15
00001A16  4E75                    1113              RTS
00001A18                          1114              
00001A18                          1115  OP_ADDQ_W    * size is word
00001A18  183C 0001               1116              MOVE.B  #1,D4
00001A1C  43F9 00003D19           1117              LEA     DISP_ADDQ_W,A1
00001A22  103C 000E               1118              MOVE.B  #14,D0
00001A26  4E4F                    1119              TRAP    #15
00001A28  4E75                    1120              RTS
00001A2A                          1121              
00001A2A                          1122  OP_ADDQ_L    * size is long
00001A2A  183C 0002               1123              MOVE.B  #2,D4
00001A2E  43F9 00003D23           1124              LEA     DISP_ADDQ_L,A1
00001A34  103C 000E               1125              MOVE.B  #14,D0
00001A38  4E4F                    1126              TRAP    #15
00001A3A  4E75                    1127              RTS
00001A3C                          1128  
00001A3C                          1129  *---------------------------------------------------------------------------*
00001A3C                          1130  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001A3C                          1131  *---------------------------------------------------------------------------*              
00001A3C  4280                    1132  OP0110      CLR.L   D0                  
00001A3E  4281                    1133              CLR.L   D1   
00001A40  4284                    1134              CLR.L   D4                 
00001A42  227C 00000000           1135              MOVEA.L #0,A1
00001A48  2205                    1136              MOVE.L  D5, D1                
00001A4A  0281 000000FF           1137              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001A50  2205                    1138              MOVE.L  D5,D1                  
00001A52  0281 00000F00           1139              ANDI.L  #$0F00,D1
00001A58                          1140                 
00001A58  0C41 0000               1141              CMPI.W  #$0000,D1               * Check for BRA
00001A5C  6700 0050               1142              BEQ     OP_BRA                  
00001A60                          1143                          
00001A60  0C41 0D00               1144              CMPI.W  #$0D00,D1               * Check for BLT
00001A64  6700 0056               1145              BEQ     OP_BLT      
00001A68                          1146  
00001A68  0C41 0700               1147              CMPI.W  #$0700,D1               * Check for BEQ
00001A6C  6700 0032               1148              BEQ     OP_BEQ      
00001A70                          1149  
00001A70  0C41 0600               1150              CMPI.W  #$0600,D1               * Check for BNE
00001A74  6700 001C               1151              BEQ     OP_BNE  
00001A78                          1152              
00001A78  0C41 0200               1153              CMPI.W  #$0200,D1               * Check for BHI
00001A7C  6700 0006               1154              BEQ     OP_BHI
00001A80                          1155  
00001A80  4EF8 14C6               1156              JMP     OP_DATA
00001A84                          1157              
00001A84  43F9 00003EDE           1158  OP_BHI      LEA     DISP_BHI,A1             
00001A8A  103C 000E               1159              MOVE.B  #14,D0
00001A8E  4E4F                    1160              TRAP    #15
00001A90  4E75                    1161              RTS
00001A92                          1162  
00001A92  43F9 00003ED7           1163  OP_BNE      LEA     DISP_BNE,A1             
00001A98  103C 000E               1164              MOVE.B  #14,D0
00001A9C  4E4F                    1165              TRAP    #15
00001A9E  4E75                    1166              RTS
00001AA0                          1167  
00001AA0  43F9 00003ED0           1168  OP_BEQ      LEA     DISP_BEQ,A1             
00001AA6  103C 000E               1169              MOVE.B  #14,D0
00001AAA  4E4F                    1170              TRAP    #15
00001AAC  4E75                    1171              RTS          
00001AAE                          1172                          
00001AAE  43F9 00003EC2           1173  OP_BRA      LEA     DISP_BRA,A1             
00001AB4  103C 000E               1174              MOVE.B  #14,D0
00001AB8  4E4F                    1175              TRAP    #15
00001ABA  4E75                    1176              RTS
00001ABC                          1177              
00001ABC  43F9 00003EC9           1178  OP_BLT      LEA     DISP_BLT,A1          
00001AC2  103C 000E               1179              MOVE.B  #14,D0
00001AC6  4E4F                    1180              TRAP    #15
00001AC8  4E75                    1181              RTS
00001ACA                          1182     
00001ACA                          1183  *---------------------------------------------------------------------------*
00001ACA                          1184  * OP0111 : MOVEQ not required
00001ACA                          1185  *---------------------------------------------------------------------------*           
00001ACA  4EF8 14C6               1186  OP0111      JMP     OP_DATA
00001ACE                          1187             
00001ACE                          1188  *---------------------------------------------------------------------------*
00001ACE                          1189  * OP1000 : decode DIVS
00001ACE                          1190  *---------------------------------------------------------------------------*           
00001ACE                          1191  OP1000      
00001ACE  4280                    1192              CLR.L   D0                
00001AD0  4281                    1193              CLR.L   D1   
00001AD2  4284                    1194              CLR.L   D4                
00001AD4  207C 00000000           1195              MOVEA.L #0, A0               
00001ADA  227C 00000000           1196              MOVEA.L #0, A1               
00001AE0                          1197              
00001AE0  2205                    1198              MOVE.L  D5,D1
00001AE2  EA89                    1199              LSR.L   #5,D1
00001AE4  0281 0000000E           1200              ANDI.L  #$E,D1
00001AEA                          1201    
00001AEA  0C01 000E               1202              CMPI.B  #$E,D1
00001AEE  6700 0006               1203              BEQ     OP_DIVS
00001AF2                          1204              
00001AF2  4EF8 14C6               1205              JMP     OP_DATA
00001AF6                          1206  
00001AF6                          1207  *---------------------------------------------------------------------------*
00001AF6                          1208  * OP_DIVS: display DIVS and proceed to EA
00001AF6                          1209  *---------------------------------------------------------------------------*  
00001AF6  43F9 00003D2D           1210  OP_DIVS     LEA     DISP_DIVS,A1
00001AFC  103C 000E               1211              MOVE.B  #14,D0
00001B00  4E4F                    1212              TRAP    #15
00001B02  4EF9 000028DA           1213              JMP     EA_ARITH
00001B08                          1214  
00001B08  4E75                    1215              RTS
00001B0A                          1216              
00001B0A                          1217  *---------------------------------------------------------------------------*
00001B0A                          1218  * OP1001: decode SUB/SUBA
00001B0A                          1219  *---------------------------------------------------------------------------*      
00001B0A                          1220  OP1001      
00001B0A  4280                    1221              CLR.L   D0                  
00001B0C  4281                    1222              CLR.L   D1       
00001B0E  4284                    1223              CLR.L   D4                   
00001B10  227C 00000000           1224              MOVEA.L #0, A1              
00001B16  2205                    1225              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001B18                          1226              
00001B18                          1227              *CLEAR D3
00001B18  4283                    1228              CLR.L   D3
00001B1A                          1229              
00001B1A                          1230              
00001B1A                          1231              
00001B1A                          1232              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00001B1A  2205                    1233              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001B1C                          1234              *BITS (INDEX 8) 
00001B1C                          1235              *0 = ADD.B/W/L <EA>,Dn
00001B1C                          1236              *1 = ADD.B/W/L Dn,<EA> 
00001B1C  EC99                    1237              ROR.L   #6,D1
00001B1E  0281 00000007           1238              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001B24  0C81 00000007           1239              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001B2A  6700 0010               1240              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001B2E  0C81 00000003           1241              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001B34  6700 0078               1242              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001B38  6000 00E6               1243              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001B3C                          1244              
00001B3C                          1245  OP1001_SUBA_L
00001B3C                          1246              *LOAD STACK WITH THIS OPMODE
00001B3C  6100 1AD6               1247              BSR     PUSH_STACK
00001B40  163C 0053               1248              MOVE.B  #'S',D3
00001B44  6100 1ACE               1249              BSR     PUSH_STACK
00001B48  163C 0055               1250              MOVE.B  #'U',D3
00001B4C  6100 1AC6               1251              BSR     PUSH_STACK
00001B50  163C 0042               1252              MOVE.B  #'B',D3
00001B54  6100 1ABE               1253              BSR     PUSH_STACK
00001B58  163C 0041               1254              MOVE.B  #'A',D3
00001B5C  6100 1AB6               1255              BSR     PUSH_STACK
00001B60  163C 002E               1256              MOVE.B  #'.',D3
00001B64  6100 1AAE               1257              BSR     PUSH_STACK
00001B68  163C 004C               1258              MOVE.B  #'L',D3
00001B6C  6100 1AA6               1259              BSR     PUSH_STACK
00001B70                          1260              
00001B70                          1261             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B70  13FC 0000 00003F3A      1262             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B78  13FC 0000 00003F3B      1263             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B80                          1264             
00001B80                          1265             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B80  13FC 00B9 00003F3D      1266             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B88  13FC 0020 00003F3E      1267             MOVE.B   #$20,GET_SRC_START_END
00001B90                          1268  
00001B90                          1269              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001B90  0285 0000FE3F           1270              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001B96  0685 00000040           1271              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001B9C                          1272       
00001B9C                          1273              *PRINT <EA>,AN
00001B9C  6100 11D8               1274              BSR     GET_EA_EA_SRC       *GETS <ea>
00001BA0  163C 002C               1275              MOVE.B  #',',D3
00001BA4  6100 1A6E               1276              BSR     PUSH_STACK                     
00001BA8  6100 15FC               1277              BSR     GET_EA_EA_DEST      *GETS Dn
00001BAC                          1278  
00001BAC                          1279              
00001BAC                          1280              
00001BAC  4E75                    1281              RTS
00001BAE                          1282  OP1001_SUBA_W
00001BAE                          1283              *LOAD STACK WITH THIS OPMODE
00001BAE  6100 1A64               1284              BSR     PUSH_STACK
00001BB2  163C 0053               1285              MOVE.B  #'S',D3
00001BB6  6100 1A5C               1286              BSR     PUSH_STACK
00001BBA  163C 0055               1287              MOVE.B  #'U',D3
00001BBE  6100 1A54               1288              BSR     PUSH_STACK
00001BC2  163C 0042               1289              MOVE.B  #'B',D3
00001BC6  6100 1A4C               1290              BSR     PUSH_STACK
00001BCA  163C 0041               1291              MOVE.B  #'A',D3
00001BCE  6100 1A44               1292              BSR     PUSH_STACK
00001BD2  163C 002E               1293              MOVE.B  #'.',D3
00001BD6  6100 1A3C               1294              BSR     PUSH_STACK
00001BDA  163C 0057               1295              MOVE.B  #'W',D3
00001BDE  6100 1A34               1296              BSR     PUSH_STACK
00001BE2                          1297              
00001BE2                          1298             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001BE2  13FC 0000 00003F3A      1299             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001BEA  13FC 0000 00003F3B      1300             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001BF2                          1301             
00001BF2                          1302             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001BF2  13FC 00B9 00003F3D      1303             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001BFA  13FC 0020 00003F3E      1304             MOVE.B   #$20,GET_SRC_START_END
00001C02                          1305  
00001C02                          1306              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001C02  0285 0000FE3F           1307              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001C08  0685 00000040           1308              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001C0E                          1309       
00001C0E                          1310              *PRINT <EA>,AN
00001C0E  6100 1166               1311              BSR     GET_EA_EA_SRC       *GETS <ea>
00001C12  163C 002C               1312              MOVE.B  #',',D3
00001C16  6100 19FC               1313              BSR     PUSH_STACK                     
00001C1A  6100 158A               1314              BSR     GET_EA_EA_DEST      *GETS Dn
00001C1E                          1315  
00001C1E  4E75                    1316              RTS
00001C20                          1317  
00001C20                          1318  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001C20                          1319              *LOAD STACK WITH THIS OPMODE
00001C20  6100 19F2               1320              BSR     PUSH_STACK
00001C24  163C 0053               1321              MOVE.B  #'S',D3
00001C28  6100 19EA               1322              BSR     PUSH_STACK
00001C2C  163C 0055               1323              MOVE.B  #'U',D3
00001C30  6100 19E2               1324              BSR     PUSH_STACK
00001C34  163C 0042               1325              MOVE.B  #'B',D3
00001C38  6100 19DA               1326              BSR     PUSH_STACK
00001C3C  163C 002E               1327              MOVE.B  #'.',D3
00001C40  6100 19D2               1328              BSR     PUSH_STACK
00001C44                          1329              
00001C44  2205                    1330              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001C46                          1331              
00001C46                          1332              *BITS (INDEX 8) 
00001C46                          1333              *0 = ADD.B/W/L <EA>,Dn
00001C46                          1334              *1 = ADD.B/W/L Dn,<EA> 
00001C46  E099                    1335              ROR.L   #8,D1
00001C48  0281 00000001           1336              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001C4E  0C81 00000000           1337              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001C54  6700 0102               1338              BEQ     OP1001_EA_DN
00001C58                          1339              *else procede to Dn_EA
00001C58                          1340              
00001C58                          1341  OP1001_DN_EA
00001C58                          1342              *BITS (7 TO 6) 
00001C58                          1343              *00 = .B
00001C58                          1344              *01 = .W
00001C58                          1345              *10 = .L 
00001C58  2205                    1346              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001C5A  EC99                    1347              ROR.L   #6,D1
00001C5C  0281 00000003           1348              ANDI.L  #$03,D1
00001C62  0C81 00000000           1349              CMPI.L  #$00,D1 *EQUALS .B
00001C68  6700 0016               1350              BEQ     OP1001_PRINT_B2
00001C6C  0C81 00000001           1351              CMPI.L  #$01,D1 *EQUALS .W
00001C72  6700 0054               1352              BEQ     OP1001_PRINT_W2
00001C76  0C81 00000002           1353              CMPI.L  #$02,D1 *EQUALS .L
00001C7C  6700 0092               1354              BEQ     OP1001_PRINT_L2
00001C80                          1355  OP1001_PRINT_B2
00001C80                          1356              *PUSH 'B'
00001C80  163C 0042               1357              MOVE.B  #'B',D3
00001C84  6100 198E               1358              BSR     PUSH_STACK
00001C88                          1359             
00001C88                          1360              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C88  13FC 0000 00003F3A      1361             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C90  13FC 0083 00003F3B      1362             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C98                          1363             
00001C98                          1364             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C98  13FC 00B9 00003F3D      1365             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CA0  13FC 0020 00003F3E      1366             MOVE.B   #$20,GET_SRC_START_END
00001CA8                          1367  
00001CA8                          1368              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CA8  0285 0000FE3F           1369              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CAE  0685 00000040           1370              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001CB4                          1371       
00001CB4  6100 14F0               1372              BSR     GET_EA_EA_DEST      *GETS Dn
00001CB8  163C 002C               1373              MOVE.B  #',',D3
00001CBC  6100 1956               1374              BSR     PUSH_STACK                     
00001CC0  6100 10B4               1375              BSR     GET_EA_EA_SRC       *GETS <ea>
00001CC4                          1376  
00001CC4                          1377              
00001CC4  6000 08C0               1378              BRA     OP1101_ADD_RETURN
00001CC8                          1379  OP1001_PRINT_W2
00001CC8  163C 0057               1380              MOVE.B  #'W',D3
00001CCC  6100 1946               1381              BSR     PUSH_STACK
00001CD0                          1382  
00001CD0                          1383              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CD0  13FC 0000 00003F3A      1384              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CD8  13FC 0083 00003F3B      1385              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CE0                          1386             
00001CE0                          1387              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CE0  13FC 00B9 00003F3D      1388              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CE8  13FC 0020 00003F3E      1389              MOVE.B   #$20,GET_SRC_START_END
00001CF0                          1390  
00001CF0                          1391              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CF0  0285 0000FE3F           1392              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CF6  0685 00000040           1393              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001CFC                          1394  
00001CFC                          1395        
00001CFC  6100 14A8               1396              BSR     GET_EA_EA_DEST      *GETS Dn
00001D00  163C 002C               1397              MOVE.B  #',',D3
00001D04  6100 190E               1398              BSR     PUSH_STACK               
00001D08  6100 106C               1399              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001D0C                          1400  
00001D0C                          1401  
00001D0C                          1402  
00001D0C  6000 0878               1403              BRA     OP1101_ADD_RETURN
00001D10                          1404  OP1001_PRINT_L2 
00001D10  163C 004C               1405              MOVE.B  #'L',D3
00001D14  6100 18FE               1406              BSR     PUSH_STACK
00001D18                          1407              
00001D18                          1408              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D18  13FC 0000 00003F3A      1409              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D20  13FC 0083 00003F3B      1410              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D28                          1411             
00001D28                          1412              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D28  13FC 00B9 00003F3D      1413              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D30  13FC 0020 00003F3E      1414              MOVE.B   #$20,GET_SRC_START_END
00001D38                          1415  
00001D38                          1416             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D38  0285 0000FE3F           1417              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D3E  0685 00000040           1418              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001D44                          1419  
00001D44                          1420               
00001D44  6100 1460               1421              BSR     GET_EA_EA_DEST       *GETS Dn
00001D48  163C 002C               1422              MOVE.B  #',',D3
00001D4C  6100 18C6               1423              BSR     PUSH_STACK          
00001D50  6100 1024               1424              BSR     GET_EA_EA_SRC        *GETS <ea>
00001D54                          1425  
00001D54  6000 0830               1426              BRA     OP1101_ADD_RETURN
00001D58                          1427              
00001D58                          1428  OP1001_EA_DN           
00001D58                          1429              *BITS (7 TO 6) 
00001D58                          1430              *00 = .B
00001D58                          1431              *01 = .W
00001D58                          1432              *10 = .L 
00001D58  2205                    1433              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001D5A  EC99                    1434              ROR.L   #6,D1
00001D5C  0281 00000003           1435              ANDI.L  #$03,D1
00001D62  0C81 00000000           1436              CMPI.L  #$00,D1 *EQUALS .B
00001D68  6700 0016               1437              BEQ     OP1001_PRINT_B
00001D6C  0C81 00000001           1438              CMPI.L  #$01,D1 *EQUALS .W
00001D72  6700 0054               1439              BEQ     OP1001_PRINT_W
00001D76  0C81 00000002           1440              CMPI.L  #$02,D1 *EQUALS .L
00001D7C  6700 0092               1441              BEQ     OP1001_PRINT_L
00001D80                          1442  OP1001_PRINT_B
00001D80  163C 0042               1443              MOVE.B  #'B',D3
00001D84  6100 188E               1444              BSR     PUSH_STACK
00001D88                          1445                
00001D88                          1446              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D88  13FC 0000 00003F3A      1447              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D90  13FC 0002 00003F3B      1448              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D98                          1449             
00001D98                          1450              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D98  13FC 00B9 00003F3D      1451              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DA0  13FC 0020 00003F3E      1452              MOVE.B   #$20,GET_SRC_START_END
00001DA8                          1453  
00001DA8                          1454             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DA8  0285 0000FE3F           1455              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DAE  0685 00000040           1456              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00001DB4                          1457  
00001DB4                          1458              
00001DB4  6100 0FC0               1459              BSR     GET_EA_EA_SRC      *GETS <ea>
00001DB8  163C 002C               1460              MOVE.B  #',',D3
00001DBC  6100 1856               1461              BSR     PUSH_STACK          
00001DC0  6100 13E4               1462              BSR     GET_EA_EA_DEST       *GETS Dn
00001DC4                          1463              
00001DC4  6000 07C0               1464              BRA     OP1101_ADD_RETURN
00001DC8                          1465  OP1001_PRINT_W
00001DC8  163C 0057               1466              MOVE.B  #'W',D3
00001DCC  6100 1846               1467              BSR     PUSH_STACK
00001DD0                          1468  
00001DD0                          1469              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DD0  13FC 0000 00003F3A      1470              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001DD8  13FC 0000 00003F3B      1471              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001DE0                          1472             
00001DE0                          1473              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DE0  13FC 00B9 00003F3D      1474              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DE8  13FC 0020 00003F3E      1475              MOVE.B   #$20,GET_SRC_START_END
00001DF0                          1476  
00001DF0                          1477             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DF0  0285 0000FE3F           1478              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DF6  0685 00000040           1479              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001DFC                          1480  
00001DFC                          1481              
00001DFC  6100 0F78               1482              BSR     GET_EA_EA_SRC      *GETS <ea>
00001E00  163C 002C               1483              MOVE.B  #',',D3
00001E04  6100 180E               1484              BSR     PUSH_STACK
00001E08  6100 139C               1485              BSR     GET_EA_EA_DEST       *GETS Dn    
00001E0C                          1486              
00001E0C  6000 004A               1487              BRA     OP1001_ADD_RETURN
00001E10                          1488  OP1001_PRINT_L 
00001E10  163C 004C               1489              MOVE.B  #'L',D3
00001E14  6100 17FE               1490              BSR     PUSH_STACK
00001E18                          1491              
00001E18                          1492              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E18  13FC 0000 00003F3A      1493              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E20  13FC 0000 00003F3B      1494              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E28                          1495             
00001E28                          1496              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E28  13FC 00B9 00003F3D      1497              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E30  13FC 0020 00003F3E      1498              MOVE.B   #$20,GET_SRC_START_END
00001E38                          1499  
00001E38                          1500              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E38  0285 0000FE3F           1501              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E3E  0685 00000040           1502              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E44                          1503  
00001E44                          1504                     
00001E44  6100 0F30               1505              BSR     GET_EA_EA_SRC      *GETS <ea>
00001E48  163C 002C               1506              MOVE.B  #',',D3
00001E4C  6100 17C6               1507              BSR     PUSH_STACK                  
00001E50  6100 1354               1508              BSR     GET_EA_EA_DEST       *GETS Dn    
00001E54                          1509  
00001E54                          1510              
00001E54  6000 0002               1511              BRA     OP1001_ADD_RETURN
00001E58                          1512              
00001E58                          1513  OP1001_ADD_RETURN
00001E58  4E75                    1514              RTS
00001E5A                          1515  
00001E5A                          1516    
00001E5A                          1517  *---------------------------------------------------------------------------*
00001E5A                          1518  * OP_SUB: display SUB and proceed to EA
00001E5A                          1519  *---------------------------------------------------------------------------*            
00001E5A  43F9 00003D35           1520  OP_SUB_B    LEA     DISP_SUB_B,A1
00001E60  103C 000E               1521              MOVE.B  #14,D0
00001E64  4E4F                    1522              TRAP    #15
00001E66  183C 0000               1523              MOVE.B  #0,D4
00001E6A  4EF9 00002926           1524              JMP     EA_GEN
00001E70                          1525  
00001E70  4E75                    1526              RTS
00001E72                          1527  
00001E72  43F9 00003D3E           1528  OP_SUB_W    LEA     DISP_SUB_W,A1
00001E78  103C 000E               1529              MOVE.B  #14,D0
00001E7C  4E4F                    1530              TRAP    #15
00001E7E  183C 0001               1531              MOVE.B  #1,D4
00001E82  4EF9 00002926           1532              JMP     EA_GEN
00001E88                          1533  
00001E88  4E75                    1534              RTS
00001E8A                          1535  
00001E8A  43F9 00003D47           1536  OP_SUB_L    LEA     DISP_SUB_L,A1
00001E90  103C 000E               1537              MOVE.B  #14,D0
00001E94  4E4F                    1538              TRAP    #15
00001E96  183C 0002               1539              MOVE.B  #2,D4
00001E9A  4EF9 00002926           1540              JMP     EA_GEN
00001EA0                          1541  
00001EA0  4E75                    1542              RTS
00001EA2                          1543  
00001EA2                          1544  *---------------------------------------------------------------------------*
00001EA2                          1545  * OP_SUBA: display SUBA
00001EA2                          1546  *---------------------------------------------------------------------------*  
00001EA2  43F9 00003D6E           1547  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00001EA8  103C 000E               1548              MOVE.B  #14,D0
00001EAC  4E4F                    1549              TRAP    #15
00001EAE  183C 0001               1550              MOVE.B  #1,D4
00001EB2  4E75                    1551              RTS
00001EB4                          1552  
00001EB4  43F9 00003D78           1553  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00001EBA  103C 000E               1554              MOVE.B  #14,D0
00001EBE  4E4F                    1555              TRAP    #15
00001EC0  183C 0002               1556              MOVE.B  #2,D4
00001EC4  4E75                    1557              RTS         
00001EC6                          1558  *---------------------------------------------------------------------------*
00001EC6                          1559  * OP1010 : unassigned
00001EC6                          1560  *---------------------------------------------------------------------------*           
00001EC6  4EF8 14C6               1561  OP1010      JMP     OP_DATA
00001ECA                          1562              
00001ECA                          1563  *---------------------------------------------------------------------------*
00001ECA                          1564  * OP1011 : decode CMP/EOR/CMPA
00001ECA                          1565  *---------------------------------------------------------------------------*           
00001ECA  4280                    1566  OP1011      CLR.L   D0                
00001ECC  4281                    1567              CLR.L   D1            
00001ECE  4284                    1568              CLR.L   D4                   
00001ED0  227C 00000000           1569              MOVEA.L #0, A1               
00001ED6  2205                    1570              MOVE.L  D5,D1
00001ED8  EA99                    1571              ROR.L   #5,D1
00001EDA  0281 0000000E           1572              ANDI.L  #$E,D1
00001EE0  0C01 0000               1573              CMPI.B  #$0,D1
00001EE4  6700 0062               1574              BEQ     OP_CMP_B
00001EE8  0C01 0002               1575              CMPI.B  #$2,D1
00001EEC  6700 0072               1576              BEQ     OP_CMP_W
00001EF0  0C01 0004               1577              CMPI.B  #$4,D1
00001EF4  6700 0082               1578              BEQ     OP_CMP_L
00001EF8  0C01 0008               1579              CMPI.B  #$8,D1
00001EFC  6700 0092               1580              BEQ     OP_EOR_B
00001F00  0C01 000A               1581              CMPI.B  #$A,D1
00001F04  6700 009C               1582              BEQ     OP_EOR_W
00001F08  0C01 000C               1583              CMPI.B  #$C,D1
00001F0C  6700 00A6               1584              BEQ     OP_EOR_L  
00001F10  0C01 0006               1585              CMPI.B  #$6,D1
00001F14  6700 000E               1586              BEQ     OP_CMPA_W
00001F18  0C01 000E               1587              CMPI.B  #$E,D1
00001F1C  6700 0018               1588              BEQ     OP_CMPA_L 
00001F20                          1589  
00001F20  4EF8 14C6               1590              JMP     OP_DATA          
00001F24                          1591  
00001F24                          1592  *---------------------------------------------------------------------------*
00001F24                          1593  * OP_CMPA: display CMPA 
00001F24                          1594  *---------------------------------------------------------------------------
00001F24  43F9 00003DB8           1595  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00001F2A  103C 000E               1596              MOVE.B  #14,D0
00001F2E  4E4F                    1597              TRAP    #15
00001F30  183C 0001               1598              MOVE.B  #1,D4
00001F34  4E75                    1599              RTS
00001F36                          1600  
00001F36  43F9 00003DC2           1601  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00001F3C  103C 000E               1602              MOVE.B  #14,D0
00001F40  4E4F                    1603              TRAP    #15
00001F42  183C 0002               1604              MOVE.B  #2,D4
00001F46  4E75                    1605              RTS
00001F48                          1606  
00001F48                          1607  *---------------------------------------------------------------------------*
00001F48                          1608  * OP_CMP: display CMP and proceed to EA
00001F48                          1609  *---------------------------------------------------------------------------*  
00001F48  43F9 00003D9D           1610  OP_CMP_B    LEA     DISP_CMP_B,A1
00001F4E  103C 000E               1611              MOVE.B  #14,D0
00001F52  4E4F                    1612              TRAP    #15
00001F54  183C 0000               1613              MOVE.B  #0,D4
00001F58  4EF9 00002926           1614              JMP     EA_GEN
00001F5E                          1615  
00001F5E  4E75                    1616              RTS
00001F60                          1617              
00001F60  43F9 00003DA6           1618  OP_CMP_W    LEA     DISP_CMP_W,A1
00001F66  103C 000E               1619              MOVE.B  #14,D0
00001F6A  4E4F                    1620              TRAP    #15
00001F6C  183C 0001               1621              MOVE.B  #1,D4
00001F70  4EF9 00002926           1622              JMP     EA_GEN
00001F76                          1623  
00001F76  4E75                    1624              RTS
00001F78                          1625              
00001F78  43F9 00003DAF           1626  OP_CMP_L    LEA     DISP_CMP_L,A1
00001F7E  103C 000E               1627              MOVE.B  #14,D0
00001F82  4E4F                    1628              TRAP    #15
00001F84  183C 0002               1629              MOVE.B  #2,D4
00001F88  4EF9 00002926           1630              JMP     EA_GEN
00001F8E                          1631  
00001F8E  4E75                    1632              RTS
00001F90                          1633              
00001F90                          1634  *---------------------------------------------------------------------------*
00001F90                          1635  * OP_EOR: display EOR
00001F90                          1636  *---------------------------------------------------------------------------*  
00001F90  43F9 00003D82           1637  OP_EOR_B    LEA     DISP_EOR_B,A1
00001F96  103C 000E               1638              MOVE.B  #14,D0
00001F9A  4E4F                    1639              TRAP    #15
00001F9C  183C 0000               1640              MOVE.B  #0,D4
00001FA0  4E75                    1641              RTS
00001FA2                          1642              
00001FA2  43F9 00003D8B           1643  OP_EOR_W    LEA     DISP_EOR_W,A1
00001FA8  103C 000E               1644              MOVE.B  #14,D0
00001FAC  4E4F                    1645              TRAP    #15
00001FAE  183C 0001               1646              MOVE.B  #1,D4
00001FB2  4E75                    1647              RTS
00001FB4                          1648              
00001FB4  43F9 00003D94           1649  OP_EOR_L    LEA     DISP_EOR_L,A1
00001FBA  103C 000E               1650              MOVE.B  #14,D0
00001FBE  4E4F                    1651              TRAP    #15
00001FC0  183C 0002               1652              MOVE.B  #2,D4
00001FC4  4E75                    1653              RTS    
00001FC6                          1654  
00001FC6                          1655  *---------------------------------------------------------------------------*
00001FC6                          1656  * OP1100: Decode and display MULS/AND and proceed to EA
00001FC6                          1657  *---------------------------------------------------------------------------* 
00001FC6  4280                    1658  OP1100      CLR.L   D0                 
00001FC8  4281                    1659              CLR.L   D1    
00001FCA  4284                    1660              CLR.L   D4                
00001FCC  227C 00000000           1661              MOVEA.L #0, A1             
00001FD2                          1662              
00001FD2  2205                    1663              MOVE.L  D5,D1
00001FD4  EA89                    1664              LSR.L   #5,D1
00001FD6  0281 0000000E           1665              ANDI.L  #$E,D1
00001FDC  0C41 000E               1666              CMPI.W  #$E,D1
00001FE0  6700 0006               1667              BEQ     OP_MULS
00001FE4  6000 0016               1668              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
00001FE8                          1669  
00001FE8  43F9 00003DCC           1670  OP_MULS     LEA     DISP_MULS_W,A1
00001FEE  103C 000E               1671              MOVE.B  #14,D0
00001FF2  4E4F                    1672              TRAP    #15
00001FF4  4EF9 000028DA           1673              JMP     EA_ARITH
00001FFA  4E75                    1674              RTS
00001FFC                          1675              
00001FFC                          1676  OP1100_DETERMINE_DN_EA_OR_EA_DN 
00001FFC                          1677              *LOAD STACK WITH THIS OPMODE
00001FFC  4283                    1678              CLR.L   D3
00001FFE  6100 1614               1679              BSR     PUSH_STACK
00002002  163C 0041               1680              MOVE.B  #'A',D3
00002006  6100 160C               1681              BSR     PUSH_STACK
0000200A  163C 004E               1682              MOVE.B  #'N',D3
0000200E  6100 1604               1683              BSR     PUSH_STACK
00002012  163C 0044               1684              MOVE.B  #'D',D3
00002016  6100 15FC               1685              BSR     PUSH_STACK
0000201A  163C 002E               1686              MOVE.B  #'.',D3
0000201E  6100 15F4               1687              BSR     PUSH_STACK
00002022                          1688              
00002022  2205                    1689              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002024                          1690              
00002024                          1691              *BITS (INDEX 8) 
00002024                          1692              *0 = ADD.B/W/L <EA>,Dn
00002024                          1693              *1 = ADD.B/W/L Dn,<EA> 
00002024  E099                    1694              ROR.L   #8,D1
00002026  0281 00000001           1695              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000202C  0C81 00000000           1696              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002032  6700 0102               1697              BEQ     OP1100_EA_DN
00002036                          1698              *else procede to Dn_EA
00002036                          1699              
00002036                          1700  OP1100_DN_EA
00002036                          1701              *BITS (7 TO 6) 
00002036                          1702              *00 = .B
00002036                          1703              *01 = .W
00002036                          1704              *10 = .L 
00002036  2205                    1705              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002038  EC99                    1706              ROR.L   #6,D1
0000203A  0281 00000003           1707              ANDI.L  #$03,D1
00002040  0C81 00000000           1708              CMPI.L  #$00,D1 *EQUALS .B
00002046  6700 0016               1709              BEQ     OP1100_PRINT_B2
0000204A  0C81 00000001           1710              CMPI.L  #$01,D1 *EQUALS .W
00002050  6700 0054               1711              BEQ     OP1100_PRINT_W2
00002054  0C81 00000002           1712              CMPI.L  #$02,D1 *EQUALS .L
0000205A  6700 0092               1713              BEQ     OP1100_PRINT_L2
0000205E                          1714  OP1100_PRINT_B2
0000205E                          1715              *PUSH 'B'
0000205E  163C 0042               1716              MOVE.B  #'B',D3
00002062  6100 15B0               1717              BSR     PUSH_STACK
00002066                          1718             
00002066                          1719              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002066  13FC 0000 00003F3A      1720             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000206E  13FC 0083 00003F3B      1721             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002076                          1722             
00002076                          1723             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002076  13FC 00B9 00003F3D      1724             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000207E  13FC 0020 00003F3E      1725             MOVE.B   #$20,GET_SRC_START_END
00002086                          1726  
00002086                          1727              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002086  0285 0000FE3F           1728              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000208C  0685 00000000           1729              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002092                          1730       
00002092  6100 1112               1731              BSR     GET_EA_EA_DEST      *GETS Dn
00002096  163C 002C               1732              MOVE.B  #',',D3
0000209A  6100 1578               1733              BSR     PUSH_STACK                     
0000209E  6100 0CD6               1734              BSR     GET_EA_EA_SRC       *GETS <ea>
000020A2                          1735  
000020A2                          1736              
000020A2  6000 0192               1737              BRA     OP1100_AND_RETURN
000020A6                          1738  OP1100_PRINT_W2
000020A6  163C 0057               1739              MOVE.B  #'W',D3
000020AA  6100 1568               1740              BSR     PUSH_STACK
000020AE                          1741  
000020AE                          1742              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020AE  13FC 0000 00003F3A      1743              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020B6  13FC 0083 00003F3B      1744              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020BE                          1745             
000020BE                          1746              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020BE  13FC 00B9 00003F3D      1747              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020C6  13FC 0020 00003F3E      1748              MOVE.B   #$20,GET_SRC_START_END
000020CE                          1749  
000020CE                          1750              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000020CE  0285 0000FE3F           1751              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020D4  0685 00000000           1752              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000020DA                          1753  
000020DA                          1754        
000020DA  6100 10CA               1755              BSR     GET_EA_EA_DEST      *GETS Dn
000020DE  163C 002C               1756              MOVE.B  #',',D3
000020E2  6100 1530               1757              BSR     PUSH_STACK               
000020E6  6100 0C8E               1758              BSR     GET_EA_EA_SRC       *GETS <ea>       
000020EA                          1759  
000020EA                          1760  
000020EA                          1761  
000020EA  6000 049A               1762              BRA     OP1101_ADD_RETURN
000020EE                          1763  OP1100_PRINT_L2 
000020EE  163C 004C               1764              MOVE.B  #'L',D3
000020F2  6100 1520               1765              BSR     PUSH_STACK
000020F6                          1766              
000020F6                          1767              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020F6  13FC 0000 00003F3A      1768              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020FE  13FC 0083 00003F3B      1769              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002106                          1770             
00002106                          1771              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002106  13FC 00B9 00003F3D      1772              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000210E  13FC 0020 00003F3E      1773              MOVE.B   #$20,GET_SRC_START_END
00002116                          1774  
00002116                          1775             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002116  0285 0000FE3F           1776              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000211C  0685 00000000           1777              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002122                          1778  
00002122                          1779               
00002122  6100 1082               1780              BSR     GET_EA_EA_DEST       *GETS Dn
00002126  163C 002C               1781              MOVE.B  #',',D3
0000212A  6100 14E8               1782              BSR     PUSH_STACK          
0000212E  6100 0C46               1783              BSR     GET_EA_EA_SRC        *GETS <ea>
00002132                          1784  
00002132  6000 0102               1785              BRA     OP1100_AND_RETURN
00002136                          1786              
00002136                          1787  OP1100_EA_DN           
00002136                          1788              *BITS (7 TO 6) 
00002136                          1789              *00 = .B
00002136                          1790              *01 = .W
00002136                          1791              *10 = .L 
00002136  2205                    1792              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002138  EC99                    1793              ROR.L   #6,D1
0000213A  0281 00000003           1794              ANDI.L  #$03,D1
00002140  0C81 00000000           1795              CMPI.L  #$00,D1 *EQUALS .B
00002146  6700 0016               1796              BEQ     OP1100_PRINT_B
0000214A  0C81 00000001           1797              CMPI.L  #$01,D1 *EQUALS .W
00002150  6700 0054               1798              BEQ     OP1100_PRINT_W
00002154  0C81 00000002           1799              CMPI.L  #$02,D1 *EQUALS .L
0000215A  6700 0092               1800              BEQ     OP1100_PRINT_L
0000215E                          1801  OP1100_PRINT_B
0000215E  163C 0042               1802              MOVE.B  #'B',D3
00002162  6100 14B0               1803              BSR     PUSH_STACK
00002166                          1804                
00002166                          1805              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002166  13FC 0000 00003F3A      1806              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000216E  13FC 0002 00003F3B      1807              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002176                          1808             
00002176                          1809              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002176  13FC 00B9 00003F3D      1810              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000217E  13FC 0020 00003F3E      1811              MOVE.B   #$20,GET_SRC_START_END
00002186                          1812  
00002186                          1813             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002186  0285 0000FE3F           1814              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000218C  0685 00000000           1815              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002192                          1816  
00002192                          1817              
00002192  6100 0BE2               1818              BSR     GET_EA_EA_SRC      *GETS <ea>
00002196  163C 002C               1819              MOVE.B  #',',D3
0000219A  6100 1478               1820              BSR     PUSH_STACK          
0000219E  6100 1006               1821              BSR     GET_EA_EA_DEST       *GETS Dn
000021A2                          1822              
000021A2  6000 03E2               1823              BRA     OP1101_ADD_RETURN
000021A6                          1824  OP1100_PRINT_W
000021A6  163C 0057               1825              MOVE.B  #'W',D3
000021AA  6100 1468               1826              BSR     PUSH_STACK
000021AE                          1827  
000021AE                          1828              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021AE  13FC 0000 00003F3A      1829              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021B6  13FC 0002 00003F3B      1830              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021BE                          1831             
000021BE                          1832              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021BE  13FC 00B9 00003F3D      1833              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021C6  13FC 0020 00003F3E      1834              MOVE.B   #$20,GET_SRC_START_END
000021CE                          1835  
000021CE                          1836             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021CE  0285 0000FE3F           1837              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021D4  0685 00000000           1838              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000021DA                          1839  
000021DA                          1840              
000021DA  6100 0B9A               1841              BSR     GET_EA_EA_SRC      *GETS <ea>
000021DE  163C 002C               1842              MOVE.B  #',',D3
000021E2  6100 1430               1843              BSR     PUSH_STACK
000021E6  6100 0FBE               1844              BSR     GET_EA_EA_DEST       *GETS Dn    
000021EA                          1845              
000021EA  6000 FC6C               1846              BRA     OP1001_ADD_RETURN
000021EE                          1847  OP1100_PRINT_L 
000021EE  163C 004C               1848              MOVE.B  #'L',D3
000021F2  6100 1420               1849              BSR     PUSH_STACK
000021F6                          1850              
000021F6                          1851              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021F6  13FC 0000 00003F3A      1852              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021FE  13FC 0002 00003F3B      1853              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002206                          1854             
00002206                          1855              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002206  13FC 00B9 00003F3D      1856              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000220E  13FC 0020 00003F3E      1857              MOVE.B   #$20,GET_SRC_START_END
00002216                          1858  
00002216                          1859              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002216  0285 0000FE3F           1860              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000221C  0685 00000000           1861              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002222                          1862  
00002222                          1863                     
00002222  6100 0B52               1864              BSR     GET_EA_EA_SRC      *GETS <ea>
00002226  163C 002C               1865              MOVE.B  #',',D3
0000222A  6100 13E8               1866              BSR     PUSH_STACK                  
0000222E  6100 0F76               1867              BSR     GET_EA_EA_DEST       *GETS Dn    
00002232                          1868  
00002232                          1869              
00002232  6000 0002               1870              BRA     OP1100_AND_RETURN
00002236                          1871              
00002236                          1872  OP1100_AND_RETURN
00002236  4E75                    1873              RTS
00002238                          1874  
00002238                          1875  
00002238                          1876  *---------------------------------------------------------------------------*
00002238                          1877  * OP1101: Decode ADD/ADDA
00002238                          1878  *---------------------------------------------------------------------------* 
00002238  4280                    1879  OP1101      CLR.L   D0                  
0000223A  4281                    1880              CLR.L   D1       
0000223C  4284                    1881              CLR.L   D4                   
0000223E  227C 00000000           1882              MOVEA.L #0, A1              
00002244  2205                    1883              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002246                          1884              
00002246                          1885              *CLEAR D3
00002246  4283                    1886              CLR.L   D3
00002248                          1887              
00002248                          1888              
00002248                          1889              
00002248                          1890              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002248  2205                    1891              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000224A                          1892              *BITS (INDEX 8) 
0000224A                          1893              *0 = ADD.B/W/L <EA>,Dn
0000224A                          1894              *1 = ADD.B/W/L Dn,<EA> 
0000224A  EC99                    1895              ROR.L   #6,D1
0000224C  0281 00000007           1896              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002252  0C81 00000007           1897              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002258  6700 0010               1898              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
0000225C  0C81 00000003           1899              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002262  6700 0078               1900              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002266  6000 00E6               1901              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000226A                          1902              
0000226A                          1903  OP1101_ADDA_L
0000226A                          1904              *LOAD STACK WITH THIS OPMODE
0000226A  6100 13A8               1905              BSR     PUSH_STACK
0000226E  163C 0041               1906              MOVE.B  #'A',D3
00002272  6100 13A0               1907              BSR     PUSH_STACK
00002276  163C 0044               1908              MOVE.B  #'D',D3
0000227A  6100 1398               1909              BSR     PUSH_STACK
0000227E  163C 0044               1910              MOVE.B  #'D',D3
00002282  6100 1390               1911              BSR     PUSH_STACK
00002286  163C 0041               1912              MOVE.B  #'A',D3
0000228A  6100 1388               1913              BSR     PUSH_STACK
0000228E  163C 002E               1914              MOVE.B  #'.',D3
00002292  6100 1380               1915              BSR     PUSH_STACK
00002296  163C 004C               1916              MOVE.B  #'L',D3
0000229A  6100 1378               1917              BSR     PUSH_STACK
0000229E                          1918              
0000229E                          1919             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000229E  13FC 0000 00003F3A      1920             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022A6  13FC 0000 00003F3B      1921             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022AE                          1922             
000022AE                          1923             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022AE  13FC 00B9 00003F3D      1924             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022B6  13FC 0020 00003F3E      1925             MOVE.B   #$20,GET_SRC_START_END
000022BE                          1926  
000022BE                          1927              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022BE  0285 0000FE3F           1928              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022C4  0685 00000040           1929              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022CA                          1930       
000022CA                          1931              *PRINT <EA>,AN
000022CA  6100 0AAA               1932              BSR     GET_EA_EA_SRC       *GETS <ea>
000022CE  163C 002C               1933              MOVE.B  #',',D3
000022D2  6100 1340               1934              BSR     PUSH_STACK                     
000022D6  6100 0ECE               1935              BSR     GET_EA_EA_DEST      *GETS Dn
000022DA                          1936  
000022DA                          1937              
000022DA                          1938              
000022DA  4E75                    1939              RTS
000022DC                          1940  OP1101_ADDA_W
000022DC                          1941              *LOAD STACK WITH THIS OPMODE
000022DC  6100 1336               1942              BSR     PUSH_STACK
000022E0  163C 0041               1943              MOVE.B  #'A',D3
000022E4  6100 132E               1944              BSR     PUSH_STACK
000022E8  163C 0044               1945              MOVE.B  #'D',D3
000022EC  6100 1326               1946              BSR     PUSH_STACK
000022F0  163C 0044               1947              MOVE.B  #'D',D3
000022F4  6100 131E               1948              BSR     PUSH_STACK
000022F8  163C 0041               1949              MOVE.B  #'A',D3
000022FC  6100 1316               1950              BSR     PUSH_STACK
00002300  163C 002E               1951              MOVE.B  #'.',D3
00002304  6100 130E               1952              BSR     PUSH_STACK
00002308  163C 0057               1953              MOVE.B  #'W',D3
0000230C  6100 1306               1954              BSR     PUSH_STACK
00002310                          1955              
00002310                          1956             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002310  13FC 0000 00003F3A      1957             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002318  13FC 0000 00003F3B      1958             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002320                          1959             
00002320                          1960             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002320  13FC 00B9 00003F3D      1961             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002328  13FC 0020 00003F3E      1962             MOVE.B   #$20,GET_SRC_START_END
00002330                          1963  
00002330                          1964              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002330  0285 0000FE3F           1965              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002336  0685 00000040           1966              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000233C                          1967       
0000233C                          1968              *PRINT <EA>,AN
0000233C  6100 0A38               1969              BSR     GET_EA_EA_SRC       *GETS <ea>
00002340  163C 002C               1970              MOVE.B  #',',D3
00002344  6100 12CE               1971              BSR     PUSH_STACK                     
00002348  6100 0E5C               1972              BSR     GET_EA_EA_DEST      *GETS Dn
0000234C                          1973  
0000234C  4E75                    1974              RTS
0000234E                          1975  
0000234E                          1976  OP1101_DETERMINE_DN_EA_OR_EA_DN 
0000234E                          1977              *LOAD STACK WITH THIS OPMODE
0000234E  6100 12C4               1978              BSR     PUSH_STACK
00002352  163C 0041               1979              MOVE.B  #'A',D3
00002356  6100 12BC               1980              BSR     PUSH_STACK
0000235A  163C 0044               1981              MOVE.B  #'D',D3
0000235E  6100 12B4               1982              BSR     PUSH_STACK
00002362  163C 0044               1983              MOVE.B  #'D',D3
00002366  6100 12AC               1984              BSR     PUSH_STACK
0000236A  163C 002E               1985              MOVE.B  #'.',D3
0000236E  6100 12A4               1986              BSR     PUSH_STACK
00002372                          1987              
00002372  2205                    1988              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002374                          1989              
00002374                          1990              *BITS (INDEX 8) 
00002374                          1991              *0 = ADD.B/W/L <EA>,Dn
00002374                          1992              *1 = ADD.B/W/L Dn,<EA> 
00002374  E099                    1993              ROR.L   #8,D1
00002376  0281 00000001           1994              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000237C  0C81 00000000           1995              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002382  6700 0102               1996              BEQ     OP1101_EA_DN
00002386                          1997              *else procede to Dn_EA
00002386                          1998              
00002386                          1999  OP1101_DN_EA
00002386                          2000              *BITS (7 TO 6) 
00002386                          2001              *00 = .B
00002386                          2002              *01 = .W
00002386                          2003              *10 = .L 
00002386  2205                    2004              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002388  EC99                    2005              ROR.L   #6,D1
0000238A  0281 00000003           2006              ANDI.L  #$03,D1
00002390  0C81 00000000           2007              CMPI.L  #$00,D1 *EQUALS .B
00002396  6700 0016               2008              BEQ     OP1101_PRINT_B2
0000239A  0C81 00000001           2009              CMPI.L  #$01,D1 *EQUALS .W
000023A0  6700 0054               2010              BEQ     OP1101_PRINT_W2
000023A4  0C81 00000002           2011              CMPI.L  #$02,D1 *EQUALS .L
000023AA  6700 0092               2012              BEQ     OP1101_PRINT_L2
000023AE                          2013  OP1101_PRINT_B2
000023AE                          2014              *PUSH 'B'
000023AE  163C 0042               2015              MOVE.B  #'B',D3
000023B2  6100 1260               2016              BSR     PUSH_STACK
000023B6                          2017             
000023B6                          2018              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023B6  13FC 0002 00003F3A      2019             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023BE  13FC 0083 00003F3B      2020             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023C6                          2021             
000023C6                          2022             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023C6  13FC 00B9 00003F3D      2023             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023CE  13FC 0020 00003F3E      2024             MOVE.B   #$20,GET_SRC_START_END
000023D6                          2025  
000023D6                          2026              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023D6  0285 0000FE3F           2027              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023DC  0685 00000000           2028              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000023E2                          2029       
000023E2  6100 0DC2               2030              BSR     GET_EA_EA_DEST      *GETS Dn
000023E6  163C 002C               2031              MOVE.B  #',',D3
000023EA  6100 1228               2032              BSR     PUSH_STACK                     
000023EE  6100 0986               2033              BSR     GET_EA_EA_SRC       *GETS <ea>
000023F2                          2034  
000023F2                          2035              
000023F2  6000 0192               2036              BRA     OP1101_ADD_RETURN
000023F6                          2037  OP1101_PRINT_W2
000023F6  163C 0057               2038              MOVE.B  #'W',D3
000023FA  6100 1218               2039              BSR     PUSH_STACK
000023FE                          2040  
000023FE                          2041              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023FE  13FC 0000 00003F3A      2042              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002406  13FC 0083 00003F3B      2043              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000240E                          2044             
0000240E                          2045              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000240E  13FC 00B9 00003F3D      2046              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002416  13FC 0020 00003F3E      2047              MOVE.B   #$20,GET_SRC_START_END
0000241E                          2048  
0000241E                          2049              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000241E  0285 0000FE3F           2050              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002424  0685 00000000           2051              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000242A                          2052  
0000242A                          2053        
0000242A  6100 0D7A               2054              BSR     GET_EA_EA_DEST      *GETS Dn
0000242E  163C 002C               2055              MOVE.B  #',',D3
00002432  6100 11E0               2056              BSR     PUSH_STACK               
00002436  6100 093E               2057              BSR     GET_EA_EA_SRC       *GETS <ea>       
0000243A                          2058  
0000243A                          2059  
0000243A                          2060  
0000243A  6000 014A               2061              BRA     OP1101_ADD_RETURN
0000243E                          2062  OP1101_PRINT_L2 
0000243E  163C 004C               2063              MOVE.B  #'L',D3
00002442  6100 11D0               2064              BSR     PUSH_STACK
00002446                          2065              
00002446                          2066              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002446  13FC 0000 00003F3A      2067              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000244E  13FC 0083 00003F3B      2068              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002456                          2069             
00002456                          2070              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002456  13FC 00B9 00003F3D      2071              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000245E  13FC 0020 00003F3E      2072              MOVE.B   #$20,GET_SRC_START_END
00002466                          2073  
00002466                          2074             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002466  0285 0000FE3F           2075              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000246C  0685 00000000           2076              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002472                          2077  
00002472                          2078               
00002472  6100 0D32               2079              BSR     GET_EA_EA_DEST       *GETS Dn
00002476  163C 002C               2080              MOVE.B  #',',D3
0000247A  6100 1198               2081              BSR     PUSH_STACK          
0000247E  6100 08F6               2082              BSR     GET_EA_EA_SRC        *GETS <ea>
00002482                          2083  
00002482  6000 0102               2084              BRA     OP1101_ADD_RETURN
00002486                          2085              
00002486                          2086  OP1101_EA_DN           
00002486                          2087              *BITS (7 TO 6) 
00002486                          2088              *00 = .B
00002486                          2089              *01 = .W
00002486                          2090              *10 = .L 
00002486  2205                    2091              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002488  EC99                    2092              ROR.L   #6,D1
0000248A  0281 00000003           2093              ANDI.L  #$03,D1
00002490  0C81 00000000           2094              CMPI.L  #$00,D1 *EQUALS .B
00002496  6700 0016               2095              BEQ     OP1101_PRINT_B
0000249A  0C81 00000001           2096              CMPI.L  #$01,D1 *EQUALS .W
000024A0  6700 0054               2097              BEQ     OP1101_PRINT_W
000024A4  0C81 00000002           2098              CMPI.L  #$02,D1 *EQUALS .L
000024AA  6700 0092               2099              BEQ     OP1101_PRINT_L
000024AE                          2100  OP1101_PRINT_B
000024AE  163C 0042               2101              MOVE.B  #'B',D3
000024B2  6100 1160               2102              BSR     PUSH_STACK
000024B6                          2103                
000024B6                          2104              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024B6  13FC 0002 00003F3A      2105              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024BE  13FC 0002 00003F3B      2106              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024C6                          2107             
000024C6                          2108              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024C6  13FC 00B9 00003F3D      2109              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024CE  13FC 0020 00003F3E      2110              MOVE.B   #$20,GET_SRC_START_END
000024D6                          2111  
000024D6                          2112             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024D6  0285 0000FE3F           2113              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024DC  0685 00000000           2114              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000024E2                          2115  
000024E2                          2116              
000024E2  6100 0892               2117              BSR     GET_EA_EA_SRC      *GETS <ea>
000024E6  163C 002C               2118              MOVE.B  #',',D3
000024EA  6100 1128               2119              BSR     PUSH_STACK          
000024EE  6100 0CB6               2120              BSR     GET_EA_EA_DEST       *GETS Dn
000024F2                          2121              
000024F2  6000 0092               2122              BRA     OP1101_ADD_RETURN
000024F6                          2123  OP1101_PRINT_W
000024F6  163C 0057               2124              MOVE.B  #'W',D3
000024FA  6100 1118               2125              BSR     PUSH_STACK
000024FE                          2126  
000024FE                          2127              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024FE  13FC 0000 00003F3A      2128              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002506  13FC 0000 00003F3B      2129              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000250E                          2130             
0000250E                          2131              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000250E  13FC 00B9 00003F3D      2132              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002516  13FC 0020 00003F3E      2133              MOVE.B   #$20,GET_SRC_START_END
0000251E                          2134  
0000251E                          2135             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000251E  0285 0000FE3F           2136              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002524  0685 00000000           2137              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000252A                          2138  
0000252A                          2139              
0000252A  6100 084A               2140              BSR     GET_EA_EA_SRC      *GETS <ea>
0000252E  163C 002C               2141              MOVE.B  #',',D3
00002532  6100 10E0               2142              BSR     PUSH_STACK
00002536  6100 0C6E               2143              BSR     GET_EA_EA_DEST       *GETS Dn    
0000253A                          2144              
0000253A  6000 004A               2145              BRA     OP1101_ADD_RETURN
0000253E                          2146  OP1101_PRINT_L 
0000253E  163C 004C               2147              MOVE.B  #'L',D3
00002542  6100 10D0               2148              BSR     PUSH_STACK
00002546                          2149              
00002546                          2150              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002546  13FC 0000 00003F3A      2151              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000254E  13FC 0000 00003F3B      2152              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002556                          2153             
00002556                          2154              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002556  13FC 00B9 00003F3D      2155              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000255E  13FC 0020 00003F3E      2156              MOVE.B   #$20,GET_SRC_START_END
00002566                          2157  
00002566                          2158              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002566  0285 0000FE3F           2159              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000256C  0685 00000000           2160              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002572                          2161  
00002572                          2162                     
00002572  6100 0802               2163              BSR     GET_EA_EA_SRC      *GETS <ea>
00002576  163C 002C               2164              MOVE.B  #',',D3
0000257A  6100 1098               2165              BSR     PUSH_STACK                  
0000257E  6100 0C26               2166              BSR     GET_EA_EA_DEST       *GETS Dn    
00002582                          2167  
00002582                          2168              
00002582  6000 0002               2169              BRA     OP1101_ADD_RETURN
00002586                          2170              
00002586                          2171  OP1101_ADD_RETURN
00002586  4E75                    2172              RTS
00002588                          2173              
00002588                          2174              *ADDW
00002588  0C01 0006               2175              CMPI.B  #$6,D1
0000258C  6700 0056               2176              BEQ     OP_ADDA_W
00002590  0C01 000E               2177              CMPI.B  #$E,D1
00002594  6700 0066               2178              BEQ     OP_ADDA_L 
00002598                          2179  
00002598  4EF8 14C6               2180              JMP     OP_DATA  
0000259C                          2181            
0000259C                          2182  *---------------------------------------------------------------------------*
0000259C                          2183  * OP_ADD: display ADD and proceed to EA
0000259C                          2184  *---------------------------------------------------------------------------*  
0000259C  43F9 00003DF1           2185  OP_ADD_B    LEA     DISP_ADD_B,A1
000025A2  103C 000E               2186              MOVE.B  #14,D0
000025A6  4E4F                    2187              TRAP    #15
000025A8  183C 0000               2188              MOVE.B  #0,D4
000025AC  4EF9 00002926           2189              JMP     EA_GEN
000025B2                          2190  
000025B2  4E75                    2191              RTS
000025B4                          2192  
000025B4  43F9 00003DFA           2193  OP_ADD_W    LEA     DISP_ADD_W,A1
000025BA  103C 000E               2194              MOVE.B  #14,D0
000025BE  4E4F                    2195              TRAP    #15
000025C0  183C 0001               2196              MOVE.B  #1,D4
000025C4  4EF9 00002926           2197              JMP     EA_GEN
000025CA                          2198  
000025CA  4E75                    2199              RTS
000025CC                          2200  
000025CC  43F9 00003E03           2201  OP_ADD_L    LEA     DISP_ADD_L,A1
000025D2  103C 000E               2202              MOVE.B  #14,D0
000025D6  4E4F                    2203              TRAP    #15
000025D8  183C 0002               2204              MOVE.B  #2,D4
000025DC  4EF9 00002926           2205              JMP     EA_GEN
000025E2                          2206  
000025E2  4E75                    2207              RTS
000025E4                          2208  
000025E4                          2209  *---------------------------------------------------------------------------*
000025E4                          2210  * OP_ADDA: display ADDA and proceed to EA
000025E4                          2211  *---------------------------------------------------------------------------*  
000025E4  43F9 00003E0C           2212  OP_ADDA_W   LEA     DISP_ADDA_W,A1
000025EA  103C 000E               2213              MOVE.B  #14,D0
000025EE  4E4F                    2214              TRAP    #15
000025F0  183C 0001               2215              MOVE.B  #1,D4
000025F4  4EF9 00002926           2216              JMP     EA_GEN
000025FA                          2217  
000025FA  4E75                    2218              RTS
000025FC                          2219  
000025FC  43F9 00003E16           2220  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002602  103C 000E               2221              MOVE.B  #14,D0
00002606  4E4F                    2222              TRAP    #15
00002608  183C 0002               2223              MOVE.B  #2,D4
0000260C  4EF9 00002926           2224              JMP     EA_GEN
00002612                          2225  
00002612  4E75                    2226              RTS
00002614                          2227              
00002614                          2228  *---------------------------------------------------------------------------*
00002614                          2229  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002614                          2230  *---------------------------------------------------------------------------* 
00002614  4280                    2231  OP1110      CLR.L   D0                  
00002616  4281                    2232              CLR.L   D1   
00002618  4284                    2233              CLR.L   D4                   
0000261A  227C 00000000           2234              MOVEA.L #0, A1                 
00002620  2205                    2235              MOVE.L  D5,D1
00002622                          2236              
00002622                          2237              * check for LSX
00002622  E699                    2238              ROR.L   #3,D1
00002624  0281 00000001           2239              ANDI.L  #$1,D1
0000262A  0C01 0001               2240              CMPI.B  #1,D1
0000262E  6700 002E               2241              BEQ     OP_LSX
00002632                          2242              
00002632                          2243              * reset D1 and check for ASX
00002632  4281                    2244              CLR.L   D1
00002634  2205                    2245              MOVE.L  D5,D1
00002636  E699                    2246              ROR.L   #3,D1
00002638  0281 00000001           2247              ANDI.L  #$1,D1
0000263E  0C01 0000               2248              CMPI.B  #0,D1
00002642  6700 0032               2249              BEQ     OP_ASX
00002646                          2250  
00002646                          2251              * reset D1 and check for ROX
00002646  4281                    2252              CLR.L   D1
00002648  2205                    2253              MOVE.L  D5,D1
0000264A  E699                    2254              ROR.L   #3,D1
0000264C  0281 00000001           2255              ANDI.L  #$1,D1
00002652  0C01 0003               2256              CMPI.B  #3,D1
00002656  6700 0036               2257              BEQ     OP_ROX
0000265A                          2258              
0000265A  4EF8 14C6               2259              JMP     OP_DATA
0000265E                          2260  
0000265E                          2261  *---------------------------------------------------------------------------*
0000265E                          2262  * OP_LSX: process LSR/LSL
0000265E                          2263  *---------------------------------------------------------------------------*            
0000265E  EA99                    2264  OP_LSX      ROR.L   #5,D1
00002660  0281 00000001           2265              ANDI.L  #$1,D1
00002666  0C01 0000               2266              CMPI.B  #0,D1
0000266A  6700 003A               2267              BEQ     OP_LSR
0000266E  0C01 0001               2268              CMPI.B  #1,D1
00002672  6700 008C               2269              BEQ     OP_LSL
00002676                          2270              
00002676                          2271  *---------------------------------------------------------------------------*
00002676                          2272  * OP_ASX: process ASR/ASL
00002676                          2273  *---------------------------------------------------------------------------*  
00002676  EA99                    2274  OP_ASX      ROR.L   #5,D1
00002678  0281 00000001           2275              ANDI.L  #$1,D1
0000267E  0C01 0000               2276              CMPI.B  #0,D1
00002682  6700 00D6               2277              BEQ     OP_ASR
00002686  0C01 0001               2278              CMPI.B  #1,D1
0000268A  6700 0128               2279              BEQ     OP_ASL
0000268E                          2280              
0000268E                          2281  *---------------------------------------------------------------------------*
0000268E                          2282  * OP_ROX: process ROR/ROL
0000268E                          2283  *---------------------------------------------------------------------------*  
0000268E  EA99                    2284  OP_ROX      ROR.L   #5,D1
00002690  0281 00000001           2285              ANDI.L  #$1,D1
00002696  0C01 0000               2286              CMPI.B  #0,D1
0000269A  6700 0172               2287              BEQ     OP_ROR
0000269E  0C01 0001               2288              CMPI.B  #1,D1
000026A2  6700 01C4               2289              BEQ     OP_ROL
000026A6                          2290  
000026A6                          2291  *---------------------------------------------------------------------------*
000026A6                          2292  * OP_LSR: decode and display LSR
000026A6                          2293  *---------------------------------------------------------------------------*        
000026A6  E599                    2294  OP_LSR      ROL.L   #2,D1
000026A8  0281 00000003           2295              ANDI.L  #$3,D1
000026AE  0C01 0000               2296              CMPI.B  #0,D1
000026B2  6700 0016               2297              BEQ     OP_LSR_B
000026B6  0C01 0001               2298              CMPI.B  #$1,D1
000026BA  6700 0032               2299              BEQ     OP_LSR_W
000026BE  0C01 0002               2300              CMPI.B  #$2,D1
000026C2  6700 0018               2301              BEQ     OP_LSR_L
000026C6                          2302              
000026C6  4EF8 14C6               2303              JMP     OP_DATA
000026CA                          2304  
000026CA  43F9 00003E20           2305  OP_LSR_B    LEA     DISP_LSR_B,A1
000026D0  103C 000E               2306              MOVE.B  #14,D0
000026D4  4E4F                    2307              TRAP    #15
000026D6  183C 0000               2308              MOVE.B  #0,D4
000026DA  4E75                    2309              RTS
000026DC                          2310  
000026DC  43F9 00003E44           2311  OP_LSR_L    LEA     DISP_LSR_L,A1
000026E2  103C 000E               2312              MOVE.B  #14,D0
000026E6  4E4F                    2313              TRAP    #15
000026E8  183C 0002               2314              MOVE.B  #2,D4
000026EC  4E75                    2315              RTS
000026EE                          2316  
000026EE  43F9 00003E32           2317  OP_LSR_W    LEA     DISP_LSR_W,A1
000026F4  103C 000E               2318              MOVE.B  #14,D0
000026F8  4E4F                    2319              TRAP    #15
000026FA  183C 0001               2320              MOVE.B  #1,D4
000026FE  4E75                    2321              RTS
00002700                          2322   
00002700                          2323  *---------------------------------------------------------------------------*
00002700                          2324  * OP_LSL: decode and display LSL
00002700                          2325  *---------------------------------------------------------------------------*             
00002700  E599                    2326  OP_LSL      ROL.L   #2,D1
00002702  0281 00000003           2327              ANDI.L  #$3,D1
00002708  0C01 0000               2328              CMPI.B  #0,D1
0000270C  6700 0016               2329              BEQ     OP_LSL_B
00002710  0C01 0001               2330              CMPI.B  #$1,D1
00002714  6700 0032               2331              BEQ     OP_LSL_W
00002718  0C01 0002               2332              CMPI.B  #$2,D1
0000271C  6700 0018               2333              BEQ     OP_LSL_L
00002720                          2334              
00002720  4EF8 14C6               2335              JMP OP_DATA
00002724                          2336  
00002724  43F9 00003E29           2337  OP_LSL_B    LEA     DISP_LSL_B,A1
0000272A  103C 000E               2338              MOVE.B  #14,D0
0000272E  4E4F                    2339              TRAP    #15
00002730  183C 0000               2340              MOVE.B  #0,D4
00002734  4E75                    2341              RTS
00002736                          2342  
00002736  43F9 00003E4D           2343  OP_LSL_L    LEA     DISP_LSL_L,A1
0000273C  103C 000E               2344              MOVE.B  #14,D0
00002740  4E4F                    2345              TRAP    #15
00002742  183C 0002               2346              MOVE.B  #2,D4
00002746  4E75                    2347              RTS
00002748                          2348  
00002748  43F9 00003E3B           2349  OP_LSL_W    LEA     DISP_LSL_W,A1
0000274E  103C 000E               2350              MOVE.B  #14,D0
00002752  4E4F                    2351              TRAP    #15
00002754  183C 0001               2352              MOVE.B  #1,D4
00002758  4E75                    2353              RTS
0000275A                          2354   
0000275A                          2355  *---------------------------------------------------------------------------*
0000275A                          2356  * OP_ASR: decode and display ASR
0000275A                          2357  *---------------------------------------------------------------------------*             
0000275A  E599                    2358  OP_ASR      ROL.L   #2,D1
0000275C  0281 00000003           2359              ANDI.L  #$3,D1
00002762  0C01 0000               2360              CMPI.B  #0,D1
00002766  6700 0016               2361              BEQ     OP_ASR_B
0000276A  0C01 0001               2362              CMPI.B  #$1,D1
0000276E  6700 0032               2363              BEQ     OP_ASR_W
00002772  0C01 0002               2364              CMPI.B  #$2,D1
00002776  6700 0018               2365              BEQ     OP_ASR_L
0000277A                          2366              
0000277A  4EF8 14C6               2367              JMP OP_DATA
0000277E                          2368  
0000277E  43F9 00003E56           2369  OP_ASR_B    LEA     DISP_ASR_B,A1
00002784  103C 000E               2370              MOVE.B  #14,D0
00002788  4E4F                    2371              TRAP    #15
0000278A  183C 0000               2372              MOVE.B  #0,D4
0000278E  4E75                    2373              RTS
00002790                          2374  
00002790  43F9 00003E7A           2375  OP_ASR_L    LEA     DISP_ASR_L,A1
00002796  103C 000E               2376              MOVE.B  #14,D0
0000279A  4E4F                    2377              TRAP    #15
0000279C  183C 0002               2378              MOVE.B  #2,D4
000027A0  4E75                    2379              RTS
000027A2                          2380  
000027A2  43F9 00003E68           2381  OP_ASR_W    LEA     DISP_ASR_W,A1
000027A8  103C 000E               2382              MOVE.B  #14,D0
000027AC  4E4F                    2383              TRAP    #15
000027AE  183C 0001               2384              MOVE.B  #1,D4
000027B2  4E75                    2385              RTS
000027B4                          2386       
000027B4                          2387  *---------------------------------------------------------------------------*
000027B4                          2388  * OP_ASL: decode and display ASL
000027B4                          2389  *---------------------------------------------------------------------------*         
000027B4  E599                    2390  OP_ASL      ROL.L   #2,D1
000027B6  0281 00000003           2391              ANDI.L  #$3,D1
000027BC  0C01 0000               2392              CMPI.B  #0,D1
000027C0  6700 0016               2393              BEQ     OP_ASL_B
000027C4  0C01 0001               2394              CMPI.B  #$1,D1
000027C8  6700 0032               2395              BEQ     OP_ASL_W
000027CC  0C01 0002               2396              CMPI.B  #$2,D1
000027D0  6700 0018               2397              BEQ     OP_ASL_L
000027D4                          2398              
000027D4  4EF8 14C6               2399              JMP OP_DATA
000027D8                          2400  
000027D8  43F9 00003E5F           2401  OP_ASL_B    LEA     DISP_ASL_B,A1
000027DE  103C 000E               2402              MOVE.B  #14,D0
000027E2  4E4F                    2403              TRAP    #15
000027E4  183C 0000               2404              MOVE.B  #0,D4
000027E8  4E75                    2405              RTS
000027EA                          2406  
000027EA  43F9 00003E83           2407  OP_ASL_L    LEA     DISP_ASL_L,A1
000027F0  103C 000E               2408              MOVE.B  #14,D0
000027F4  4E4F                    2409              TRAP    #15
000027F6  183C 0002               2410              MOVE.B  #2,D4
000027FA  4E75                    2411              RTS
000027FC                          2412  
000027FC  43F9 00003E71           2413  OP_ASL_W    LEA     DISP_ASL_W,A1
00002802  103C 000E               2414              MOVE.B  #14,D0
00002806  4E4F                    2415              TRAP    #15
00002808  183C 0001               2416              MOVE.B  #1,D4
0000280C  4E75                    2417              RTS
0000280E                          2418   
0000280E                          2419  *---------------------------------------------------------------------------*
0000280E                          2420  * OP_ROR: decode and display ROR
0000280E                          2421  *---------------------------------------------------------------------------*             
0000280E  E599                    2422  OP_ROR      ROL.L   #2,D1
00002810  0281 00000003           2423              ANDI.L  #$3,D1
00002816  0C01 0000               2424              CMPI.B  #0,D1
0000281A  6700 0016               2425              BEQ     OP_ROR_B
0000281E  0C01 0001               2426              CMPI.B  #$1,D1
00002822  6700 0032               2427              BEQ     OP_ROR_W
00002826  0C01 0002               2428              CMPI.B  #$2,D1
0000282A  6700 0018               2429              BEQ     OP_ROR_L
0000282E                          2430              
0000282E  4EF8 14C6               2431              JMP OP_DATA
00002832                          2432  
00002832  43F9 00003E8C           2433  OP_ROR_B    LEA     DISP_ROR_B,A1
00002838  103C 000E               2434              MOVE.B  #14,D0
0000283C  4E4F                    2435              TRAP    #15
0000283E  183C 0000               2436              MOVE.B  #0,D4
00002842  4E75                    2437              RTS
00002844                          2438  
00002844  43F9 00003EB0           2439  OP_ROR_L    LEA     DISP_ROR_L,A1
0000284A  103C 000E               2440              MOVE.B  #14,D0
0000284E  4E4F                    2441              TRAP    #15
00002850  183C 0002               2442              MOVE.B  #2,D4
00002854  4E75                    2443              RTS
00002856                          2444  
00002856  43F9 00003E9E           2445  OP_ROR_W    LEA     DISP_ROR_W,A1
0000285C  103C 000E               2446              MOVE.B  #14,D0
00002860  4E4F                    2447              TRAP    #15
00002862  183C 0001               2448              MOVE.B  #1,D4
00002866  4E75                    2449              RTS
00002868                          2450  
00002868                          2451  *---------------------------------------------------------------------------*
00002868                          2452  * OP_ROL: decode and display ROL
00002868                          2453  *---------------------------------------------------------------------------*             
00002868  E599                    2454  OP_ROL      ROL.L   #2,D1
0000286A  0281 00000003           2455              ANDI.L  #$3,D1
00002870  0C01 0000               2456              CMPI.B  #0,D1
00002874  6700 0016               2457              BEQ     OP_ROL_B
00002878  0C01 0001               2458              CMPI.B  #$1,D1
0000287C  6700 0032               2459              BEQ     OP_ROL_W
00002880  0C01 0002               2460              CMPI.B  #$2,D1
00002884  6700 0018               2461              BEQ     OP_ROL_L
00002888                          2462              
00002888  4EF8 14C6               2463              JMP OP_DATA
0000288C                          2464  
0000288C                          2465  
0000288C  43F9 00003E95           2466  OP_ROL_B    LEA     DISP_ROL_B,A1
00002892  103C 000E               2467              MOVE.B  #14,D0
00002896  4E4F                    2468              TRAP    #15
00002898  183C 0000               2469              MOVE.B  #0,D4
0000289C  4E75                    2470              RTS
0000289E                          2471  
0000289E  43F9 00003EB9           2472  OP_ROL_L    LEA     DISP_ROL_L,A1
000028A4  103C 000E               2473              MOVE.B  #14,D0
000028A8  4E4F                    2474              TRAP    #15
000028AA  183C 0002               2475              MOVE.B  #2,D4
000028AE  4E75                    2476              RTS
000028B0                          2477  
000028B0  43F9 00003EA7           2478  OP_ROL_W    LEA     DISP_ROL_W,A1
000028B6  103C 000E               2479              MOVE.B  #14,D0
000028BA  4E4F                    2480              TRAP    #15
000028BC  183C 0001               2481              MOVE.B  #1,D4
000028C0  4E75                    2482              RTS
000028C2                          2483              
000028C2                          2484  *---------------------------------------------------------------------------*
000028C2                          2485  * OP1111 : Special reserved
000028C2                          2486  *---------------------------------------------------------------------------*           
000028C2  4EF8 14C6               2487  OP1111      JMP     OP_DATA
000028C6                          2488  
000028C6                          2489  *---------------------------------------------------------------------------*
000028C6                          2490  * EA_NOSRC: decode and display effective addresses for NEG/JSR
000028C6                          2491  *---------------------------------------------------------------------------*
000028C6                          2492  EA_NOSRC    
000028C6  4EB9 00002984           2493              JSR     SRC_MODE
000028CC  43F9 00003B86           2494              LEA     ENDLINE_M,A1
000028D2  103C 000E               2495              MOVE.B  #14,D0
000028D6  4E4F                    2496              TRAP    #15
000028D8  4E75                    2497              RTS
000028DA                          2498              
000028DA                          2499  *---------------------------------------------------------------------------*
000028DA                          2500  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000028DA                          2501  *---------------------------------------------------------------------------*
000028DA                          2502  EA_ARITH
000028DA  4EB9 00002984           2503              JSR     SRC_MODE
000028E0  43F9 00003F00           2504              LEA     DISP_D,A1
000028E6  103C 000E               2505              MOVE.B  #14,D0
000028EA  4E4F                    2506              TRAP    #15
000028EC  4EB9 00002C10           2507              JSR     DEST_REGISTER
000028F2  43F9 00003B86           2508              LEA     ENDLINE_M,A1
000028F8  103C 000E               2509              MOVE.B  #14,D0
000028FC  4E4F                    2510              TRAP    #15
000028FE  4E75                    2511              RTS
00002900                          2512              
00002900                          2513  *---------------------------------------------------------------------------*
00002900                          2514  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00002900                          2515  *---------------------------------------------------------------------------*
00002900                          2516  EA_MOVEA
00002900  4EB9 00002984           2517              JSR     SRC_MODE
00002906  43F9 00003F11           2518              LEA     DISP_AOP,A1
0000290C  103C 000E               2519              MOVE.B  #14,D0
00002910  4E4F                    2520              TRAP    #15
00002912  4EB9 00002C10           2521              JSR     DEST_REGISTER
00002918  43F9 00003F0F           2522              LEA     DISP_CP,A1
0000291E  103C 000D               2523              MOVE.B  #13,D0
00002922  4E4F                    2524              TRAP    #15
00002924  4E75                    2525              RTS
00002926                          2526              
00002926                          2527  *---------------------------------------------------------------------------*
00002926                          2528  * EA_GEN: decode and display effective addresses for MOVE
00002926                          2529  *---------------------------------------------------------------------------*
00002926                          2530  EA_GEN          
00002926                          2531              * retrieve/display source mode/register
00002926  4EB9 00002984           2532              JSR     SRC_MODE
0000292C                          2533              
0000292C                          2534              * retrieve/display destination mode/register
0000292C  4EB9 00002940           2535              JSR     DEST_MODE
00002932                          2536              
00002932  43F9 00003B86           2537              LEA     ENDLINE_M,A1
00002938  103C 000E               2538              MOVE.B  #14,D0
0000293C  4E4F                    2539              TRAP    #15
0000293E                          2540              
0000293E  4E75                    2541              RTS
00002940                          2542  
00002940                          2543  *---------------------------------------------------------------------------*
00002940                          2544  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002940                          2545  *---------------------------------------------------------------------------*           
00002940                          2546  DEST_MODE   
00002940                          2547              * clear registers to store temp data
00002940  4280                    2548              CLR.L   D0                      
00002942  4281                    2549              CLR.L   D1                      
00002944  207C 00000000           2550              MOVEA.L #0, A0                  
0000294A  227C 00000000           2551              MOVEA.L #0, A1                  
00002950  2205                    2552              MOVE.L  D5,D1
00002952  EC89                    2553              LSR.L   #6,D1
00002954  0281 00000007           2554              ANDI.L  #$7,D1
0000295A  0C01 0000               2555              CMPI.B  #0,D1   * Dn
0000295E  6700 0082               2556              BEQ     D_MODE000
00002962  0C01 0002               2557              CMPI.B  #2,D1   * (An)
00002966  6700 00C2               2558              BEQ     D_MODE010
0000296A  0C01 0003               2559              CMPI.B  #3,D1   * (An)+
0000296E  6700 011A               2560              BEQ     D_MODE011
00002972  0C01 0004               2561              CMPI.B  #4,D1   * -(An)
00002976  6700 0132               2562              BEQ     D_MODE100
0000297A  0C01 0007               2563              CMPI.B  #7,D1  * abs
0000297E  6700 017C               2564              BEQ     D_MODE111 
00002982  4E75                    2565              RTS
00002984                          2566  
00002984                          2567  *---------------------------------------------------------------------------*
00002984                          2568  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002984                          2569  *---------------------------------------------------------------------------*  
00002984                          2570  SRC_MODE    
00002984                          2571              * clear registers to store temp data
00002984  4280                    2572              CLR.L   D0                      
00002986  4281                    2573              CLR.L   D1                      
00002988  207C 00000000           2574              MOVEA.L #0, A0                  
0000298E  227C 00000000           2575              MOVEA.L #0, A1                  
00002994  2205                    2576              MOVE.L  D5,D1
00002996  E489                    2577              LSR.L   #2,D1
00002998  0281 0000000E           2578              ANDI.L  #$E,D1
0000299E                          2579              
0000299E  0C01 0000               2580              CMPI.B  #0,D1   * Dn
000029A2  6700 002A               2581              BEQ     MODE000
000029A6  0C01 0002               2582              CMPI.B  #2,D1   * An 
000029AA  6700 004A               2583              BEQ     MODE001
000029AE  0C01 0004               2584              CMPI.B  #4,D1   * (An)
000029B2  6700 0056               2585              BEQ     MODE010
000029B6  0C01 0006               2586              CMPI.B  #6,D1   * (An)+
000029BA  6700 008E               2587              BEQ     MODE011
000029BE  0C01 0008               2588              CMPI.B  #8,D1   * -(An)
000029C2  6700 00A6               2589              BEQ     MODE100
000029C6  0C01 000F               2590              CMPI.B  #15,D1  * abs/immediate
000029CA  6700 00FE               2591              BEQ     MODE111 
000029CE                          2592        
000029CE                          2593  *---------------------------------------------------------------------------*
000029CE                          2594  * MODE000: decode and display source mode Dn
000029CE                          2595  *---------------------------------------------------------------------------*           
000029CE                          2596  MODE000     *Dn
000029CE  43F9 00003F00           2597              LEA     DISP_D,A1
000029D4  103C 000E               2598              MOVE.B  #14,D0
000029D8  4E4F                    2599              TRAP    #15
000029DA  4EB9 00002C6C           2600              JSR     SRC_REGISTER
000029E0  4E75                    2601              RTS
000029E2                          2602  
000029E2                          2603  *---------------------------------------------------------------------------*
000029E2                          2604  * D_MODE000: decode and display dest mode Dn
000029E2                          2605  *---------------------------------------------------------------------------*
000029E2                          2606  D_MODE000     *Dn
000029E2  43F9 00003F00           2607              LEA     DISP_D,A1
000029E8  103C 000E               2608              MOVE.B  #14,D0
000029EC  4E4F                    2609              TRAP    #15
000029EE  4EB9 00002C10           2610              JSR     DEST_REGISTER
000029F4  4E75                    2611              RTS
000029F6                          2612  
000029F6                          2613  *---------------------------------------------------------------------------*
000029F6                          2614  * MODE001: decode and display source mode An
000029F6                          2615  *---------------------------------------------------------------------------* 
000029F6                          2616  MODE001 *An
000029F6  43F9 00003F05           2617              LEA     DISP_A,A1
000029FC  103C 000E               2618              MOVE.B  #14,D0
00002A00  4E4F                    2619              TRAP    #15
00002A02  4EB9 00002C6C           2620              JSR     SRC_REGISTER
00002A08                          2621          
00002A08  4E75                    2622              RTS
00002A0A                          2623  
00002A0A                          2624  *---------------------------------------------------------------------------*
00002A0A                          2625  * MODE010: decode and display source mode (An)
00002A0A                          2626  *---------------------------------------------------------------------------*    
00002A0A                          2627  MODE010 *(An)
00002A0A  43F9 00003F11           2628              LEA     DISP_AOP,A1  *display (A
00002A10  103C 000E               2629              MOVE.B  #14,D0
00002A14  4E4F                    2630              TRAP    #15
00002A16                          2631  
00002A16  4EB9 00002C6C           2632              JSR     SRC_REGISTER * display register
00002A1C                          2633  
00002A1C  43F9 00003F0F           2634              LEA     DISP_CP,A1   *display )
00002A22  103C 000E               2635              MOVE.B  #14,D0
00002A26  4E4F                    2636              TRAP    #15
00002A28                          2637              
00002A28  4E75                    2638              RTS
00002A2A                          2639  
00002A2A                          2640  *---------------------------------------------------------------------------*
00002A2A                          2641  * D_MODE010: decode and display dest mode (An)
00002A2A                          2642  *---------------------------------------------------------------------------*
00002A2A                          2643  D_MODE010 *(An)
00002A2A  43F9 00003F11           2644              LEA     DISP_AOP,A1  *display (A
00002A30  103C 000E               2645              MOVE.B  #14,D0
00002A34  4E4F                    2646              TRAP    #15
00002A36                          2647     
00002A36  4EB9 00002C10           2648              JSR     DEST_REGISTER * display register
00002A3C                          2649  
00002A3C  43F9 00003F0F           2650              LEA     DISP_CP,A1   *display )
00002A42  103C 000E               2651              MOVE.B  #14,D0
00002A46  4E4F                    2652              TRAP    #15
00002A48                          2653              
00002A48  4E75                    2654              RTS
00002A4A                          2655  
00002A4A                          2656  *---------------------------------------------------------------------------*
00002A4A                          2657  * MODE011: decode and display source mode (An)+
00002A4A                          2658  *---------------------------------------------------------------------------*
00002A4A                          2659  MODE011 *(An)+
00002A4A  43F9 00003F11           2660              LEA     DISP_AOP,A1      *display (A
00002A50  103C 000E               2661              MOVE.B  #14,D0
00002A54  4E4F                    2662              TRAP    #15
00002A56                          2663              
00002A56  4EB9 00002C6C           2664              JSR     SRC_REGISTER    * display register
00002A5C                          2665  
00002A5C  43F9 00003F1E           2666              LEA     DISP_POST,A1    *display )+
00002A62  103C 000E               2667              MOVE.B  #14,D0
00002A66  4E4F                    2668              TRAP    #15
00002A68                          2669              
00002A68  4E75                    2670              RTS
00002A6A                          2671              
00002A6A                          2672  *---------------------------------------------------------------------------*
00002A6A                          2673  * MODE100: decode and display source mode -(An)
00002A6A                          2674  *---------------------------------------------------------------------------*
00002A6A                          2675  MODE100 *-(An)
00002A6A  43F9 00003F17           2676              LEA     DISP_PRE,A1    *display -(A
00002A70  103C 000E               2677              MOVE.B  #14,D0
00002A74  4E4F                    2678              TRAP    #15
00002A76                          2679  
00002A76  4EB9 00002C6C           2680              JSR     SRC_REGISTER    *display register
00002A7C                          2681  
00002A7C  43F9 00003F0F           2682              LEA     DISP_CP,A1   *display )
00002A82  103C 000E               2683              MOVE.B  #14,D0
00002A86  4E4F                    2684              TRAP    #15
00002A88                          2685              
00002A88  4E75                    2686              RTS
00002A8A                          2687  
00002A8A                          2688  *---------------------------------------------------------------------------*
00002A8A                          2689  * D_MODE011: decode and display dest mode (An)+
00002A8A                          2690  *---------------------------------------------------------------------------*
00002A8A                          2691  D_MODE011 *(An)+
00002A8A  43F9 00003F11           2692              LEA     DISP_AOP,A1      *display (A
00002A90  103C 000E               2693              MOVE.B  #14,D0
00002A94  4E4F                    2694              TRAP    #15
00002A96                          2695  
00002A96  4EB9 00002C10           2696              JSR     DEST_REGISTER    * display register
00002A9C                          2697  
00002A9C  43F9 00003F1E           2698              LEA     DISP_POST,A1    *display )+
00002AA2  103C 000E               2699              MOVE.B  #14,D0
00002AA6  4E4F                    2700              TRAP    #15
00002AA8                          2701              
00002AA8  4E75                    2702              RTS
00002AAA                          2703              
00002AAA                          2704  *---------------------------------------------------------------------------*
00002AAA                          2705  * D_MODE100: decode and display dest mode -(An)
00002AAA                          2706  *---------------------------------------------------------------------------*            
00002AAA                          2707  D_MODE100 *-(An)
00002AAA  43F9 00003F17           2708              LEA     DISP_PRE,A1    *display -(A
00002AB0  103C 000E               2709              MOVE.B  #14,D0
00002AB4  4E4F                    2710              TRAP    #15
00002AB6                          2711              
00002AB6  4EB9 00002C10           2712              JSR     DEST_REGISTER    *display register
00002ABC                          2713  
00002ABC  43F9 00003F0F           2714              LEA     DISP_CP,A1   *display )
00002AC2  103C 000E               2715              MOVE.B  #14,D0
00002AC6  4E4F                    2716              TRAP    #15
00002AC8                          2717              
00002AC8  4E75                    2718              RTS
00002ACA                          2719  
00002ACA                          2720  *---------------------------------------------------------------------------*
00002ACA                          2721  * MODE111: decode and display source mode absolute/immediate
00002ACA                          2722  *---------------------------------------------------------------------------*
00002ACA                          2723  MODE111     * abs/immediate
00002ACA                          2724              * clear registers to store temp data
00002ACA  4280                    2725              CLR.L   D0                      
00002ACC  4281                    2726              CLR.L   D1                      
00002ACE  207C 00000000           2727              MOVEA.L #0, A0                  
00002AD4  227C 00000000           2728              MOVEA.L #0, A1                  
00002ADA  2205                    2729              MOVE.L  D5,D1
00002ADC                          2730              
00002ADC                          2731              * retrieve source register for MODE 111
00002ADC  E389                    2732              LSL.L   #1,D1   * shift the bits to left by 1
00002ADE  0281 0000000E           2733              ANDI.L  #$E,D1  * mask the first 4 bits 
00002AE4  0C01 0000               2734              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002AE8  6700 003E               2735              BEQ     WORDMODE
00002AEC  0C01 0002               2736              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002AF0  6700 0062               2737              BEQ     LONGMODE
00002AF4  0C01 0008               2738              CMPI.B  #8, D1  * if it's 1000, immediate data
00002AF8  6700 0086               2739              BEQ     IMMEDIATE
00002AFC                          2740       
00002AFC                          2741  *---------------------------------------------------------------------------*
00002AFC                          2742  * D_MODE111: decode and display dest mode absolute/immediate
00002AFC                          2743  *---------------------------------------------------------------------------*           
00002AFC                          2744  D_MODE111   * abs
00002AFC                          2745              * clear registers to store temp data
00002AFC  4280                    2746              CLR.L   D0                      
00002AFE  4281                    2747              CLR.L   D1                      
00002B00  207C 00000000           2748              MOVEA.L #0, A0                  
00002B06  227C 00000000           2749              MOVEA.L #0, A1                  
00002B0C  2205                    2750              MOVE.L  D5,D1
00002B0E                          2751              
00002B0E                          2752              * retrieve dest register for MODE 111
00002B0E  EC89                    2753              LSR.L   #6,D1   * shift the bits to right by 6
00002B10  E689                    2754              LSR.L   #3,D1   * shift the bits to right by extra 3
00002B12  0201 0001               2755              ANDI.B  #1,D1   * mask the first 2 bits 
00002B16  0C01 0000               2756              CMPI.B  #0, D1  * if it's 000, absolute word address
00002B1A  6700 000C               2757              BEQ     WORDMODE
00002B1E  0C01 0001               2758              CMPI.B  #1, D1  * if it's 001, absolute long address
00002B22  6700 0030               2759              BEQ     LONGMODE
00002B26                          2760              *JSR     OP_DATA *not sure..
00002B26  4E75                    2761              RTS
00002B28                          2762  
00002B28                          2763  
00002B28                          2764  *---------------------------------------------------------------------------*
00002B28                          2765  * WORDMODE: absolute word address
00002B28                          2766  *---------------------------------------------------------------------------*
00002B28  43F9 00003EFB           2767  WORDMODE    LEA     DISP_HEX,A1
00002B2E  103C 000E               2768              MOVE.B  #14,D0
00002B32  4E4F                    2769              TRAP    #15
00002B34                          2770              
00002B34  4285                    2771              CLR.L   D5
00002B36  3A1D                    2772              MOVE.W  (A5)+,D5
00002B38                          2773              
00002B38  43F9 00003BD9           2774              LEA     TMPOUTPUT,A1
00002B3E  2205                    2775              MOVE.L  D5,D1
00002B40  7404                    2776              MOVE.L  #4,D2       *move word size 4
00002B42  4EB8 11C6               2777              JSR     HEX2ASCII
00002B46  43F9 00003BD9           2778              LEA     TMPOUTPUT,A1
00002B4C  103C 000E               2779              MOVE.B  #14,D0
00002B50  4E4F                    2780              TRAP    #15
00002B52                          2781              
00002B52  4E75                    2782              RTS
00002B54                          2783  
00002B54                          2784  *---------------------------------------------------------------------------*
00002B54                          2785  * LONGMODE: absolute long address
00002B54                          2786  *---------------------------------------------------------------------------*
00002B54  43F9 00003EFB           2787  LONGMODE    LEA     DISP_HEX,A1
00002B5A  103C 000E               2788              MOVE.B  #14,D0
00002B5E  4E4F                    2789              TRAP    #15
00002B60                          2790              
00002B60  4285                    2791              CLR.L   D5
00002B62  2A1D                    2792              MOVE.L  (A5)+,D5
00002B64                          2793              
00002B64  43F9 00003BD9           2794              LEA     TMPOUTPUT,A1
00002B6A  2205                    2795              MOVE.L  D5,D1
00002B6C  7408                    2796              MOVE.L  #8,D2           *move longword size 8
00002B6E  4EB8 11C6               2797              JSR     HEX2ASCII
00002B72  43F9 00003BD9           2798              LEA     TMPOUTPUT,A1
00002B78  103C 000E               2799              MOVE.B  #14,D0
00002B7C  4E4F                    2800              TRAP    #15
00002B7E                          2801              
00002B7E  4E75                    2802              RTS
00002B80                          2803  
00002B80                          2804  
00002B80                          2805  *---------------------------------------------------------------------------*
00002B80                          2806  * IMMEDIATE: immediate address
00002B80                          2807  *---------------------------------------------------------------------------*
00002B80  43F9 00003F21           2808  IMMEDIATE   LEA     DISP_LB,A1
00002B86  103C 000E               2809              MOVE.B  #14,D0
00002B8A  4E4F                    2810              TRAP    #15
00002B8C  43F9 00003EFB           2811              LEA     DISP_HEX,A1
00002B92  103C 000E               2812              MOVE.B  #14,D0
00002B96  4E4F                    2813              TRAP    #15
00002B98                          2814              
00002B98                          2815              * check for size
00002B98  0C04 0000               2816              CMPI.B  #0,D4
00002B9C  6700 0012               2817              BEQ     IMMD_B
00002BA0  0C04 0001               2818              CMPI.B  #1,D4
00002BA4  6700 002A               2819              BEQ     IMMD_W
00002BA8  0C04 0002               2820              CMPI.B  #2,D4
00002BAC  6700 0042               2821              BEQ     IMMD_L
00002BB0                          2822  
00002BB0                          2823  IMMD_B
00002BB0  4285                    2824              CLR.L   D5
00002BB2  3A1D                    2825              MOVE.W  (A5)+,D5
00002BB4                          2826              
00002BB4  43F9 00003BD9           2827              LEA     TMPOUTPUT,A1
00002BBA  2205                    2828              MOVE.L  D5,D1
00002BBC  7402                    2829              MOVE.L  #2,D2
00002BBE  4EB8 11C6               2830              JSR     HEX2ASCII
00002BC2  43F9 00003BD9           2831              LEA     TMPOUTPUT,A1
00002BC8  103C 000E               2832              MOVE.B  #14,D0
00002BCC  4E4F                    2833              TRAP    #15
00002BCE  4E75                    2834              RTS
00002BD0                          2835              
00002BD0                          2836  IMMD_W
00002BD0  4285                    2837              CLR.L   D5
00002BD2  3A1D                    2838              MOVE.W  (A5)+,D5
00002BD4                          2839              
00002BD4  43F9 00003BD9           2840              LEA     TMPOUTPUT,A1
00002BDA  2205                    2841              MOVE.L  D5,D1
00002BDC  7404                    2842              MOVE.L  #4,D2
00002BDE  4EB8 11C6               2843              JSR     HEX2ASCII
00002BE2  43F9 00003BD9           2844              LEA     TMPOUTPUT,A1
00002BE8  103C 000E               2845              MOVE.B  #14,D0
00002BEC  4E4F                    2846              TRAP    #15
00002BEE  4E75                    2847              RTS
00002BF0                          2848              
00002BF0                          2849  
00002BF0                          2850  IMMD_L
00002BF0  4285                    2851              CLR.L   D5
00002BF2  3A1D                    2852              MOVE.W  (A5)+,D5
00002BF4                          2853              
00002BF4  43F9 00003BD9           2854              LEA     TMPOUTPUT,A1
00002BFA  2205                    2855              MOVE.L  D5,D1
00002BFC  7408                    2856              MOVE.L  #8,D2
00002BFE  4EB8 11C6               2857              JSR     HEX2ASCII
00002C02  43F9 00003BD9           2858              LEA     TMPOUTPUT,A1
00002C08  103C 000E               2859              MOVE.B  #14,D0
00002C0C  4E4F                    2860              TRAP    #15
00002C0E  4E75                    2861              RTS
00002C10                          2862  
00002C10                          2863  
00002C10                          2864  *---------------------------------------------------------------------------*
00002C10                          2865  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00002C10                          2866  *---------------------------------------------------------------------------*
00002C10                          2867  DEST_REGISTER
00002C10                          2868              * clear registers to store temp data
00002C10  4280                    2869              CLR.L   D0                      
00002C12  4281                    2870              CLR.L   D1                      
00002C14  207C 00000000           2871              MOVEA.L #0, A0                  
00002C1A  227C 00000000           2872              MOVEA.L #0, A1 
00002C20                          2873              
00002C20  2205                    2874              MOVE.L  D5,D1
00002C22  EC89                    2875              LSR.L   #6,D1
00002C24  E689                    2876              LSR.L   #3,D1
00002C26  0281 00000007           2877              ANDI.L  #7,D1
00002C2C                          2878              
00002C2C  0C01 0000               2879              CMPI.B  #0,D1
00002C30  6700 0092               2880              BEQ     REG_0
00002C34  0C01 0001               2881              CMPI.B  #1,D1
00002C38  6700 0098               2882              BEQ     REG_1
00002C3C  0C01 0002               2883              CMPI.B  #2,D1
00002C40  6700 009E               2884              BEQ     REG_2
00002C44  0C01 0003               2885              CMPI.B  #3,D1
00002C48  6700 00A4               2886              BEQ     REG_3
00002C4C  0C01 0004               2887              CMPI.B  #4,D1
00002C50  6700 00AA               2888              BEQ     REG_4
00002C54  0C01 0005               2889              CMPI.B  #5,D1
00002C58  6700 00B0               2890              BEQ     REG_5
00002C5C  0C01 0006               2891              CMPI.B  #6,D1
00002C60  6700 00B6               2892              BEQ     REG_6
00002C64  0C01 0007               2893              CMPI.B  #7,D1
00002C68  6700 00BC               2894              BEQ     REG_7
00002C6C                          2895  
00002C6C                          2896  *---------------------------------------------------------------------------*
00002C6C                          2897  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00002C6C                          2898  *---------------------------------------------------------------------------*           
00002C6C                          2899  SRC_REGISTER 
00002C6C                          2900              * clear registers to store temp data
00002C6C  4280                    2901              CLR.L   D0                      
00002C6E  4281                    2902              CLR.L   D1                      
00002C70  207C 00000000           2903              MOVEA.L #0, A0                  
00002C76  227C 00000000           2904              MOVEA.L #0, A1                  
00002C7C                          2905              
00002C7C  2205                    2906              MOVE.L  D5,D1   * temp store the processing data
00002C7E  0281 00000007           2907              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00002C84                          2908              
00002C84  0C01 0000               2909              CMPI.B  #0,D1
00002C88  6700 003A               2910              BEQ     REG_0
00002C8C  0C01 0001               2911              CMPI.B  #1,D1
00002C90  6700 0040               2912              BEQ     REG_1
00002C94  0C01 0002               2913              CMPI.B  #2,D1
00002C98  6700 0046               2914              BEQ     REG_2
00002C9C  0C01 0003               2915              CMPI.B  #3,D1
00002CA0  6700 004C               2916              BEQ     REG_3
00002CA4  0C01 0004               2917              CMPI.B  #4,D1
00002CA8  6700 0052               2918              BEQ     REG_4
00002CAC  0C01 0005               2919              CMPI.B  #5,D1
00002CB0  6700 0058               2920              BEQ     REG_5
00002CB4  0C01 0006               2921              CMPI.B  #6,D1
00002CB8  6700 005E               2922              BEQ     REG_6
00002CBC  0C01 0007               2923              CMPI.B  #7,D1
00002CC0  6700 0064               2924              BEQ     REG_7
00002CC4                          2925  
00002CC4                          2926  *---------------------------------------------------------------------------*
00002CC4                          2927  * REG_0 ~ REG_7: display register 0 to 7
00002CC4                          2928  *---------------------------------------------------------------------------*
00002CC4  43F9 00003F26           2929  REG_0       LEA     DISP_0,A1
00002CCA  103C 000E               2930              MOVE.B  #14,D0
00002CCE  4E4F                    2931              TRAP    #15
00002CD0  4E75                    2932              RTS
00002CD2                          2933              
00002CD2  43F9 00003F28           2934  REG_1       LEA     DISP_1,A1
00002CD8  103C 000E               2935              MOVE.B  #14,D0
00002CDC  4E4F                    2936              TRAP    #15
00002CDE  4E75                    2937              RTS
00002CE0                          2938              
00002CE0                          2939  
00002CE0  43F9 00003F2A           2940  REG_2       LEA     DISP_2,A1
00002CE6  103C 000E               2941              MOVE.B  #14,D0
00002CEA  4E4F                    2942              TRAP    #15
00002CEC  4E75                    2943              RTS
00002CEE                          2944            
00002CEE  43F9 00003F2C           2945  REG_3       LEA     DISP_3,A1
00002CF4  103C 000E               2946              MOVE.B  #14,D0
00002CF8  4E4F                    2947              TRAP    #15
00002CFA  4E75                    2948              RTS
00002CFC                          2949              
00002CFC  43F9 00003F2E           2950  REG_4       LEA     DISP_4,A1
00002D02  103C 000E               2951              MOVE.B  #14,D0
00002D06  4E4F                    2952              TRAP    #15
00002D08  4E75                    2953              RTS
00002D0A                          2954              
00002D0A  43F9 00003F30           2955  REG_5       LEA     DISP_5,A1
00002D10  103C 000E               2956              MOVE.B  #14,D0
00002D14  4E4F                    2957              TRAP    #15
00002D16  4E75                    2958              RTS
00002D18                          2959              
00002D18  43F9 00003F32           2960  REG_6       LEA     DISP_6,A1
00002D1E  103C 000E               2961              MOVE.B  #14,D0
00002D22  4E4F                    2962              TRAP    #15
00002D24  4E75                    2963              RTS
00002D26                          2964              
00002D26  43F9 00003F34           2965  REG_7       LEA     DISP_7,A1
00002D2C  103C 000E               2966              MOVE.B  #14,D0
00002D30  4E4F                    2967              TRAP    #15
00002D32  4E75                    2968              RTS
00002D34                          2969              
00002D34                          2970  *---------------------------------------------------------------------------*
00002D34                          2971  * REPEAT : Ask user whether they wish to run the program again
00002D34                          2972  *---------------------------------------------------------------------------*           
00002D34  4246                    2973  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00002D36  43F9 000039FF           2974              LEA     REPEATMSG,A1
00002D3C  103C 000E               2975              MOVE.B  #14,D0
00002D40  4E4F                    2976              TRAP    #15
00002D42                          2977              
00002D42  43F9 00003B89           2978              LEA     TMPINPUT,A1             * allocate space to temp store user input
00002D48  103C 0002               2979              MOVE.B  #2,D0
00002D4C  4E4F                    2980              TRAP    #15
00002D4E                          2981  
00002D4E  0C01 0001               2982              CMPI.B  #1,D1                   * check for length of user input
00002D52  66E0                    2983              BNE     REPEAT                  * return to the beginning of the function if unequal
00002D54                          2984              
00002D54  0C11 0059               2985              CMPI.B  #$59,(A1)               * compare the input with Y    
00002D58  6700 E2B0               2986              BEQ     PROGLP                  * repeat the program
00002D5C                          2987              
00002D5C  0C11 0079               2988              CMPI.B  #$79,(A1)               * compare the input with y    
00002D60  6700 E2A8               2989              BEQ     PROGLP                  * repeat the program
00002D64                          2990              
00002D64  0C11 004E               2991              CMPI.B  #$4E,(A1)               * compare the input with N    
00002D68  6700 0928               2992              BEQ     TERMINATE               * finish program
00002D6C                          2993              
00002D6C  0C11 006E               2994              CMPI.B  #$6E,(A1)               * compare the input with n    
00002D70  6700 0920               2995              BEQ     TERMINATE               * finish program
00002D74                          2996              
00002D74  60BE                    2997              BRA     REPEAT                  * invalid input/repeat the function
00002D76                          2998  
00002D76                          2999  *---------------------------------------------------------------------------*
00002D76                          3000  * EA DECODING INTERFACE
00002D76                          3001  * [A0] - RESERVED FOR USE
00002D76                          3002  * [D2] - RESERVED FOR USE
00002D76                          3003  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00002D76                          3004  *---------------------------------------------------------------------------*
00002D76                          3005  GET_EA_EA_SRC
00002D76                          3006      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00002D76                          3007      
00002D76                          3008      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00002D76  2405                    3009      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00002D78  E68A                    3010      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00002D7A  23C2 00003F4C           3011      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00002D80  7407                    3012      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00002D82  C5B9 00003F4C           3013      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00002D88                          3014                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00002D88                          3015      
00002D88                          3016      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00002D88                          3017      *DESTINATION REGISTER FORMAT STANDARD         *
00002D88                          3018      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00002D88                          3019      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00002D88                          3020      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00002D88                          3021      *0 - Dn                                       *
00002D88                          3022      *1 - An                                       *
00002D88                          3023      *2 - (An)                                     *
00002D88                          3024      *3 - (An)+                                    *
00002D88                          3025      *4 - -(An)                                    *
00002D88                          3026      *5 - (XXX).W                                  *
00002D88                          3027      *6 - (XXX).L                                  *
00002D88                          3028      *7 - #<data>                                  *
00002D88                          3029      ***********************************************
00002D88                          3030      
00002D88                          3031      *** Check if source ...  <ea> = Dn
00002D88                          3032  CHECK0    
00002D88  41F9 00003F3C           3033            LEA     TEMP_REGISTER_FORMAT,A0
00002D8E  1439 00003F3B           3034            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002D94  1082                    3035            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002D96  0239 0001 00003F3C      3036            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00002D9E  0C39 0001 00003F3C      3037            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00002DA6  6700 006A               3038            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002DAA  0CB9 00000000 00003F4C  3039            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00002DB4  6600 005C               3040            BNE     CHECK1
00002DB8                          3041            
00002DB8                          3042            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002DB8  163C 0020               3043            MOVE.B    #' ',D3
00002DBC  6100 0856               3044            BSR       PUSH_STACK
00002DC0  163C 0044               3045            MOVE.B    #'D',D3
00002DC4  6100 084E               3046            BSR       PUSH_STACK
00002DC8                          3047  
00002DC8                          3048            *FIND REGISTER NUMBER END LOCATION*  
00002DC8  13F9 00003F3E 00003F44  3049            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002DD2  0239 000F 00003F44      3050            AND.B   #$0F,VAR_BYTE_END
00002DDA                          3051            
00002DDA                          3052            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002DDA  23C5 00003F48           3053            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002DE0  1439 00003F44           3054            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002DE6                          3055            
00002DE6                          3056            *INTITIALIZE FOR BIT SHIFTING
00002DE6  41F9 00003F48           3057            LEA     VAR_TEMP_CLEANCOPY,A0
00002DEC  2639 00003F48           3058            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002DF2                          3059  LOOP_SHIFTING
00002DF2  0C02 0000               3060            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002DF6  6700 0008               3061            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002DFA  E24B                    3062            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002DFC  5302                    3063            SUB.B   #1,D2                     *DECREMENT COUNTER
00002DFE  60F2                    3064            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00002E00                          3065  MASKING_NEXT
00002E00  C6BC 00000007           3066            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002E06  0603 0030               3067            ADD.B   #$30,D3                   *CONVERT TO CHAR
00002E0A  6100 0808               3068            BSR     PUSH_STACK                *PUSH TO STACK
00002E0E                          3069            
00002E0E  6000 0394               3070            BRA     GET_SRC_SUCCESS           *RETURN          
00002E12                          3071            
00002E12                          3072            
00002E12                          3073            *** Check if source ...  <ea> = An
00002E12  41F9 00003F3C           3074  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00002E18  1439 00003F3B           3075            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002E1E  1082                    3076            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002E20  0239 0002 00003F3C      3077            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00002E28  0C39 0002 00003F3C      3078            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00002E30  6700 006A               3079            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002E34  0CB9 00000001 00003F4C  3080            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00002E3E  6600 005C               3081            BNE     CHECK2
00002E42                          3082            
00002E42                          3083            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002E42  163C 0020               3084            MOVE.B    #' ',D3
00002E46  6100 07CC               3085            BSR       PUSH_STACK
00002E4A  163C 0041               3086            MOVE.B    #'A',D3
00002E4E  6100 07C4               3087            BSR       PUSH_STACK
00002E52                          3088  
00002E52                          3089            
00002E52                          3090            *FIND REGISTER NUMBER END LOCATION*  
00002E52  13F9 00003F3E 00003F44  3091            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002E5C  0239 000F 00003F44      3092            AND.B   #$0F,VAR_BYTE_END
00002E64                          3093            
00002E64                          3094            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002E64  23C5 00003F48           3095            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002E6A  1439 00003F44           3096            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00002E70                          3097            
00002E70                          3098            *INTITIALIZE FOR BIT SHIFTING
00002E70  41F9 00003F48           3099            LEA     VAR_TEMP_CLEANCOPY,A0
00002E76  2639 00003F48           3100            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002E7C                          3101  LOOP_SHIFTING1
00002E7C  0C02 0000               3102            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002E80  6700 0008               3103            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002E84  E24B                    3104            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002E86  5302                    3105            SUB.B   #1,D2                     *DECREMENT COUNTER
00002E88  60F2                    3106            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00002E8A                          3107  MASKING_NEXT1
00002E8A  C6BC 00000007           3108            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002E90  0603 0030               3109            ADD.B   #$30,D3                   *CONVERT TO CHAR
00002E94  6100 077E               3110            BSR     PUSH_STACK                *PUSH TO STACK
00002E98                          3111            
00002E98  6000 030A               3112            BRA     GET_SRC_SUCCESS                   *RETURN 
00002E9C                          3113            
00002E9C                          3114            
00002E9C                          3115            
00002E9C                          3116            
00002E9C                          3117            *** Check if source ...  <ea> = (An)       
00002E9C  41F9 00003F3C           3118  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00002EA2  1439 00003F3B           3119            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002EA8  1082                    3120            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002EAA  0239 0004 00003F3C      3121            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00002EB2  0C39 0004 00003F3C      3122            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00002EBA  6700 007A               3123            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00002EBE  0CB9 00000002 00003F4C  3124            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00002EC8  6600 006C               3125            BNE     CHECK3
00002ECC                          3126            
00002ECC                          3127            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00002ECC  163C 0020               3128            MOVE.B    #' ',D3
00002ED0  6100 0742               3129            BSR       PUSH_STACK
00002ED4  163C 0028               3130            MOVE.B    #'(',D3
00002ED8  6100 073A               3131            BSR       PUSH_STACK
00002EDC  163C 0041               3132            MOVE.B    #'A',D3
00002EE0  6100 0732               3133            BSR       PUSH_STACK
00002EE4                          3134  
00002EE4                          3135            
00002EE4                          3136            *FIND REGISTER NUMBER END LOCATION*  
00002EE4  13F9 00003F3E 00003F44  3137            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002EEE  0239 000F 00003F44      3138            AND.B   #$0F,VAR_BYTE_END
00002EF6                          3139            
00002EF6                          3140            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002EF6  23C5 00003F48           3141            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002EFC  1439 00003F44           3142            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002F02                          3143            
00002F02                          3144            *INTITIALIZE FOR BIT SHIFTING
00002F02  41F9 00003F48           3145            LEA     VAR_TEMP_CLEANCOPY,A0
00002F08  2639 00003F48           3146            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002F0E                          3147  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00002F0E  0C02 0000               3148            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002F12  6700 0008               3149            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00002F16  E24B                    3150            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002F18  5302                    3151            SUB.B   #1,D2                     *DECREMENT COUNTER
00002F1A  60F2                    3152            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00002F1C                          3153  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00002F1C  0283 00000007           3154            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002F22  0603 0030               3155            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00002F26  6100 06EC               3156            BSR     PUSH_STACK                *PUSH TO STACK
00002F2A                          3157            
00002F2A  163C 0029               3158            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00002F2E  6100 06E4               3159            BSR       PUSH_STACK
00002F32                          3160            
00002F32  6000 0270               3161            BRA     GET_SRC_SUCCESS                   *RETURN 
00002F36                          3162  
00002F36                          3163            
00002F36                          3164            
00002F36                          3165                      
00002F36                          3166  *** Check if source ...  <ea> = (An)+       
00002F36  41F9 00003F3C           3167  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00002F3C  1439 00003F3B           3168            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002F42  1082                    3169            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002F44  0239 0008 00003F3C      3170            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00002F4C  0C39 0008 00003F3C      3171            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00002F54  6700 0082               3172            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00002F58  0CB9 00000003 00003F4C  3173            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00002F62  6600 0074               3174            BNE     CHECK4
00002F66                          3175            
00002F66                          3176            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00002F66  163C 0020               3177            MOVE.B    #' ',D3
00002F6A  6100 06A8               3178            BSR       PUSH_STACK
00002F6E  163C 0028               3179            MOVE.B    #'(',D3
00002F72  6100 06A0               3180            BSR       PUSH_STACK
00002F76  163C 0041               3181            MOVE.B    #'A',D3
00002F7A  6100 0698               3182            BSR       PUSH_STACK
00002F7E                          3183  
00002F7E                          3184            
00002F7E                          3185            *FIND REGISTER NUMBER END LOCATION*  
00002F7E  13F9 00003F3E 00003F44  3186            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002F88  0239 000F 00003F44      3187            ANDI.B   #$0F,VAR_BYTE_END
00002F90                          3188            
00002F90                          3189            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002F90  23C5 00003F48           3190            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002F96  1439 00003F44           3191            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002F9C                          3192            
00002F9C                          3193            *INTITIALIZE FOR BIT SHIFTING
00002F9C  41F9 00003F48           3194            LEA     VAR_TEMP_CLEANCOPY,A0
00002FA2  2639 00003F48           3195            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002FA8                          3196            
00002FA8                          3197  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00002FA8  0C02 0000               3198            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002FAC  6700 0008               3199            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00002FB0  E24B                    3200            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002FB2  5302                    3201            SUBI.B   #1,D2                     *DECREMENT COUNTER
00002FB4  60F2                    3202            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00002FB6                          3203                                               *change: NAME OF LABEL*
00002FB6                          3204  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00002FB6  0283 00000007           3205            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002FBC  0603 0030               3206            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00002FC0  6100 0652               3207            BSR     PUSH_STACK                *PUSH TO STACK
00002FC4                          3208            
00002FC4  163C 0029               3209            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00002FC8  6100 064A               3210            BSR       PUSH_STACK
00002FCC  163C 002B               3211            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00002FD0  6100 0642               3212            BSR       PUSH_STACK
00002FD4                          3213            
00002FD4  6000 01CE               3214            BRA       GET_SRC_SUCCESS                   *RETURN 
00002FD8                          3215  
00002FD8                          3216            
00002FD8                          3217            
00002FD8                          3218                      
00002FD8                          3219            *** Check if source ...  <ea> = -(An)       
00002FD8  41F9 00003F3C           3220  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00002FDE  1439 00003F3B           3221            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002FE4  1082                    3222            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002FE6  0239 0010 00003F3C      3223            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00002FEE  0C39 0010 00003F3C      3224            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00002FF6  6700 0082               3225            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00002FFA  0CB9 00000004 00003F4C  3226            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003004  6600 0074               3227            BNE     CHECK7
00003008                          3228            
00003008                          3229            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003008  163C 0020               3230            MOVE.B    #' ',D3
0000300C  6100 0606               3231            BSR       PUSH_STACK
00003010  163C 002D               3232            MOVE.B    #'-',D3
00003014  6100 05FE               3233            BSR       PUSH_STACK
00003018  163C 0028               3234            MOVE.B    #'(',D3
0000301C  6100 05F6               3235            BSR       PUSH_STACK
00003020  163C 0041               3236            MOVE.B    #'A',D3
00003024  6100 05EE               3237            BSR       PUSH_STACK
00003028                          3238  
00003028                          3239            
00003028                          3240            *FIND REGISTER NUMBER END LOCATION*  
00003028  13F9 00003F3E 00003F44  3241            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003032  0239 000F 00003F44      3242            AND.B   #$0F,VAR_BYTE_END
0000303A                          3243            
0000303A                          3244            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000303A  23C5 00003F48           3245            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003040  1439 00003F44           3246            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003046                          3247            
00003046                          3248            *INTITIALIZE FOR BIT SHIFTING
00003046  41F9 00003F48           3249            LEA     VAR_TEMP_CLEANCOPY,A0
0000304C  2639 00003F48           3250            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003052                          3251            
00003052                          3252  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003052  0C02 0000               3253            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003056  6700 0008               3254            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000305A  E24B                    3255            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000305C  5302                    3256            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000305E  60F2                    3257            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003060                          3258                                               *change: NAME OF LABEL*
00003060                          3259  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003060  0283 00000007           3260            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003066  0603 0030               3261            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000306A  6100 05A8               3262            BSR     PUSH_STACK                *PUSH TO STACK
0000306E                          3263            
0000306E  163C 0029               3264            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003072  6100 05A0               3265            BSR       PUSH_STACK
00003076                          3266            
00003076  6000 012C               3267            BRA     GET_SRC_SUCCESS                   *RETURN
0000307A                          3268            
0000307A                          3269                      
0000307A                          3270            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000307A  0CB9 00000007 00003F4C  3271  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003084  6600 011A               3272            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003088                          3273                   
00003088                          3274            *NEXT: (MODE == 111) 
00003088                          3275            *NOW: CHECK FOR SRC REGISTER 
00003088                          3276                  *(000 = (xxx).W)
00003088                          3277                  *(001 = (xxx).L)
00003088                          3278                  *(010 = #<data>)
00003088                          3279                  
00003088                          3280            *FIND REGISTER NUMBER END LOCATION*  
00003088  13F9 00003F3E 00003F44  3281            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003092  0239 000F 00003F44      3282            AND.B   #$0F,VAR_BYTE_END
0000309A                          3283            
0000309A                          3284            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000309A  23C5 00003F48           3285            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000030A0  1439 00003F44           3286            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000030A6                          3287            
000030A6                          3288            *INTITIALIZE FOR BIT SHIFTING
000030A6  41F9 00003F48           3289            LEA     VAR_TEMP_CLEANCOPY,A0
000030AC  2C39 00003F48           3290            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000030B2                          3291  SRC_LOOP_SHIFTING
000030B2  0C02 0000               3292            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000030B6  6700 0008               3293            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000030BA  E24E                    3294            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000030BC  5302                    3295            SUB.B   #1,D2                     *DECREMENT COUNTER
000030BE  60F2                    3296            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
000030C0                          3297  SRC_MASKING_NEXT
000030C0  CCBC 00000007           3298            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000030C6                          3299           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000030C6                          3300           
000030C6                          3301  CHECK_WORD  
000030C6  41F9 00003F3C           3302            LEA     TEMP_REGISTER_FORMAT,A0
000030CC  1439 00003F3B           3303            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000030D2  1082                    3304            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000030D4  0239 0020 00003F3C      3305            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000030DC  0C39 0020 00003F3C      3306            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000030E4  6700 0026               3307            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000030E8  0C06 0000               3308            CMPI.B  #0,D6                          
000030EC  6600 001E               3309            BNE     CHECK_LONG 
000030F0                          3310            
000030F0                          3311            *IT IS A WORD AT THIS POINT*
000030F0                          3312            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000030F0  163C 0020               3313            MOVE.B    #' ',D3
000030F4  6100 051E               3314            BSR       PUSH_STACK
000030F8  163C 0024               3315            MOVE.B    #'$',D3
000030FC  6100 0516               3316            BSR       PUSH_STACK
00003100  321D                    3317            MOVE.W    (A5)+,D1
00003102  7404                    3318            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003104  6100 E102               3319            BSR       HEX2ASCII2STACK
00003108  6000 009A               3320            BRA     GET_SRC_SUCCESS
0000310C                          3321  
0000310C                          3322  CHECK_LONG
0000310C  41F9 00003F3C           3323            LEA     TEMP_REGISTER_FORMAT,A0
00003112  1439 00003F3B           3324            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003118  1082                    3325            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000311A  0239 0040 00003F3C      3326            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003122  0C39 0040 00003F3C      3327            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000312A  6700 002E               3328            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000312E  0C06 0001               3329            CMPI.B  #1,D6                          
00003132  6600 0026               3330            BNE     CHECK_IMMEDIATE  
00003136                          3331  
00003136                          3332            *IT IS A WORD AT THIS POINT*
00003136                          3333            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003136  163C 0020               3334            MOVE.B    #' ',D3
0000313A  6100 04D8               3335            BSR       PUSH_STACK
0000313E  163C 0024               3336            MOVE.B    #'$',D3
00003142  6100 04D0               3337            BSR       PUSH_STACK
00003146  321D                    3338            MOVE.W    (A5)+,D1
00003148  7404                    3339            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000314A  6100 E0BC               3340            BSR       HEX2ASCII2STACK
0000314E  321D                    3341            MOVE.W    (A5)+,D1
00003150  7404                    3342            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003152  6100 E0B4               3343            BSR       HEX2ASCII2STACK
00003156  6000 004C               3344            BRA     GET_SRC_SUCCESS
0000315A                          3345            
0000315A                          3346  CHECK_IMMEDIATE
0000315A  41F9 00003F3C           3347            LEA     TEMP_REGISTER_FORMAT,A0
00003160  1439 00003F3B           3348            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003166  1082                    3349            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003168  0239 0080 00003F3C      3350            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003170  0C39 0080 00003F3C      3351            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003178  6700 0026               3352            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000317C  0C06 0004               3353            CMPI.B  #4,D6                          
00003180  6600 001E               3354            BNE     GET_SRC_FAILED 
00003184                          3355  
00003184                          3356            *IT IS A WORD AT THIS POINT*
00003184                          3357            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003184  163C 0020               3358            MOVE.B    #' ',D3
00003188  6100 048A               3359            BSR       PUSH_STACK
0000318C  163C 0023               3360            MOVE.B    #'#',D3
00003190  6100 0482               3361            BSR       PUSH_STACK
00003194  321D                    3362            MOVE.W    (A5)+,D1
00003196  7404                    3363            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003198  6100 E06E               3364            BSR       HEX2ASCII2STACK
0000319C  6000 0006               3365            BRA     GET_SRC_SUCCESS
000031A0                          3366            
000031A0                          3367  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
000031A0  7801                    3368            MOVE.L #1,D4
000031A2  4E75                    3369            RTS
000031A4                          3370  GET_SRC_SUCCESS 
000031A4  4E75                    3371            RTS
000031A6                          3372                                 
000031A6                          3373      
000031A6                          3374  
000031A6                          3375  
000031A6                          3376  
000031A6                          3377  
000031A6                          3378  
000031A6                          3379  
000031A6                          3380  GET_EA_EA_DEST
000031A6                          3381  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000031A6                          3382      
000031A6                          3383      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000031A6  2405                    3384      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000031A8  EC8A                    3385      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
000031AA  23C2 00003F4C           3386      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000031B0  7407                    3387      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000031B2  C5B9 00003F4C           3388      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000031B8                          3389                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000031B8                          3390      
000031B8                          3391      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000031B8                          3392      *DESTINATION REGISTER FORMAT STANDARD         *
000031B8                          3393      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000031B8                          3394      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000031B8                          3395      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000031B8                          3396      *0 - Dn                                       *
000031B8                          3397      *1 - An                                       *
000031B8                          3398      *2 - (An)                                     *
000031B8                          3399      *3 - (An)+                                    *
000031B8                          3400      *4 - -(An)                                    *
000031B8                          3401      *5 - (XXX).W                                  *
000031B8                          3402      *6 - (XXX).L                                  *
000031B8                          3403      *7 - #<data>                                  *
000031B8                          3404      ***********************************************
000031B8                          3405      
000031B8                          3406      *** Check if source ...  <ea> = Dn
000031B8                          3407  DEST_CHECK0    
000031B8  41F9 00003F3C           3408            LEA     TEMP_REGISTER_FORMAT,A0
000031BE  1439 00003F3A           3409            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000031C4  1082                    3410            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000031C6  0239 0001 00003F3C      3411            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000031CE  0C39 0001 00003F3C      3412            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
000031D6  6700 006A               3413            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000031DA  0CB9 00000000 00003F4C  3414            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000031E4  6600 005C               3415            BNE     DEST_CHECK1
000031E8                          3416            
000031E8                          3417            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000031E8  163C 0020               3418            MOVE.B    #' ',D3
000031EC  6100 0426               3419            BSR       PUSH_STACK
000031F0  163C 0044               3420            MOVE.B    #'D',D3
000031F4  6100 041E               3421            BSR       PUSH_STACK
000031F8                          3422  
000031F8                          3423            *FIND REGISTER NUMBER END LOCATION*  
000031F8  13F9 00003F3D 00003F44  3424            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003202  0239 000F 00003F44      3425            AND.B   #$0F,VAR_BYTE_END
0000320A                          3426            
0000320A                          3427            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000320A  23C5 00003F48           3428            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003210  1439 00003F44           3429            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003216                          3430            
00003216                          3431            *INTITIALIZE FOR BIT SHIFTING
00003216  41F9 00003F48           3432            LEA     VAR_TEMP_CLEANCOPY,A0
0000321C  2639 00003F48           3433            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003222                          3434  DEST_LOOP_SHIFTING
00003222  0C02 0000               3435            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003226  6700 0008               3436            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000322A  E24B                    3437            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000322C  5302                    3438            SUB.B   #1,D2                     *DECREMENT COUNTER
0000322E  60F2                    3439            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003230                          3440  DEST_MASKING_NEXT
00003230  C6BC 00000007           3441            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003236  0603 0030               3442            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000323A  6100 03D8               3443            BSR     PUSH_STACK                *PUSH TO STACK
0000323E                          3444            
0000323E  6000 0394               3445            BRA     GET_DST_SUCCESS           *RETURN          
00003242                          3446            
00003242                          3447            
00003242                          3448            *** Check if source ...  <ea> = An
00003242                          3449  DEST_CHECK1    
00003242  41F9 00003F3C           3450            LEA     TEMP_REGISTER_FORMAT,A0
00003248  1439 00003F3A           3451            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000324E  1082                    3452            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003250  0239 0002 00003F3C      3453            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003258  0C39 0002 00003F3C      3454            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003260  6700 006A               3455            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003264  0CB9 00000001 00003F4C  3456            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
0000326E  6600 005C               3457            BNE     DEST_CHECK2
00003272                          3458            
00003272                          3459            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003272  163C 0020               3460            MOVE.B    #' ',D3
00003276  6100 039C               3461            BSR       PUSH_STACK
0000327A  163C 0041               3462            MOVE.B    #'A',D3
0000327E  6100 0394               3463            BSR       PUSH_STACK
00003282                          3464  
00003282                          3465            
00003282                          3466            *FIND REGISTER NUMBER END LOCATION*  
00003282  13F9 00003F3D 00003F44  3467            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000328C  0239 000F 00003F44      3468            AND.B   #$0F,VAR_BYTE_END
00003294                          3469            
00003294                          3470            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003294  23C5 00003F48           3471            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000329A  1439 00003F44           3472            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
000032A0                          3473            
000032A0                          3474            *INTITIALIZE FOR BIT SHIFTING
000032A0  41F9 00003F48           3475            LEA     VAR_TEMP_CLEANCOPY,A0
000032A6  2639 00003F48           3476            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000032AC                          3477  DEST_LOOP_SHIFTING1
000032AC  0C02 0000               3478            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000032B0  6700 0008               3479            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000032B4  E24B                    3480            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000032B6  5302                    3481            SUB.B   #1,D2                     *DECREMENT COUNTER
000032B8  60F2                    3482            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
000032BA                          3483  DEST_MASKING_NEXT1
000032BA  C6BC 00000007           3484            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000032C0  0603 0030               3485            ADD.B   #$30,D3                   *CONVERT TO CHAR
000032C4  6100 034E               3486            BSR     PUSH_STACK                *PUSH TO STACK
000032C8                          3487            
000032C8  6000 030A               3488            BRA     GET_DST_SUCCESS                   *RETURN 
000032CC                          3489            
000032CC                          3490            
000032CC                          3491            
000032CC                          3492            
000032CC                          3493            *** Check if source ...  <ea> = (An)       
000032CC                          3494  DEST_CHECK2    
000032CC  41F9 00003F3C           3495            LEA     TEMP_REGISTER_FORMAT,A0
000032D2  1439 00003F3A           3496            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000032D8  1082                    3497            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000032DA  0239 0004 00003F3C      3498            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000032E2  0C39 0004 00003F3C      3499            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000032EA  6700 007A               3500            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000032EE  0CB9 00000002 00003F4C  3501            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000032F8  6600 006C               3502            BNE     DEST_CHECK3
000032FC                          3503            
000032FC                          3504            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000032FC  163C 0020               3505            MOVE.B    #' ',D3
00003300  6100 0312               3506            BSR       PUSH_STACK
00003304  163C 0028               3507            MOVE.B    #'(',D3
00003308  6100 030A               3508            BSR       PUSH_STACK
0000330C  163C 0041               3509            MOVE.B    #'A',D3
00003310  6100 0302               3510            BSR       PUSH_STACK
00003314                          3511  
00003314                          3512            
00003314                          3513            *FIND REGISTER NUMBER END LOCATION*  
00003314  13F9 00003F3D 00003F44  3514            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000331E  0239 000F 00003F44      3515            AND.B   #$0F,VAR_BYTE_END
00003326                          3516            
00003326                          3517            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003326  23C5 00003F48           3518            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000332C  1439 00003F44           3519            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003332                          3520            
00003332                          3521            *INTITIALIZE FOR BIT SHIFTING
00003332  41F9 00003F48           3522            LEA     VAR_TEMP_CLEANCOPY,A0
00003338  2639 00003F48           3523            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000333E                          3524  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
0000333E  0C02 0000               3525            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003342  6700 0008               3526            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003346  E24B                    3527            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003348  5302                    3528            SUB.B   #1,D2                     *DECREMENT COUNTER
0000334A  60F2                    3529            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
0000334C                          3530  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
0000334C  0283 00000007           3531            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003352  0603 0030               3532            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003356  6100 02BC               3533            BSR     PUSH_STACK                *PUSH TO STACK
0000335A                          3534            
0000335A  163C 0029               3535            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000335E  6100 02B4               3536            BSR       PUSH_STACK
00003362                          3537            
00003362  6000 0270               3538            BRA     GET_DST_SUCCESS                   *RETURN 
00003366                          3539  
00003366                          3540            
00003366                          3541            
00003366                          3542                      
00003366                          3543  *** Check if source ...  <ea> = (An)+       
00003366  41F9 00003F3C           3544  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
0000336C  1439 00003F3A           3545            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003372  1082                    3546            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003374  0239 0008 00003F3C      3547            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
0000337C  0C39 0008 00003F3C      3548            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003384  6700 0082               3549            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003388  0CB9 00000003 00003F4C  3550            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003392  6600 0074               3551            BNE     DEST_CHECK4
00003396                          3552            
00003396                          3553            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003396  163C 0020               3554            MOVE.B    #' ',D3
0000339A  6100 0278               3555            BSR       PUSH_STACK
0000339E  163C 0028               3556            MOVE.B    #'(',D3
000033A2  6100 0270               3557            BSR       PUSH_STACK
000033A6  163C 0041               3558            MOVE.B    #'A',D3
000033AA  6100 0268               3559            BSR       PUSH_STACK
000033AE                          3560  
000033AE                          3561            
000033AE                          3562            *FIND REGISTER NUMBER END LOCATION*  
000033AE  13F9 00003F3D 00003F44  3563            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000033B8  0239 000F 00003F44      3564            ANDI.B   #$0F,VAR_BYTE_END
000033C0                          3565            
000033C0                          3566            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000033C0  23C5 00003F48           3567            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000033C6  1439 00003F44           3568            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000033CC                          3569            
000033CC                          3570            *INTITIALIZE FOR BIT SHIFTING
000033CC  41F9 00003F48           3571            LEA     VAR_TEMP_CLEANCOPY,A0
000033D2  2639 00003F48           3572            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000033D8                          3573            
000033D8                          3574  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
000033D8  0C02 0000               3575            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000033DC  6700 0008               3576            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000033E0  E24B                    3577            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000033E2  5302                    3578            SUBI.B   #1,D2                     *DECREMENT COUNTER
000033E4  60F2                    3579            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
000033E6                          3580                                               *change: NAME OF LABEL*
000033E6                          3581  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000033E6  0283 00000007           3582            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000033EC  0603 0030               3583            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000033F0  6100 0222               3584            BSR     PUSH_STACK                *PUSH TO STACK
000033F4                          3585            
000033F4  163C 0029               3586            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000033F8  6100 021A               3587            BSR       PUSH_STACK
000033FC  163C 002B               3588            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003400  6100 0212               3589            BSR       PUSH_STACK
00003404                          3590            
00003404  6000 01CE               3591            BRA       GET_DST_SUCCESS                   *RETURN 
00003408                          3592  
00003408                          3593            
00003408                          3594            
00003408                          3595                      
00003408                          3596            *** Check if source ...  <ea> = -(An)       
00003408                          3597  DEST_CHECK4    
00003408  41F9 00003F3C           3598            LEA     TEMP_REGISTER_FORMAT,A0
0000340E  1439 00003F3A           3599            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003414  1082                    3600            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003416  0239 0010 00003F3C      3601            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
0000341E  0C39 0010 00003F3C      3602            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003426  6700 0082               3603            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000342A  0CB9 00000004 00003F4C  3604            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003434  6600 0074               3605            BNE     DEST_CHECK7
00003438                          3606            
00003438                          3607            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003438  163C 0020               3608            MOVE.B    #' ',D3
0000343C  6100 01D6               3609            BSR       PUSH_STACK
00003440  163C 002D               3610            MOVE.B    #'-',D3
00003444  6100 01CE               3611            BSR       PUSH_STACK
00003448  163C 0028               3612            MOVE.B    #'(',D3
0000344C  6100 01C6               3613            BSR       PUSH_STACK
00003450  163C 0041               3614            MOVE.B    #'A',D3
00003454  6100 01BE               3615            BSR       PUSH_STACK
00003458                          3616  
00003458                          3617            
00003458                          3618            *FIND REGISTER NUMBER END LOCATION*  
00003458  13F9 00003F3D 00003F44  3619            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003462  0239 000F 00003F44      3620            AND.B   #$0F,VAR_BYTE_END
0000346A                          3621            
0000346A                          3622            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000346A  23C5 00003F48           3623            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003470  1439 00003F44           3624            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003476                          3625            
00003476                          3626            *INTITIALIZE FOR BIT SHIFTING
00003476  41F9 00003F48           3627            LEA     VAR_TEMP_CLEANCOPY,A0
0000347C  2639 00003F48           3628            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003482                          3629            
00003482                          3630  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003482  0C02 0000               3631            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003486  6700 0008               3632            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000348A  E24B                    3633            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000348C  5302                    3634            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000348E  60F2                    3635            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003490                          3636                                               *change: NAME OF LABEL*
00003490                          3637  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003490  0283 00000007           3638            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003496  0603 0030               3639            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000349A  6100 0178               3640            BSR     PUSH_STACK                *PUSH TO STACK
0000349E                          3641            
0000349E  163C 0029               3642            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000034A2  6100 0170               3643            BSR       PUSH_STACK
000034A6                          3644            
000034A6  6000 012C               3645            BRA     GET_DST_SUCCESS                   *RETURN
000034AA                          3646            
000034AA                          3647                      
000034AA                          3648            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000034AA                          3649  DEST_CHECK7    
000034AA  0CB9 00000007 00003F4C  3650            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000034B4  6600 011A               3651            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000034B8                          3652                   
000034B8                          3653            *NEXT: (MODE == 111) 
000034B8                          3654            *NOW: CHECK FOR SRC REGISTER 
000034B8                          3655                  *(000 = (xxx).W)
000034B8                          3656                  *(001 = (xxx).L)
000034B8                          3657                  *(010 = #<data>)
000034B8                          3658                  
000034B8                          3659            *FIND REGISTER NUMBER END LOCATION*  
000034B8  13F9 00003F3D 00003F44  3660            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000034C2  0239 000F 00003F44      3661            AND.B   #$0F,VAR_BYTE_END
000034CA                          3662            
000034CA                          3663            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000034CA  23C5 00003F48           3664            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000034D0  1439 00003F44           3665            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000034D6                          3666            
000034D6                          3667            *INTITIALIZE FOR BIT SHIFTING
000034D6  41F9 00003F48           3668            LEA     VAR_TEMP_CLEANCOPY,A0
000034DC  2C39 00003F48           3669            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000034E2                          3670  DEST_LOOP_SHIFTING7
000034E2  0C02 0000               3671            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000034E6  6700 0008               3672            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000034EA  E24E                    3673            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000034EC  5302                    3674            SUB.B   #1,D2                     *DECREMENT COUNTER
000034EE  60F2                    3675            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
000034F0                          3676  DEST_MASKING_NEXT7
000034F0  CCBC 00000007           3677            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000034F6                          3678           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000034F6                          3679            
000034F6                          3680  DEST_CHECK_WORD  
000034F6  41F9 00003F3C           3681            LEA     TEMP_REGISTER_FORMAT,A0
000034FC  1439 00003F3A           3682            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003502  1082                    3683            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003504  0239 0020 00003F3C      3684            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
0000350C  0C39 0020 00003F3C      3685            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003514  6700 0026               3686            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003518  0C06 0000               3687            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
0000351C  6600 001E               3688            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003520                          3689            *IT IS A WORD AT THIS POINT*
00003520                          3690            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003520  163C 0020               3691            MOVE.B    #' ',D3
00003524  6100 00EE               3692            BSR       PUSH_STACK
00003528  163C 0024               3693            MOVE.B    #'$',D3
0000352C  6100 00E6               3694            BSR       PUSH_STACK
00003530  321D                    3695            MOVE.W    (A5)+,D1
00003532  7404                    3696            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003534  6100 DCD2               3697            BSR       HEX2ASCII2STACK
00003538  6000 009A               3698            BRA       GET_DST_SUCCESS
0000353C                          3699  
0000353C                          3700  DEST_CHECK_LONG
0000353C  41F9 00003F3C           3701            LEA     TEMP_REGISTER_FORMAT,A0
00003542  1439 00003F3A           3702            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003548  1082                    3703            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000354A  0239 0040 00003F3C      3704            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003552  0C39 0040 00003F3C      3705            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000355A  6700 002E               3706            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000355E  0C06 0001               3707            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003562  6600 0026               3708            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003566                          3709            *IT IS A WORD AT THIS POINT*
00003566                          3710            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003566  163C 0020               3711            MOVE.B    #' ',D3
0000356A  6100 00A8               3712            BSR       PUSH_STACK
0000356E  163C 0024               3713            MOVE.B    #'$',D3
00003572  6100 00A0               3714            BSR       PUSH_STACK
00003576  321D                    3715            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003578  7404                    3716            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
0000357A  6100 DC8C               3717            BSR       HEX2ASCII2STACK
0000357E  321D                    3718            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003580  7404                    3719            MOVE.L    #4,D2          
00003582  6100 DC84               3720            BSR       HEX2ASCII2STACK
00003586  6000 004C               3721            BRA     GET_DST_SUCCESS
0000358A                          3722            
0000358A                          3723  DEST_CHECK_IMMEDIATE
0000358A  41F9 00003F3C           3724            LEA     TEMP_REGISTER_FORMAT,A0
00003590  1439 00003F3A           3725            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003596  1082                    3726            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003598  0239 0080 00003F3C      3727            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000035A0  0C39 0080 00003F3C      3728            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000035A8  6700 0026               3729            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000035AC  0C06 0004               3730            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
000035B0  6600 001E               3731            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
000035B4                          3732            
000035B4                          3733            *IT IS A WORD AT THIS POINT*
000035B4                          3734            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000035B4  163C 0020               3735            MOVE.B    #' ',D3
000035B8  6100 005A               3736            BSR       PUSH_STACK
000035BC  163C 0023               3737            MOVE.B    #'#',D3
000035C0  6100 0052               3738            BSR       PUSH_STACK
000035C4  321D                    3739            MOVE.W    (A5)+,D1
000035C6  7404                    3740            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000035C8  6100 DC3E               3741            BSR       HEX2ASCII2STACK
000035CC  6000 0006               3742            BRA       GET_DST_SUCCESS
000035D0                          3743            
000035D0                          3744  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
000035D0  7801                    3745            MOVE.L #1,D4
000035D2  4E75                    3746            RTS
000035D4                          3747  GET_DST_SUCCESS 
000035D4  4E75                    3748            RTS
000035D6                          3749  
000035D6                          3750  
000035D6                          3751  *---------------------------------------------------------------------------*
000035D6                          3752  * STACK/QUEUE INTERFACE
000035D6                          3753  *---------------------------------------------------------------------------*
000035D6                          3754  PRINT_STACK
000035D6  0C39 0000 00003F36      3755            CMP.B     #0,COUNTER
000035DE  6700 000E               3756            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
000035E2                          3757            
000035E2                          3758  PRINT_STACK_HELPER
000035E2  6100 0038               3759            BSR      POP_STACK          *PRINTS ADDRESS
000035E6  103C 0006               3760            MOVE.B   #6,D0              *Display single character in D1.B. 
000035EA  4E4F                    3761            TRAP     #15             *ACTIVATES PRINT
000035EC                          3762  
000035EC  60E8                    3763            BRA       PRINT_STACK
000035EE                          3764  PRINT_STACK_RETURN
000035EE  4E75                    3765            RTS
000035F0                          3766            
000035F0                          3767            
000035F0                          3768  PRINT_QUEUE
000035F0  0C39 0000 00003F36      3769            CMP.B     #0,COUNTER
000035F8  6700 0018               3770            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
000035FC                          3771            
000035FC                          3772  PRINT_QUEUE_HELPER
000035FC  33F9 00003F36 00003F38  3773            MOVE.W   COUNTER,QUEUE_COUNTER
00003606  6100 0022               3774            BSR      POP_FRONT          *PRINTS ADDRESS
0000360A  103C 0006               3775            MOVE.B   #6,D0              *Display single character in D1.B. 
0000360E  4E4F                    3776            TRAP     #15             *ACTIVATES PRINT
00003610                          3777  
00003610  60DE                    3778            BRA       PRINT_QUEUE
00003612                          3779  PRINT_QUEUE_RETURN
00003612  4E75                    3780            RTS
00003614                          3781            
00003614                          3782  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003614                          3783  PUSH_STACK
00003614  1503                    3784              MOVE.B  D3,-(A2)
00003616  6100 0058               3785              BSR     INCREMENT
0000361A  4E75                    3786              RTS
0000361C                          3787  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
0000361C                          3788  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
0000361C                          3789  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
0000361C                          3790  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
0000361C                          3791  *         TRAP        #15             *ACTIVATES PRINT
0000361C                          3792  POP_STACK
0000361C  BECA                    3793              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
0000361E  6700 0008               3794              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003622  121A                    3795              MOVE.B  (A2)+,D1 
00003624  6100 0052               3796              BSR     DECREMENT
00003628                          3797  POP_RETURN
00003628  4E75                    3798              RTS 
0000362A                          3799        
0000362A                          3800  *USE [A4] AS SECOND POINTER IN SHIFTING      
0000362A  0C39 0000 00003F38      3801  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003632  6700 0030               3802              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003636                          3803              
00003636                          3804              
00003636                          3805              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003636  347C 7000               3806              MOVEA.W #STACK,A2   *START A2 AT STACK
0000363A  0622 0000               3807              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
0000363E  384A                    3808              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003640  0624 0000               3809              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003644  1212                    3810              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003646                          3811  POP_SHIFT_LOOP
00003646  0C39 0000 00003F38      3812              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000364E  6700 0014               3813              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003652  1494                    3814              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003654  0624 0000               3815              ADD.B   #0,-(A4)
00003658  0622 0000               3816              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
0000365C  5339 00003F38           3817              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003662                          3818              
00003662  60E2                    3819              BRA     POP_SHIFT_LOOP
00003664                          3820                          
00003664                          3821  POP_FRONT_RETURN 
00003664                          3822              *RESET A2 BACK TO SP
00003664  347C 7000               3823              MOVEA.W #STACK,A2    
00003668  5339 00003F36           3824              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
0000366E  4E75                    3825              RTS   
00003670                          3826  
00003670                          3827  INCREMENT
00003670  5239 00003F36           3828              ADD.B   #1, COUNTER
00003676  4E75                    3829              RTS           
00003678                          3830  DECREMENT
00003678  5339 00003F36           3831              SUB.B   #1, COUNTER
0000367E  4E75                    3832              RTS           
00003680                          3833  CLEAR_STACK
00003680  0C39 0000 00003F36      3834              CMP.B     #0,COUNTER
00003688  6700 0006               3835              BEQ       CLEAR_RETURN
0000368C  618E                    3836              BSR       POP_STACK
0000368E  60F0                    3837              BRA       CLEAR_STACK
00003690                          3838   
00003690                          3839  CLEAR_RETURN
00003690  4E75                    3840              RTS    
00003692                          3841  *---------------------------------------------------------------------------*
00003692                          3842  * TERMINATE
00003692                          3843  *---------------------------------------------------------------------------*
00003692                          3844  TERMINATE   
00003692  43F9 00003A42           3845              LEA     FINMSG,A1
00003698  103C 000E               3846              MOVE.B  #14,D0
0000369C  4E4F                    3847              TRAP    #15
0000369E                          3848  
0000369E  103C 0009               3849              MOVE.B  #9,D0
000036A2  4E4F                    3850              TRAP    #15
000036A4                          3851  
000036A4                          3852  *---------------------------------------------------------------------------*
000036A4                          3853  * Data storage                                                 
000036A4                          3854  *---------------------------------------------------------------------------*  
000036A4                          3855  WELCOME
000036A4= 20 20 20 20 20 20 ...   3856              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
000036F4= 3D 3D 3D 3D 3D 20 ...   3857              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003744= 3D 3D 3D 3D 3D 20 ...   3858              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003794                          3859      
00003794= 20 20 20 20 20 20 ...   3860              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
000037E4= 20 20 20 20 20 20 ...   3861              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00003834= 20 20 20 20 20 20 ...   3862              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003884                          3863      
00003884= 20 20 20 20 20 20 ...   3864              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
000038D4= 3D 3D 3D 3D 3D 20 ...   3865              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00003924= 3D 3D 3D 3D 3D 20 ...   3866              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003979                          3867  
00003979                          3868  PROMPT_START
00003979= 50 6C 65 61 73 65 ...   3869              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000039A8                          3870      
000039A8                          3871  PROMPT_END
000039A8= 50 6C 65 61 73 65 ...   3872              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
000039D5= 0D 0A 48 69 74 20 ...   3873  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
000039FF= 57 6F 75 6C 64 20 ...   3874  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003A42= 54 68 61 6E 6B 20 ...   3875  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003A6D= 45 72 72 6F 72 3A ...   3876  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003A8C= 45 72 72 6F 72 3A ...   3877  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003AB1= 45 72 72 6F 72 3A ...   3878  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003ADE                          3879  
00003ADE                          3880  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003B2E                          3881  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003B7E                          3882  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003B82                          3883  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003B86= 0D 0A 00                3884  ENDLINE_M   DC.B    CR,LF,0
00003B89                          3885  TMPINPUT    DS.B    80                      * temp store user input
00003BD9                          3886  TMPOUTPUT   DS.B    80                      * temp store prog output
00003C29= 20 20 20 4F 52 49 ...   3887  DISP_ORI_B  DC.B    '   ORI.B',0
00003C32= 20 20 20 4F 52 49 ...   3888  DISP_ORI_W  DC.B    '   ORI.W',0
00003C3B= 20 20 20 4F 52 49 ...   3889  DISP_ORI_L  DC.B    '   ORI.L',0
00003C44= 20 20 20 45 4F 52 ...   3890  DISP_EORI_B  DC.B    '   EORI.B',0
00003C4E= 20 20 20 45 4F 52 ...   3891  DISP_EORI_W  DC.B    '   EORI.W',0
00003C58= 20 20 20 45 4F 52 ...   3892  DISP_EORI_L  DC.B    '   EORI.L',0
00003C62= 20 20 20 42 54 53 ...   3893  DISP_BTST   DC.B    '   BTST',0
00003C6A= 20 20 20 43 4D 50 ...   3894  DISP_CMPI_B  DC.B    '   CMPI.B',0
00003C74= 20 20 20 43 4D 50 ...   3895  DISP_CMPI_W  DC.B    '   CMPI.W',0
00003C7E= 20 20 20 43 4D 50 ...   3896  DISP_CMPI_L  DC.B    '   CMPI.L',0
00003C88= 20 20 20 44 41 54 ...   3897  DISP_DATA   DC.B    '   DATA',0
00003C90= 20 20 20 4D 4F 56 ...   3898  DISP_MOVE_B DC.B    '   MOVE.B',0
00003C9A= 20 20 20 4D 4F 56 ...   3899  DISP_MOVE_W DC.B    '   MOVE.W',0
00003CA4= 20 20 20 4D 4F 56 ...   3900  DISP_MOVE_L DC.B    '   MOVE.L',0
00003CAE= 20 20 20 52 54 53 00    3901  DISP_RTS    DC.B    '   RTS',0
00003CB5= 20 20 20 4A 53 52 00    3902  DISP_JSR    DC.B    '   JSR',0
00003CBC= 20 20 20 4E 45 47 ...   3903  DISP_NEG_B    DC.B    '   NEG.B',0
00003CC5= 20 20 20 4E 45 47 ...   3904  DISP_NEG_W    DC.B    '   NEG.W',0
00003CCE= 20 20 20 4E 45 47 ...   3905  DISP_NEG_L    DC.B    '   NEG.L',0
00003CD7= 20 20 20 4E 4F 54 ...   3906  DISP_NOT_B  DC.B    '   NOT.B',0
00003CE0= 20 20 20 4E 4F 54 ...   3907  DISP_NOT_W  DC.B    '   NOT.W',0
00003CE9= 20 20 20 4E 4F 54 ...   3908  DISP_NOT_L  DC.B    '   NOT.L',0
00003CF2= 20 20 20 4C 45 41 00    3909  DISP_LEA    DC.B    '   LEA',0
00003CF9= 20 20 20 4D 4F 56 ...   3910  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00003D04= 20 20 20 4D 4F 56 ...   3911  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00003D0F= 20 20 20 41 44 44 ...   3912  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00003D19= 20 20 20 41 44 44 ...   3913  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00003D23= 20 20 20 41 44 44 ...   3914  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00003D2D= 20 20 20 44 49 56 ...   3915  DISP_DIVS   DC.B    '   DIVS',0
00003D35= 20 20 20 53 55 42 ...   3916  DISP_SUB_B  DC.B    '   SUB.B',0
00003D3E= 20 20 20 53 55 42 ...   3917  DISP_SUB_W  DC.B    '   SUB.W',0
00003D47= 20 20 20 53 55 42 ...   3918  DISP_SUB_L  DC.B    '   SUB.L',0
00003D50= 20 20 20 53 55 42 ...   3919  DISP_SUBI_B  DC.B    '   SUBI.B',0
00003D5A= 20 20 20 53 55 42 ...   3920  DISP_SUBI_W  DC.B    '   SUBI.W',0
00003D64= 20 20 20 53 55 42 ...   3921  DISP_SUBI_L  DC.B    '   SUBI.L',0
00003D6E= 20 20 20 53 55 42 ...   3922  DISP_SUBA_W  DC.B    '   SUBA.W',0
00003D78= 20 20 20 53 55 42 ...   3923  DISP_SUBA_L  DC.B    '   SUBA.L',0
00003D82= 20 20 20 45 4F 52 ...   3924  DISP_EOR_B  DC.B    '   EOR.B',0
00003D8B= 20 20 20 45 4F 52 ...   3925  DISP_EOR_W  DC.B    '   EOR.W',0
00003D94= 20 20 20 45 4F 52 ...   3926  DISP_EOR_L  DC.B    '   EOR.L',0
00003D9D= 20 20 20 43 4D 50 ...   3927  DISP_CMP_B  DC.B    '   CMP.B',0
00003DA6= 20 20 20 43 4D 50 ...   3928  DISP_CMP_W  DC.B    '   CMP.W',0
00003DAF= 20 20 20 43 4D 50 ...   3929  DISP_CMP_L  DC.B    '   CMP.L',0
00003DB8= 20 20 20 43 4D 50 ...   3930  DISP_CMPA_W  DC.B    '   CMPA.W',0
00003DC2= 20 20 20 43 4D 50 ...   3931  DISP_CMPA_L  DC.B    '   CMPA.L',0
00003DCC= 20 20 20 4D 55 4C ...   3932  DISP_MULS_W DC.B    '   MULS.W',0
00003DD6= 20 20 20 41 4E 44 ...   3933  DISP_AND_B  DC.B    '   AND.B',0
00003DDF= 20 20 20 41 4E 44 ...   3934  DISP_AND_W  DC.B    '   AND.W',0
00003DE8= 20 20 20 41 4E 44 ...   3935  DISP_AND_L  DC.B    '   AND.L',0
00003DF1= 20 20 20 41 44 44 ...   3936  DISP_ADD_B  DC.B    '   ADD.B',0
00003DFA= 20 20 20 41 44 44 ...   3937  DISP_ADD_W  DC.B    '   ADD.W',0
00003E03= 20 20 20 41 44 44 ...   3938  DISP_ADD_L  DC.B    '   ADD.L',0
00003E0C= 20 20 20 41 44 44 ...   3939  DISP_ADDA_W DC.B    '   ADDA.W',0
00003E16= 20 20 20 41 44 44 ...   3940  DISP_ADDA_L DC.B    '   ADDA.L',0
00003E20= 20 20 20 4C 53 52 ...   3941  DISP_LSR_B  DC.B    '   LSR.B',0
00003E29= 20 20 20 4C 53 4C ...   3942  DISP_LSL_B  DC.B    '   LSL.B',0
00003E32= 20 20 20 4C 53 52 ...   3943  DISP_LSR_W  DC.B    '   LSR.W',0
00003E3B= 20 20 20 4C 53 4C ...   3944  DISP_LSL_W  DC.B    '   LSL.W',0
00003E44= 20 20 20 4C 53 52 ...   3945  DISP_LSR_L  DC.B    '   LSR.L',0
00003E4D= 20 20 20 4C 53 4C ...   3946  DISP_LSL_L  DC.B    '   LSL.L',0
00003E56= 20 20 20 41 53 52 ...   3947  DISP_ASR_B  DC.B    '   ASR.B',0
00003E5F= 20 20 20 41 53 4C ...   3948  DISP_ASL_B  DC.B    '   ASL.B',0
00003E68= 20 20 20 41 53 52 ...   3949  DISP_ASR_W  DC.B    '   ASR.W',0
00003E71= 20 20 20 41 53 4C ...   3950  DISP_ASL_W  DC.B    '   ASL.W',0
00003E7A= 20 20 20 41 53 52 ...   3951  DISP_ASR_L  DC.B    '   ASR.L',0
00003E83= 20 20 20 41 53 4C ...   3952  DISP_ASL_L  DC.B    '   ASL.L',0
00003E8C= 20 20 20 52 4F 52 ...   3953  DISP_ROR_B  DC.B    '   ROR.B',0
00003E95= 20 20 20 52 4F 4C ...   3954  DISP_ROL_B  DC.B    '   ROL.B',0
00003E9E= 20 20 20 52 4F 52 ...   3955  DISP_ROR_W  DC.B    '   ROR.W',0
00003EA7= 20 20 20 52 4F 4C ...   3956  DISP_ROL_W  DC.B    '   ROL.W',0
00003EB0= 20 20 20 52 4F 52 ...   3957  DISP_ROR_L  DC.B    '   ROR.L',0
00003EB9= 20 20 20 52 4F 4C ...   3958  DISP_ROL_L  DC.B    '   ROL.L',0
00003EC2= 20 20 20 42 52 41 00    3959  DISP_BRA    DC.B    '   BRA',0
00003EC9= 20 20 20 42 4C 54 00    3960  DISP_BLT    DC.B    '   BLT',0
00003ED0= 20 20 20 42 45 51 00    3961  DISP_BEQ    DC.B    '   BEQ',0
00003ED7= 20 20 20 42 4E 45 00    3962  DISP_BNE    DC.B    '   BNE',0
00003EDE= 20 20 20 42 48 49 00    3963  DISP_BHI    DC.B    '   BHI',0
00003EE5= 20 20 20 4D 4F 56 ...   3964  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00003EF0= 20 20 20 4D 4F 56 ...   3965  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00003EFB                          3966  
00003EFB= 20 20 20 24 00          3967  DISP_HEX     DC.B    '   $',0
00003F00= 20 20 20 44 00          3968  DISP_D  DC.B    '   D',0
00003F05= 20 20 20 41 00          3969  DISP_A  DC.B    '   A',0
00003F0A= 20 20 20 28 00          3970  DISP_OP  DC.B    '   (',0
00003F0F= 29 00                   3971  DISP_CP  DC.B   ')',0
00003F11= 20 20 20 28 41 00       3972  DISP_AOP  DC.B    '   (A',0
00003F17                          3973  
00003F17= 20 20 20 2D 28 41 00    3974  DISP_PRE    DC.B    '   -(A',0
00003F1E= 29 2B 00                3975  DISP_POST   DC.B    ')+',0
00003F21= 20 20 20 23 00          3976  DISP_LB DC.B    '   #',0
00003F26= 30 00                   3977  DISP_0  DC.B    '0',0
00003F28= 31 00                   3978  DISP_1  DC.B    '1',0
00003F2A= 32 00                   3979  DISP_2  DC.B    '2',0
00003F2C= 33 00                   3980  DISP_3  DC.B    '3',0
00003F2E= 34 00                   3981  DISP_4  DC.B    '4',0
00003F30= 35 00                   3982  DISP_5  DC.B    '5',0
00003F32= 36 00                   3983  DISP_6  DC.B    '6',0
00003F34= 37 00                   3984  DISP_7  DC.B    '7',0
00003F36                          3985  
00003F36                          3986  *STACK INTERFACE VARIABLES*
00003F36                          3987  COUNTER         DS.W    1
00003F38                          3988  QUEUE_COUNTER   DS.W    1
00003F3A                          3989  
00003F3A                          3990  *EA DECODING INTERFACE VARIABLES* 
00003F3A                          3991  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00003F3B                          3992  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00003F3C                          3993  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00003F3D                          3994  
00003F3D                          3995  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00003F3D                          3996  * WORD + WORD = LONG
00003F3D                          3997  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00003F3D                          3998  * A              + F            = AF         <= EXAMPLE
00003F3D                          3999  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00003F3D                          4000  GET_DST_START_END    DS.B    1
00003F3E                          4001  GET_SRC_START_END    DS.B    1
00003F3F                          4002  
00003F3F                          4003  *STORES THE START + END BITS HERE (FROM ABOVE)
00003F40                          4004  VAR_BYTE_START      DS.L    1
00003F44                          4005  VAR_BYTE_END        DS.L    1
00003F48                          4006  VAR_TEMP_CLEANCOPY  DS.L    1
00003F4C                          4007  
00003F4C                          4008  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00003F50                          4009  
00003F50                          4010  *MORE FOR STACK USAGE*
00003F50= 2C 00                   4011  DISP_COMMA  DC.B    ',',0
00003F52= 20 20 20 00             4012  DISP_INDENT  DC.B    '   ',0
00003F56                          4013  
00003F56                          4014  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00003F56                          4015  POINTER_WORD    DS.W       1
00003F58                          4016  
00003F58                          4017  
00003F58                          4018  
00003F58                          4019  *---------------------------------------------------------------------------*
00003F58                          4020  * Ends program
00003F58                          4021  *---------------------------------------------------------------------------*
00003F58                          4022              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1164
ASCII2HEX           115E
ASC_ERR             11C0
ASC_LOW             11A2
ASC_NUM             11B2
ASC_SFT             11BA
ASC_UPP             11AA
CHECK0              2D88
CHECK1              2E12
CHECK2              2E9C
CHECK3              2F36
CHECK4              2FD8
CHECK7              307A
CHECK_IMMEDIATE     315A
CHECK_LONG          310C
CHECK_WORD          30C6
CLEAR_RETURN        3690
CLEAR_STACK         3680
COUNTER             3F36
CR                  D
DECREMENT           3678
DEST_CHECK0         31B8
DEST_CHECK1         3242
DEST_CHECK2         32CC
DEST_CHECK3         3366
DEST_CHECK4         3408
DEST_CHECK7         34AA
DEST_CHECK_IMMEDIATE  358A
DEST_CHECK_LONG     353C
DEST_CHECK_WORD     34F6
DEST_LOOP_SHIFTING  3222
DEST_LOOP_SHIFTING1  32AC
DEST_LOOP_SHIFTING2  333E
DEST_LOOP_SHIFTING3  33D8
DEST_LOOP_SHIFTING4  3482
DEST_LOOP_SHIFTING7  34E2
DEST_MASKING_NEXT   3230
DEST_MASKING_NEXT1  32BA
DEST_MASKING_NEXT2  334C
DEST_MASKING_NEXT3  33E6
DEST_MASKING_NEXT4  3490
DEST_MASKING_NEXT7  34F0
DEST_MODE           2940
DEST_REGISTER       2C10
DEST_REGISTER_FORMAT  3F3A
DISPLAY_30_LINES    130C
DISP_0              3F26
DISP_1              3F28
DISP_2              3F2A
DISP_3              3F2C
DISP_4              3F2E
DISP_5              3F30
DISP_6              3F32
DISP_7              3F34
DISP_A              3F05
DISP_ADDA_L         3E16
DISP_ADDA_W         3E0C
DISP_ADDQ_B         3D0F
DISP_ADDQ_L         3D23
DISP_ADDQ_W         3D19
DISP_ADD_B          3DF1
DISP_ADD_L          3E03
DISP_ADD_W          3DFA
DISP_AND_B          3DD6
DISP_AND_L          3DE8
DISP_AND_W          3DDF
DISP_AOP            3F11
DISP_ASL_B          3E5F
DISP_ASL_L          3E83
DISP_ASL_W          3E71
DISP_ASR_B          3E56
DISP_ASR_L          3E7A
DISP_ASR_W          3E68
DISP_BEQ            3ED0
DISP_BHI            3EDE
DISP_BLT            3EC9
DISP_BNE            3ED7
DISP_BRA            3EC2
DISP_BTST           3C62
DISP_CMPA_L         3DC2
DISP_CMPA_W         3DB8
DISP_CMPI_B         3C6A
DISP_CMPI_L         3C7E
DISP_CMPI_W         3C74
DISP_CMP_B          3D9D
DISP_CMP_L          3DAF
DISP_CMP_W          3DA6
DISP_COMMA          3F50
DISP_CP             3F0F
DISP_D              3F00
DISP_DATA           3C88
DISP_DIVS           3D2D
DISP_EORI_B         3C44
DISP_EORI_L         3C58
DISP_EORI_W         3C4E
DISP_EOR_B          3D82
DISP_EOR_L          3D94
DISP_EOR_W          3D8B
DISP_HEX            3EFB
DISP_INDENT         3F52
DISP_JSR            3CB5
DISP_LB             3F21
DISP_LEA            3CF2
DISP_LSL_B          3E29
DISP_LSL_L          3E4D
DISP_LSL_W          3E3B
DISP_LSR_B          3E20
DISP_LSR_L          3E44
DISP_LSR_W          3E32
DISP_MOVEA_L        3EF0
DISP_MOVEA_W        3EE5
DISP_MOVEM_L        3D04
DISP_MOVEM_W        3CF9
DISP_MOVE_B         3C90
DISP_MOVE_L         3CA4
DISP_MOVE_W         3C9A
DISP_MULS_W         3DCC
DISP_NEG_B          3CBC
DISP_NEG_L          3CCE
DISP_NEG_W          3CC5
DISP_NEXT           39D5
DISP_NOT_B          3CD7
DISP_NOT_L          3CE9
DISP_NOT_W          3CE0
DISP_OP             3F0A
DISP_ORI_B          3C29
DISP_ORI_L          3C3B
DISP_ORI_W          3C32
DISP_POST           3F1E
DISP_PRE            3F17
DISP_ROL_B          3E95
DISP_ROL_L          3EB9
DISP_ROL_W          3EA7
DISP_ROR_B          3E8C
DISP_ROR_L          3EB0
DISP_ROR_W          3E9E
DISP_RTS            3CAE
DISP_SUBA_L         3D78
DISP_SUBA_W         3D6E
DISP_SUBI_B         3D50
DISP_SUBI_L         3D64
DISP_SUBI_W         3D5A
DISP_SUB_B          3D35
DISP_SUB_L          3D47
DISP_SUB_W          3D3E
D_MODE000           29E2
D_MODE010           2A2A
D_MODE011           2A8A
D_MODE100           2AAA
D_MODE111           2AFC
EA_ARITH            28DA
EA_DATA             14EA
EA_GEN              2926
EA_MOVEA            2900
EA_NOSRC            28C6
ENDLINE_M           3B86
END_ADDR            10AA
ERRMSG_1            3A6D
ERRMSG_3            3A8C
ERRMSG_5            3AB1
ERROR_1             110E
ERROR_2             111E
ERROR_3             112E
ERROR_4             113E
ERROR_5             114E
E_ADDR_HX           3B82
FINMSG              3A42
GET_DST_FAILED      35D0
GET_DST_START_END   3F3D
GET_DST_SUCCESS     35D4
GET_EA_EA_DEST      31A6
GET_EA_EA_SRC       2D76
GET_SRC_FAILED      31A0
GET_SRC_START_END   3F3E
GET_SRC_SUCCESS     31A4
HEX2ASCII           11C6
HEX2ASCII2STACK     1208
HEX_CHAR            11F4
HEX_CONT            11F8
HEX_LOOP            11DA
IMMD_B              2BB0
IMMD_L              2BF0
IMMD_W              2BD0
IMMEDIATE           2B80
INCREMENT           3670
INTRO               1028
IS_ODD              124C
IS_ODD_ERR          1262
JMPTABLE            1338
LF                  A
LONGMODE            2B54
LOOP_SHIFTING       2DF2
LOOP_SHIFTING1      2E7C
LOOP_SHIFTING2      2F0E
LOOP_SHIFTING3      2FA8
LOOP_SHIFTING4      3052
MAIN                1268
MASKING_NEXT        2E00
MASKING_NEXT1       2E8A
MASKING_NEXT2       2F1C
MASKING_NEXT3       2FB6
MASKING_NEXT4       3060
MODE000             29CE
MODE001             29F6
MODE010             2A0A
MODE011             2A4A
MODE100             2A6A
MODE111             2ACA
NEXTLINES           131A
OP0000              1398
OP0001              15BE
OP0010              162C
OP0011              172A
OP0100              1826
OP0101              19C0
OP0110              1A3C
OP0111              1ACA
OP1000              1ACE
OP1001              1B0A
OP1001_ADD_RETURN   1E58
OP1001_DETERMINE_DN_EA_OR_EA_DN  1C20
OP1001_DN_EA        1C58
OP1001_EA_DN        1D58
OP1001_PRINT_B      1D80
OP1001_PRINT_B2     1C80
OP1001_PRINT_L      1E10
OP1001_PRINT_L2     1D10
OP1001_PRINT_W      1DC8
OP1001_PRINT_W2     1CC8
OP1001_SUBA_L       1B3C
OP1001_SUBA_W       1BAE
OP1010              1EC6
OP1011              1ECA
OP1100              1FC6
OP1100_AND_RETURN   2236
OP1100_DETERMINE_DN_EA_OR_EA_DN  1FFC
OP1100_DN_EA        2036
OP1100_EA_DN        2136
OP1100_PRINT_B      215E
OP1100_PRINT_B2     205E
OP1100_PRINT_L      21EE
OP1100_PRINT_L2     20EE
OP1100_PRINT_W      21A6
OP1100_PRINT_W2     20A6
OP1101              2238
OP1101_ADDA_L       226A
OP1101_ADDA_W       22DC
OP1101_ADD_RETURN   2586
OP1101_DETERMINE_DN_EA_OR_EA_DN  234E
OP1101_DN_EA        2386
OP1101_EA_DN        2486
OP1101_PRINT_B      24AE
OP1101_PRINT_B2     23AE
OP1101_PRINT_L      253E
OP1101_PRINT_L2     243E
OP1101_PRINT_W      24F6
OP1101_PRINT_W2     23F6
OP1110              2614
OP1111              28C2
OP_ADDA_L           25FC
OP_ADDA_W           25E4
OP_ADDQ             19E0
OP_ADDQ_B           1A06
OP_ADDQ_L           1A2A
OP_ADDQ_W           1A18
OP_ADD_B            259C
OP_ADD_L            25CC
OP_ADD_W            25B4
OP_ASL              27B4
OP_ASL_B            27D8
OP_ASL_L            27EA
OP_ASL_W            27FC
OP_ASR              275A
OP_ASR_B            277E
OP_ASR_L            2790
OP_ASR_W            27A2
OP_ASX              2676
OP_BEQ              1AA0
OP_BHI              1A84
OP_BLT              1ABC
OP_BNE              1A92
OP_BRA              1AAE
OP_BTST             140C
OP_CMPA_L           1F36
OP_CMPA_W           1F24
OP_CMPI             1512
OP_CMPI_B           1532
OP_CMPI_L           1556
OP_CMPI_W           1544
OP_CMP_B            1F48
OP_CMP_L            1F78
OP_CMP_W            1F60
OP_DATA             14C6
OP_DIVS             1AF6
OP_EORI             141A
OP_EORI_B           143A
OP_EORI_L           145E
OP_EORI_W           144C
OP_EOR_B            1F90
OP_EOR_L            1FB4
OP_EOR_W            1FA2
OP_JSR              199E
OP_LEA              18CC
OP_LSL              2700
OP_LSL_B            2724
OP_LSL_L            2736
OP_LSL_W            2748
OP_LSR              26A6
OP_LSR_B            26CA
OP_LSR_L            26DC
OP_LSR_W            26EE
OP_LSX              265E
OP_MOVEA_L          16BA
OP_MOVEA_W          17B6
OP_MOVEM_L          18BA
OP_MOVEM_W          18A8
OP_MOVE_B           15C4
OP_MOVE_L           1652
OP_MOVE_W           174E
OP_MULS             1FE8
OP_NEG              18E0
OP_NEG_B            1900
OP_NEG_L            1930
OP_NEG_W            1918
OP_NOT              1948
OP_NOT_B            1968
OP_NOT_L            198C
OP_NOT_W            197A
OP_ORI              1568
OP_ORI_B            1588
OP_ORI_L            15AC
OP_ORI_W            159A
OP_ROL              2868
OP_ROL_B            288C
OP_ROL_L            289E
OP_ROL_W            28B0
OP_ROR              280E
OP_ROR_B            2832
OP_ROR_L            2844
OP_ROR_W            2856
OP_ROX              268E
OP_RTS              19B2
OP_SUBA_L           1EB4
OP_SUBA_W           1EA2
OP_SUBI             1470
OP_SUBI_B           1490
OP_SUBI_L           14B4
OP_SUBI_W           14A2
OP_SUB_B            1E5A
OP_SUB_L            1E8A
OP_SUB_W            1E72
OUTPUT_PROCESSED_DATA  12EC
POINTER_WORD        3F56
POP_FRONT           362A
POP_FRONT_RETURN    3664
POP_RETURN          3628
POP_SHIFT_LOOP      3646
POP_STACK           361C
PRINT_QUEUE         35F0
PRINT_QUEUE_HELPER  35FC
PRINT_QUEUE_RETURN  3612
PRINT_STACK         35D6
PRINT_STACK_HELPER  35E2
PRINT_STACK_RETURN  35EE
PROGLP              100A
PROMPT_END          39A8
PROMPT_START        3979
PUSH_STACK          3614
QUEUE_COUNTER       3F38
REG_0               2CC4
REG_1               2CD2
REG_2               2CE0
REG_3               2CEE
REG_4               2CFC
REG_5               2D0A
REG_6               2D18
REG_7               2D26
REPEAT              2D34
REPEATMSG           39FF
RETURN              11C4
SRC_LOOP_SHIFTING   30B2
SRC_MASKING_NEXT    30C0
SRC_MODE            2984
SRC_REGISTER        2C6C
SRC_REGISTER_FORMAT  3F3B
STACK               7000
STACK_HEX_CHAR      1236
STACK_HEX_CONT      123A
STACK_HEX_LOOP      121C
START               1004
START_ADDR          1058
S_ADDR_HX           3B7E
TEMP_REGISTER_FORMAT  3F3C
TERMINATE           3692
TESTING             1036
TMPINPUT            3B89
TMPOUTPUT           3BD9
VAR_BYTE_END        3F44
VAR_BYTE_START      3F40
VAR_LONG_ADDRESS_MODE_CHECK  3F4C
VAR_TEMP_CLEANCOPY  3F48
VR_E_ADDR           3B2E
VR_S_ADDR           3ADE
WELCOME             36A4
WORDMODE            2B28
