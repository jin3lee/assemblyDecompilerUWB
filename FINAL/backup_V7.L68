00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 12:28:53 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 0000104A             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109C             38              JSR     END_ADDR
00001016  43F9 00003D24             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 0000125A             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003842             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  87C3                      53              DIVS.W  D3,D3
00001038  87D3                      54              DIVS.W  (A3),D3
0000103A  89DC                      55              DIVS.W  (A4)+,D4
0000103C  8BE5                      56              DIVS.W  -(A5),D5
0000103E  8DF8 3331                 57              DIVS.W  $3331,D6
00001042  8FF9 44444441             58              DIVS.W  $44444441,D7
00001048                            59              
00001048                            60  
00001048                            61              
00001048  4E75                      62              RTS
0000104A                            63  *---------------------------------------------------------------------------*
0000104A                            64  * START_ADDR: Compute the starting address
0000104A                            65  *---------------------------------------------------------------------------*
0000104A                            66  START_ADDR
0000104A                            67              * Output
0000104A  43F9 00003B17             68              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001050  103C 000E                 69              MOVE.B  #14,D0                  * Display PROMPT_START
00001054  4E4F                      70              TRAP    #15
00001056                            71      
00001056                            72              * Input
00001056  43F9 00003C7C             73              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105C  103C 0002                 74              MOVE.B  #2,D0                   * Ask user for input
00001060  4E4F                      75              TRAP    #15
00001062                            76              
00001062                            77              * Error Checking (length)
00001062  0C01 0000                 78              CMPI.B  #0, D1                  * Check if input length <= 0
00001066  6F00 0098                 79              BLE     ERROR_1
0000106A  0C01 0008                 80              CMPI.B  #8, D1                  * Check if input length > 8
0000106E  6E00 0090                 81              BGT     ERROR_1
00001072                            82              
00001072                            83              * Conversion & Storage
00001072  4EB9 00001150             84              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001078  0C07 0001                 85              CMPI.B  #1, D7                  * Check for error
0000107C  6700 0082                 86              BEQ     ERROR_1                 
00001080  23C1 00003D1C             87              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001086                            88              
00001086                            89              * Error Checking (Odd)
00001086  43F9 00003D1C             90              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108C  4EB9 0000123E             91              JSR     IS_ODD                  * Check if the input address is odd
00001092  0C07 0001                 92              CMPI.B  #1, D7                  * Check for error
00001096  6700 0088                 93              BEQ     ERROR_3
0000109A                            94              
0000109A                            95              * Return
0000109A  4E75                      96              RTS     
0000109C                            97  *---------------------------------------------------------------------------*
0000109C                            98  * END_ADDR: Compute the ending address
0000109C                            99  *---------------------------------------------------------------------------*
0000109C                           100  END_ADDR
0000109C                           101              * Output
0000109C  43F9 00003B46            102              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A2  103C 000E                103              MOVE.B  #14,D0                  * Display PROMPT_END
000010A6  4E4F                     104              TRAP    #15
000010A8                           105  
000010A8                           106              * Input
000010A8  43F9 00003CCC            107              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AE  103C 0002                108              MOVE.B  #2,D0                   * Ask user for input
000010B2  4E4F                     109              TRAP    #15
000010B4                           110              
000010B4                           111              * Error Checking (length)
000010B4  0C01 0000                112              CMPI.B  #0, D1                  * Check if input length <= 0
000010B8  6F00 0056                113              BLE     ERROR_2
000010BC  0C01 0008                114              CMPI.B  #8, D1                  * Check if input length > 8
000010C0  6E00 004E                115              BGT     ERROR_2
000010C4                           116              
000010C4                           117              * Conversion & Storage
000010C4  4EB9 00001150            118              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010CA  0C07 0001                119              CMPI.B  #1, D7                  * Check for error
000010CE  6700 0040                120              BEQ     ERROR_2
000010D2  23C1 00003D20            121              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D8                           122              
000010D8                           123              * Error Checking (start > end case)
000010D8  2439 00003D1C            124              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DE  B282                     125              CMP.L   D2, D1                  * Compare starting and ending address
000010E0  6300 005E                126              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E4                           127              
000010E4                           128              * Error Checking (Odd case)
000010E4  43F9 00003D20            129              LEA     E_ADDR_HX, A1           * Move the ending address
000010EA  4EB9 0000123E            130              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010F0  0C07 0001                131              CMPI.B  #1, D7                  * Check for an error flag
000010F4  6700 003A                132              BEQ     ERROR_4
000010F8                           133              
000010F8                           134              * Inputs are valid
000010F8  2A79 00003D1C            135              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FE                           136              
000010FE  4E75                     137              RTS
00001100                           138              
00001100                           139  *---------------------------------------------------------------------------*
00001100                           140  * ERROR_1: Address error (Invalid starting address)
00001100                           141  *---------------------------------------------------------------------------*
00001100                           142  ERROR_1
00001100  43F9 00003C0B            143              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001106  103C 000E                144              MOVE.B  #14, D0                 * Display ERRMSG_1
0000110A  4E4F                     145              TRAP    #15
0000110C  4EF8 104A                146              JMP     START_ADDR              * Jump to START_ADDR
00001110                           147      
00001110                           148  *---------------------------------------------------------------------------*
00001110                           149  * ERROR_2: Address error (Invalid ending address)
00001110                           150  *---------------------------------------------------------------------------*
00001110                           151  ERROR_2
00001110  43F9 00003C0B            152              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001116  103C 000E                153              MOVE.B  #14, D0                 * Display ERRMSG_1
0000111A  4E4F                     154              TRAP    #15
0000111C  4EF8 109C                155              JMP     END_ADDR                * Jump to END_ADDR
00001120                           156  
00001120                           157  *---------------------------------------------------------------------------*
00001120                           158  * ERROR_3: Address error (Odd starting address)
00001120                           159  *---------------------------------------------------------------------------*
00001120                           160  ERROR_3
00001120  43F9 00003C2A            161              LEA     ERRMSG_3, A1
00001126  103C 000E                162              MOVE.B  #14, D0
0000112A  4E4F                     163              TRAP    #15
0000112C  4EF8 104A                164              JMP     START_ADDR
00001130                           165     
00001130                           166  *---------------------------------------------------------------------------*
00001130                           167  * ERROR_4: Address error (Odd ending address)
00001130                           168  *---------------------------------------------------------------------------*         
00001130                           169  ERROR_4
00001130  43F9 00003C2A            170              LEA     ERRMSG_3, A1
00001136  103C 000E                171              MOVE.B  #14, D0
0000113A  4E4F                     172              TRAP    #15
0000113C  4EF8 109C                173              JMP     END_ADDR
00001140                           174            
00001140                           175  *---------------------------------------------------------------------------*
00001140                           176  * ERROR_3: Address error (Ending address is less than starting address)
00001140                           177  *---------------------------------------------------------------------------*
00001140                           178  ERROR_5
00001140  43F9 00003C4F            179              LEA     ERRMSG_5, A1
00001146  103C 000E                180              MOVE.B  #14, D0
0000114A  4E4F                     181              TRAP    #15
0000114C  4EF8 109C                182              JMP     END_ADDR
00001150                           183    
00001150                           184  *---------------------------------------------------------------------------*
00001150                           185  * ASCII2HEX: Convert ASCii to Hexadecimal
00001150                           186  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001150                           187  *---------------------------------------------------------------------------*
00001150  4281                     188  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001152  4287                     189              CLR.L   D7                      * Set the error flag to 0
00001154  4282                     190              CLR.L   D2                      * Clear D2 for temp storage
00001156                           191              
00001156  1419                     192  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001158  0C02 0000                193              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115C  6700 0058                194              BEQ     RETURN                  * If it's NULL, go to return
00001160  0C02 0066                195              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001164  6E00 004C                196              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001168  0C02 0061                197              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116C  6C00 0026                198              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001170  0C02 0046                199              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001174  6E00 003C                200              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001178  0C02 0041                201              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117C  6C00 001E                202              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001180  0C02 0039                203              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001184  6E00 002C                204              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001188  0C02 0030                205              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118C  6C00 0016                206              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
00001190  6000 0020                207              BRA     ASC_ERR                 * Invalid input
00001194                           208  
00001194  0442 0057                209  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001198  6000 0012                210              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119C                           211              
0000119C  0442 0037                212  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011A0  6000 000A                213              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A4                           214              
000011A4  0442 0030                215  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A8  6000 0002                216              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AC                           217              
000011AC  E981                     218  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AE  D202                     219              ADD.B   D2, D1                  * Add the converted input to D1
000011B0  60A4                     220              BRA     ASC2HXLP                * Loop
000011B2                           221  
000011B2  1E3C 0001                222  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B6  4E75                     223  RETURN      RTS     
000011B8                           224  
000011B8                           225  *---------------------------------------------------------------------------*
000011B8                           226  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011B8                           227  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011B8                           228  *---------------------------------------------------------------------------*
000011B8  0C02 0008                229  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011BC  6700 000E                230              BEQ     HEX_LOOP
000011C0  4841                     231              SWAP    D1
000011C2  0C02 0002                232              CMPI.B  #2,D2
000011C6  6600 0004                233              BNE     HEX_LOOP
000011CA  E189                     234              LSL.L   #8,D1
000011CC                           235             
000011CC  E999                     236  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011CE  2601                     237              MOVE.L  D1, D3                  * Move D1 to D3
000011D0  0283 0000000F            238              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011D6  0C03 0009                239              CMPI.B  #9, D3                  * Compare te digit
000011DA  6E00 000A                240              BGT     HEX_CHAR              
000011DE  0603 0030                241              ADDI.B  #48,D3                  * Add 48 for numerical output
000011E2  6000 0006                242              BRA     HEX_CONT
000011E6                           243              
000011E6  0603 0037                244  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011EA                           245  
000011EA  12C3                     246  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011EC  5342                     247              SUBI    #1, D2                  * Decrement the size
000011EE  0C02 0000                248              CMPI.B  #0, D2                  * Check if D2 is 0
000011F2  66D8                     249              BNE     HEX_LOOP                * Loop
000011F4  12BC 0000                250              MOVE.B  #$0,(A1)                * Null terminator
000011F8  4E75                     251              RTS
000011FA                           252  *---------------------------------------------------------------------------*
000011FA                           253  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
000011FA                           254  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011FA                           255  *---------------------------------------------------------------------------*
000011FA                           256  HEX2ASCII2STACK
000011FA  0C02 0008                257              CMPI.B  #8, D2                  * Check to see if the size is long
000011FE  6700 000E                258              BEQ     STACK_HEX_LOOP
00001202  4841                     259              SWAP    D1
00001204  0C02 0002                260              CMPI.B  #2,D2
00001208  6600 0004                261              BNE     STACK_HEX_LOOP
0000120C  E189                     262              LSL.L   #8,D1
0000120E                           263             
0000120E                           264  STACK_HEX_LOOP    
0000120E  E999                     265              ROL.L   #4, D1                  * Roll D1 to left
00001210  2601                     266              MOVE.L  D1, D3                  * Move D1 to D3
00001212  0283 0000000F            267              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001218  0C03 0009                268              CMPI.B  #9, D3                  * Compare te digit
0000121C  6E00 000A                269              BGT     STACK_HEX_CHAR              
00001220  0603 0030                270              ADDI.B  #48,D3                  * Add 48 for numerical output
00001224  6000 0006                271              BRA     STACK_HEX_CONT
00001228                           272              
00001228                           273  STACK_HEX_CHAR    
00001228  0603 0037                274              ADDI.B  #55,D3                  * Add 55 for character output
0000122C                           275  
0000122C                           276  STACK_HEX_CONT    
0000122C  6100 2584                277              BSR     PUSH_STACK              *PLACE INTO STACK
00001230  5342                     278              SUBI    #1, D2                  * Decrement the size
00001232  0C02 0000                279              CMPI.B  #0, D2                  * Check if D2 is 0
00001236  66D6                     280              BNE     STACK_HEX_LOOP                * Loop
00001238  12BC 0000                281              MOVE.B  #$0,(A1)                * Null terminator
0000123C  4E75                     282              RTS
0000123E                           283  
0000123E                           284  
0000123E                           285  *---------------------------------------------------------------------------*
0000123E                           286  * IS_ODD: Check whether the source address is odd
0000123E                           287  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000123E                           288  *---------------------------------------------------------------------------*
0000123E  4281                     289  IS_ODD      CLR.L   D1                      * Clear the result
00001240  4287                     290              CLR.L   D7                      * Set the error flag to 0
00001242  2211                     291              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001244  82FC 0002                292              DIVU    #2, D1                  * Divide the result by 2
00001248  4841                     293              SWAP    D1                      * Swap remainder with quotient
0000124A  0C01 0001                294              CMPI.B  #1, D1                  * Check for error
0000124E  6700 0004                295              BEQ     IS_ODD_ERR
00001252  4E75                     296              RTS
00001254                           297              
00001254  1E3C 0001                298  IS_ODD_ERR  MOVE.B  #1, D7
00001258  4E75                     299              RTS
0000125A                           300  
0000125A                           301  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
0000125A                           302  * MAIN                    
0000125A                           303  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
0000125A                           304  * A5: Processing address
0000125A                           305  *
0000125A                           306  * D3: USED FOR PUSHING INTO STACK
0000125A                           307  *     To push into stack => MOVE.W #DATA,D3 
0000125A                           308  *                           BSR    PUSH_STACK
0000125A                           309  *     To print stack     => BSR    PRINT_STACK 
0000125A                           310  *     To clear stack     => BSR    CLEAR_STACK
0000125A                           311  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
0000125A                           312  MAIN        
0000125A                           313              *initialize stack pointer
0000125A  33FC 0000 000040D4       314              MOVE.W  #0,COUNTER
00001262  347C 7000                315              MOVEA.W #STACK,A2
00001266  163C 0020                316              MOVE.B  #' ',D3
0000126A  6100 2546                317              BSR     PUSH_STACK
0000126E  6100 2542                318              BSR     PUSH_STACK
00001272  6100 253E                319              BSR     PUSH_STACK
00001276                           320              
00001276                           321              * clear registers for temp storage
00001276  4280                     322              CLR.L   D0                   
00001278  4281                     323              CLR.L   D1                   
0000127A  227C 00000000            324              MOVEA.L #0, A1                
00001280                           325              
00001280  220D                     326              MOVE.L  A5,D1                   * check to see if the address is fully read
00001282  23CD 00003D1C            327              MOVE.L  A5,S_ADDR_HX
00001288  B2B9 00003D20            328              CMP.L   E_ADDR_HX,D1
0000128E  6C00 1C42                329              BGE     REPEAT                  * go to repeat for user action
00001292                           330  
00001292  43F9 00003D77            331              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001298  143C 0008                332              MOVE.B  #8,D2                   * set the output size
0000129C  4EB8 11B8                333              JSR     HEX2ASCII               
000012A0  43F9 00003D77            334              LEA     TMPOUTPUT,A1
000012A6  103C 000E                335              MOVE.B  #14,D0
000012AA  4E4F                     336              TRAP    #15
000012AC                           337              
000012AC  4285                     338              CLR.L    D5                      * clear the processing data
000012AE  3A1D                     339              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012B0                           340                                               * advance the current instruction pointer to the next
000012B0                           341                                               * instruction in memory
000012B0                           342  *----------------------------------------*
000012B0                           343  * Registers          
000012B0                           344  * [D1] - COPY OF D5
000012B0                           345  * [D5] - DATA TO BE PROCESSED
000012B0                           346  * [D6] - COUNTER FOR LINES PROCESSED
000012B0                           347  *
000012B0                           348  * [D4]      - ERROR FLAG BEFORE PRINTING
000012B0                           349  * [STACK]   - PRINTS PROCESS DATA
000012B0                           350  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012B0                           351  *
000012B0                           352  * [A1] - USED FOR JUMPING/PRINTING
000012B0                           353  *
000012B0                           354  *----------------------------------------*
000012B0                           355  
000012B0                           356              
000012B0                           357              *Processing the first 4 most significant bits 
000012B0  2205                     358              MOVE.L  D5,D1                    * copy the current processing data to D1
000012B2  143C 000C                359              MOVE.B  #12,D2                   * shift to right by 12 bits
000012B6  E469                     360              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012B8  C2FC 0006                361              MULU    #6,D1                    * form offset
000012BC  43F9 0000132A            362              LEA     JMPTABLE,A1              * index into table
000012C2  4EB1 1000                363              JSR     0(A1,D1)                 * jump indirect with index
000012C6                           364              
000012C6                           365              *SECURED EA*
000012C6  B83C 0001                366              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012CA  6600 0012                367              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012CE  6100 01E8                368              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012D2  6100 254A                369              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012D6  183C 0000                370              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012DA  6000 0022                371              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012DE                           372             
000012DE                           373  OUTPUT_PROCESSED_DATA       
000012DE  163C 000D                374              MOVE.B  #$D,D3                  *carriage return
000012E2  6100 24CE                375              BSR     PUSH_STACK
000012E6  163C 000A                376              MOVE.B  #$A,D3                  *new line feed
000012EA  6100 24C6                377              BSR     PUSH_STACK
000012EE  163C 0000                378              MOVE.B  #$0,D3                  *null
000012F2  6100 24BE                379              BSR     PUSH_STACK
000012F6                           380       
000012F6  6100 2496                381              BSR     PRINT_QUEUE
000012FA  183C 0000                382              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012FE                           383  DISPLAY_30_LINES
000012FE                           384              * display 30 lines per page
000012FE  5206                     385              ADDI.B  #1,D6
00001300  0C06 001E                386              CMPI.B  #30,D6
00001304  6C00 0006                387              BGE     NEXTLINES
00001308  6000 FF50                388              BRA     MAIN
0000130C                           389            
0000130C                           390  *---------------------------------------------------------------------------*
0000130C                           391  * NEXTLINES: receive input from user to print the next 30 lines
0000130C                           392  *---------------------------------------------------------------------------*  
0000130C  4206                     393  NEXTLINES   CLR.B   D6
0000130E  43F9 00003B73            394              LEA     DISP_NEXT,A1
00001314  103C 000E                395              MOVE.B  #14,D0
00001318  4E4F                     396              TRAP    #15
0000131A  43F9 00003D27            397              LEA     TMPINPUT,A1
00001320  103C 0002                398              MOVE.B  #2,D0
00001324  4E4F                     399              TRAP    #15
00001326  4EF8 125A                400              JMP     MAIN
0000132A                           401    
0000132A                           402  *---------------------------------------------------------------------------*
0000132A                           403  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
0000132A                           404  *---------------------------------------------------------------------------*  
0000132A  4EF9 0000138A            405  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
00001330  4EF9 000015B0            406              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001336  4EF9 0000161E            407              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000133C  4EF9 0000171C            408              JMP     OP0011  * MOVE.W/MOVEA.W
00001342  4EF9 00001818            409              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS
00001348  4EF9 000019B2            410              JMP     OP0101  * ADDQ  
0000134E  4EF9 00001A2E            411              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)
00001354  4EF9 00001ABC            412              JMP     OP0111  * MOVEQ (unassigned)
0000135A  4EF9 00001AC0            413              JMP     OP1000  * DIVS
00001360  4EF9 00001BC8            414              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001366  4EF9 00001F84            415              JMP     OP1010  * Unassigned 
0000136C  4EF9 00001F88            416              JMP     OP1011  * CMP/EOR/CMPA
00001372  4EF9 00002084            417              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
00001378  4EF9 000023D6            418              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000137E  4EF9 000027B2            419              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001384  4EF9 00002A60            420              JMP     OP1111  * Special/Reserved
0000138A                           421              
0000138A                           422  *---------------------------------------------------------------------------*
0000138A                           423  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
0000138A                           424  *---------------------------------------------------------------------------*           
0000138A                           425  OP0000                                                                                  
0000138A  4281                     426              CLR.L   D1          * to temporarily store the address to process
0000138C  4280                     427              CLR.L   D0  
0000138E  4284                     428              CLR.L   D4                 
00001390  227C 00000000            429              MOVEA.L #0, A1                
00001396                           430              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001396                           431              * Check if bit 11,10,9,8 are 0000)
00001396  2205                     432              MOVE.L  D5,D1
00001398  0281 00000F00            433              ANDI.L  #$0F00,D1
0000139E  0C81 00000000            434              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013A4  6700 01B4                435              BEQ     OP_ORI
000013A8                           436  
000013A8                           437              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013A8                           438              * check if bit 11,10,9,8 are 1100
000013A8  4281                     439              CLR.L   D1
000013AA  2205                     440              MOVE.L  D5,D1
000013AC  0281 00000F00            441              ANDI.L  #$0F00,D1
000013B2  0C81 00000C00            442              CMPI.L  #$0C00,D1
000013B8  6700 014A                443              BEQ     OP_CMPI
000013BC                           444              
000013BC                           445              * check for SUBI
000013BC  4281                     446              CLR.L   D1
000013BE  2205                     447              MOVE.L  D5,D1
000013C0  0281 00000F00            448              ANDI.L  #$0F00,D1
000013C6  0C81 00000400            449              CMPI.L  #$0400,D1
000013CC  6700 0094                450              BEQ     OP_SUBI
000013D0                           451              
000013D0                           452              * check for EORI
000013D0  4281                     453              CLR.L   D1
000013D2  2205                     454              MOVE.L  D5,D1
000013D4  0281 00000F00            455              ANDI.L  #$0F00,D1
000013DA  0C81 00000A00            456              CMPI.L  #$0A00,D1
000013E0  6700 002A                457              BEQ     OP_EORI
000013E4                           458              
000013E4                           459              * check for BTST
000013E4  4281                     460              CLR.L   D1
000013E6  2205                     461              MOVE.L  D5,D1
000013E8  EA99                     462              ROR.L   #5,D1
000013EA  0281 00000008            463              ANDI.L  #$8,D1
000013F0  0C01 0008                464              CMPI.B  #8,D1
000013F4  6700 0008                465              BEQ     OP_BTST
000013F8                           466  
000013F8                           467              * OP0000 series other than ORI/CMPI/BTST/EORI
000013F8  4EF9 000014B8            468              JMP     OP_DATA
000013FE                           469              
000013FE                           470  *---------------------------------------------------------------------------*
000013FE                           471  * OP_BTST: display BTST
000013FE                           472  *---------------------------------------------------------------------------* 
000013FE  43F9 00003E00            473  OP_BTST     LEA     DISP_BTST,A1
00001404  103C 000E                474              MOVE.B  #14,D0
00001408  4E4F                     475              TRAP    #15
0000140A  4E75                     476              RTS
0000140C                           477  
0000140C                           478  *---------------------------------------------------------------------------*
0000140C                           479  * OP_EORI: decode and display EORI
0000140C                           480  *---------------------------------------------------------------------------* 
0000140C                           481  OP_EORI
0000140C  4281                     482              CLR.L   D1
0000140E  4284                     483              CLR.L   D4
00001410  2205                     484              MOVE.L  D5,D1
00001412  EC99                     485              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001414  0C01 0000                486              CMPI.B  #0,D1
00001418  6700 0012                487              BEQ     OP_EORI_B    * size is byte
0000141C  0C01 0001                488              CMPI.B  #1,D1
00001420  6700 001C                489              BEQ     OP_EORI_W    * size is word
00001424  0C01 0002                490              CMPI.B  #2,D1
00001428  6700 0026                491              BEQ     OP_EORI_L    * size is long
0000142C                           492  
0000142C                           493  OP_EORI_B    * size is byte    
0000142C  183C 0000                494              MOVE.B  #0,D4
00001430  43F9 00003DE2            495              LEA     DISP_EORI_B,A1
00001436  103C 000E                496              MOVE.B  #14,D0
0000143A  4E4F                     497              TRAP    #15
0000143C  4E75                     498              RTS
0000143E                           499              
0000143E                           500  OP_EORI_W    * size is word
0000143E  183C 0001                501              MOVE.B  #1,D4
00001442  43F9 00003DEC            502              LEA     DISP_EORI_W,A1
00001448  103C 000E                503              MOVE.B  #14,D0
0000144C  4E4F                     504              TRAP    #15
0000144E  4E75                     505              RTS
00001450                           506              
00001450                           507  OP_EORI_L    * size is long
00001450  183C 0002                508              MOVE.B  #2,D4
00001454  43F9 00003DF6            509              LEA     DISP_EORI_L,A1
0000145A  103C 000E                510              MOVE.B  #14,D0
0000145E  4E4F                     511              TRAP    #15
00001460  4E75                     512              RTS
00001462                           513              
00001462                           514  *---------------------------------------------------------------------------*
00001462                           515  * OP_SUBI: decode SUBI.B/.W/.L
00001462                           516  *---------------------------------------------------------------------------* 
00001462                           517  OP_SUBI
00001462  4281                     518              CLR.L   D1
00001464  4284                     519              CLR.L   D4
00001466  2205                     520              MOVE.L  D5,D1
00001468  EC99                     521              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000146A  0C01 0000                522              CMPI.B  #0,D1
0000146E  6700 0012                523              BEQ     OP_SUBI_B    * size is byte
00001472  0C01 0001                524              CMPI.B  #1,D1
00001476  6700 001C                525              BEQ     OP_SUBI_W    * size is word
0000147A  0C01 0002                526              CMPI.B  #2,D1
0000147E  6700 0026                527              BEQ     OP_SUBI_L    * size is long
00001482                           528  
00001482                           529  OP_SUBI_B    * size is byte    
00001482  183C 0000                530              MOVE.B  #0,D4
00001486  43F9 00003EEE            531              LEA     DISP_SUBI_B,A1
0000148C  103C 000E                532              MOVE.B  #14,D0
00001490  4E4F                     533              TRAP    #15
00001492  4E75                     534              RTS
00001494                           535              
00001494                           536  OP_SUBI_W    * size is word
00001494  183C 0001                537              MOVE.B  #1,D4
00001498  43F9 00003EF8            538              LEA     DISP_SUBI_W,A1
0000149E  103C 000E                539              MOVE.B  #14,D0
000014A2  4E4F                     540              TRAP    #15
000014A4  4E75                     541              RTS
000014A6                           542              
000014A6                           543  OP_SUBI_L    * size is long
000014A6  183C 0002                544              MOVE.B  #2,D4
000014AA  43F9 00003F02            545              LEA     DISP_SUBI_L,A1
000014B0  103C 000E                546              MOVE.B  #14,D0
000014B4  4E4F                     547              TRAP    #15
000014B6  4E75                     548              RTS
000014B8                           549              
000014B8                           550  *---------------------------------------------------------------------------*
000014B8                           551  * OP_DATA : unidentified opcode
000014B8                           552  *---------------------------------------------------------------------------* 
000014B8                           553  OP_DATA
000014B8  4280                     554              CLR.L   D0                   
000014BA  4281                     555              CLR.L   D1     
000014BC  4284                     556              CLR.L   D4                    
000014BE  227C 00000000            557              MOVEA.L #0, A1             
000014C4  4287                     558              CLR.L   D7
000014C6  1E3C 0001                559              MOVE.B  #1,D7                   * error flag is true
000014CA                           560              
000014CA  43F9 00003E26            561              LEA     DISP_DATA,A1
000014D0  103C 000E                562              MOVE.B  #14,D0
000014D4  4E4F                     563              TRAP    #15
000014D6                           564              
000014D6  4EF9 000014DC            565              JMP     EA_DATA
000014DC                           566             
000014DC                           567             
000014DC                           568  *---------------------------------------------------------------------------*
000014DC                           569  * EA_DATA
000014DC                           570  *---------------------------------------------------------------------------*       
000014DC  43F9 00003D77            571  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014E2  2205                     572              MOVE.L  D5,D1           * transfer the processing data to D1
000014E4  7404                     573              MOVE.L  #4,D2           * set to word size
000014E6  4EB8 11B8                574              JSR     HEX2ASCII       * prepare output in ascii
000014EA  43F9 00004099            575              LEA     DISP_HEX,A1     * display $ symbol
000014F0  103C 000E                576              MOVE.B  #14,D0      
000014F4  4E4F                     577              TRAP    #15
000014F6  43F9 00003D77            578              LEA     TMPOUTPUT,A1    * display with a new line
000014FC  103C 000D                579              MOVE.B  #13,D0
00001500  4E4F                     580              TRAP    #15
00001502                           581  
00001502  4E75                     582              RTS
00001504                           583              
00001504                           584  *---------------------------------------------------------------------------*
00001504                           585  * OP_CMPI : decode CMPI and its size
00001504                           586  *---------------------------------------------------------------------------*          
00001504                           587  OP_CMPI
00001504  4281                     588              CLR.L   D1
00001506  4284                     589              CLR.L   D4
00001508  2205                     590              MOVE.L  D5,D1
0000150A  EC99                     591              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000150C  0C01 0000                592              CMPI.B  #0,D1
00001510  6700 0012                593              BEQ     OP_CMPI_B    * size is byte
00001514  0C01 0001                594              CMPI.B  #1,D1
00001518  6700 001C                595              BEQ     OP_CMPI_W    * size is word
0000151C  0C01 0002                596              CMPI.B  #2,D1
00001520  6700 0026                597              BEQ     OP_CMPI_L    * size is long
00001524                           598  
00001524                           599  OP_CMPI_B    * size is byte    
00001524  183C 0000                600              MOVE.B  #0,D4
00001528  43F9 00003E08            601              LEA     DISP_CMPI_B,A1
0000152E  103C 000E                602              MOVE.B  #14,D0
00001532  4E4F                     603              TRAP    #15
00001534  4E75                     604              RTS
00001536                           605              
00001536                           606  OP_CMPI_W    * size is word
00001536  183C 0001                607              MOVE.B  #1,D4
0000153A  43F9 00003E12            608              LEA     DISP_CMPI_W,A1
00001540  103C 000E                609              MOVE.B  #14,D0
00001544  4E4F                     610              TRAP    #15
00001546  4E75                     611              RTS
00001548                           612              
00001548                           613  OP_CMPI_L    * size is long
00001548  183C 0002                614              MOVE.B  #2,D4
0000154C  43F9 00003E1C            615              LEA     DISP_CMPI_L,A1
00001552  103C 000E                616              MOVE.B  #14,D0
00001556  4E4F                     617              TRAP    #15
00001558  4E75                     618              RTS
0000155A                           619   
0000155A                           620  *---------------------------------------------------------------------------*
0000155A                           621  * OP_ORI : decode ORI and its size
0000155A                           622  *---------------------------------------------------------------------------* 
0000155A                           623  OP_ORI      
0000155A  4281                     624              CLR.L   D1
0000155C  4284                     625              CLR.L   D4
0000155E  2205                     626              MOVE.L  D5,D1
00001560  EC99                     627              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001562  0C01 0000                628              CMPI.B  #0,D1
00001566  6700 0012                629              BEQ     OP_ORI_B    * size is byte
0000156A  0C01 0001                630              CMPI.B  #1,D1
0000156E  6700 001C                631              BEQ     OP_ORI_W    * size is word
00001572  0C01 0002                632              CMPI.B  #2,D1
00001576  6700 0026                633              BEQ     OP_ORI_L    * size is long
0000157A                           634  
0000157A                           635  OP_ORI_B    * size is byte    
0000157A  183C 0000                636              MOVE.B  #0,D4
0000157E  43F9 00003DC7            637              LEA     DISP_ORI_B,A1
00001584  103C 000E                638              MOVE.B  #14,D0
00001588  4E4F                     639              TRAP    #15
0000158A  4E75                     640              RTS
0000158C                           641              
0000158C                           642  OP_ORI_W    * size is word
0000158C  183C 0001                643              MOVE.B  #1,D4
00001590  43F9 00003DD0            644              LEA     DISP_ORI_W,A1
00001596  103C 000E                645              MOVE.B  #14,D0
0000159A  4E4F                     646              TRAP    #15
0000159C  4E75                     647              RTS
0000159E                           648              
0000159E                           649  OP_ORI_L    * size is long
0000159E  183C 0002                650              MOVE.B  #2,D4
000015A2  43F9 00003DD9            651              LEA     DISP_ORI_L,A1
000015A8  103C 000E                652              MOVE.B  #14,D0
000015AC  4E4F                     653              TRAP    #15
000015AE  4E75                     654              RTS
000015B0                           655          
000015B0                           656  *---------------------------------------------------------------------------*
000015B0                           657  * OP0001: MOVE.B
000015B0                           658  *---------------------------------------------------------------------------*
000015B0                           659  OP0001      
000015B0  4EF9 000015B6            660              JMP     OP_MOVE_B   * display MOVE.B
000015B6                           661              
000015B6                           662  *---------------------------------------------------------------------------*
000015B6                           663  * OP_MOVE_B: display MOVE_B and proceed to EA
000015B6                           664  *---------------------------------------------------------------------------*
000015B6                           665  OP_MOVE_B                                                                       
000015B6                           666             
000015B6                           667             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015B6  13FC 0082 000040D8       668             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015BE  13FC 0000 000040D9       669             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015C6                           670             
000015C6                           671             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015C6  13FC 00B9 000040DB       672             MOVE.B   #$B9,GET_DST_START_END
000015CE  13FC 0020 000040DC       673             MOVE.B   #$20,GET_SRC_START_END
000015D6                           674             
000015D6                           675              *CLEAR D3
000015D6  4283                     676              CLR.L   D3
000015D8                           677              *LOAD STACK WITH THIS OPMODE
000015D8  6100 21D8                678              BSR     PUSH_STACK
000015DC  163C 004D                679              MOVE.B  #'M',D3
000015E0  6100 21D0                680              BSR     PUSH_STACK
000015E4  163C 004F                681              MOVE.B  #'O',D3
000015E8  6100 21C8                682              BSR     PUSH_STACK
000015EC  163C 0056                683              MOVE.B  #'V',D3
000015F0  6100 21C0                684              BSR     PUSH_STACK
000015F4  163C 0045                685              MOVE.B  #'E',D3
000015F8  6100 21B8                686              BSR     PUSH_STACK
000015FC  163C 002E                687              MOVE.B  #'.',D3
00001600  6100 21B0                688              BSR     PUSH_STACK
00001604  163C 0042                689              MOVE.B  #'B',D3
00001608  6100 21A8                690              BSR     PUSH_STACK
0000160C                           691              
0000160C  6100 1906                692              BSR     GET_EA_EA_SRC
00001610  163C 002C                693              MOVE.B  #',',D3
00001614  6100 219C                694              BSR     PUSH_STACK
00001618  6100 1D2A                695              BSR     GET_EA_EA_DEST
0000161C                           696              
0000161C  4E75                     697              RTS
0000161E                           698              
0000161E                           699             
0000161E                           700  *---------------------------------------------------------------------------*
0000161E                           701  * OP0010: decode MOVE.L/MOVEA.L
0000161E                           702  *---------------------------------------------------------------------------*
0000161E                           703  OP0010      
0000161E  183C 0002                704              MOVE.B  #2,D4
00001622  4280                     705              CLR.L   D0                     
00001624  4281                     706              CLR.L   D1                      
00001626  227C 00000000            707              MOVEA.L #0, A1                 
0000162C                           708              
0000162C  2205                     709              MOVE.L  D5,D1
0000162E  EA99                     710              ROR.L   #5,D1
00001630  0281 0000000E            711              ANDI.L  #$E,D1
00001636  0C01 0002                712              CMPI.B  #2,D1
0000163A  6700 0070                713              BEQ     OP_MOVEA_L
0000163E                           714  
0000163E  4EF9 00001644            715              JMP     OP_MOVE_L
00001644                           716             
00001644                           717  
00001644                           718  *---------------------------------------------------------------------------*
00001644                           719  * OP_MOVE_L: display MOVE_L and proceed to EA
00001644                           720  *---------------------------------------------------------------------------*
00001644                           721  OP_MOVE_L   
00001644                           722             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001644  13FC 0082 000040D8       723             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000164C  13FC 0000 000040D9       724             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001654                           725             
00001654                           726             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001654  13FC 00B9 000040DB       727             MOVE.B   #$B9,GET_DST_START_END
0000165C  13FC 0020 000040DC       728             MOVE.B   #$20,GET_SRC_START_END
00001664                           729             
00001664                           730              *CLEAR D3
00001664  4283                     731              CLR.L   D3
00001666                           732              *LOAD STACK WITH THIS OPMODE
00001666  6100 214A                733              BSR     PUSH_STACK
0000166A  163C 004D                734              MOVE.B  #'M',D3
0000166E  6100 2142                735              BSR     PUSH_STACK
00001672  163C 004F                736              MOVE.B  #'O',D3
00001676  6100 213A                737              BSR     PUSH_STACK
0000167A  163C 0056                738              MOVE.B  #'V',D3
0000167E  6100 2132                739              BSR     PUSH_STACK
00001682  163C 0045                740              MOVE.B  #'E',D3
00001686  6100 212A                741              BSR     PUSH_STACK
0000168A  163C 002E                742              MOVE.B  #'.',D3
0000168E  6100 2122                743              BSR     PUSH_STACK
00001692  163C 004C                744              MOVE.B  #'L',D3
00001696  6100 211A                745              BSR     PUSH_STACK
0000169A                           746              
0000169A  6100 1878                747              BSR     GET_EA_EA_SRC
0000169E  163C 002C                748              MOVE.B  #',',D3
000016A2  6100 210E                749              BSR     PUSH_STACK
000016A6  6100 1C9C                750              BSR     GET_EA_EA_DEST
000016AA                           751              
000016AA  4E75                     752              RTS
000016AC                           753  
000016AC                           754  
000016AC                           755  *---------------------------------------------------------------------------*
000016AC                           756  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000016AC                           757  *---------------------------------------------------------------------------*
000016AC                           758  OP_MOVEA_L 
000016AC                           759             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016AC  13FC 00FD 000040D8       760             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016B4  13FC 0000 000040D9       761             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016BC                           762             
000016BC                           763             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016BC  13FC 00B9 000040DB       764             MOVE.B   #$B9,GET_DST_START_END
000016C4  13FC 0020 000040DC       765             MOVE.B   #$20,GET_SRC_START_END
000016CC                           766             
000016CC                           767              *CLEAR D3
000016CC  4283                     768              CLR.L   D3
000016CE                           769              *LOAD STACK WITH THIS OPMODE
000016CE  6100 20E2                770              BSR     PUSH_STACK
000016D2  163C 004D                771              MOVE.B  #'M',D3
000016D6  6100 20DA                772              BSR     PUSH_STACK
000016DA  163C 004F                773              MOVE.B  #'O',D3
000016DE  6100 20D2                774              BSR     PUSH_STACK
000016E2  163C 0056                775              MOVE.B  #'V',D3
000016E6  6100 20CA                776              BSR     PUSH_STACK
000016EA  163C 0045                777              MOVE.B  #'E',D3
000016EE  6100 20C2                778              BSR     PUSH_STACK           
000016F2  163C 0041                779              MOVE.B  #'A',D3
000016F6  6100 20BA                780              BSR     PUSH_STACK
000016FA  163C 002E                781              MOVE.B  #'.',D3
000016FE  6100 20B2                782              BSR     PUSH_STACK
00001702  163C 004C                783              MOVE.B  #'L',D3
00001706  6100 20AA                784              BSR     PUSH_STACK
0000170A                           785              
0000170A  6100 1808                786              BSR     GET_EA_EA_SRC
0000170E  163C 002C                787              MOVE.B  #',',D3
00001712  6100 209E                788              BSR     PUSH_STACK
00001716  6100 1C2C                789              BSR     GET_EA_EA_DEST
0000171A                           790              
0000171A  4E75                     791              RTS
0000171C                           792  
0000171C                           793              
0000171C                           794  *---------------------------------------------------------------------------*
0000171C                           795  * OP0011: decode MOVE.W/MOVEA.W
0000171C                           796  *---------------------------------------------------------------------------*
0000171C                           797  OP0011      
0000171C  4280                     798              CLR.L   D0                      
0000171E  4281                     799              CLR.L   D1  
00001720  4284                     800              CLR.L   D4                   
00001722  227C 00000000            801              MOVEA.L #0, A1 
00001728                           802                
00001728  2205                     803              MOVE.L  D5,D1
0000172A  EC99                     804              ROR.L   #6,D1
0000172C  0281 00000007            805              ANDI.L  #$07,D1
00001732  0C01 0001                806              CMPI.B  #1,D1
00001736  6700 0070                807              BEQ     OP_MOVEA_W
0000173A                           808              
0000173A  4EF9 00001740            809              JMP     OP_MOVE_W
00001740                           810            
00001740                           811  *---------------------------------------------------------------------------*
00001740                           812  * OP_MOVE_W: display MOVE_W and proceed to EA
00001740                           813  *---------------------------------------------------------------------------*
00001740                           814  OP_MOVE_W   
00001740                           815             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001740  13FC 0082 000040D8       816             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001748  13FC 0000 000040D9       817             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001750                           818             
00001750                           819             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001750  13FC 00B9 000040DB       820             MOVE.B   #$B9,GET_DST_START_END
00001758  13FC 0020 000040DC       821             MOVE.B   #$20,GET_SRC_START_END
00001760                           822             
00001760                           823              *CLEAR D3
00001760  4283                     824              CLR.L   D3
00001762                           825              *LOAD STACK WITH THIS OPMODE
00001762  6100 204E                826              BSR     PUSH_STACK
00001766  163C 004D                827              MOVE.B  #'M',D3
0000176A  6100 2046                828              BSR     PUSH_STACK
0000176E  163C 004F                829              MOVE.B  #'O',D3
00001772  6100 203E                830              BSR     PUSH_STACK
00001776  163C 0056                831              MOVE.B  #'V',D3
0000177A  6100 2036                832              BSR     PUSH_STACK
0000177E  163C 0045                833              MOVE.B  #'E',D3
00001782  6100 202E                834              BSR     PUSH_STACK
00001786  163C 002E                835              MOVE.B  #'.',D3
0000178A  6100 2026                836              BSR     PUSH_STACK
0000178E  163C 0057                837              MOVE.B  #'W',D3
00001792  6100 201E                838              BSR     PUSH_STACK
00001796                           839              
00001796  6100 177C                840              BSR     GET_EA_EA_SRC
0000179A  163C 002C                841              MOVE.B  #',',D3
0000179E  6100 2012                842              BSR     PUSH_STACK
000017A2  6100 1BA0                843              BSR     GET_EA_EA_DEST
000017A6                           844              
000017A6  4E75                     845              RTS
000017A8                           846  
000017A8                           847  *---------------------------------------------------------------------------*
000017A8                           848  * OP_MOVEA_W: display MOVEA and proceed to EA
000017A8                           849  *---------------------------------------------------------------------------*
000017A8                           850  OP_MOVEA_W 
000017A8                           851             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017A8  13FC 00FD 000040D8       852             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000017B0  13FC 0000 000040D9       853             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017B8                           854             
000017B8                           855             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017B8  13FC 00B9 000040DB       856             MOVE.B   #$B9,GET_DST_START_END
000017C0  13FC 0020 000040DC       857             MOVE.B   #$20,GET_SRC_START_END
000017C8                           858             
000017C8                           859              *CLEAR D3
000017C8  4283                     860              CLR.L   D3
000017CA                           861              *LOAD STACK WITH THIS OPMODE
000017CA  6100 1FE6                862              BSR     PUSH_STACK
000017CE  163C 004D                863              MOVE.B  #'M',D3
000017D2  6100 1FDE                864              BSR     PUSH_STACK
000017D6  163C 004F                865              MOVE.B  #'O',D3
000017DA  6100 1FD6                866              BSR     PUSH_STACK
000017DE  163C 0056                867              MOVE.B  #'V',D3
000017E2  6100 1FCE                868              BSR     PUSH_STACK
000017E6  163C 0045                869              MOVE.B  #'E',D3
000017EA  6100 1FC6                870              BSR     PUSH_STACK           
000017EE  163C 0041                871              MOVE.B  #'A',D3
000017F2  6100 1FBE                872              BSR     PUSH_STACK
000017F6  163C 002E                873              MOVE.B  #'.',D3
000017FA  6100 1FB6                874              BSR     PUSH_STACK
000017FE  163C 0057                875              MOVE.B  #'W',D3
00001802  6100 1FAE                876              BSR     PUSH_STACK
00001806                           877              
00001806  6100 170C                878              BSR     GET_EA_EA_SRC
0000180A  163C 002C                879              MOVE.B  #',',D3
0000180E  6100 1FA2                880              BSR     PUSH_STACK
00001812  6100 1B30                881              BSR     GET_EA_EA_DEST
00001816                           882            
00001816  4E75                     883              RTS
00001818                           884  *---------------------------------------------------------------------------*
00001818                           885  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001818                           886  *---------------------------------------------------------------------------*
00001818                           887  OP0100
00001818  4280                     888              CLR.L   D0                      
0000181A  4281                     889              CLR.L   D1  
0000181C  4284                     890              CLR.L   D4                      
0000181E  227C 00000000            891              MOVEA.L #0, A1                  
00001824  2205                     892              MOVE.L  D5,D1  
00001826                           893              
00001826                           894              * check for RTS
00001826  0C41 4E75                895              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
0000182A  6700 0178                896              BEQ     OP_RTS
0000182E                           897              
0000182E                           898              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
0000182E  4281                     899              CLR.L   D1 
00001830  2205                     900              MOVE.L  D5,D1  
00001832  0241 0F00                901              ANDI.W  #$0F00,D1
00001836  0C41 0E00                902              CMPI.W  #$0E00,D1
0000183A  6700 0154                903              BEQ     OP_JSR
0000183E                           904  
0000183E                           905              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000183E  4281                     906              CLR.L   D1 
00001840  2205                     907              MOVE.L  D5,D1  
00001842  0241 0F00                908              ANDI.W  #$0F00,D1
00001846  0C41 0400                909              CMPI.W  #$0400,D1
0000184A  6700 0086                910              BEQ     OP_NEG
0000184E                           911              
0000184E                           912              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
0000184E  4281                     913              CLR.L   D1 
00001850  2205                     914              MOVE.L  D5,D1  
00001852  0241 0F00                915              ANDI.W  #$0F00,D1
00001856  0C41 0600                916              CMPI.W  #$0600,D1
0000185A  6700 00DE                917              BEQ     OP_NOT
0000185E                           918              
0000185E                           919              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
0000185E  4281                     920              CLR.L   D1 
00001860  2205                     921              MOVE.L  D5,D1  
00001862  E099                     922              ROR.L   #8,D1
00001864  0C01 0001                923              CMPI.B  #1,D1
00001868  6700 0054                924              BEQ     OP_LEA
0000186C                           925              
0000186C                           926              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
0000186C  4281                     927              CLR.L   D1 
0000186E  2205                     928              MOVE.L  D5,D1  
00001870  EB59                     929              ROL.W   #5,D1
00001872  0C01 0001                930              CMPI.B  #1,D1
00001876  6600 FC40                931              BNE     OP_DATA
0000187A  E959                     932              ROL.W   #4,D1
0000187C  0C01 0001                933              CMPI.B  #1,D1
00001880  6600 FC36                934              BNE     OP_DATA
00001884  E359                     935              ROL.W   #1,D1
00001886  0C01 0000                936              CMPI.B  #0,D1
0000188A  6700 000E                937              BEQ     OP_MOVEM_W
0000188E  0C01 0001                938              CMPI.B  #1,D1
00001892  6700 0018                939              BEQ     OP_MOVEM_L
00001896  4EF8 14B8                940              JMP     OP_DATA
0000189A                           941  
0000189A                           942  *---------------------------------------------------------------------------*
0000189A                           943  * OP_MOVEM_W: display MOVEM_W
0000189A                           944  *---------------------------------------------------------------------------*    
0000189A                           945  OP_MOVEM_W  
0000189A  183C 0001                946              MOVE.B  #1,D4
0000189E  43F9 00003E97            947              LEA     DISP_MOVEM_W,A1
000018A4  103C 000E                948              MOVE.B  #14,D0
000018A8  4E4F                     949              TRAP    #15
000018AA  4E75                     950              RTS
000018AC                           951  
000018AC                           952  *---------------------------------------------------------------------------*
000018AC                           953  * OP_MOVEM_L: display MOVEM_L
000018AC                           954  *---------------------------------------------------------------------------*
000018AC                           955  OP_MOVEM_L  
000018AC  183C 0002                956              MOVE.B  #2,D4
000018B0  43F9 00003EA2            957              LEA     DISP_MOVEM_L,A1
000018B6  103C 000E                958              MOVE.B  #14,D0
000018BA  4E4F                     959              TRAP    #15
000018BC  4E75                     960              RTS
000018BE                           961     
000018BE                           962  *---------------------------------------------------------------------------*
000018BE                           963  * OP_LEA: decode and display LEA
000018BE                           964  *---------------------------------------------------------------------------*
000018BE                           965  OP_LEA      
000018BE  43F9 00003E90            966              LEA     DISP_LEA,A1
000018C4  103C 000E                967              MOVE.B  #14,D0
000018C8  4E4F                     968              TRAP    #15
000018CA  4EF9 00002A9E            969              JMP     EA_MOVEA
000018D0                           970  
000018D0  4E75                     971              RTS
000018D2                           972  
000018D2                           973  *---------------------------------------------------------------------------*
000018D2                           974  * OP_NEG: decode and display NEG 
000018D2                           975  *---------------------------------------------------------------------------*
000018D2                           976  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
000018D2  4281                     977              CLR.L   D1
000018D4  4284                     978              CLR.L   D4
000018D6  2205                     979              MOVE.L  D5,D1
000018D8  EC99                     980              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000018DA  0C01 0000                981              CMPI.B  #0,D1
000018DE  6700 0012                982              BEQ     OP_NEG_B    * size is byte
000018E2  0C01 0001                983              CMPI.B  #1,D1
000018E6  6700 0022                984              BEQ     OP_NEG_W    * size is word
000018EA  0C01 0002                985              CMPI.B  #2,D1
000018EE  6700 0032                986              BEQ     OP_NEG_L    * size is long
000018F2                           987                         
000018F2                           988  OP_NEG_B    * size is byte   
000018F2  183C 0000                989              MOVE.B  #0,D4 
000018F6  43F9 00003E5A            990              LEA     DISP_NEG_B,A1
000018FC  103C 000E                991              MOVE.B  #14,D0
00001900  4E4F                     992              TRAP    #15
00001902                           993              
00001902  4EB9 00002A64            994              JSR     EA_NOSRC
00001908  4E75                     995              RTS
0000190A                           996              
0000190A                           997  OP_NEG_W    * size is word
0000190A  183C 0001                998              MOVE.B  #1,D4
0000190E  43F9 00003E63            999              LEA     DISP_NEG_W,A1
00001914  103C 000E               1000              MOVE.B  #14,D0
00001918  4E4F                    1001              TRAP    #15
0000191A  4EB9 00002A64           1002              JSR     EA_NOSRC
00001920  4E75                    1003              RTS
00001922                          1004              
00001922                          1005  OP_NEG_L    * size is long
00001922  183C 0002               1006              MOVE.B  #2,D4
00001926  43F9 00003E6C           1007              LEA     DISP_NEG_L,A1
0000192C  103C 000E               1008              MOVE.B  #14,D0
00001930  4E4F                    1009              TRAP    #15
00001932  4EB9 00002A64           1010              JSR     EA_NOSRC
00001938                          1011              
00001938  4E75                    1012              RTS
0000193A                          1013  
0000193A                          1014  *---------------------------------------------------------------------------*
0000193A                          1015  * OP_NOT: decode and display NOT 
0000193A                          1016  *---------------------------------------------------------------------------*
0000193A                          1017  OP_NOT
0000193A  4281                    1018              CLR.L   D1
0000193C  4284                    1019              CLR.L   D4
0000193E  2205                    1020              MOVE.L  D5,D1
00001940  EC99                    1021              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001942  0C01 0000               1022              CMPI.B  #0,D1
00001946  6700 0012               1023              BEQ     OP_NOT_B    * size is byte
0000194A  0C01 0001               1024              CMPI.B  #1,D1
0000194E  6700 001C               1025              BEQ     OP_NOT_W    * size is word
00001952  0C01 0002               1026              CMPI.B  #2,D1
00001956  6700 0026               1027              BEQ     OP_NOT_L    * size is long
0000195A                          1028                         
0000195A                          1029  OP_NOT_B    * size is byte   
0000195A  183C 0000               1030              MOVE.B  #0,D4 
0000195E  43F9 00003E75           1031              LEA     DISP_NOT_B,A1
00001964  103C 000E               1032              MOVE.B  #14,D0
00001968  4E4F                    1033              TRAP    #15
0000196A  4E75                    1034              RTS
0000196C                          1035              
0000196C                          1036  OP_NOT_W    * size is word
0000196C  183C 0001               1037              MOVE.B  #1,D4
00001970  43F9 00003E7E           1038              LEA     DISP_NOT_W,A1
00001976  103C 000E               1039              MOVE.B  #14,D0
0000197A  4E4F                    1040              TRAP    #15
0000197C  4E75                    1041              RTS
0000197E                          1042              
0000197E                          1043  OP_NOT_L    * size is long
0000197E  183C 0002               1044              MOVE.B  #2,D4
00001982  43F9 00003E87           1045              LEA     DISP_NOT_L,A1
00001988  103C 000E               1046              MOVE.B  #14,D0
0000198C  4E4F                    1047              TRAP    #15
0000198E  4E75                    1048              RTS
00001990                          1049  
00001990                          1050  *---------------------------------------------------------------------------*
00001990                          1051  * OP_JSR: display JSR     
00001990                          1052  *---------------------------------------------------------------------------*
00001990  43F9 00003E53           1053  OP_JSR      LEA     DISP_JSR,A1
00001996  103C 000E               1054              MOVE.B  #14,D0
0000199A  4E4F                    1055              TRAP    #15
0000199C  4EB9 00002A64           1056              JSR     EA_NOSRC
000019A2                          1057  
000019A2  4E75                    1058              RTS
000019A4                          1059  
000019A4                          1060  *---------------------------------------------------------------------------*
000019A4                          1061  * OP_RTS: display RTS     
000019A4                          1062  *---------------------------------------------------------------------------* 
000019A4  43F9 00003E4C           1063  OP_RTS      LEA     DISP_RTS,A1
000019AA  103C 000E               1064              MOVE.B  #14,D0
000019AE  4E4F                    1065              TRAP    #15
000019B0  4E75                    1066              RTS
000019B2                          1067  
000019B2                          1068  *---------------------------------------------------------------------------*
000019B2                          1069  * OP0101: decode ADDQ
000019B2                          1070  *---------------------------------------------------------------------------* 
000019B2  4280                    1071  OP0101      CLR.L   D0               * clear registers for temp storage       
000019B4  4281                    1072              CLR.L   D1
000019B6  4284                    1073              CLR.L   D4                  
000019B8  227C 00000000           1074              MOVEA.L #0, A1  
000019BE                          1075              
000019BE  2205                    1076              MOVE.L  D5,D1           * copy the processing data 
000019C0  E089                    1077              LSR.L   #8,D1           * shift to right by 8 bits to check the value of bit 8
000019C2  0201 0001               1078              ANDI.B  #$1,D1          * mask all bits except the last 2 bits
000019C6  0C01 0000               1079              CMPI.B  #0,D1           * if the value is 0, it's ADDQ
000019CA  6700 0006               1080              BEQ     OP_ADDQ
000019CE                          1081              
000019CE  4EF8 14B8               1082              JMP     OP_DATA
000019D2                          1083       
000019D2  4281                    1084  OP_ADDQ     CLR.L   D1
000019D4  2205                    1085              MOVE.L  D5,D1
000019D6  EC99                    1086              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000019D8  0281 00000003           1087              ANDI.L  #$3,D1
000019DE  0C01 0000               1088              CMPI.B  #0,D1
000019E2  6700 0014               1089              BEQ     OP_ADDQ_B    * size is byte
000019E6  0C41 0001               1090              CMPI.W  #1,D1
000019EA  6700 001E               1091              BEQ     OP_ADDQ_W    * size is word
000019EE  0C81 00000002           1092              CMPI.L  #2,D1
000019F4  6700 0026               1093              BEQ     OP_ADDQ_L    * size is long
000019F8                          1094              
000019F8                          1095  *---------------------------------------------------------------------------*
000019F8                          1096  * OP_ADDQ: display ADDQ
000019F8                          1097  *---------------------------------------------------------------------------*              
000019F8                          1098  OP_ADDQ_B    * size is byte   
000019F8  183C 0000               1099              MOVE.B  #0,D4 
000019FC  43F9 00003EAD           1100              LEA     DISP_ADDQ_B,A1
00001A02  103C 000E               1101              MOVE.B  #14,D0
00001A06  4E4F                    1102              TRAP    #15
00001A08  4E75                    1103              RTS
00001A0A                          1104              
00001A0A                          1105  OP_ADDQ_W    * size is word
00001A0A  183C 0001               1106              MOVE.B  #1,D4
00001A0E  43F9 00003EB7           1107              LEA     DISP_ADDQ_W,A1
00001A14  103C 000E               1108              MOVE.B  #14,D0
00001A18  4E4F                    1109              TRAP    #15
00001A1A  4E75                    1110              RTS
00001A1C                          1111              
00001A1C                          1112  OP_ADDQ_L    * size is long
00001A1C  183C 0002               1113              MOVE.B  #2,D4
00001A20  43F9 00003EC1           1114              LEA     DISP_ADDQ_L,A1
00001A26  103C 000E               1115              MOVE.B  #14,D0
00001A2A  4E4F                    1116              TRAP    #15
00001A2C  4E75                    1117              RTS
00001A2E                          1118  
00001A2E                          1119  *---------------------------------------------------------------------------*
00001A2E                          1120  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001A2E                          1121  *---------------------------------------------------------------------------*              
00001A2E  4280                    1122  OP0110      CLR.L   D0                  
00001A30  4281                    1123              CLR.L   D1   
00001A32  4284                    1124              CLR.L   D4                 
00001A34  227C 00000000           1125              MOVEA.L #0,A1
00001A3A  2205                    1126              MOVE.L  D5, D1                
00001A3C  0281 000000FF           1127              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001A42  2205                    1128              MOVE.L  D5,D1                  
00001A44  0281 00000F00           1129              ANDI.L  #$0F00,D1
00001A4A                          1130                 
00001A4A  0C41 0000               1131              CMPI.W  #$0000,D1               * Check for BRA
00001A4E  6700 0050               1132              BEQ     OP_BRA                  
00001A52                          1133                          
00001A52  0C41 0D00               1134              CMPI.W  #$0D00,D1               * Check for BLT
00001A56  6700 0056               1135              BEQ     OP_BLT      
00001A5A                          1136  
00001A5A  0C41 0700               1137              CMPI.W  #$0700,D1               * Check for BEQ
00001A5E  6700 0032               1138              BEQ     OP_BEQ      
00001A62                          1139  
00001A62  0C41 0600               1140              CMPI.W  #$0600,D1               * Check for BNE
00001A66  6700 001C               1141              BEQ     OP_BNE  
00001A6A                          1142              
00001A6A  0C41 0200               1143              CMPI.W  #$0200,D1               * Check for BHI
00001A6E  6700 0006               1144              BEQ     OP_BHI
00001A72                          1145  
00001A72  4EF8 14B8               1146              JMP     OP_DATA
00001A76                          1147              
00001A76  43F9 0000407C           1148  OP_BHI      LEA     DISP_BHI,A1             
00001A7C  103C 000E               1149              MOVE.B  #14,D0
00001A80  4E4F                    1150              TRAP    #15
00001A82  4E75                    1151              RTS
00001A84                          1152  
00001A84  43F9 00004075           1153  OP_BNE      LEA     DISP_BNE,A1             
00001A8A  103C 000E               1154              MOVE.B  #14,D0
00001A8E  4E4F                    1155              TRAP    #15
00001A90  4E75                    1156              RTS
00001A92                          1157  
00001A92  43F9 0000406E           1158  OP_BEQ      LEA     DISP_BEQ,A1             
00001A98  103C 000E               1159              MOVE.B  #14,D0
00001A9C  4E4F                    1160              TRAP    #15
00001A9E  4E75                    1161              RTS          
00001AA0                          1162                          
00001AA0  43F9 00004060           1163  OP_BRA      LEA     DISP_BRA,A1             
00001AA6  103C 000E               1164              MOVE.B  #14,D0
00001AAA  4E4F                    1165              TRAP    #15
00001AAC  4E75                    1166              RTS
00001AAE                          1167              
00001AAE  43F9 00004067           1168  OP_BLT      LEA     DISP_BLT,A1          
00001AB4  103C 000E               1169              MOVE.B  #14,D0
00001AB8  4E4F                    1170              TRAP    #15
00001ABA  4E75                    1171              RTS
00001ABC                          1172     
00001ABC                          1173  *---------------------------------------------------------------------------*
00001ABC                          1174  * OP0111 : MOVEQ not required
00001ABC                          1175  *---------------------------------------------------------------------------*           
00001ABC  4EF8 14B8               1176  OP0111      JMP     OP_DATA
00001AC0                          1177             
00001AC0                          1178  *---------------------------------------------------------------------------*
00001AC0                          1179  * OP1000 : decode DIVS
00001AC0                          1180  *---------------------------------------------------------------------------*           
00001AC0                          1181  OP1000                           
00001AC0  4281                    1182              CLR.L   D1       
00001AC2  4284                    1183              CLR.L   D4                   
00001AC4  227C 00000000           1184              MOVEA.L #0, A1              
00001ACA  2205                    1185              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001ACC                          1186              *CLEAR D3
00001ACC  4283                    1187              CLR.L   D3
00001ACE                          1188  
00001ACE                          1189  OP1000_DIVS_DN_EA_OR_EA_DN 
00001ACE                          1190              *LOAD STACK WITH THIS OPMODE
00001ACE  6100 1CE2               1191              BSR     PUSH_STACK
00001AD2  163C 0044               1192              MOVE.B  #'D',D3
00001AD6  6100 1CDA               1193              BSR     PUSH_STACK
00001ADA  163C 0049               1194              MOVE.B  #'I',D3
00001ADE  6100 1CD2               1195              BSR     PUSH_STACK
00001AE2  163C 0056               1196              MOVE.B  #'V',D3
00001AE6  6100 1CCA               1197              BSR     PUSH_STACK
00001AEA  163C 0053               1198              MOVE.B  #'S',D3
00001AEE  6100 1CC2               1199              BSR     PUSH_STACK
00001AF2  163C 002E               1200              MOVE.B  #'.',D3
00001AF6  6100 1CBA               1201              BSR     PUSH_STACK
00001AFA                          1202              
00001AFA  2205                    1203              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001AFC                          1204              
00001AFC                          1205  OP1000_EA_DN_DIVS
00001AFC                          1206              *BITS (7 TO 6) 
00001AFC                          1207              *00 = .B
00001AFC                          1208              *01 = .W
00001AFC                          1209              *10 = .L 
00001AFC  2205                    1210              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001AFE  EC99                    1211              ROR.L   #6,D1
00001B00  0281 00000003           1212              ANDI.L  #$03,D1
00001B06  0C81 00000003           1213              CMPI.L  #%11,D1 *EQUALS .W
00001B0C  6700 0014               1214              BEQ     OP1000_PRINT_W_DIVS
00001B10  0C81 00000000           1215              CMPI.L  #%00,D1 *EQUALS .L
00001B16  6700 0052               1216              BEQ     OP1000_PRINT_L_DIVS
00001B1A                          1217              
00001B1A  183C 0001               1218              MOVE.B  #1,D4               *ERROR READ
00001B1E  6000 0092               1219              BRA     OP1000_DIVS_RETURN
00001B22                          1220  OP1000_PRINT_W_DIVS
00001B22  163C 0057               1221              MOVE.B  #'W',D3
00001B26  6100 1C8A               1222              BSR     PUSH_STACK
00001B2A                          1223  
00001B2A                          1224              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B2A  13FC 0000 000040D8      1225              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B32  13FC 0000 000040D9      1226              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B3A                          1227             
00001B3A                          1228              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B3A  13FC 00B9 000040DB      1229              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B42  13FC 0020 000040DC      1230              MOVE.B   #$20,GET_SRC_START_END
00001B4A                          1231  
00001B4A                          1232             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001B4A  0285 0000FE3F           1233              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001B50  0685 00000000           1234              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001B56                          1235  
00001B56                          1236              
00001B56  6100 13BC               1237              BSR     GET_EA_EA_SRC      *GETS <ea>
00001B5A  163C 002C               1238              MOVE.B  #',',D3
00001B5E  6100 1C52               1239              BSR     PUSH_STACK
00001B62  6100 17E0               1240              BSR     GET_EA_EA_DEST       *GETS Dn    
00001B66                          1241              
00001B66  6000 004A               1242              BRA     OP1000_DIVS_RETURN
00001B6A                          1243  OP1000_PRINT_L_DIVS
00001B6A  163C 004C               1244              MOVE.B  #'L',D3
00001B6E  6100 1C42               1245              BSR     PUSH_STACK
00001B72                          1246              
00001B72                          1247              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B72  13FC 0000 000040D8      1248              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B7A  13FC 0000 000040D9      1249              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B82                          1250             
00001B82                          1251              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B82  13FC 00B9 000040DB      1252              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B8A  13FC 0020 000040DC      1253              MOVE.B   #$20,GET_SRC_START_END
00001B92                          1254  
00001B92                          1255              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001B92  0285 0000FE3F           1256              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001B98  0685 00000000           1257              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001B9E                          1258  
00001B9E                          1259                     
00001B9E  6100 1374               1260              BSR     GET_EA_EA_SRC      *GETS <ea>
00001BA2  163C 002C               1261              MOVE.B  #',',D3
00001BA6  6100 1C0A               1262              BSR     PUSH_STACK                  
00001BAA  6100 1798               1263              BSR     GET_EA_EA_DEST       *GETS Dn    
00001BAE                          1264  
00001BAE                          1265              
00001BAE  6000 0002               1266              BRA     OP1000_DIVS_RETURN
00001BB2                          1267              
00001BB2                          1268  OP1000_DIVS_RETURN
00001BB2  4E75                    1269              RTS
00001BB4                          1270              
00001BB4                          1271  
00001BB4                          1272  
00001BB4                          1273  *---------------------------------------------------------------------------*
00001BB4                          1274  * OP_DIVS: display DIVS and proceed to EA
00001BB4                          1275  *---------------------------------------------------------------------------*  
00001BB4  43F9 00003ECB           1276  OP_DIVS     LEA     DISP_DIVS,A1
00001BBA  103C 000E               1277              MOVE.B  #14,D0
00001BBE  4E4F                    1278              TRAP    #15
00001BC0  4EF9 00002A78           1279              JMP     EA_ARITH
00001BC6                          1280  
00001BC6  4E75                    1281              RTS
00001BC8                          1282              
00001BC8                          1283  *---------------------------------------------------------------------------*
00001BC8                          1284  * OP1001: decode SUB/SUBA
00001BC8                          1285  *---------------------------------------------------------------------------*      
00001BC8                          1286  OP1001      
00001BC8  4280                    1287              CLR.L   D0                  
00001BCA  4281                    1288              CLR.L   D1       
00001BCC  4284                    1289              CLR.L   D4                   
00001BCE  227C 00000000           1290              MOVEA.L #0, A1              
00001BD4  2205                    1291              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001BD6                          1292              
00001BD6                          1293              *CLEAR D3
00001BD6  4283                    1294              CLR.L   D3
00001BD8                          1295              
00001BD8                          1296              
00001BD8                          1297              
00001BD8                          1298              **INTEGRATING SUB.W/.L INTO THIS CODE**
00001BD8  2205                    1299              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001BDA                          1300              *BITS (INDEX 8) 
00001BDA                          1301              *0 = ADD.B/W/L <EA>,Dn
00001BDA                          1302              *1 = ADD.B/W/L Dn,<EA> 
00001BDA  EC99                    1303              ROR.L   #6,D1
00001BDC  0281 00000007           1304              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001BE2  0C81 00000007           1305              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001BE8  6700 0010               1306              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001BEC  0C81 00000003           1307              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001BF2  6700 0078               1308              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001BF6  6000 00E6               1309              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001BFA                          1310              
00001BFA                          1311  OP1001_SUBA_L
00001BFA                          1312              *LOAD STACK WITH THIS OPMODE
00001BFA  6100 1BB6               1313              BSR     PUSH_STACK
00001BFE  163C 0053               1314              MOVE.B  #'S',D3
00001C02  6100 1BAE               1315              BSR     PUSH_STACK
00001C06  163C 0055               1316              MOVE.B  #'U',D3
00001C0A  6100 1BA6               1317              BSR     PUSH_STACK
00001C0E  163C 0042               1318              MOVE.B  #'B',D3
00001C12  6100 1B9E               1319              BSR     PUSH_STACK
00001C16  163C 0041               1320              MOVE.B  #'A',D3
00001C1A  6100 1B96               1321              BSR     PUSH_STACK
00001C1E  163C 002E               1322              MOVE.B  #'.',D3
00001C22  6100 1B8E               1323              BSR     PUSH_STACK
00001C26  163C 004C               1324              MOVE.B  #'L',D3
00001C2A  6100 1B86               1325              BSR     PUSH_STACK
00001C2E                          1326              
00001C2E                          1327             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C2E  13FC 0000 000040D8      1328             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C36  13FC 0000 000040D9      1329             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C3E                          1330             
00001C3E                          1331             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C3E  13FC 00B9 000040DB      1332             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001C46  13FC 0020 000040DC      1333             MOVE.B   #$20,GET_SRC_START_END
00001C4E                          1334  
00001C4E                          1335              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001C4E  0285 0000FE3F           1336              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001C54  0685 00000040           1337              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001C5A                          1338       
00001C5A                          1339              *PRINT <EA>,AN
00001C5A  6100 12B8               1340              BSR     GET_EA_EA_SRC       *GETS <ea>
00001C5E  163C 002C               1341              MOVE.B  #',',D3
00001C62  6100 1B4E               1342              BSR     PUSH_STACK                     
00001C66  6100 16DC               1343              BSR     GET_EA_EA_DEST      *GETS Dn
00001C6A                          1344  
00001C6A                          1345              
00001C6A                          1346              
00001C6A  4E75                    1347              RTS
00001C6C                          1348  OP1001_SUBA_W
00001C6C                          1349              *LOAD STACK WITH THIS OPMODE
00001C6C  6100 1B44               1350              BSR     PUSH_STACK
00001C70  163C 0053               1351              MOVE.B  #'S',D3
00001C74  6100 1B3C               1352              BSR     PUSH_STACK
00001C78  163C 0055               1353              MOVE.B  #'U',D3
00001C7C  6100 1B34               1354              BSR     PUSH_STACK
00001C80  163C 0042               1355              MOVE.B  #'B',D3
00001C84  6100 1B2C               1356              BSR     PUSH_STACK
00001C88  163C 0041               1357              MOVE.B  #'A',D3
00001C8C  6100 1B24               1358              BSR     PUSH_STACK
00001C90  163C 002E               1359              MOVE.B  #'.',D3
00001C94  6100 1B1C               1360              BSR     PUSH_STACK
00001C98  163C 0057               1361              MOVE.B  #'W',D3
00001C9C  6100 1B14               1362              BSR     PUSH_STACK
00001CA0                          1363              
00001CA0                          1364             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CA0  13FC 0000 000040D8      1365             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CA8  13FC 0000 000040D9      1366             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CB0                          1367             
00001CB0                          1368             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CB0  13FC 00B9 000040DB      1369             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CB8  13FC 0020 000040DC      1370             MOVE.B   #$20,GET_SRC_START_END
00001CC0                          1371  
00001CC0                          1372              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CC0  0285 0000FE3F           1373              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CC6  0685 00000040           1374              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001CCC                          1375       
00001CCC                          1376              *PRINT <EA>,AN
00001CCC  6100 1246               1377              BSR     GET_EA_EA_SRC       *GETS <ea>
00001CD0  163C 002C               1378              MOVE.B  #',',D3
00001CD4  6100 1ADC               1379              BSR     PUSH_STACK                     
00001CD8  6100 166A               1380              BSR     GET_EA_EA_DEST      *GETS Dn
00001CDC                          1381  
00001CDC  4E75                    1382              RTS
00001CDE                          1383  
00001CDE                          1384  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001CDE                          1385              *LOAD STACK WITH THIS OPMODE
00001CDE  6100 1AD2               1386              BSR     PUSH_STACK
00001CE2  163C 0053               1387              MOVE.B  #'S',D3
00001CE6  6100 1ACA               1388              BSR     PUSH_STACK
00001CEA  163C 0055               1389              MOVE.B  #'U',D3
00001CEE  6100 1AC2               1390              BSR     PUSH_STACK
00001CF2  163C 0042               1391              MOVE.B  #'B',D3
00001CF6  6100 1ABA               1392              BSR     PUSH_STACK
00001CFA  163C 002E               1393              MOVE.B  #'.',D3
00001CFE  6100 1AB2               1394              BSR     PUSH_STACK
00001D02                          1395              
00001D02  2205                    1396              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001D04                          1397              
00001D04                          1398              *BITS (INDEX 8) 
00001D04                          1399              *0 = ADD.B/W/L <EA>,Dn
00001D04                          1400              *1 = ADD.B/W/L Dn,<EA> 
00001D04  E099                    1401              ROR.L   #8,D1
00001D06  0281 00000001           1402              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001D0C  0C81 00000000           1403              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001D12  6700 0102               1404              BEQ     OP1001_EA_DN
00001D16                          1405              *else procede to Dn_EA
00001D16                          1406              
00001D16                          1407  OP1001_DN_EA
00001D16                          1408              *BITS (7 TO 6) 
00001D16                          1409              *00 = .B
00001D16                          1410              *01 = .W
00001D16                          1411              *10 = .L 
00001D16  2205                    1412              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001D18  EC99                    1413              ROR.L   #6,D1
00001D1A  0281 00000003           1414              ANDI.L  #$03,D1
00001D20  0C81 00000000           1415              CMPI.L  #$00,D1 *EQUALS .B
00001D26  6700 0016               1416              BEQ     OP1001_PRINT_B2
00001D2A  0C81 00000001           1417              CMPI.L  #$01,D1 *EQUALS .W
00001D30  6700 0054               1418              BEQ     OP1001_PRINT_W2
00001D34  0C81 00000002           1419              CMPI.L  #$02,D1 *EQUALS .L
00001D3A  6700 0092               1420              BEQ     OP1001_PRINT_L2
00001D3E                          1421  OP1001_PRINT_B2
00001D3E                          1422              *PUSH 'B'
00001D3E  163C 0042               1423              MOVE.B  #'B',D3
00001D42  6100 1A6E               1424              BSR     PUSH_STACK
00001D46                          1425             
00001D46                          1426              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D46  13FC 0000 000040D8      1427             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D4E  13FC 0083 000040D9      1428             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D56                          1429             
00001D56                          1430             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D56  13FC 00B9 000040DB      1431             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D5E  13FC 0020 000040DC      1432             MOVE.B   #$20,GET_SRC_START_END
00001D66                          1433  
00001D66                          1434              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D66  0285 0000FE3F           1435              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D6C  0685 00000040           1436              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001D72                          1437       
00001D72  6100 15D0               1438              BSR     GET_EA_EA_DEST      *GETS Dn
00001D76  163C 002C               1439              MOVE.B  #',',D3
00001D7A  6100 1A36               1440              BSR     PUSH_STACK                     
00001D7E  6100 1194               1441              BSR     GET_EA_EA_SRC       *GETS <ea>
00001D82                          1442  
00001D82                          1443              
00001D82  6000 09A0               1444              BRA     OP1101_ADD_RETURN
00001D86                          1445  OP1001_PRINT_W2
00001D86  163C 0057               1446              MOVE.B  #'W',D3
00001D8A  6100 1A26               1447              BSR     PUSH_STACK
00001D8E                          1448  
00001D8E                          1449              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D8E  13FC 0000 000040D8      1450              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D96  13FC 0083 000040D9      1451              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D9E                          1452             
00001D9E                          1453              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D9E  13FC 00B9 000040DB      1454              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DA6  13FC 0020 000040DC      1455              MOVE.B   #$20,GET_SRC_START_END
00001DAE                          1456  
00001DAE                          1457              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DAE  0285 0000FE3F           1458              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DB4  0685 00000040           1459              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001DBA                          1460  
00001DBA                          1461        
00001DBA  6100 1588               1462              BSR     GET_EA_EA_DEST      *GETS Dn
00001DBE  163C 002C               1463              MOVE.B  #',',D3
00001DC2  6100 19EE               1464              BSR     PUSH_STACK               
00001DC6  6100 114C               1465              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001DCA                          1466  
00001DCA                          1467  
00001DCA                          1468  
00001DCA  6000 0958               1469              BRA     OP1101_ADD_RETURN
00001DCE                          1470  OP1001_PRINT_L2 
00001DCE  163C 004C               1471              MOVE.B  #'L',D3
00001DD2  6100 19DE               1472              BSR     PUSH_STACK
00001DD6                          1473              
00001DD6                          1474              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DD6  13FC 0000 000040D8      1475              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001DDE  13FC 0083 000040D9      1476              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001DE6                          1477             
00001DE6                          1478              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DE6  13FC 00B9 000040DB      1479              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DEE  13FC 0020 000040DC      1480              MOVE.B   #$20,GET_SRC_START_END
00001DF6                          1481  
00001DF6                          1482             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DF6  0285 0000FE3F           1483              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DFC  0685 00000040           1484              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E02                          1485  
00001E02                          1486               
00001E02  6100 1540               1487              BSR     GET_EA_EA_DEST       *GETS Dn
00001E06  163C 002C               1488              MOVE.B  #',',D3
00001E0A  6100 19A6               1489              BSR     PUSH_STACK          
00001E0E  6100 1104               1490              BSR     GET_EA_EA_SRC        *GETS <ea>
00001E12                          1491  
00001E12  6000 0910               1492              BRA     OP1101_ADD_RETURN
00001E16                          1493              
00001E16                          1494  OP1001_EA_DN           
00001E16                          1495              *BITS (7 TO 6) 
00001E16                          1496              *00 = .B
00001E16                          1497              *01 = .W
00001E16                          1498              *10 = .L 
00001E16  2205                    1499              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001E18  EC99                    1500              ROR.L   #6,D1
00001E1A  0281 00000003           1501              ANDI.L  #$03,D1
00001E20  0C81 00000000           1502              CMPI.L  #$00,D1 *EQUALS .B
00001E26  6700 0016               1503              BEQ     OP1001_PRINT_B
00001E2A  0C81 00000001           1504              CMPI.L  #$01,D1 *EQUALS .W
00001E30  6700 0054               1505              BEQ     OP1001_PRINT_W
00001E34  0C81 00000002           1506              CMPI.L  #$02,D1 *EQUALS .L
00001E3A  6700 0092               1507              BEQ     OP1001_PRINT_L
00001E3E                          1508  OP1001_PRINT_B
00001E3E  163C 0042               1509              MOVE.B  #'B',D3
00001E42  6100 196E               1510              BSR     PUSH_STACK
00001E46                          1511                
00001E46                          1512              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E46  13FC 0000 000040D8      1513              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E4E  13FC 0002 000040D9      1514              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E56                          1515             
00001E56                          1516              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E56  13FC 00B9 000040DB      1517              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E5E  13FC 0020 000040DC      1518              MOVE.B   #$20,GET_SRC_START_END
00001E66                          1519  
00001E66                          1520             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E66  0285 0000FE3F           1521              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E6C  0685 00000040           1522              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00001E72                          1523  
00001E72                          1524              
00001E72  6100 10A0               1525              BSR     GET_EA_EA_SRC      *GETS <ea>
00001E76  163C 002C               1526              MOVE.B  #',',D3
00001E7A  6100 1936               1527              BSR     PUSH_STACK          
00001E7E  6100 14C4               1528              BSR     GET_EA_EA_DEST       *GETS Dn
00001E82                          1529              
00001E82  6000 08A0               1530              BRA     OP1101_ADD_RETURN
00001E86                          1531  OP1001_PRINT_W
00001E86  163C 0057               1532              MOVE.B  #'W',D3
00001E8A  6100 1926               1533              BSR     PUSH_STACK
00001E8E                          1534  
00001E8E                          1535              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E8E  13FC 0000 000040D8      1536              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E96  13FC 0000 000040D9      1537              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E9E                          1538             
00001E9E                          1539              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E9E  13FC 00B9 000040DB      1540              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001EA6  13FC 0020 000040DC      1541              MOVE.B   #$20,GET_SRC_START_END
00001EAE                          1542  
00001EAE                          1543             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001EAE  0285 0000FE3F           1544              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001EB4  0685 00000040           1545              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001EBA                          1546  
00001EBA                          1547              
00001EBA  6100 1058               1548              BSR     GET_EA_EA_SRC      *GETS <ea>
00001EBE  163C 002C               1549              MOVE.B  #',',D3
00001EC2  6100 18EE               1550              BSR     PUSH_STACK
00001EC6  6100 147C               1551              BSR     GET_EA_EA_DEST       *GETS Dn    
00001ECA                          1552              
00001ECA  6000 004A               1553              BRA     OP1001_ADD_RETURN
00001ECE                          1554  OP1001_PRINT_L 
00001ECE  163C 004C               1555              MOVE.B  #'L',D3
00001ED2  6100 18DE               1556              BSR     PUSH_STACK
00001ED6                          1557              
00001ED6                          1558              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001ED6  13FC 0000 000040D8      1559              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001EDE  13FC 0000 000040D9      1560              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001EE6                          1561             
00001EE6                          1562              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001EE6  13FC 00B9 000040DB      1563              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001EEE  13FC 0020 000040DC      1564              MOVE.B   #$20,GET_SRC_START_END
00001EF6                          1565  
00001EF6                          1566              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001EF6  0285 0000FE3F           1567              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001EFC  0685 00000040           1568              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001F02                          1569  
00001F02                          1570                     
00001F02  6100 1010               1571              BSR     GET_EA_EA_SRC      *GETS <ea>
00001F06  163C 002C               1572              MOVE.B  #',',D3
00001F0A  6100 18A6               1573              BSR     PUSH_STACK                  
00001F0E  6100 1434               1574              BSR     GET_EA_EA_DEST       *GETS Dn    
00001F12                          1575  
00001F12                          1576              
00001F12  6000 0002               1577              BRA     OP1001_ADD_RETURN
00001F16                          1578              
00001F16                          1579  OP1001_ADD_RETURN
00001F16  4E75                    1580              RTS
00001F18                          1581  
00001F18                          1582    
00001F18                          1583  *---------------------------------------------------------------------------*
00001F18                          1584  * OP_SUB: display SUB and proceed to EA
00001F18                          1585  *---------------------------------------------------------------------------*            
00001F18  43F9 00003ED3           1586  OP_SUB_B    LEA     DISP_SUB_B,A1
00001F1E  103C 000E               1587              MOVE.B  #14,D0
00001F22  4E4F                    1588              TRAP    #15
00001F24  183C 0000               1589              MOVE.B  #0,D4
00001F28  4EF9 00002AC4           1590              JMP     EA_GEN
00001F2E                          1591  
00001F2E  4E75                    1592              RTS
00001F30                          1593  
00001F30  43F9 00003EDC           1594  OP_SUB_W    LEA     DISP_SUB_W,A1
00001F36  103C 000E               1595              MOVE.B  #14,D0
00001F3A  4E4F                    1596              TRAP    #15
00001F3C  183C 0001               1597              MOVE.B  #1,D4
00001F40  4EF9 00002AC4           1598              JMP     EA_GEN
00001F46                          1599  
00001F46  4E75                    1600              RTS
00001F48                          1601  
00001F48  43F9 00003EE5           1602  OP_SUB_L    LEA     DISP_SUB_L,A1
00001F4E  103C 000E               1603              MOVE.B  #14,D0
00001F52  4E4F                    1604              TRAP    #15
00001F54  183C 0002               1605              MOVE.B  #2,D4
00001F58  4EF9 00002AC4           1606              JMP     EA_GEN
00001F5E                          1607  
00001F5E  4E75                    1608              RTS
00001F60                          1609  
00001F60                          1610  *---------------------------------------------------------------------------*
00001F60                          1611  * OP_SUBA: display SUBA
00001F60                          1612  *---------------------------------------------------------------------------*  
00001F60  43F9 00003F0C           1613  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00001F66  103C 000E               1614              MOVE.B  #14,D0
00001F6A  4E4F                    1615              TRAP    #15
00001F6C  183C 0001               1616              MOVE.B  #1,D4
00001F70  4E75                    1617              RTS
00001F72                          1618  
00001F72  43F9 00003F16           1619  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00001F78  103C 000E               1620              MOVE.B  #14,D0
00001F7C  4E4F                    1621              TRAP    #15
00001F7E  183C 0002               1622              MOVE.B  #2,D4
00001F82  4E75                    1623              RTS         
00001F84                          1624  *---------------------------------------------------------------------------*
00001F84                          1625  * OP1010 : unassigned
00001F84                          1626  *---------------------------------------------------------------------------*           
00001F84  4EF8 14B8               1627  OP1010      JMP     OP_DATA
00001F88                          1628              
00001F88                          1629  *---------------------------------------------------------------------------*
00001F88                          1630  * OP1011 : decode CMP/EOR/CMPA
00001F88                          1631  *---------------------------------------------------------------------------*           
00001F88  4280                    1632  OP1011      CLR.L   D0                
00001F8A  4281                    1633              CLR.L   D1            
00001F8C  4284                    1634              CLR.L   D4                   
00001F8E  227C 00000000           1635              MOVEA.L #0, A1               
00001F94  2205                    1636              MOVE.L  D5,D1
00001F96  EA99                    1637              ROR.L   #5,D1
00001F98  0281 0000000E           1638              ANDI.L  #$E,D1
00001F9E  0C01 0000               1639              CMPI.B  #$0,D1
00001FA2  6700 0062               1640              BEQ     OP_CMP_B
00001FA6  0C01 0002               1641              CMPI.B  #$2,D1
00001FAA  6700 0072               1642              BEQ     OP_CMP_W
00001FAE  0C01 0004               1643              CMPI.B  #$4,D1
00001FB2  6700 0082               1644              BEQ     OP_CMP_L
00001FB6  0C01 0008               1645              CMPI.B  #$8,D1
00001FBA  6700 0092               1646              BEQ     OP_EOR_B
00001FBE  0C01 000A               1647              CMPI.B  #$A,D1
00001FC2  6700 009C               1648              BEQ     OP_EOR_W
00001FC6  0C01 000C               1649              CMPI.B  #$C,D1
00001FCA  6700 00A6               1650              BEQ     OP_EOR_L  
00001FCE  0C01 0006               1651              CMPI.B  #$6,D1
00001FD2  6700 000E               1652              BEQ     OP_CMPA_W
00001FD6  0C01 000E               1653              CMPI.B  #$E,D1
00001FDA  6700 0018               1654              BEQ     OP_CMPA_L 
00001FDE                          1655  
00001FDE  4EF8 14B8               1656              JMP     OP_DATA          
00001FE2                          1657  
00001FE2                          1658  *---------------------------------------------------------------------------*
00001FE2                          1659  * OP_CMPA: display CMPA 
00001FE2                          1660  *---------------------------------------------------------------------------
00001FE2  43F9 00003F56           1661  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00001FE8  103C 000E               1662              MOVE.B  #14,D0
00001FEC  4E4F                    1663              TRAP    #15
00001FEE  183C 0001               1664              MOVE.B  #1,D4
00001FF2  4E75                    1665              RTS
00001FF4                          1666  
00001FF4  43F9 00003F60           1667  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00001FFA  103C 000E               1668              MOVE.B  #14,D0
00001FFE  4E4F                    1669              TRAP    #15
00002000  183C 0002               1670              MOVE.B  #2,D4
00002004  4E75                    1671              RTS
00002006                          1672  
00002006                          1673  *---------------------------------------------------------------------------*
00002006                          1674  * OP_CMP: display CMP and proceed to EA
00002006                          1675  *---------------------------------------------------------------------------*  
00002006  43F9 00003F3B           1676  OP_CMP_B    LEA     DISP_CMP_B,A1
0000200C  103C 000E               1677              MOVE.B  #14,D0
00002010  4E4F                    1678              TRAP    #15
00002012  183C 0000               1679              MOVE.B  #0,D4
00002016  4EF9 00002AC4           1680              JMP     EA_GEN
0000201C                          1681  
0000201C  4E75                    1682              RTS
0000201E                          1683              
0000201E  43F9 00003F44           1684  OP_CMP_W    LEA     DISP_CMP_W,A1
00002024  103C 000E               1685              MOVE.B  #14,D0
00002028  4E4F                    1686              TRAP    #15
0000202A  183C 0001               1687              MOVE.B  #1,D4
0000202E  4EF9 00002AC4           1688              JMP     EA_GEN
00002034                          1689  
00002034  4E75                    1690              RTS
00002036                          1691              
00002036  43F9 00003F4D           1692  OP_CMP_L    LEA     DISP_CMP_L,A1
0000203C  103C 000E               1693              MOVE.B  #14,D0
00002040  4E4F                    1694              TRAP    #15
00002042  183C 0002               1695              MOVE.B  #2,D4
00002046  4EF9 00002AC4           1696              JMP     EA_GEN
0000204C                          1697  
0000204C  4E75                    1698              RTS
0000204E                          1699              
0000204E                          1700  *---------------------------------------------------------------------------*
0000204E                          1701  * OP_EOR: display EOR
0000204E                          1702  *---------------------------------------------------------------------------*  
0000204E  43F9 00003F20           1703  OP_EOR_B    LEA     DISP_EOR_B,A1
00002054  103C 000E               1704              MOVE.B  #14,D0
00002058  4E4F                    1705              TRAP    #15
0000205A  183C 0000               1706              MOVE.B  #0,D4
0000205E  4E75                    1707              RTS
00002060                          1708              
00002060  43F9 00003F29           1709  OP_EOR_W    LEA     DISP_EOR_W,A1
00002066  103C 000E               1710              MOVE.B  #14,D0
0000206A  4E4F                    1711              TRAP    #15
0000206C  183C 0001               1712              MOVE.B  #1,D4
00002070  4E75                    1713              RTS
00002072                          1714              
00002072  43F9 00003F32           1715  OP_EOR_L    LEA     DISP_EOR_L,A1
00002078  103C 000E               1716              MOVE.B  #14,D0
0000207C  4E4F                    1717              TRAP    #15
0000207E  183C 0002               1718              MOVE.B  #2,D4
00002082  4E75                    1719              RTS    
00002084                          1720  
00002084                          1721  *---------------------------------------------------------------------------*
00002084                          1722  * OP1100: Decode and display MULS/AND and proceed to EA
00002084                          1723  *---------------------------------------------------------------------------* 
00002084  4280                    1724  OP1100      CLR.L   D0                 
00002086  4281                    1725              CLR.L   D1    
00002088  4284                    1726              CLR.L   D4                
0000208A  227C 00000000           1727              MOVEA.L #0, A1        
00002090  2205                    1728              MOVE.L  D5,D1
00002092  EA89                    1729              LSR.L   #5,D1
00002094  0281 0000000E           1730              ANDI.L  #$E,D1
0000209A  0C41 000E               1731              CMPI.W  #$E,D1
0000209E  6700 0006               1732              BEQ     OP_MULS
000020A2  6000 00F6               1733              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000020A6                          1734  
000020A6                          1735  OP_MULS                      
000020A6  4281                    1736              CLR.L   D1       
000020A8  4284                    1737              CLR.L   D4                   
000020AA  227C 00000000           1738              MOVEA.L #0, A1              
000020B0  2205                    1739              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020B2                          1740              *CLEAR D3
000020B2  4283                    1741              CLR.L   D3
000020B4                          1742  
000020B4                          1743  OP1100_MULS_DN_EA_OR_EA_DN 
000020B4                          1744              *LOAD STACK WITH THIS OPMODE
000020B4  6100 16FC               1745              BSR     PUSH_STACK
000020B8  163C 004D               1746              MOVE.B  #'M',D3
000020BC  6100 16F4               1747              BSR     PUSH_STACK
000020C0  163C 0055               1748              MOVE.B  #'U',D3
000020C4  6100 16EC               1749              BSR     PUSH_STACK
000020C8  163C 004C               1750              MOVE.B  #'L',D3
000020CC  6100 16E4               1751              BSR     PUSH_STACK
000020D0  163C 0053               1752              MOVE.B  #'S',D3
000020D4  6100 16DC               1753              BSR     PUSH_STACK
000020D8  163C 002E               1754              MOVE.B  #'.',D3
000020DC  6100 16D4               1755              BSR     PUSH_STACK
000020E0                          1756              
000020E0  2205                    1757              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000020E2                          1758              
000020E2                          1759  OP1100_EA_DN_MULS           
000020E2                          1760              *BITS (7 TO 6) 
000020E2                          1761              *00 = .B
000020E2                          1762              *01 = .W
000020E2                          1763              *10 = .L 
000020E2  2205                    1764              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000020E4  EC99                    1765              ROR.L   #6,D1
000020E6  0281 00000003           1766              ANDI.L  #$03,D1
000020EC  0C81 00000003           1767              CMPI.L  #%11,D1 *EQUALS .W
000020F2  6700 0014               1768              BEQ     OP1100_PRINT_W_MULS
000020F6  0C81 00000000           1769              CMPI.L  #%00,D1 *EQUALS .L
000020FC  6700 0052               1770              BEQ     OP1100_PRINT_L_MULS
00002100                          1771              
00002100  183C 0001               1772              MOVE.B  #1,D4               *ERROR READ
00002104  6000 0092               1773              BRA     OP1100_MULS_RETURN
00002108                          1774  OP1100_PRINT_W_MULS
00002108  163C 0057               1775              MOVE.B  #'W',D3
0000210C  6100 16A4               1776              BSR     PUSH_STACK
00002110                          1777  
00002110                          1778              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002110  13FC 0000 000040D8      1779              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002118  13FC 0000 000040D9      1780              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002120                          1781             
00002120                          1782              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002120  13FC 00B9 000040DB      1783              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002128  13FC 0020 000040DC      1784              MOVE.B   #$20,GET_SRC_START_END
00002130                          1785  
00002130                          1786             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002130  0285 0000FE3F           1787              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002136  0685 00000000           1788              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000213C                          1789  
0000213C                          1790              
0000213C  6100 0DD6               1791              BSR     GET_EA_EA_SRC      *GETS <ea>
00002140  163C 002C               1792              MOVE.B  #',',D3
00002144  6100 166C               1793              BSR     PUSH_STACK
00002148  6100 11FA               1794              BSR     GET_EA_EA_DEST       *GETS Dn    
0000214C                          1795              
0000214C  6000 004A               1796              BRA     OP1100_MULS_RETURN
00002150                          1797  OP1100_PRINT_L_MULS 
00002150  163C 004C               1798              MOVE.B  #'L',D3
00002154  6100 165C               1799              BSR     PUSH_STACK
00002158                          1800              
00002158                          1801              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002158  13FC 0000 000040D8      1802              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002160  13FC 0000 000040D9      1803              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002168                          1804             
00002168                          1805              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002168  13FC 00B9 000040DB      1806              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002170  13FC 0020 000040DC      1807              MOVE.B   #$20,GET_SRC_START_END
00002178                          1808  
00002178                          1809              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002178  0285 0000FE3F           1810              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000217E  0685 00000000           1811              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002184                          1812  
00002184                          1813                     
00002184  6100 0D8E               1814              BSR     GET_EA_EA_SRC      *GETS <ea>
00002188  163C 002C               1815              MOVE.B  #',',D3
0000218C  6100 1624               1816              BSR     PUSH_STACK                  
00002190  6100 11B2               1817              BSR     GET_EA_EA_DEST       *GETS Dn    
00002194                          1818  
00002194                          1819              
00002194  6000 0002               1820              BRA     OP1100_MULS_RETURN
00002198                          1821              
00002198                          1822  OP1100_MULS_RETURN
00002198  4E75                    1823              RTS
0000219A                          1824              
0000219A                          1825  
0000219A                          1826  
0000219A                          1827  
0000219A                          1828  
0000219A                          1829  
0000219A                          1830  
0000219A                          1831  
0000219A                          1832  
0000219A                          1833  
0000219A                          1834  
0000219A                          1835  
0000219A                          1836  
0000219A                          1837  OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000219A                          1838              *LOAD STACK WITH THIS OPMODE
0000219A  4283                    1839              CLR.L   D3
0000219C  6100 1614               1840              BSR     PUSH_STACK
000021A0  163C 0041               1841              MOVE.B  #'A',D3
000021A4  6100 160C               1842              BSR     PUSH_STACK
000021A8  163C 004E               1843              MOVE.B  #'N',D3
000021AC  6100 1604               1844              BSR     PUSH_STACK
000021B0  163C 0044               1845              MOVE.B  #'D',D3
000021B4  6100 15FC               1846              BSR     PUSH_STACK
000021B8  163C 002E               1847              MOVE.B  #'.',D3
000021BC  6100 15F4               1848              BSR     PUSH_STACK
000021C0                          1849              
000021C0  2205                    1850              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021C2                          1851              
000021C2                          1852              *BITS (INDEX 8) 
000021C2                          1853              *0 = ADD.B/W/L <EA>,Dn
000021C2                          1854              *1 = ADD.B/W/L Dn,<EA> 
000021C2  E099                    1855              ROR.L   #8,D1
000021C4  0281 00000001           1856              ANDI.L  #$01,D1     *MASKS WITH 00000001
000021CA  0C81 00000000           1857              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000021D0  6700 0102               1858              BEQ     OP1100_EA_DN
000021D4                          1859              *else procede to Dn_EA
000021D4                          1860              
000021D4                          1861  OP1100_DN_EA
000021D4                          1862              *BITS (7 TO 6) 
000021D4                          1863              *00 = .B
000021D4                          1864              *01 = .W
000021D4                          1865              *10 = .L 
000021D4  2205                    1866              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000021D6  EC99                    1867              ROR.L   #6,D1
000021D8  0281 00000003           1868              ANDI.L  #$03,D1
000021DE  0C81 00000000           1869              CMPI.L  #$00,D1 *EQUALS .B
000021E4  6700 0016               1870              BEQ     OP1100_PRINT_B2
000021E8  0C81 00000001           1871              CMPI.L  #$01,D1 *EQUALS .W
000021EE  6700 0054               1872              BEQ     OP1100_PRINT_W2
000021F2  0C81 00000002           1873              CMPI.L  #$02,D1 *EQUALS .L
000021F8  6700 0092               1874              BEQ     OP1100_PRINT_L2
000021FC                          1875  OP1100_PRINT_B2
000021FC                          1876              *PUSH 'B'
000021FC  163C 0042               1877              MOVE.B  #'B',D3
00002200  6100 15B0               1878              BSR     PUSH_STACK
00002204                          1879             
00002204                          1880              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002204  13FC 0000 000040D8      1881             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000220C  13FC 0083 000040D9      1882             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002214                          1883             
00002214                          1884             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002214  13FC 00B9 000040DB      1885             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000221C  13FC 0020 000040DC      1886             MOVE.B   #$20,GET_SRC_START_END
00002224                          1887  
00002224                          1888              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002224  0285 0000FE3F           1889              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000222A  0685 00000000           1890              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002230                          1891       
00002230  6100 1112               1892              BSR     GET_EA_EA_DEST      *GETS Dn
00002234  163C 002C               1893              MOVE.B  #',',D3
00002238  6100 1578               1894              BSR     PUSH_STACK                     
0000223C  6100 0CD6               1895              BSR     GET_EA_EA_SRC       *GETS <ea>
00002240                          1896  
00002240                          1897              
00002240  6000 0192               1898              BRA     OP1100_AND_RETURN
00002244                          1899  OP1100_PRINT_W2
00002244  163C 0057               1900              MOVE.B  #'W',D3
00002248  6100 1568               1901              BSR     PUSH_STACK
0000224C                          1902  
0000224C                          1903              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000224C  13FC 0000 000040D8      1904              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002254  13FC 0083 000040D9      1905              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000225C                          1906             
0000225C                          1907              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000225C  13FC 00B9 000040DB      1908              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002264  13FC 0020 000040DC      1909              MOVE.B   #$20,GET_SRC_START_END
0000226C                          1910  
0000226C                          1911              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000226C  0285 0000FE3F           1912              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002272  0685 00000000           1913              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002278                          1914  
00002278                          1915        
00002278  6100 10CA               1916              BSR     GET_EA_EA_DEST      *GETS Dn
0000227C  163C 002C               1917              MOVE.B  #',',D3
00002280  6100 1530               1918              BSR     PUSH_STACK               
00002284  6100 0C8E               1919              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002288                          1920  
00002288                          1921  
00002288                          1922  
00002288  6000 049A               1923              BRA     OP1101_ADD_RETURN
0000228C                          1924  OP1100_PRINT_L2 
0000228C  163C 004C               1925              MOVE.B  #'L',D3
00002290  6100 1520               1926              BSR     PUSH_STACK
00002294                          1927              
00002294                          1928              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002294  13FC 0000 000040D8      1929              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000229C  13FC 0083 000040D9      1930              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022A4                          1931             
000022A4                          1932              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022A4  13FC 00B9 000040DB      1933              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022AC  13FC 0020 000040DC      1934              MOVE.B   #$20,GET_SRC_START_END
000022B4                          1935  
000022B4                          1936             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022B4  0285 0000FE3F           1937              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022BA  0685 00000000           1938              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022C0                          1939  
000022C0                          1940               
000022C0  6100 1082               1941              BSR     GET_EA_EA_DEST       *GETS Dn
000022C4  163C 002C               1942              MOVE.B  #',',D3
000022C8  6100 14E8               1943              BSR     PUSH_STACK          
000022CC  6100 0C46               1944              BSR     GET_EA_EA_SRC        *GETS <ea>
000022D0                          1945  
000022D0  6000 0102               1946              BRA     OP1100_AND_RETURN
000022D4                          1947              
000022D4                          1948  OP1100_EA_DN           
000022D4                          1949              *BITS (7 TO 6) 
000022D4                          1950              *00 = .B
000022D4                          1951              *01 = .W
000022D4                          1952              *10 = .L 
000022D4  2205                    1953              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000022D6  EC99                    1954              ROR.L   #6,D1
000022D8  0281 00000003           1955              ANDI.L  #$03,D1
000022DE  0C81 00000000           1956              CMPI.L  #$00,D1 *EQUALS .B
000022E4  6700 0016               1957              BEQ     OP1100_PRINT_B
000022E8  0C81 00000001           1958              CMPI.L  #$01,D1 *EQUALS .W
000022EE  6700 0054               1959              BEQ     OP1100_PRINT_W
000022F2  0C81 00000002           1960              CMPI.L  #$02,D1 *EQUALS .L
000022F8  6700 0092               1961              BEQ     OP1100_PRINT_L
000022FC                          1962  OP1100_PRINT_B
000022FC  163C 0042               1963              MOVE.B  #'B',D3
00002300  6100 14B0               1964              BSR     PUSH_STACK
00002304                          1965                
00002304                          1966              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002304  13FC 0000 000040D8      1967              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000230C  13FC 0002 000040D9      1968              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002314                          1969             
00002314                          1970              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002314  13FC 00B9 000040DB      1971              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000231C  13FC 0020 000040DC      1972              MOVE.B   #$20,GET_SRC_START_END
00002324                          1973  
00002324                          1974             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002324  0285 0000FE3F           1975              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000232A  0685 00000000           1976              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002330                          1977  
00002330                          1978              
00002330  6100 0BE2               1979              BSR     GET_EA_EA_SRC      *GETS <ea>
00002334  163C 002C               1980              MOVE.B  #',',D3
00002338  6100 1478               1981              BSR     PUSH_STACK          
0000233C  6100 1006               1982              BSR     GET_EA_EA_DEST       *GETS Dn
00002340                          1983              
00002340  6000 03E2               1984              BRA     OP1101_ADD_RETURN
00002344                          1985  OP1100_PRINT_W
00002344  163C 0057               1986              MOVE.B  #'W',D3
00002348  6100 1468               1987              BSR     PUSH_STACK
0000234C                          1988  
0000234C                          1989              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000234C  13FC 0000 000040D8      1990              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002354  13FC 0002 000040D9      1991              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000235C                          1992             
0000235C                          1993              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000235C  13FC 00B9 000040DB      1994              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002364  13FC 0020 000040DC      1995              MOVE.B   #$20,GET_SRC_START_END
0000236C                          1996  
0000236C                          1997             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000236C  0285 0000FE3F           1998              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002372  0685 00000000           1999              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002378                          2000  
00002378                          2001              
00002378  6100 0B9A               2002              BSR     GET_EA_EA_SRC      *GETS <ea>
0000237C  163C 002C               2003              MOVE.B  #',',D3
00002380  6100 1430               2004              BSR     PUSH_STACK
00002384  6100 0FBE               2005              BSR     GET_EA_EA_DEST       *GETS Dn    
00002388                          2006              
00002388  6000 FB8C               2007              BRA     OP1001_ADD_RETURN
0000238C                          2008  OP1100_PRINT_L 
0000238C  163C 004C               2009              MOVE.B  #'L',D3
00002390  6100 1420               2010              BSR     PUSH_STACK
00002394                          2011              
00002394                          2012              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002394  13FC 0000 000040D8      2013              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000239C  13FC 0002 000040D9      2014              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023A4                          2015             
000023A4                          2016              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023A4  13FC 00B9 000040DB      2017              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023AC  13FC 0020 000040DC      2018              MOVE.B   #$20,GET_SRC_START_END
000023B4                          2019  
000023B4                          2020              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023B4  0285 0000FE3F           2021              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023BA  0685 00000000           2022              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023C0                          2023  
000023C0                          2024                     
000023C0  6100 0B52               2025              BSR     GET_EA_EA_SRC      *GETS <ea>
000023C4  163C 002C               2026              MOVE.B  #',',D3
000023C8  6100 13E8               2027              BSR     PUSH_STACK                  
000023CC  6100 0F76               2028              BSR     GET_EA_EA_DEST       *GETS Dn    
000023D0                          2029  
000023D0                          2030              
000023D0  6000 0002               2031              BRA     OP1100_AND_RETURN
000023D4                          2032              
000023D4                          2033  OP1100_AND_RETURN
000023D4  4E75                    2034              RTS
000023D6                          2035  
000023D6                          2036  
000023D6                          2037  *---------------------------------------------------------------------------*
000023D6                          2038  * OP1101: Decode ADD/ADDA
000023D6                          2039  *---------------------------------------------------------------------------* 
000023D6  4280                    2040  OP1101      CLR.L   D0                  
000023D8  4281                    2041              CLR.L   D1       
000023DA  4284                    2042              CLR.L   D4                   
000023DC  227C 00000000           2043              MOVEA.L #0, A1              
000023E2  2205                    2044              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000023E4                          2045              
000023E4                          2046              *CLEAR D3
000023E4  4283                    2047              CLR.L   D3
000023E6                          2048              
000023E6                          2049              
000023E6                          2050              
000023E6                          2051              **INTEGRATING ADDA.W/.L INTO THIS CODE**
000023E6  2205                    2052              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000023E8                          2053              *BITS (INDEX 8) 
000023E8                          2054              *0 = ADD.B/W/L <EA>,Dn
000023E8                          2055              *1 = ADD.B/W/L Dn,<EA> 
000023E8  EC99                    2056              ROR.L   #6,D1
000023EA  0281 00000007           2057              ANDI.L  #$07,D1                 *MASKS WITH 00000111
000023F0  0C81 00000007           2058              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
000023F6  6700 0010               2059              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
000023FA  0C81 00000003           2060              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002400  6700 0078               2061              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002404  6000 00E6               2062              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002408                          2063              
00002408                          2064  OP1101_ADDA_L
00002408                          2065              *LOAD STACK WITH THIS OPMODE
00002408  6100 13A8               2066              BSR     PUSH_STACK
0000240C  163C 0041               2067              MOVE.B  #'A',D3
00002410  6100 13A0               2068              BSR     PUSH_STACK
00002414  163C 0044               2069              MOVE.B  #'D',D3
00002418  6100 1398               2070              BSR     PUSH_STACK
0000241C  163C 0044               2071              MOVE.B  #'D',D3
00002420  6100 1390               2072              BSR     PUSH_STACK
00002424  163C 0041               2073              MOVE.B  #'A',D3
00002428  6100 1388               2074              BSR     PUSH_STACK
0000242C  163C 002E               2075              MOVE.B  #'.',D3
00002430  6100 1380               2076              BSR     PUSH_STACK
00002434  163C 004C               2077              MOVE.B  #'L',D3
00002438  6100 1378               2078              BSR     PUSH_STACK
0000243C                          2079              
0000243C                          2080             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000243C  13FC 0000 000040D8      2081             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002444  13FC 0000 000040D9      2082             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000244C                          2083             
0000244C                          2084             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000244C  13FC 00B9 000040DB      2085             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002454  13FC 0020 000040DC      2086             MOVE.B   #$20,GET_SRC_START_END
0000245C                          2087  
0000245C                          2088              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000245C  0285 0000FE3F           2089              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002462  0685 00000040           2090              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002468                          2091       
00002468                          2092              *PRINT <EA>,AN
00002468  6100 0AAA               2093              BSR     GET_EA_EA_SRC       *GETS <ea>
0000246C  163C 002C               2094              MOVE.B  #',',D3
00002470  6100 1340               2095              BSR     PUSH_STACK                     
00002474  6100 0ECE               2096              BSR     GET_EA_EA_DEST      *GETS Dn
00002478                          2097  
00002478                          2098              
00002478                          2099              
00002478  4E75                    2100              RTS
0000247A                          2101  OP1101_ADDA_W
0000247A                          2102              *LOAD STACK WITH THIS OPMODE
0000247A  6100 1336               2103              BSR     PUSH_STACK
0000247E  163C 0041               2104              MOVE.B  #'A',D3
00002482  6100 132E               2105              BSR     PUSH_STACK
00002486  163C 0044               2106              MOVE.B  #'D',D3
0000248A  6100 1326               2107              BSR     PUSH_STACK
0000248E  163C 0044               2108              MOVE.B  #'D',D3
00002492  6100 131E               2109              BSR     PUSH_STACK
00002496  163C 0041               2110              MOVE.B  #'A',D3
0000249A  6100 1316               2111              BSR     PUSH_STACK
0000249E  163C 002E               2112              MOVE.B  #'.',D3
000024A2  6100 130E               2113              BSR     PUSH_STACK
000024A6  163C 0057               2114              MOVE.B  #'W',D3
000024AA  6100 1306               2115              BSR     PUSH_STACK
000024AE                          2116              
000024AE                          2117             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024AE  13FC 0000 000040D8      2118             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024B6  13FC 0000 000040D9      2119             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024BE                          2120             
000024BE                          2121             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024BE  13FC 00B9 000040DB      2122             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024C6  13FC 0020 000040DC      2123             MOVE.B   #$20,GET_SRC_START_END
000024CE                          2124  
000024CE                          2125              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024CE  0285 0000FE3F           2126              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024D4  0685 00000040           2127              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024DA                          2128       
000024DA                          2129              *PRINT <EA>,AN
000024DA  6100 0A38               2130              BSR     GET_EA_EA_SRC       *GETS <ea>
000024DE  163C 002C               2131              MOVE.B  #',',D3
000024E2  6100 12CE               2132              BSR     PUSH_STACK                     
000024E6  6100 0E5C               2133              BSR     GET_EA_EA_DEST      *GETS Dn
000024EA                          2134  
000024EA  4E75                    2135              RTS
000024EC                          2136  
000024EC                          2137  OP1101_DETERMINE_DN_EA_OR_EA_DN 
000024EC                          2138              *LOAD STACK WITH THIS OPMODE
000024EC  6100 12C4               2139              BSR     PUSH_STACK
000024F0  163C 0041               2140              MOVE.B  #'A',D3
000024F4  6100 12BC               2141              BSR     PUSH_STACK
000024F8  163C 0044               2142              MOVE.B  #'D',D3
000024FC  6100 12B4               2143              BSR     PUSH_STACK
00002500  163C 0044               2144              MOVE.B  #'D',D3
00002504  6100 12AC               2145              BSR     PUSH_STACK
00002508  163C 002E               2146              MOVE.B  #'.',D3
0000250C  6100 12A4               2147              BSR     PUSH_STACK
00002510                          2148              
00002510  2205                    2149              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002512                          2150              
00002512                          2151              *BITS (INDEX 8) 
00002512                          2152              *0 = ADD.B/W/L <EA>,Dn
00002512                          2153              *1 = ADD.B/W/L Dn,<EA> 
00002512  E099                    2154              ROR.L   #8,D1
00002514  0281 00000001           2155              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000251A  0C81 00000000           2156              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002520  6700 0102               2157              BEQ     OP1101_EA_DN
00002524                          2158              *else procede to Dn_EA
00002524                          2159              
00002524                          2160  OP1101_DN_EA
00002524                          2161              *BITS (7 TO 6) 
00002524                          2162              *00 = .B
00002524                          2163              *01 = .W
00002524                          2164              *10 = .L 
00002524  2205                    2165              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002526  EC99                    2166              ROR.L   #6,D1
00002528  0281 00000003           2167              ANDI.L  #$03,D1
0000252E  0C81 00000000           2168              CMPI.L  #$00,D1 *EQUALS .B
00002534  6700 0016               2169              BEQ     OP1101_PRINT_B2
00002538  0C81 00000001           2170              CMPI.L  #$01,D1 *EQUALS .W
0000253E  6700 0054               2171              BEQ     OP1101_PRINT_W2
00002542  0C81 00000002           2172              CMPI.L  #$02,D1 *EQUALS .L
00002548  6700 0092               2173              BEQ     OP1101_PRINT_L2
0000254C                          2174  OP1101_PRINT_B2
0000254C                          2175              *PUSH 'B'
0000254C  163C 0042               2176              MOVE.B  #'B',D3
00002550  6100 1260               2177              BSR     PUSH_STACK
00002554                          2178             
00002554                          2179              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002554  13FC 0002 000040D8      2180             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000255C  13FC 0083 000040D9      2181             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002564                          2182             
00002564                          2183             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002564  13FC 00B9 000040DB      2184             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000256C  13FC 0020 000040DC      2185             MOVE.B   #$20,GET_SRC_START_END
00002574                          2186  
00002574                          2187              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002574  0285 0000FE3F           2188              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000257A  0685 00000000           2189              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002580                          2190       
00002580  6100 0DC2               2191              BSR     GET_EA_EA_DEST      *GETS Dn
00002584  163C 002C               2192              MOVE.B  #',',D3
00002588  6100 1228               2193              BSR     PUSH_STACK                     
0000258C  6100 0986               2194              BSR     GET_EA_EA_SRC       *GETS <ea>
00002590                          2195  
00002590                          2196              
00002590  6000 0192               2197              BRA     OP1101_ADD_RETURN
00002594                          2198  OP1101_PRINT_W2
00002594  163C 0057               2199              MOVE.B  #'W',D3
00002598  6100 1218               2200              BSR     PUSH_STACK
0000259C                          2201  
0000259C                          2202              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000259C  13FC 0000 000040D8      2203              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025A4  13FC 0083 000040D9      2204              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025AC                          2205             
000025AC                          2206              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025AC  13FC 00B9 000040DB      2207              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025B4  13FC 0020 000040DC      2208              MOVE.B   #$20,GET_SRC_START_END
000025BC                          2209  
000025BC                          2210              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025BC  0285 0000FE3F           2211              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000025C2  0685 00000000           2212              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000025C8                          2213  
000025C8                          2214        
000025C8  6100 0D7A               2215              BSR     GET_EA_EA_DEST      *GETS Dn
000025CC  163C 002C               2216              MOVE.B  #',',D3
000025D0  6100 11E0               2217              BSR     PUSH_STACK               
000025D4  6100 093E               2218              BSR     GET_EA_EA_SRC       *GETS <ea>       
000025D8                          2219  
000025D8                          2220  
000025D8                          2221  
000025D8  6000 014A               2222              BRA     OP1101_ADD_RETURN
000025DC                          2223  OP1101_PRINT_L2 
000025DC  163C 004C               2224              MOVE.B  #'L',D3
000025E0  6100 11D0               2225              BSR     PUSH_STACK
000025E4                          2226              
000025E4                          2227              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025E4  13FC 0000 000040D8      2228              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025EC  13FC 0083 000040D9      2229              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025F4                          2230             
000025F4                          2231              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025F4  13FC 00B9 000040DB      2232              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025FC  13FC 0020 000040DC      2233              MOVE.B   #$20,GET_SRC_START_END
00002604                          2234  
00002604                          2235             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002604  0285 0000FE3F           2236              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000260A  0685 00000000           2237              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002610                          2238  
00002610                          2239               
00002610  6100 0D32               2240              BSR     GET_EA_EA_DEST       *GETS Dn
00002614  163C 002C               2241              MOVE.B  #',',D3
00002618  6100 1198               2242              BSR     PUSH_STACK          
0000261C  6100 08F6               2243              BSR     GET_EA_EA_SRC        *GETS <ea>
00002620                          2244  
00002620  6000 0102               2245              BRA     OP1101_ADD_RETURN
00002624                          2246              
00002624                          2247  OP1101_EA_DN           
00002624                          2248              *BITS (7 TO 6) 
00002624                          2249              *00 = .B
00002624                          2250              *01 = .W
00002624                          2251              *10 = .L 
00002624  2205                    2252              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002626  EC99                    2253              ROR.L   #6,D1
00002628  0281 00000003           2254              ANDI.L  #$03,D1
0000262E  0C81 00000000           2255              CMPI.L  #$00,D1 *EQUALS .B
00002634  6700 0016               2256              BEQ     OP1101_PRINT_B
00002638  0C81 00000001           2257              CMPI.L  #$01,D1 *EQUALS .W
0000263E  6700 0054               2258              BEQ     OP1101_PRINT_W
00002642  0C81 00000002           2259              CMPI.L  #$02,D1 *EQUALS .L
00002648  6700 0092               2260              BEQ     OP1101_PRINT_L
0000264C                          2261  OP1101_PRINT_B
0000264C  163C 0042               2262              MOVE.B  #'B',D3
00002650  6100 1160               2263              BSR     PUSH_STACK
00002654                          2264                
00002654                          2265              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002654  13FC 0002 000040D8      2266              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000265C  13FC 0002 000040D9      2267              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002664                          2268             
00002664                          2269              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002664  13FC 00B9 000040DB      2270              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000266C  13FC 0020 000040DC      2271              MOVE.B   #$20,GET_SRC_START_END
00002674                          2272  
00002674                          2273             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002674  0285 0000FE3F           2274              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000267A  0685 00000000           2275              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002680                          2276  
00002680                          2277              
00002680  6100 0892               2278              BSR     GET_EA_EA_SRC      *GETS <ea>
00002684  163C 002C               2279              MOVE.B  #',',D3
00002688  6100 1128               2280              BSR     PUSH_STACK          
0000268C  6100 0CB6               2281              BSR     GET_EA_EA_DEST       *GETS Dn
00002690                          2282              
00002690  6000 0092               2283              BRA     OP1101_ADD_RETURN
00002694                          2284  OP1101_PRINT_W
00002694  163C 0057               2285              MOVE.B  #'W',D3
00002698  6100 1118               2286              BSR     PUSH_STACK
0000269C                          2287  
0000269C                          2288              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000269C  13FC 0000 000040D8      2289              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000026A4  13FC 0000 000040D9      2290              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000026AC                          2291             
000026AC                          2292              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026AC  13FC 00B9 000040DB      2293              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000026B4  13FC 0020 000040DC      2294              MOVE.B   #$20,GET_SRC_START_END
000026BC                          2295  
000026BC                          2296             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026BC  0285 0000FE3F           2297              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026C2  0685 00000000           2298              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026C8                          2299  
000026C8                          2300              
000026C8  6100 084A               2301              BSR     GET_EA_EA_SRC      *GETS <ea>
000026CC  163C 002C               2302              MOVE.B  #',',D3
000026D0  6100 10E0               2303              BSR     PUSH_STACK
000026D4  6100 0C6E               2304              BSR     GET_EA_EA_DEST       *GETS Dn    
000026D8                          2305              
000026D8  6000 004A               2306              BRA     OP1101_ADD_RETURN
000026DC                          2307  OP1101_PRINT_L 
000026DC  163C 004C               2308              MOVE.B  #'L',D3
000026E0  6100 10D0               2309              BSR     PUSH_STACK
000026E4                          2310              
000026E4                          2311              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026E4  13FC 0000 000040D8      2312              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000026EC  13FC 0000 000040D9      2313              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000026F4                          2314             
000026F4                          2315              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026F4  13FC 00B9 000040DB      2316              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000026FC  13FC 0020 000040DC      2317              MOVE.B   #$20,GET_SRC_START_END
00002704                          2318  
00002704                          2319              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002704  0285 0000FE3F           2320              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000270A  0685 00000000           2321              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002710                          2322  
00002710                          2323                     
00002710  6100 0802               2324              BSR     GET_EA_EA_SRC      *GETS <ea>
00002714  163C 002C               2325              MOVE.B  #',',D3
00002718  6100 1098               2326              BSR     PUSH_STACK                  
0000271C  6100 0C26               2327              BSR     GET_EA_EA_DEST       *GETS Dn    
00002720                          2328  
00002720                          2329              
00002720  6000 0002               2330              BRA     OP1101_ADD_RETURN
00002724                          2331              
00002724                          2332  OP1101_ADD_RETURN
00002724  4E75                    2333              RTS
00002726                          2334              
00002726                          2335              *ADDW
00002726  0C01 0006               2336              CMPI.B  #$6,D1
0000272A  6700 0056               2337              BEQ     OP_ADDA_W
0000272E  0C01 000E               2338              CMPI.B  #$E,D1
00002732  6700 0066               2339              BEQ     OP_ADDA_L 
00002736                          2340  
00002736  4EF8 14B8               2341              JMP     OP_DATA  
0000273A                          2342            
0000273A                          2343  *---------------------------------------------------------------------------*
0000273A                          2344  * OP_ADD: display ADD and proceed to EA
0000273A                          2345  *---------------------------------------------------------------------------*  
0000273A  43F9 00003F8F           2346  OP_ADD_B    LEA     DISP_ADD_B,A1
00002740  103C 000E               2347              MOVE.B  #14,D0
00002744  4E4F                    2348              TRAP    #15
00002746  183C 0000               2349              MOVE.B  #0,D4
0000274A  4EF9 00002AC4           2350              JMP     EA_GEN
00002750                          2351  
00002750  4E75                    2352              RTS
00002752                          2353  
00002752  43F9 00003F98           2354  OP_ADD_W    LEA     DISP_ADD_W,A1
00002758  103C 000E               2355              MOVE.B  #14,D0
0000275C  4E4F                    2356              TRAP    #15
0000275E  183C 0001               2357              MOVE.B  #1,D4
00002762  4EF9 00002AC4           2358              JMP     EA_GEN
00002768                          2359  
00002768  4E75                    2360              RTS
0000276A                          2361  
0000276A  43F9 00003FA1           2362  OP_ADD_L    LEA     DISP_ADD_L,A1
00002770  103C 000E               2363              MOVE.B  #14,D0
00002774  4E4F                    2364              TRAP    #15
00002776  183C 0002               2365              MOVE.B  #2,D4
0000277A  4EF9 00002AC4           2366              JMP     EA_GEN
00002780                          2367  
00002780  4E75                    2368              RTS
00002782                          2369  
00002782                          2370  *---------------------------------------------------------------------------*
00002782                          2371  * OP_ADDA: display ADDA and proceed to EA
00002782                          2372  *---------------------------------------------------------------------------*  
00002782  43F9 00003FAA           2373  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002788  103C 000E               2374              MOVE.B  #14,D0
0000278C  4E4F                    2375              TRAP    #15
0000278E  183C 0001               2376              MOVE.B  #1,D4
00002792  4EF9 00002AC4           2377              JMP     EA_GEN
00002798                          2378  
00002798  4E75                    2379              RTS
0000279A                          2380  
0000279A  43F9 00003FB4           2381  OP_ADDA_L   LEA     DISP_ADDA_L,A1
000027A0  103C 000E               2382              MOVE.B  #14,D0
000027A4  4E4F                    2383              TRAP    #15
000027A6  183C 0002               2384              MOVE.B  #2,D4
000027AA  4EF9 00002AC4           2385              JMP     EA_GEN
000027B0                          2386  
000027B0  4E75                    2387              RTS
000027B2                          2388              
000027B2                          2389  *---------------------------------------------------------------------------*
000027B2                          2390  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
000027B2                          2391  *---------------------------------------------------------------------------* 
000027B2  4280                    2392  OP1110      CLR.L   D0                  
000027B4  4281                    2393              CLR.L   D1   
000027B6  4284                    2394              CLR.L   D4                   
000027B8  227C 00000000           2395              MOVEA.L #0, A1                 
000027BE  2205                    2396              MOVE.L  D5,D1
000027C0                          2397              
000027C0                          2398              * check for LSX
000027C0  E699                    2399              ROR.L   #3,D1
000027C2  0281 00000001           2400              ANDI.L  #$1,D1
000027C8  0C01 0001               2401              CMPI.B  #1,D1
000027CC  6700 002E               2402              BEQ     OP_LSX
000027D0                          2403              
000027D0                          2404              * reset D1 and check for ASX
000027D0  4281                    2405              CLR.L   D1
000027D2  2205                    2406              MOVE.L  D5,D1
000027D4  E699                    2407              ROR.L   #3,D1
000027D6  0281 00000001           2408              ANDI.L  #$1,D1
000027DC  0C01 0000               2409              CMPI.B  #0,D1
000027E0  6700 0032               2410              BEQ     OP_ASX
000027E4                          2411  
000027E4                          2412              * reset D1 and check for ROX
000027E4  4281                    2413              CLR.L   D1
000027E6  2205                    2414              MOVE.L  D5,D1
000027E8  E699                    2415              ROR.L   #3,D1
000027EA  0281 00000001           2416              ANDI.L  #$1,D1
000027F0  0C01 0003               2417              CMPI.B  #3,D1
000027F4  6700 0036               2418              BEQ     OP_ROX
000027F8                          2419              
000027F8  4EF8 14B8               2420              JMP     OP_DATA
000027FC                          2421  
000027FC                          2422  *---------------------------------------------------------------------------*
000027FC                          2423  * OP_LSX: process LSR/LSL
000027FC                          2424  *---------------------------------------------------------------------------*            
000027FC  EA99                    2425  OP_LSX      ROR.L   #5,D1
000027FE  0281 00000001           2426              ANDI.L  #$1,D1
00002804  0C01 0000               2427              CMPI.B  #0,D1
00002808  6700 003A               2428              BEQ     OP_LSR
0000280C  0C01 0001               2429              CMPI.B  #1,D1
00002810  6700 008C               2430              BEQ     OP_LSL
00002814                          2431              
00002814                          2432  *---------------------------------------------------------------------------*
00002814                          2433  * OP_ASX: process ASR/ASL
00002814                          2434  *---------------------------------------------------------------------------*  
00002814  EA99                    2435  OP_ASX      ROR.L   #5,D1
00002816  0281 00000001           2436              ANDI.L  #$1,D1
0000281C  0C01 0000               2437              CMPI.B  #0,D1
00002820  6700 00D6               2438              BEQ     OP_ASR
00002824  0C01 0001               2439              CMPI.B  #1,D1
00002828  6700 0128               2440              BEQ     OP_ASL
0000282C                          2441              
0000282C                          2442  *---------------------------------------------------------------------------*
0000282C                          2443  * OP_ROX: process ROR/ROL
0000282C                          2444  *---------------------------------------------------------------------------*  
0000282C  EA99                    2445  OP_ROX      ROR.L   #5,D1
0000282E  0281 00000001           2446              ANDI.L  #$1,D1
00002834  0C01 0000               2447              CMPI.B  #0,D1
00002838  6700 0172               2448              BEQ     OP_ROR
0000283C  0C01 0001               2449              CMPI.B  #1,D1
00002840  6700 01C4               2450              BEQ     OP_ROL
00002844                          2451  
00002844                          2452  *---------------------------------------------------------------------------*
00002844                          2453  * OP_LSR: decode and display LSR
00002844                          2454  *---------------------------------------------------------------------------*        
00002844  E599                    2455  OP_LSR      ROL.L   #2,D1
00002846  0281 00000003           2456              ANDI.L  #$3,D1
0000284C  0C01 0000               2457              CMPI.B  #0,D1
00002850  6700 0016               2458              BEQ     OP_LSR_B
00002854  0C01 0001               2459              CMPI.B  #$1,D1
00002858  6700 0032               2460              BEQ     OP_LSR_W
0000285C  0C01 0002               2461              CMPI.B  #$2,D1
00002860  6700 0018               2462              BEQ     OP_LSR_L
00002864                          2463              
00002864  4EF8 14B8               2464              JMP     OP_DATA
00002868                          2465  
00002868  43F9 00003FBE           2466  OP_LSR_B    LEA     DISP_LSR_B,A1
0000286E  103C 000E               2467              MOVE.B  #14,D0
00002872  4E4F                    2468              TRAP    #15
00002874  183C 0000               2469              MOVE.B  #0,D4
00002878  4E75                    2470              RTS
0000287A                          2471  
0000287A  43F9 00003FE2           2472  OP_LSR_L    LEA     DISP_LSR_L,A1
00002880  103C 000E               2473              MOVE.B  #14,D0
00002884  4E4F                    2474              TRAP    #15
00002886  183C 0002               2475              MOVE.B  #2,D4
0000288A  4E75                    2476              RTS
0000288C                          2477  
0000288C  43F9 00003FD0           2478  OP_LSR_W    LEA     DISP_LSR_W,A1
00002892  103C 000E               2479              MOVE.B  #14,D0
00002896  4E4F                    2480              TRAP    #15
00002898  183C 0001               2481              MOVE.B  #1,D4
0000289C  4E75                    2482              RTS
0000289E                          2483   
0000289E                          2484  *---------------------------------------------------------------------------*
0000289E                          2485  * OP_LSL: decode and display LSL
0000289E                          2486  *---------------------------------------------------------------------------*             
0000289E  E599                    2487  OP_LSL      ROL.L   #2,D1
000028A0  0281 00000003           2488              ANDI.L  #$3,D1
000028A6  0C01 0000               2489              CMPI.B  #0,D1
000028AA  6700 0016               2490              BEQ     OP_LSL_B
000028AE  0C01 0001               2491              CMPI.B  #$1,D1
000028B2  6700 0032               2492              BEQ     OP_LSL_W
000028B6  0C01 0002               2493              CMPI.B  #$2,D1
000028BA  6700 0018               2494              BEQ     OP_LSL_L
000028BE                          2495              
000028BE  4EF8 14B8               2496              JMP OP_DATA
000028C2                          2497  
000028C2  43F9 00003FC7           2498  OP_LSL_B    LEA     DISP_LSL_B,A1
000028C8  103C 000E               2499              MOVE.B  #14,D0
000028CC  4E4F                    2500              TRAP    #15
000028CE  183C 0000               2501              MOVE.B  #0,D4
000028D2  4E75                    2502              RTS
000028D4                          2503  
000028D4  43F9 00003FEB           2504  OP_LSL_L    LEA     DISP_LSL_L,A1
000028DA  103C 000E               2505              MOVE.B  #14,D0
000028DE  4E4F                    2506              TRAP    #15
000028E0  183C 0002               2507              MOVE.B  #2,D4
000028E4  4E75                    2508              RTS
000028E6                          2509  
000028E6  43F9 00003FD9           2510  OP_LSL_W    LEA     DISP_LSL_W,A1
000028EC  103C 000E               2511              MOVE.B  #14,D0
000028F0  4E4F                    2512              TRAP    #15
000028F2  183C 0001               2513              MOVE.B  #1,D4
000028F6  4E75                    2514              RTS
000028F8                          2515   
000028F8                          2516  *---------------------------------------------------------------------------*
000028F8                          2517  * OP_ASR: decode and display ASR
000028F8                          2518  *---------------------------------------------------------------------------*             
000028F8  E599                    2519  OP_ASR      ROL.L   #2,D1
000028FA  0281 00000003           2520              ANDI.L  #$3,D1
00002900  0C01 0000               2521              CMPI.B  #0,D1
00002904  6700 0016               2522              BEQ     OP_ASR_B
00002908  0C01 0001               2523              CMPI.B  #$1,D1
0000290C  6700 0032               2524              BEQ     OP_ASR_W
00002910  0C01 0002               2525              CMPI.B  #$2,D1
00002914  6700 0018               2526              BEQ     OP_ASR_L
00002918                          2527              
00002918  4EF8 14B8               2528              JMP OP_DATA
0000291C                          2529  
0000291C  43F9 00003FF4           2530  OP_ASR_B    LEA     DISP_ASR_B,A1
00002922  103C 000E               2531              MOVE.B  #14,D0
00002926  4E4F                    2532              TRAP    #15
00002928  183C 0000               2533              MOVE.B  #0,D4
0000292C  4E75                    2534              RTS
0000292E                          2535  
0000292E  43F9 00004018           2536  OP_ASR_L    LEA     DISP_ASR_L,A1
00002934  103C 000E               2537              MOVE.B  #14,D0
00002938  4E4F                    2538              TRAP    #15
0000293A  183C 0002               2539              MOVE.B  #2,D4
0000293E  4E75                    2540              RTS
00002940                          2541  
00002940  43F9 00004006           2542  OP_ASR_W    LEA     DISP_ASR_W,A1
00002946  103C 000E               2543              MOVE.B  #14,D0
0000294A  4E4F                    2544              TRAP    #15
0000294C  183C 0001               2545              MOVE.B  #1,D4
00002950  4E75                    2546              RTS
00002952                          2547       
00002952                          2548  *---------------------------------------------------------------------------*
00002952                          2549  * OP_ASL: decode and display ASL
00002952                          2550  *---------------------------------------------------------------------------*         
00002952  E599                    2551  OP_ASL      ROL.L   #2,D1
00002954  0281 00000003           2552              ANDI.L  #$3,D1
0000295A  0C01 0000               2553              CMPI.B  #0,D1
0000295E  6700 0016               2554              BEQ     OP_ASL_B
00002962  0C01 0001               2555              CMPI.B  #$1,D1
00002966  6700 0032               2556              BEQ     OP_ASL_W
0000296A  0C01 0002               2557              CMPI.B  #$2,D1
0000296E  6700 0018               2558              BEQ     OP_ASL_L
00002972                          2559              
00002972  4EF8 14B8               2560              JMP OP_DATA
00002976                          2561  
00002976  43F9 00003FFD           2562  OP_ASL_B    LEA     DISP_ASL_B,A1
0000297C  103C 000E               2563              MOVE.B  #14,D0
00002980  4E4F                    2564              TRAP    #15
00002982  183C 0000               2565              MOVE.B  #0,D4
00002986  4E75                    2566              RTS
00002988                          2567  
00002988  43F9 00004021           2568  OP_ASL_L    LEA     DISP_ASL_L,A1
0000298E  103C 000E               2569              MOVE.B  #14,D0
00002992  4E4F                    2570              TRAP    #15
00002994  183C 0002               2571              MOVE.B  #2,D4
00002998  4E75                    2572              RTS
0000299A                          2573  
0000299A  43F9 0000400F           2574  OP_ASL_W    LEA     DISP_ASL_W,A1
000029A0  103C 000E               2575              MOVE.B  #14,D0
000029A4  4E4F                    2576              TRAP    #15
000029A6  183C 0001               2577              MOVE.B  #1,D4
000029AA  4E75                    2578              RTS
000029AC                          2579   
000029AC                          2580  *---------------------------------------------------------------------------*
000029AC                          2581  * OP_ROR: decode and display ROR
000029AC                          2582  *---------------------------------------------------------------------------*             
000029AC  E599                    2583  OP_ROR      ROL.L   #2,D1
000029AE  0281 00000003           2584              ANDI.L  #$3,D1
000029B4  0C01 0000               2585              CMPI.B  #0,D1
000029B8  6700 0016               2586              BEQ     OP_ROR_B
000029BC  0C01 0001               2587              CMPI.B  #$1,D1
000029C0  6700 0032               2588              BEQ     OP_ROR_W
000029C4  0C01 0002               2589              CMPI.B  #$2,D1
000029C8  6700 0018               2590              BEQ     OP_ROR_L
000029CC                          2591              
000029CC  4EF8 14B8               2592              JMP OP_DATA
000029D0                          2593  
000029D0  43F9 0000402A           2594  OP_ROR_B    LEA     DISP_ROR_B,A1
000029D6  103C 000E               2595              MOVE.B  #14,D0
000029DA  4E4F                    2596              TRAP    #15
000029DC  183C 0000               2597              MOVE.B  #0,D4
000029E0  4E75                    2598              RTS
000029E2                          2599  
000029E2  43F9 0000404E           2600  OP_ROR_L    LEA     DISP_ROR_L,A1
000029E8  103C 000E               2601              MOVE.B  #14,D0
000029EC  4E4F                    2602              TRAP    #15
000029EE  183C 0002               2603              MOVE.B  #2,D4
000029F2  4E75                    2604              RTS
000029F4                          2605  
000029F4  43F9 0000403C           2606  OP_ROR_W    LEA     DISP_ROR_W,A1
000029FA  103C 000E               2607              MOVE.B  #14,D0
000029FE  4E4F                    2608              TRAP    #15
00002A00  183C 0001               2609              MOVE.B  #1,D4
00002A04  4E75                    2610              RTS
00002A06                          2611  
00002A06                          2612  *---------------------------------------------------------------------------*
00002A06                          2613  * OP_ROL: decode and display ROL
00002A06                          2614  *---------------------------------------------------------------------------*             
00002A06  E599                    2615  OP_ROL      ROL.L   #2,D1
00002A08  0281 00000003           2616              ANDI.L  #$3,D1
00002A0E  0C01 0000               2617              CMPI.B  #0,D1
00002A12  6700 0016               2618              BEQ     OP_ROL_B
00002A16  0C01 0001               2619              CMPI.B  #$1,D1
00002A1A  6700 0032               2620              BEQ     OP_ROL_W
00002A1E  0C01 0002               2621              CMPI.B  #$2,D1
00002A22  6700 0018               2622              BEQ     OP_ROL_L
00002A26                          2623              
00002A26  4EF8 14B8               2624              JMP OP_DATA
00002A2A                          2625  
00002A2A                          2626  
00002A2A  43F9 00004033           2627  OP_ROL_B    LEA     DISP_ROL_B,A1
00002A30  103C 000E               2628              MOVE.B  #14,D0
00002A34  4E4F                    2629              TRAP    #15
00002A36  183C 0000               2630              MOVE.B  #0,D4
00002A3A  4E75                    2631              RTS
00002A3C                          2632  
00002A3C  43F9 00004057           2633  OP_ROL_L    LEA     DISP_ROL_L,A1
00002A42  103C 000E               2634              MOVE.B  #14,D0
00002A46  4E4F                    2635              TRAP    #15
00002A48  183C 0002               2636              MOVE.B  #2,D4
00002A4C  4E75                    2637              RTS
00002A4E                          2638  
00002A4E  43F9 00004045           2639  OP_ROL_W    LEA     DISP_ROL_W,A1
00002A54  103C 000E               2640              MOVE.B  #14,D0
00002A58  4E4F                    2641              TRAP    #15
00002A5A  183C 0001               2642              MOVE.B  #1,D4
00002A5E  4E75                    2643              RTS
00002A60                          2644              
00002A60                          2645  *---------------------------------------------------------------------------*
00002A60                          2646  * OP1111 : Special reserved
00002A60                          2647  *---------------------------------------------------------------------------*           
00002A60  4EF8 14B8               2648  OP1111      JMP     OP_DATA
00002A64                          2649  
00002A64                          2650  *---------------------------------------------------------------------------*
00002A64                          2651  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00002A64                          2652  *---------------------------------------------------------------------------*
00002A64                          2653  EA_NOSRC    
00002A64  4EB9 00002B22           2654              JSR     SRC_MODE
00002A6A  43F9 00003D24           2655              LEA     ENDLINE_M,A1
00002A70  103C 000E               2656              MOVE.B  #14,D0
00002A74  4E4F                    2657              TRAP    #15
00002A76  4E75                    2658              RTS
00002A78                          2659              
00002A78                          2660  *---------------------------------------------------------------------------*
00002A78                          2661  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00002A78                          2662  *---------------------------------------------------------------------------*
00002A78                          2663  EA_ARITH
00002A78  4EB9 00002B22           2664              JSR     SRC_MODE
00002A7E  43F9 0000409E           2665              LEA     DISP_D,A1
00002A84  103C 000E               2666              MOVE.B  #14,D0
00002A88  4E4F                    2667              TRAP    #15
00002A8A  4EB9 00002DAE           2668              JSR     DEST_REGISTER
00002A90  43F9 00003D24           2669              LEA     ENDLINE_M,A1
00002A96  103C 000E               2670              MOVE.B  #14,D0
00002A9A  4E4F                    2671              TRAP    #15
00002A9C  4E75                    2672              RTS
00002A9E                          2673              
00002A9E                          2674  *---------------------------------------------------------------------------*
00002A9E                          2675  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00002A9E                          2676  *---------------------------------------------------------------------------*
00002A9E                          2677  EA_MOVEA
00002A9E  4EB9 00002B22           2678              JSR     SRC_MODE
00002AA4  43F9 000040AF           2679              LEA     DISP_AOP,A1
00002AAA  103C 000E               2680              MOVE.B  #14,D0
00002AAE  4E4F                    2681              TRAP    #15
00002AB0  4EB9 00002DAE           2682              JSR     DEST_REGISTER
00002AB6  43F9 000040AD           2683              LEA     DISP_CP,A1
00002ABC  103C 000D               2684              MOVE.B  #13,D0
00002AC0  4E4F                    2685              TRAP    #15
00002AC2  4E75                    2686              RTS
00002AC4                          2687              
00002AC4                          2688  *---------------------------------------------------------------------------*
00002AC4                          2689  * EA_GEN: decode and display effective addresses for MOVE
00002AC4                          2690  *---------------------------------------------------------------------------*
00002AC4                          2691  EA_GEN          
00002AC4                          2692              * retrieve/display source mode/register
00002AC4  4EB9 00002B22           2693              JSR     SRC_MODE
00002ACA                          2694              
00002ACA                          2695              * retrieve/display destination mode/register
00002ACA  4EB9 00002ADE           2696              JSR     DEST_MODE
00002AD0                          2697              
00002AD0  43F9 00003D24           2698              LEA     ENDLINE_M,A1
00002AD6  103C 000E               2699              MOVE.B  #14,D0
00002ADA  4E4F                    2700              TRAP    #15
00002ADC                          2701              
00002ADC  4E75                    2702              RTS
00002ADE                          2703  
00002ADE                          2704  *---------------------------------------------------------------------------*
00002ADE                          2705  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002ADE                          2706  *---------------------------------------------------------------------------*           
00002ADE                          2707  DEST_MODE   
00002ADE                          2708              * clear registers to store temp data
00002ADE  4280                    2709              CLR.L   D0                      
00002AE0  4281                    2710              CLR.L   D1                      
00002AE2  207C 00000000           2711              MOVEA.L #0, A0                  
00002AE8  227C 00000000           2712              MOVEA.L #0, A1                  
00002AEE  2205                    2713              MOVE.L  D5,D1
00002AF0  EC89                    2714              LSR.L   #6,D1
00002AF2  0281 00000007           2715              ANDI.L  #$7,D1
00002AF8  0C01 0000               2716              CMPI.B  #0,D1   * Dn
00002AFC  6700 0082               2717              BEQ     D_MODE000
00002B00  0C01 0002               2718              CMPI.B  #2,D1   * (An)
00002B04  6700 00C2               2719              BEQ     D_MODE010
00002B08  0C01 0003               2720              CMPI.B  #3,D1   * (An)+
00002B0C  6700 011A               2721              BEQ     D_MODE011
00002B10  0C01 0004               2722              CMPI.B  #4,D1   * -(An)
00002B14  6700 0132               2723              BEQ     D_MODE100
00002B18  0C01 0007               2724              CMPI.B  #7,D1  * abs
00002B1C  6700 017C               2725              BEQ     D_MODE111 
00002B20  4E75                    2726              RTS
00002B22                          2727  
00002B22                          2728  *---------------------------------------------------------------------------*
00002B22                          2729  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002B22                          2730  *---------------------------------------------------------------------------*  
00002B22                          2731  SRC_MODE    
00002B22                          2732              * clear registers to store temp data
00002B22  4280                    2733              CLR.L   D0                      
00002B24  4281                    2734              CLR.L   D1                      
00002B26  207C 00000000           2735              MOVEA.L #0, A0                  
00002B2C  227C 00000000           2736              MOVEA.L #0, A1                  
00002B32  2205                    2737              MOVE.L  D5,D1
00002B34  E489                    2738              LSR.L   #2,D1
00002B36  0281 0000000E           2739              ANDI.L  #$E,D1
00002B3C                          2740              
00002B3C  0C01 0000               2741              CMPI.B  #0,D1   * Dn
00002B40  6700 002A               2742              BEQ     MODE000
00002B44  0C01 0002               2743              CMPI.B  #2,D1   * An 
00002B48  6700 004A               2744              BEQ     MODE001
00002B4C  0C01 0004               2745              CMPI.B  #4,D1   * (An)
00002B50  6700 0056               2746              BEQ     MODE010
00002B54  0C01 0006               2747              CMPI.B  #6,D1   * (An)+
00002B58  6700 008E               2748              BEQ     MODE011
00002B5C  0C01 0008               2749              CMPI.B  #8,D1   * -(An)
00002B60  6700 00A6               2750              BEQ     MODE100
00002B64  0C01 000F               2751              CMPI.B  #15,D1  * abs/immediate
00002B68  6700 00FE               2752              BEQ     MODE111 
00002B6C                          2753        
00002B6C                          2754  *---------------------------------------------------------------------------*
00002B6C                          2755  * MODE000: decode and display source mode Dn
00002B6C                          2756  *---------------------------------------------------------------------------*           
00002B6C                          2757  MODE000     *Dn
00002B6C  43F9 0000409E           2758              LEA     DISP_D,A1
00002B72  103C 000E               2759              MOVE.B  #14,D0
00002B76  4E4F                    2760              TRAP    #15
00002B78  4EB9 00002E0A           2761              JSR     SRC_REGISTER
00002B7E  4E75                    2762              RTS
00002B80                          2763  
00002B80                          2764  *---------------------------------------------------------------------------*
00002B80                          2765  * D_MODE000: decode and display dest mode Dn
00002B80                          2766  *---------------------------------------------------------------------------*
00002B80                          2767  D_MODE000     *Dn
00002B80  43F9 0000409E           2768              LEA     DISP_D,A1
00002B86  103C 000E               2769              MOVE.B  #14,D0
00002B8A  4E4F                    2770              TRAP    #15
00002B8C  4EB9 00002DAE           2771              JSR     DEST_REGISTER
00002B92  4E75                    2772              RTS
00002B94                          2773  
00002B94                          2774  *---------------------------------------------------------------------------*
00002B94                          2775  * MODE001: decode and display source mode An
00002B94                          2776  *---------------------------------------------------------------------------* 
00002B94                          2777  MODE001 *An
00002B94  43F9 000040A3           2778              LEA     DISP_A,A1
00002B9A  103C 000E               2779              MOVE.B  #14,D0
00002B9E  4E4F                    2780              TRAP    #15
00002BA0  4EB9 00002E0A           2781              JSR     SRC_REGISTER
00002BA6                          2782          
00002BA6  4E75                    2783              RTS
00002BA8                          2784  
00002BA8                          2785  *---------------------------------------------------------------------------*
00002BA8                          2786  * MODE010: decode and display source mode (An)
00002BA8                          2787  *---------------------------------------------------------------------------*    
00002BA8                          2788  MODE010 *(An)
00002BA8  43F9 000040AF           2789              LEA     DISP_AOP,A1  *display (A
00002BAE  103C 000E               2790              MOVE.B  #14,D0
00002BB2  4E4F                    2791              TRAP    #15
00002BB4                          2792  
00002BB4  4EB9 00002E0A           2793              JSR     SRC_REGISTER * display register
00002BBA                          2794  
00002BBA  43F9 000040AD           2795              LEA     DISP_CP,A1   *display )
00002BC0  103C 000E               2796              MOVE.B  #14,D0
00002BC4  4E4F                    2797              TRAP    #15
00002BC6                          2798              
00002BC6  4E75                    2799              RTS
00002BC8                          2800  
00002BC8                          2801  *---------------------------------------------------------------------------*
00002BC8                          2802  * D_MODE010: decode and display dest mode (An)
00002BC8                          2803  *---------------------------------------------------------------------------*
00002BC8                          2804  D_MODE010 *(An)
00002BC8  43F9 000040AF           2805              LEA     DISP_AOP,A1  *display (A
00002BCE  103C 000E               2806              MOVE.B  #14,D0
00002BD2  4E4F                    2807              TRAP    #15
00002BD4                          2808     
00002BD4  4EB9 00002DAE           2809              JSR     DEST_REGISTER * display register
00002BDA                          2810  
00002BDA  43F9 000040AD           2811              LEA     DISP_CP,A1   *display )
00002BE0  103C 000E               2812              MOVE.B  #14,D0
00002BE4  4E4F                    2813              TRAP    #15
00002BE6                          2814              
00002BE6  4E75                    2815              RTS
00002BE8                          2816  
00002BE8                          2817  *---------------------------------------------------------------------------*
00002BE8                          2818  * MODE011: decode and display source mode (An)+
00002BE8                          2819  *---------------------------------------------------------------------------*
00002BE8                          2820  MODE011 *(An)+
00002BE8  43F9 000040AF           2821              LEA     DISP_AOP,A1      *display (A
00002BEE  103C 000E               2822              MOVE.B  #14,D0
00002BF2  4E4F                    2823              TRAP    #15
00002BF4                          2824              
00002BF4  4EB9 00002E0A           2825              JSR     SRC_REGISTER    * display register
00002BFA                          2826  
00002BFA  43F9 000040BC           2827              LEA     DISP_POST,A1    *display )+
00002C00  103C 000E               2828              MOVE.B  #14,D0
00002C04  4E4F                    2829              TRAP    #15
00002C06                          2830              
00002C06  4E75                    2831              RTS
00002C08                          2832              
00002C08                          2833  *---------------------------------------------------------------------------*
00002C08                          2834  * MODE100: decode and display source mode -(An)
00002C08                          2835  *---------------------------------------------------------------------------*
00002C08                          2836  MODE100 *-(An)
00002C08  43F9 000040B5           2837              LEA     DISP_PRE,A1    *display -(A
00002C0E  103C 000E               2838              MOVE.B  #14,D0
00002C12  4E4F                    2839              TRAP    #15
00002C14                          2840  
00002C14  4EB9 00002E0A           2841              JSR     SRC_REGISTER    *display register
00002C1A                          2842  
00002C1A  43F9 000040AD           2843              LEA     DISP_CP,A1   *display )
00002C20  103C 000E               2844              MOVE.B  #14,D0
00002C24  4E4F                    2845              TRAP    #15
00002C26                          2846              
00002C26  4E75                    2847              RTS
00002C28                          2848  
00002C28                          2849  *---------------------------------------------------------------------------*
00002C28                          2850  * D_MODE011: decode and display dest mode (An)+
00002C28                          2851  *---------------------------------------------------------------------------*
00002C28                          2852  D_MODE011 *(An)+
00002C28  43F9 000040AF           2853              LEA     DISP_AOP,A1      *display (A
00002C2E  103C 000E               2854              MOVE.B  #14,D0
00002C32  4E4F                    2855              TRAP    #15
00002C34                          2856  
00002C34  4EB9 00002DAE           2857              JSR     DEST_REGISTER    * display register
00002C3A                          2858  
00002C3A  43F9 000040BC           2859              LEA     DISP_POST,A1    *display )+
00002C40  103C 000E               2860              MOVE.B  #14,D0
00002C44  4E4F                    2861              TRAP    #15
00002C46                          2862              
00002C46  4E75                    2863              RTS
00002C48                          2864              
00002C48                          2865  *---------------------------------------------------------------------------*
00002C48                          2866  * D_MODE100: decode and display dest mode -(An)
00002C48                          2867  *---------------------------------------------------------------------------*            
00002C48                          2868  D_MODE100 *-(An)
00002C48  43F9 000040B5           2869              LEA     DISP_PRE,A1    *display -(A
00002C4E  103C 000E               2870              MOVE.B  #14,D0
00002C52  4E4F                    2871              TRAP    #15
00002C54                          2872              
00002C54  4EB9 00002DAE           2873              JSR     DEST_REGISTER    *display register
00002C5A                          2874  
00002C5A  43F9 000040AD           2875              LEA     DISP_CP,A1   *display )
00002C60  103C 000E               2876              MOVE.B  #14,D0
00002C64  4E4F                    2877              TRAP    #15
00002C66                          2878              
00002C66  4E75                    2879              RTS
00002C68                          2880  
00002C68                          2881  *---------------------------------------------------------------------------*
00002C68                          2882  * MODE111: decode and display source mode absolute/immediate
00002C68                          2883  *---------------------------------------------------------------------------*
00002C68                          2884  MODE111     * abs/immediate
00002C68                          2885              * clear registers to store temp data
00002C68  4280                    2886              CLR.L   D0                      
00002C6A  4281                    2887              CLR.L   D1                      
00002C6C  207C 00000000           2888              MOVEA.L #0, A0                  
00002C72  227C 00000000           2889              MOVEA.L #0, A1                  
00002C78  2205                    2890              MOVE.L  D5,D1
00002C7A                          2891              
00002C7A                          2892              * retrieve source register for MODE 111
00002C7A  E389                    2893              LSL.L   #1,D1   * shift the bits to left by 1
00002C7C  0281 0000000E           2894              ANDI.L  #$E,D1  * mask the first 4 bits 
00002C82  0C01 0000               2895              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002C86  6700 003E               2896              BEQ     WORDMODE
00002C8A  0C01 0002               2897              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002C8E  6700 0062               2898              BEQ     LONGMODE
00002C92  0C01 0008               2899              CMPI.B  #8, D1  * if it's 1000, immediate data
00002C96  6700 0086               2900              BEQ     IMMEDIATE
00002C9A                          2901       
00002C9A                          2902  *---------------------------------------------------------------------------*
00002C9A                          2903  * D_MODE111: decode and display dest mode absolute/immediate
00002C9A                          2904  *---------------------------------------------------------------------------*           
00002C9A                          2905  D_MODE111   * abs
00002C9A                          2906              * clear registers to store temp data
00002C9A  4280                    2907              CLR.L   D0                      
00002C9C  4281                    2908              CLR.L   D1                      
00002C9E  207C 00000000           2909              MOVEA.L #0, A0                  
00002CA4  227C 00000000           2910              MOVEA.L #0, A1                  
00002CAA  2205                    2911              MOVE.L  D5,D1
00002CAC                          2912              
00002CAC                          2913              * retrieve dest register for MODE 111
00002CAC  EC89                    2914              LSR.L   #6,D1   * shift the bits to right by 6
00002CAE  E689                    2915              LSR.L   #3,D1   * shift the bits to right by extra 3
00002CB0  0201 0001               2916              ANDI.B  #1,D1   * mask the first 2 bits 
00002CB4  0C01 0000               2917              CMPI.B  #0, D1  * if it's 000, absolute word address
00002CB8  6700 000C               2918              BEQ     WORDMODE
00002CBC  0C01 0001               2919              CMPI.B  #1, D1  * if it's 001, absolute long address
00002CC0  6700 0030               2920              BEQ     LONGMODE
00002CC4                          2921              *JSR     OP_DATA *not sure..
00002CC4  4E75                    2922              RTS
00002CC6                          2923  
00002CC6                          2924  
00002CC6                          2925  *---------------------------------------------------------------------------*
00002CC6                          2926  * WORDMODE: absolute word address
00002CC6                          2927  *---------------------------------------------------------------------------*
00002CC6  43F9 00004099           2928  WORDMODE    LEA     DISP_HEX,A1
00002CCC  103C 000E               2929              MOVE.B  #14,D0
00002CD0  4E4F                    2930              TRAP    #15
00002CD2                          2931              
00002CD2  4285                    2932              CLR.L   D5
00002CD4  3A1D                    2933              MOVE.W  (A5)+,D5
00002CD6                          2934              
00002CD6  43F9 00003D77           2935              LEA     TMPOUTPUT,A1
00002CDC  2205                    2936              MOVE.L  D5,D1
00002CDE  7404                    2937              MOVE.L  #4,D2       *move word size 4
00002CE0  4EB8 11B8               2938              JSR     HEX2ASCII
00002CE4  43F9 00003D77           2939              LEA     TMPOUTPUT,A1
00002CEA  103C 000E               2940              MOVE.B  #14,D0
00002CEE  4E4F                    2941              TRAP    #15
00002CF0                          2942              
00002CF0  4E75                    2943              RTS
00002CF2                          2944  
00002CF2                          2945  *---------------------------------------------------------------------------*
00002CF2                          2946  * LONGMODE: absolute long address
00002CF2                          2947  *---------------------------------------------------------------------------*
00002CF2  43F9 00004099           2948  LONGMODE    LEA     DISP_HEX,A1
00002CF8  103C 000E               2949              MOVE.B  #14,D0
00002CFC  4E4F                    2950              TRAP    #15
00002CFE                          2951              
00002CFE  4285                    2952              CLR.L   D5
00002D00  2A1D                    2953              MOVE.L  (A5)+,D5
00002D02                          2954              
00002D02  43F9 00003D77           2955              LEA     TMPOUTPUT,A1
00002D08  2205                    2956              MOVE.L  D5,D1
00002D0A  7408                    2957              MOVE.L  #8,D2           *move longword size 8
00002D0C  4EB8 11B8               2958              JSR     HEX2ASCII
00002D10  43F9 00003D77           2959              LEA     TMPOUTPUT,A1
00002D16  103C 000E               2960              MOVE.B  #14,D0
00002D1A  4E4F                    2961              TRAP    #15
00002D1C                          2962              
00002D1C  4E75                    2963              RTS
00002D1E                          2964  
00002D1E                          2965  
00002D1E                          2966  *---------------------------------------------------------------------------*
00002D1E                          2967  * IMMEDIATE: immediate address
00002D1E                          2968  *---------------------------------------------------------------------------*
00002D1E  43F9 000040BF           2969  IMMEDIATE   LEA     DISP_LB,A1
00002D24  103C 000E               2970              MOVE.B  #14,D0
00002D28  4E4F                    2971              TRAP    #15
00002D2A  43F9 00004099           2972              LEA     DISP_HEX,A1
00002D30  103C 000E               2973              MOVE.B  #14,D0
00002D34  4E4F                    2974              TRAP    #15
00002D36                          2975              
00002D36                          2976              * check for size
00002D36  0C04 0000               2977              CMPI.B  #0,D4
00002D3A  6700 0012               2978              BEQ     IMMD_B
00002D3E  0C04 0001               2979              CMPI.B  #1,D4
00002D42  6700 002A               2980              BEQ     IMMD_W
00002D46  0C04 0002               2981              CMPI.B  #2,D4
00002D4A  6700 0042               2982              BEQ     IMMD_L
00002D4E                          2983  
00002D4E                          2984  IMMD_B
00002D4E  4285                    2985              CLR.L   D5
00002D50  3A1D                    2986              MOVE.W  (A5)+,D5
00002D52                          2987              
00002D52  43F9 00003D77           2988              LEA     TMPOUTPUT,A1
00002D58  2205                    2989              MOVE.L  D5,D1
00002D5A  7402                    2990              MOVE.L  #2,D2
00002D5C  4EB8 11B8               2991              JSR     HEX2ASCII
00002D60  43F9 00003D77           2992              LEA     TMPOUTPUT,A1
00002D66  103C 000E               2993              MOVE.B  #14,D0
00002D6A  4E4F                    2994              TRAP    #15
00002D6C  4E75                    2995              RTS
00002D6E                          2996              
00002D6E                          2997  IMMD_W
00002D6E  4285                    2998              CLR.L   D5
00002D70  3A1D                    2999              MOVE.W  (A5)+,D5
00002D72                          3000              
00002D72  43F9 00003D77           3001              LEA     TMPOUTPUT,A1
00002D78  2205                    3002              MOVE.L  D5,D1
00002D7A  7404                    3003              MOVE.L  #4,D2
00002D7C  4EB8 11B8               3004              JSR     HEX2ASCII
00002D80  43F9 00003D77           3005              LEA     TMPOUTPUT,A1
00002D86  103C 000E               3006              MOVE.B  #14,D0
00002D8A  4E4F                    3007              TRAP    #15
00002D8C  4E75                    3008              RTS
00002D8E                          3009              
00002D8E                          3010  
00002D8E                          3011  IMMD_L
00002D8E  4285                    3012              CLR.L   D5
00002D90  3A1D                    3013              MOVE.W  (A5)+,D5
00002D92                          3014              
00002D92  43F9 00003D77           3015              LEA     TMPOUTPUT,A1
00002D98  2205                    3016              MOVE.L  D5,D1
00002D9A  7408                    3017              MOVE.L  #8,D2
00002D9C  4EB8 11B8               3018              JSR     HEX2ASCII
00002DA0  43F9 00003D77           3019              LEA     TMPOUTPUT,A1
00002DA6  103C 000E               3020              MOVE.B  #14,D0
00002DAA  4E4F                    3021              TRAP    #15
00002DAC  4E75                    3022              RTS
00002DAE                          3023  
00002DAE                          3024  
00002DAE                          3025  *---------------------------------------------------------------------------*
00002DAE                          3026  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00002DAE                          3027  *---------------------------------------------------------------------------*
00002DAE                          3028  DEST_REGISTER
00002DAE                          3029              * clear registers to store temp data
00002DAE  4280                    3030              CLR.L   D0                      
00002DB0  4281                    3031              CLR.L   D1                      
00002DB2  207C 00000000           3032              MOVEA.L #0, A0                  
00002DB8  227C 00000000           3033              MOVEA.L #0, A1 
00002DBE                          3034              
00002DBE  2205                    3035              MOVE.L  D5,D1
00002DC0  EC89                    3036              LSR.L   #6,D1
00002DC2  E689                    3037              LSR.L   #3,D1
00002DC4  0281 00000007           3038              ANDI.L  #7,D1
00002DCA                          3039              
00002DCA  0C01 0000               3040              CMPI.B  #0,D1
00002DCE  6700 0092               3041              BEQ     REG_0
00002DD2  0C01 0001               3042              CMPI.B  #1,D1
00002DD6  6700 0098               3043              BEQ     REG_1
00002DDA  0C01 0002               3044              CMPI.B  #2,D1
00002DDE  6700 009E               3045              BEQ     REG_2
00002DE2  0C01 0003               3046              CMPI.B  #3,D1
00002DE6  6700 00A4               3047              BEQ     REG_3
00002DEA  0C01 0004               3048              CMPI.B  #4,D1
00002DEE  6700 00AA               3049              BEQ     REG_4
00002DF2  0C01 0005               3050              CMPI.B  #5,D1
00002DF6  6700 00B0               3051              BEQ     REG_5
00002DFA  0C01 0006               3052              CMPI.B  #6,D1
00002DFE  6700 00B6               3053              BEQ     REG_6
00002E02  0C01 0007               3054              CMPI.B  #7,D1
00002E06  6700 00BC               3055              BEQ     REG_7
00002E0A                          3056  
00002E0A                          3057  *---------------------------------------------------------------------------*
00002E0A                          3058  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00002E0A                          3059  *---------------------------------------------------------------------------*           
00002E0A                          3060  SRC_REGISTER 
00002E0A                          3061              * clear registers to store temp data
00002E0A  4280                    3062              CLR.L   D0                      
00002E0C  4281                    3063              CLR.L   D1                      
00002E0E  207C 00000000           3064              MOVEA.L #0, A0                  
00002E14  227C 00000000           3065              MOVEA.L #0, A1                  
00002E1A                          3066              
00002E1A  2205                    3067              MOVE.L  D5,D1   * temp store the processing data
00002E1C  0281 00000007           3068              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00002E22                          3069              
00002E22  0C01 0000               3070              CMPI.B  #0,D1
00002E26  6700 003A               3071              BEQ     REG_0
00002E2A  0C01 0001               3072              CMPI.B  #1,D1
00002E2E  6700 0040               3073              BEQ     REG_1
00002E32  0C01 0002               3074              CMPI.B  #2,D1
00002E36  6700 0046               3075              BEQ     REG_2
00002E3A  0C01 0003               3076              CMPI.B  #3,D1
00002E3E  6700 004C               3077              BEQ     REG_3
00002E42  0C01 0004               3078              CMPI.B  #4,D1
00002E46  6700 0052               3079              BEQ     REG_4
00002E4A  0C01 0005               3080              CMPI.B  #5,D1
00002E4E  6700 0058               3081              BEQ     REG_5
00002E52  0C01 0006               3082              CMPI.B  #6,D1
00002E56  6700 005E               3083              BEQ     REG_6
00002E5A  0C01 0007               3084              CMPI.B  #7,D1
00002E5E  6700 0064               3085              BEQ     REG_7
00002E62                          3086  
00002E62                          3087  *---------------------------------------------------------------------------*
00002E62                          3088  * REG_0 ~ REG_7: display register 0 to 7
00002E62                          3089  *---------------------------------------------------------------------------*
00002E62  43F9 000040C4           3090  REG_0       LEA     DISP_0,A1
00002E68  103C 000E               3091              MOVE.B  #14,D0
00002E6C  4E4F                    3092              TRAP    #15
00002E6E  4E75                    3093              RTS
00002E70                          3094              
00002E70  43F9 000040C6           3095  REG_1       LEA     DISP_1,A1
00002E76  103C 000E               3096              MOVE.B  #14,D0
00002E7A  4E4F                    3097              TRAP    #15
00002E7C  4E75                    3098              RTS
00002E7E                          3099              
00002E7E                          3100  
00002E7E  43F9 000040C8           3101  REG_2       LEA     DISP_2,A1
00002E84  103C 000E               3102              MOVE.B  #14,D0
00002E88  4E4F                    3103              TRAP    #15
00002E8A  4E75                    3104              RTS
00002E8C                          3105            
00002E8C  43F9 000040CA           3106  REG_3       LEA     DISP_3,A1
00002E92  103C 000E               3107              MOVE.B  #14,D0
00002E96  4E4F                    3108              TRAP    #15
00002E98  4E75                    3109              RTS
00002E9A                          3110              
00002E9A  43F9 000040CC           3111  REG_4       LEA     DISP_4,A1
00002EA0  103C 000E               3112              MOVE.B  #14,D0
00002EA4  4E4F                    3113              TRAP    #15
00002EA6  4E75                    3114              RTS
00002EA8                          3115              
00002EA8  43F9 000040CE           3116  REG_5       LEA     DISP_5,A1
00002EAE  103C 000E               3117              MOVE.B  #14,D0
00002EB2  4E4F                    3118              TRAP    #15
00002EB4  4E75                    3119              RTS
00002EB6                          3120              
00002EB6  43F9 000040D0           3121  REG_6       LEA     DISP_6,A1
00002EBC  103C 000E               3122              MOVE.B  #14,D0
00002EC0  4E4F                    3123              TRAP    #15
00002EC2  4E75                    3124              RTS
00002EC4                          3125              
00002EC4  43F9 000040D2           3126  REG_7       LEA     DISP_7,A1
00002ECA  103C 000E               3127              MOVE.B  #14,D0
00002ECE  4E4F                    3128              TRAP    #15
00002ED0  4E75                    3129              RTS
00002ED2                          3130              
00002ED2                          3131  *---------------------------------------------------------------------------*
00002ED2                          3132  * REPEAT : Ask user whether they wish to run the program again
00002ED2                          3133  *---------------------------------------------------------------------------*           
00002ED2  4246                    3134  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00002ED4  43F9 00003B9D           3135              LEA     REPEATMSG,A1
00002EDA  103C 000E               3136              MOVE.B  #14,D0
00002EDE  4E4F                    3137              TRAP    #15
00002EE0                          3138              
00002EE0  43F9 00003D27           3139              LEA     TMPINPUT,A1             * allocate space to temp store user input
00002EE6  103C 0002               3140              MOVE.B  #2,D0
00002EEA  4E4F                    3141              TRAP    #15
00002EEC                          3142  
00002EEC  0C01 0001               3143              CMPI.B  #1,D1                   * check for length of user input
00002EF0  66E0                    3144              BNE     REPEAT                  * return to the beginning of the function if unequal
00002EF2                          3145              
00002EF2  0C11 0059               3146              CMPI.B  #$59,(A1)               * compare the input with Y    
00002EF6  6700 E112               3147              BEQ     PROGLP                  * repeat the program
00002EFA                          3148              
00002EFA  0C11 0079               3149              CMPI.B  #$79,(A1)               * compare the input with y    
00002EFE  6700 E10A               3150              BEQ     PROGLP                  * repeat the program
00002F02                          3151              
00002F02  0C11 004E               3152              CMPI.B  #$4E,(A1)               * compare the input with N    
00002F06  6700 0928               3153              BEQ     TERMINATE               * finish program
00002F0A                          3154              
00002F0A  0C11 006E               3155              CMPI.B  #$6E,(A1)               * compare the input with n    
00002F0E  6700 0920               3156              BEQ     TERMINATE               * finish program
00002F12                          3157              
00002F12  60BE                    3158              BRA     REPEAT                  * invalid input/repeat the function
00002F14                          3159  
00002F14                          3160  *---------------------------------------------------------------------------*
00002F14                          3161  * EA DECODING INTERFACE
00002F14                          3162  * [A0] - RESERVED FOR USE
00002F14                          3163  * [D2] - RESERVED FOR USE
00002F14                          3164  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00002F14                          3165  *---------------------------------------------------------------------------*
00002F14                          3166  GET_EA_EA_SRC
00002F14                          3167      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00002F14                          3168      
00002F14                          3169      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00002F14  2405                    3170      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00002F16  E68A                    3171      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00002F18  23C2 000040EA           3172      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00002F1E  7407                    3173      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00002F20  C5B9 000040EA           3174      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00002F26                          3175                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00002F26                          3176      
00002F26                          3177      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00002F26                          3178      *DESTINATION REGISTER FORMAT STANDARD         *
00002F26                          3179      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00002F26                          3180      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00002F26                          3181      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00002F26                          3182      *0 - Dn                                       *
00002F26                          3183      *1 - An                                       *
00002F26                          3184      *2 - (An)                                     *
00002F26                          3185      *3 - (An)+                                    *
00002F26                          3186      *4 - -(An)                                    *
00002F26                          3187      *5 - (XXX).W                                  *
00002F26                          3188      *6 - (XXX).L                                  *
00002F26                          3189      *7 - #<data>                                  *
00002F26                          3190      ***********************************************
00002F26                          3191      
00002F26                          3192      *** Check if source ...  <ea> = Dn
00002F26                          3193  CHECK0    
00002F26  41F9 000040DA           3194            LEA     TEMP_REGISTER_FORMAT,A0
00002F2C  1439 000040D9           3195            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002F32  1082                    3196            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002F34  0239 0001 000040DA      3197            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00002F3C  0C39 0001 000040DA      3198            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00002F44  6700 006A               3199            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002F48  0CB9 00000000 000040EA  3200            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00002F52  6600 005C               3201            BNE     CHECK1
00002F56                          3202            
00002F56                          3203            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002F56  163C 0020               3204            MOVE.B    #' ',D3
00002F5A  6100 0856               3205            BSR       PUSH_STACK
00002F5E  163C 0044               3206            MOVE.B    #'D',D3
00002F62  6100 084E               3207            BSR       PUSH_STACK
00002F66                          3208  
00002F66                          3209            *FIND REGISTER NUMBER END LOCATION*  
00002F66  13F9 000040DC 000040E2  3210            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002F70  0239 000F 000040E2      3211            AND.B   #$0F,VAR_BYTE_END
00002F78                          3212            
00002F78                          3213            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002F78  23C5 000040E6           3214            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002F7E  1439 000040E2           3215            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002F84                          3216            
00002F84                          3217            *INTITIALIZE FOR BIT SHIFTING
00002F84  41F9 000040E6           3218            LEA     VAR_TEMP_CLEANCOPY,A0
00002F8A  2639 000040E6           3219            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002F90                          3220  LOOP_SHIFTING
00002F90  0C02 0000               3221            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002F94  6700 0008               3222            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002F98  E24B                    3223            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002F9A  5302                    3224            SUB.B   #1,D2                     *DECREMENT COUNTER
00002F9C  60F2                    3225            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00002F9E                          3226  MASKING_NEXT
00002F9E  C6BC 00000007           3227            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002FA4  0603 0030               3228            ADD.B   #$30,D3                   *CONVERT TO CHAR
00002FA8  6100 0808               3229            BSR     PUSH_STACK                *PUSH TO STACK
00002FAC                          3230            
00002FAC  6000 0394               3231            BRA     GET_SRC_SUCCESS           *RETURN          
00002FB0                          3232            
00002FB0                          3233            
00002FB0                          3234            *** Check if source ...  <ea> = An
00002FB0  41F9 000040DA           3235  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00002FB6  1439 000040D9           3236            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002FBC  1082                    3237            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002FBE  0239 0002 000040DA      3238            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00002FC6  0C39 0002 000040DA      3239            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00002FCE  6700 006A               3240            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002FD2  0CB9 00000001 000040EA  3241            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00002FDC  6600 005C               3242            BNE     CHECK2
00002FE0                          3243            
00002FE0                          3244            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002FE0  163C 0020               3245            MOVE.B    #' ',D3
00002FE4  6100 07CC               3246            BSR       PUSH_STACK
00002FE8  163C 0041               3247            MOVE.B    #'A',D3
00002FEC  6100 07C4               3248            BSR       PUSH_STACK
00002FF0                          3249  
00002FF0                          3250            
00002FF0                          3251            *FIND REGISTER NUMBER END LOCATION*  
00002FF0  13F9 000040DC 000040E2  3252            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002FFA  0239 000F 000040E2      3253            AND.B   #$0F,VAR_BYTE_END
00003002                          3254            
00003002                          3255            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003002  23C5 000040E6           3256            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003008  1439 000040E2           3257            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000300E                          3258            
0000300E                          3259            *INTITIALIZE FOR BIT SHIFTING
0000300E  41F9 000040E6           3260            LEA     VAR_TEMP_CLEANCOPY,A0
00003014  2639 000040E6           3261            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000301A                          3262  LOOP_SHIFTING1
0000301A  0C02 0000               3263            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000301E  6700 0008               3264            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003022  E24B                    3265            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003024  5302                    3266            SUB.B   #1,D2                     *DECREMENT COUNTER
00003026  60F2                    3267            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003028                          3268  MASKING_NEXT1
00003028  C6BC 00000007           3269            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000302E  0603 0030               3270            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003032  6100 077E               3271            BSR     PUSH_STACK                *PUSH TO STACK
00003036                          3272            
00003036  6000 030A               3273            BRA     GET_SRC_SUCCESS                   *RETURN 
0000303A                          3274            
0000303A                          3275            
0000303A                          3276            
0000303A                          3277            
0000303A                          3278            *** Check if source ...  <ea> = (An)       
0000303A  41F9 000040DA           3279  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003040  1439 000040D9           3280            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003046  1082                    3281            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003048  0239 0004 000040DA      3282            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003050  0C39 0004 000040DA      3283            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003058  6700 007A               3284            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000305C  0CB9 00000002 000040EA  3285            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003066  6600 006C               3286            BNE     CHECK3
0000306A                          3287            
0000306A                          3288            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000306A  163C 0020               3289            MOVE.B    #' ',D3
0000306E  6100 0742               3290            BSR       PUSH_STACK
00003072  163C 0028               3291            MOVE.B    #'(',D3
00003076  6100 073A               3292            BSR       PUSH_STACK
0000307A  163C 0041               3293            MOVE.B    #'A',D3
0000307E  6100 0732               3294            BSR       PUSH_STACK
00003082                          3295  
00003082                          3296            
00003082                          3297            *FIND REGISTER NUMBER END LOCATION*  
00003082  13F9 000040DC 000040E2  3298            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000308C  0239 000F 000040E2      3299            AND.B   #$0F,VAR_BYTE_END
00003094                          3300            
00003094                          3301            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003094  23C5 000040E6           3302            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000309A  1439 000040E2           3303            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000030A0                          3304            
000030A0                          3305            *INTITIALIZE FOR BIT SHIFTING
000030A0  41F9 000040E6           3306            LEA     VAR_TEMP_CLEANCOPY,A0
000030A6  2639 000040E6           3307            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000030AC                          3308  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000030AC  0C02 0000               3309            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000030B0  6700 0008               3310            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000030B4  E24B                    3311            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000030B6  5302                    3312            SUB.B   #1,D2                     *DECREMENT COUNTER
000030B8  60F2                    3313            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000030BA                          3314  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000030BA  0283 00000007           3315            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000030C0  0603 0030               3316            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000030C4  6100 06EC               3317            BSR     PUSH_STACK                *PUSH TO STACK
000030C8                          3318            
000030C8  163C 0029               3319            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000030CC  6100 06E4               3320            BSR       PUSH_STACK
000030D0                          3321            
000030D0  6000 0270               3322            BRA     GET_SRC_SUCCESS                   *RETURN 
000030D4                          3323  
000030D4                          3324            
000030D4                          3325            
000030D4                          3326                      
000030D4                          3327  *** Check if source ...  <ea> = (An)+       
000030D4  41F9 000040DA           3328  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000030DA  1439 000040D9           3329            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000030E0  1082                    3330            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000030E2  0239 0008 000040DA      3331            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000030EA  0C39 0008 000040DA      3332            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
000030F2  6700 0082               3333            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000030F6  0CB9 00000003 000040EA  3334            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003100  6600 0074               3335            BNE     CHECK4
00003104                          3336            
00003104                          3337            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003104  163C 0020               3338            MOVE.B    #' ',D3
00003108  6100 06A8               3339            BSR       PUSH_STACK
0000310C  163C 0028               3340            MOVE.B    #'(',D3
00003110  6100 06A0               3341            BSR       PUSH_STACK
00003114  163C 0041               3342            MOVE.B    #'A',D3
00003118  6100 0698               3343            BSR       PUSH_STACK
0000311C                          3344  
0000311C                          3345            
0000311C                          3346            *FIND REGISTER NUMBER END LOCATION*  
0000311C  13F9 000040DC 000040E2  3347            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003126  0239 000F 000040E2      3348            ANDI.B   #$0F,VAR_BYTE_END
0000312E                          3349            
0000312E                          3350            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000312E  23C5 000040E6           3351            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003134  1439 000040E2           3352            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000313A                          3353            
0000313A                          3354            *INTITIALIZE FOR BIT SHIFTING
0000313A  41F9 000040E6           3355            LEA     VAR_TEMP_CLEANCOPY,A0
00003140  2639 000040E6           3356            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003146                          3357            
00003146                          3358  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003146  0C02 0000               3359            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000314A  6700 0008               3360            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000314E  E24B                    3361            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003150  5302                    3362            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003152  60F2                    3363            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003154                          3364                                               *change: NAME OF LABEL*
00003154                          3365  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003154  0283 00000007           3366            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000315A  0603 0030               3367            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000315E  6100 0652               3368            BSR     PUSH_STACK                *PUSH TO STACK
00003162                          3369            
00003162  163C 0029               3370            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003166  6100 064A               3371            BSR       PUSH_STACK
0000316A  163C 002B               3372            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000316E  6100 0642               3373            BSR       PUSH_STACK
00003172                          3374            
00003172  6000 01CE               3375            BRA       GET_SRC_SUCCESS                   *RETURN 
00003176                          3376  
00003176                          3377            
00003176                          3378            
00003176                          3379                      
00003176                          3380            *** Check if source ...  <ea> = -(An)       
00003176  41F9 000040DA           3381  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
0000317C  1439 000040D9           3382            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003182  1082                    3383            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003184  0239 0010 000040DA      3384            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
0000318C  0C39 0010 000040DA      3385            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003194  6700 0082               3386            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003198  0CB9 00000004 000040EA  3387            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000031A2  6600 0074               3388            BNE     CHECK7
000031A6                          3389            
000031A6                          3390            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000031A6  163C 0020               3391            MOVE.B    #' ',D3
000031AA  6100 0606               3392            BSR       PUSH_STACK
000031AE  163C 002D               3393            MOVE.B    #'-',D3
000031B2  6100 05FE               3394            BSR       PUSH_STACK
000031B6  163C 0028               3395            MOVE.B    #'(',D3
000031BA  6100 05F6               3396            BSR       PUSH_STACK
000031BE  163C 0041               3397            MOVE.B    #'A',D3
000031C2  6100 05EE               3398            BSR       PUSH_STACK
000031C6                          3399  
000031C6                          3400            
000031C6                          3401            *FIND REGISTER NUMBER END LOCATION*  
000031C6  13F9 000040DC 000040E2  3402            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000031D0  0239 000F 000040E2      3403            AND.B   #$0F,VAR_BYTE_END
000031D8                          3404            
000031D8                          3405            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000031D8  23C5 000040E6           3406            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000031DE  1439 000040E2           3407            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000031E4                          3408            
000031E4                          3409            *INTITIALIZE FOR BIT SHIFTING
000031E4  41F9 000040E6           3410            LEA     VAR_TEMP_CLEANCOPY,A0
000031EA  2639 000040E6           3411            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000031F0                          3412            
000031F0                          3413  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
000031F0  0C02 0000               3414            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000031F4  6700 0008               3415            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000031F8  E24B                    3416            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000031FA  5302                    3417            SUBI.B   #1,D2                     *DECREMENT COUNTER
000031FC  60F2                    3418            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
000031FE                          3419                                               *change: NAME OF LABEL*
000031FE                          3420  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
000031FE  0283 00000007           3421            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003204  0603 0030               3422            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003208  6100 05A8               3423            BSR     PUSH_STACK                *PUSH TO STACK
0000320C                          3424            
0000320C  163C 0029               3425            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003210  6100 05A0               3426            BSR       PUSH_STACK
00003214                          3427            
00003214  6000 012C               3428            BRA     GET_SRC_SUCCESS                   *RETURN
00003218                          3429            
00003218                          3430                      
00003218                          3431            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003218  0CB9 00000007 000040EA  3432  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003222  6600 011A               3433            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003226                          3434                   
00003226                          3435            *NEXT: (MODE == 111) 
00003226                          3436            *NOW: CHECK FOR SRC REGISTER 
00003226                          3437                  *(000 = (xxx).W)
00003226                          3438                  *(001 = (xxx).L)
00003226                          3439                  *(010 = #<data>)
00003226                          3440                  
00003226                          3441            *FIND REGISTER NUMBER END LOCATION*  
00003226  13F9 000040DC 000040E2  3442            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003230  0239 000F 000040E2      3443            AND.B   #$0F,VAR_BYTE_END
00003238                          3444            
00003238                          3445            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003238  23C5 000040E6           3446            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000323E  1439 000040E2           3447            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003244                          3448            
00003244                          3449            *INTITIALIZE FOR BIT SHIFTING
00003244  41F9 000040E6           3450            LEA     VAR_TEMP_CLEANCOPY,A0
0000324A  2C39 000040E6           3451            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003250                          3452  SRC_LOOP_SHIFTING
00003250  0C02 0000               3453            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003254  6700 0008               3454            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003258  E24E                    3455            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000325A  5302                    3456            SUB.B   #1,D2                     *DECREMENT COUNTER
0000325C  60F2                    3457            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
0000325E                          3458  SRC_MASKING_NEXT
0000325E  CCBC 00000007           3459            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003264                          3460           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003264                          3461           
00003264                          3462  CHECK_WORD  
00003264  41F9 000040DA           3463            LEA     TEMP_REGISTER_FORMAT,A0
0000326A  1439 000040D9           3464            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003270  1082                    3465            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003272  0239 0020 000040DA      3466            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
0000327A  0C39 0020 000040DA      3467            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003282  6700 0026               3468            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003286  0C06 0000               3469            CMPI.B  #0,D6                          
0000328A  6600 001E               3470            BNE     CHECK_LONG 
0000328E                          3471            
0000328E                          3472            *IT IS A WORD AT THIS POINT*
0000328E                          3473            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000328E  163C 0020               3474            MOVE.B    #' ',D3
00003292  6100 051E               3475            BSR       PUSH_STACK
00003296  163C 0024               3476            MOVE.B    #'$',D3
0000329A  6100 0516               3477            BSR       PUSH_STACK
0000329E  321D                    3478            MOVE.W    (A5)+,D1
000032A0  7404                    3479            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000032A2  6100 DF56               3480            BSR       HEX2ASCII2STACK
000032A6  6000 009A               3481            BRA     GET_SRC_SUCCESS
000032AA                          3482  
000032AA                          3483  CHECK_LONG
000032AA  41F9 000040DA           3484            LEA     TEMP_REGISTER_FORMAT,A0
000032B0  1439 000040D9           3485            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000032B6  1082                    3486            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000032B8  0239 0040 000040DA      3487            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000032C0  0C39 0040 000040DA      3488            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000032C8  6700 002E               3489            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000032CC  0C06 0001               3490            CMPI.B  #1,D6                          
000032D0  6600 0026               3491            BNE     CHECK_IMMEDIATE  
000032D4                          3492  
000032D4                          3493            *IT IS A WORD AT THIS POINT*
000032D4                          3494            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000032D4  163C 0020               3495            MOVE.B    #' ',D3
000032D8  6100 04D8               3496            BSR       PUSH_STACK
000032DC  163C 0024               3497            MOVE.B    #'$',D3
000032E0  6100 04D0               3498            BSR       PUSH_STACK
000032E4  321D                    3499            MOVE.W    (A5)+,D1
000032E6  7404                    3500            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000032E8  6100 DF10               3501            BSR       HEX2ASCII2STACK
000032EC  321D                    3502            MOVE.W    (A5)+,D1
000032EE  7404                    3503            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000032F0  6100 DF08               3504            BSR       HEX2ASCII2STACK
000032F4  6000 004C               3505            BRA     GET_SRC_SUCCESS
000032F8                          3506            
000032F8                          3507  CHECK_IMMEDIATE
000032F8  41F9 000040DA           3508            LEA     TEMP_REGISTER_FORMAT,A0
000032FE  1439 000040D9           3509            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003304  1082                    3510            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003306  0239 0080 000040DA      3511            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000330E  0C39 0080 000040DA      3512            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003316  6700 0026               3513            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000331A  0C06 0004               3514            CMPI.B  #4,D6                          
0000331E  6600 001E               3515            BNE     GET_SRC_FAILED 
00003322                          3516  
00003322                          3517            *IT IS A WORD AT THIS POINT*
00003322                          3518            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003322  163C 0020               3519            MOVE.B    #' ',D3
00003326  6100 048A               3520            BSR       PUSH_STACK
0000332A  163C 0023               3521            MOVE.B    #'#',D3
0000332E  6100 0482               3522            BSR       PUSH_STACK
00003332  321D                    3523            MOVE.W    (A5)+,D1
00003334  7404                    3524            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003336  6100 DEC2               3525            BSR       HEX2ASCII2STACK
0000333A  6000 0006               3526            BRA     GET_SRC_SUCCESS
0000333E                          3527            
0000333E                          3528  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
0000333E  7801                    3529            MOVE.L #1,D4
00003340  4E75                    3530            RTS
00003342                          3531  GET_SRC_SUCCESS 
00003342  4E75                    3532            RTS
00003344                          3533                                 
00003344                          3534      
00003344                          3535  
00003344                          3536  
00003344                          3537  
00003344                          3538  
00003344                          3539  
00003344                          3540  
00003344                          3541  GET_EA_EA_DEST
00003344                          3542  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003344                          3543      
00003344                          3544      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003344  2405                    3545      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003346  EC8A                    3546      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003348  23C2 000040EA           3547      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
0000334E  7407                    3548      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003350  C5B9 000040EA           3549      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003356                          3550                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003356                          3551      
00003356                          3552      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003356                          3553      *DESTINATION REGISTER FORMAT STANDARD         *
00003356                          3554      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003356                          3555      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003356                          3556      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003356                          3557      *0 - Dn                                       *
00003356                          3558      *1 - An                                       *
00003356                          3559      *2 - (An)                                     *
00003356                          3560      *3 - (An)+                                    *
00003356                          3561      *4 - -(An)                                    *
00003356                          3562      *5 - (XXX).W                                  *
00003356                          3563      *6 - (XXX).L                                  *
00003356                          3564      *7 - #<data>                                  *
00003356                          3565      ***********************************************
00003356                          3566      
00003356                          3567      *** Check if source ...  <ea> = Dn
00003356                          3568  DEST_CHECK0    
00003356  41F9 000040DA           3569            LEA     TEMP_REGISTER_FORMAT,A0
0000335C  1439 000040D8           3570            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003362  1082                    3571            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003364  0239 0001 000040DA      3572            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
0000336C  0C39 0001 000040DA      3573            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003374  6700 006A               3574            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003378  0CB9 00000000 000040EA  3575            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003382  6600 005C               3576            BNE     DEST_CHECK1
00003386                          3577            
00003386                          3578            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003386  163C 0020               3579            MOVE.B    #' ',D3
0000338A  6100 0426               3580            BSR       PUSH_STACK
0000338E  163C 0044               3581            MOVE.B    #'D',D3
00003392  6100 041E               3582            BSR       PUSH_STACK
00003396                          3583  
00003396                          3584            *FIND REGISTER NUMBER END LOCATION*  
00003396  13F9 000040DB 000040E2  3585            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000033A0  0239 000F 000040E2      3586            AND.B   #$0F,VAR_BYTE_END
000033A8                          3587            
000033A8                          3588            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000033A8  23C5 000040E6           3589            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000033AE  1439 000040E2           3590            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000033B4                          3591            
000033B4                          3592            *INTITIALIZE FOR BIT SHIFTING
000033B4  41F9 000040E6           3593            LEA     VAR_TEMP_CLEANCOPY,A0
000033BA  2639 000040E6           3594            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000033C0                          3595  DEST_LOOP_SHIFTING
000033C0  0C02 0000               3596            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000033C4  6700 0008               3597            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000033C8  E24B                    3598            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000033CA  5302                    3599            SUB.B   #1,D2                     *DECREMENT COUNTER
000033CC  60F2                    3600            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
000033CE                          3601  DEST_MASKING_NEXT
000033CE  C6BC 00000007           3602            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000033D4  0603 0030               3603            ADD.B   #$30,D3                   *CONVERT TO CHAR
000033D8  6100 03D8               3604            BSR     PUSH_STACK                *PUSH TO STACK
000033DC                          3605            
000033DC  6000 0394               3606            BRA     GET_DST_SUCCESS           *RETURN          
000033E0                          3607            
000033E0                          3608            
000033E0                          3609            *** Check if source ...  <ea> = An
000033E0                          3610  DEST_CHECK1    
000033E0  41F9 000040DA           3611            LEA     TEMP_REGISTER_FORMAT,A0
000033E6  1439 000040D8           3612            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000033EC  1082                    3613            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000033EE  0239 0002 000040DA      3614            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000033F6  0C39 0002 000040DA      3615            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000033FE  6700 006A               3616            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003402  0CB9 00000001 000040EA  3617            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
0000340C  6600 005C               3618            BNE     DEST_CHECK2
00003410                          3619            
00003410                          3620            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003410  163C 0020               3621            MOVE.B    #' ',D3
00003414  6100 039C               3622            BSR       PUSH_STACK
00003418  163C 0041               3623            MOVE.B    #'A',D3
0000341C  6100 0394               3624            BSR       PUSH_STACK
00003420                          3625  
00003420                          3626            
00003420                          3627            *FIND REGISTER NUMBER END LOCATION*  
00003420  13F9 000040DB 000040E2  3628            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000342A  0239 000F 000040E2      3629            AND.B   #$0F,VAR_BYTE_END
00003432                          3630            
00003432                          3631            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003432  23C5 000040E6           3632            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003438  1439 000040E2           3633            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000343E                          3634            
0000343E                          3635            *INTITIALIZE FOR BIT SHIFTING
0000343E  41F9 000040E6           3636            LEA     VAR_TEMP_CLEANCOPY,A0
00003444  2639 000040E6           3637            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000344A                          3638  DEST_LOOP_SHIFTING1
0000344A  0C02 0000               3639            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000344E  6700 0008               3640            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003452  E24B                    3641            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003454  5302                    3642            SUB.B   #1,D2                     *DECREMENT COUNTER
00003456  60F2                    3643            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003458                          3644  DEST_MASKING_NEXT1
00003458  C6BC 00000007           3645            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000345E  0603 0030               3646            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003462  6100 034E               3647            BSR     PUSH_STACK                *PUSH TO STACK
00003466                          3648            
00003466  6000 030A               3649            BRA     GET_DST_SUCCESS                   *RETURN 
0000346A                          3650            
0000346A                          3651            
0000346A                          3652            
0000346A                          3653            
0000346A                          3654            *** Check if source ...  <ea> = (An)       
0000346A                          3655  DEST_CHECK2    
0000346A  41F9 000040DA           3656            LEA     TEMP_REGISTER_FORMAT,A0
00003470  1439 000040D8           3657            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003476  1082                    3658            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003478  0239 0004 000040DA      3659            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003480  0C39 0004 000040DA      3660            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003488  6700 007A               3661            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000348C  0CB9 00000002 000040EA  3662            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003496  6600 006C               3663            BNE     DEST_CHECK3
0000349A                          3664            
0000349A                          3665            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000349A  163C 0020               3666            MOVE.B    #' ',D3
0000349E  6100 0312               3667            BSR       PUSH_STACK
000034A2  163C 0028               3668            MOVE.B    #'(',D3
000034A6  6100 030A               3669            BSR       PUSH_STACK
000034AA  163C 0041               3670            MOVE.B    #'A',D3
000034AE  6100 0302               3671            BSR       PUSH_STACK
000034B2                          3672  
000034B2                          3673            
000034B2                          3674            *FIND REGISTER NUMBER END LOCATION*  
000034B2  13F9 000040DB 000040E2  3675            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000034BC  0239 000F 000040E2      3676            AND.B   #$0F,VAR_BYTE_END
000034C4                          3677            
000034C4                          3678            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000034C4  23C5 000040E6           3679            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000034CA  1439 000040E2           3680            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000034D0                          3681            
000034D0                          3682            *INTITIALIZE FOR BIT SHIFTING
000034D0  41F9 000040E6           3683            LEA     VAR_TEMP_CLEANCOPY,A0
000034D6  2639 000040E6           3684            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000034DC                          3685  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000034DC  0C02 0000               3686            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000034E0  6700 0008               3687            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000034E4  E24B                    3688            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000034E6  5302                    3689            SUB.B   #1,D2                     *DECREMENT COUNTER
000034E8  60F2                    3690            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000034EA                          3691  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000034EA  0283 00000007           3692            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000034F0  0603 0030               3693            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000034F4  6100 02BC               3694            BSR     PUSH_STACK                *PUSH TO STACK
000034F8                          3695            
000034F8  163C 0029               3696            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000034FC  6100 02B4               3697            BSR       PUSH_STACK
00003500                          3698            
00003500  6000 0270               3699            BRA     GET_DST_SUCCESS                   *RETURN 
00003504                          3700  
00003504                          3701            
00003504                          3702            
00003504                          3703                      
00003504                          3704  *** Check if source ...  <ea> = (An)+       
00003504  41F9 000040DA           3705  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
0000350A  1439 000040D8           3706            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003510  1082                    3707            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003512  0239 0008 000040DA      3708            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
0000351A  0C39 0008 000040DA      3709            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003522  6700 0082               3710            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003526  0CB9 00000003 000040EA  3711            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003530  6600 0074               3712            BNE     DEST_CHECK4
00003534                          3713            
00003534                          3714            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003534  163C 0020               3715            MOVE.B    #' ',D3
00003538  6100 0278               3716            BSR       PUSH_STACK
0000353C  163C 0028               3717            MOVE.B    #'(',D3
00003540  6100 0270               3718            BSR       PUSH_STACK
00003544  163C 0041               3719            MOVE.B    #'A',D3
00003548  6100 0268               3720            BSR       PUSH_STACK
0000354C                          3721  
0000354C                          3722            
0000354C                          3723            *FIND REGISTER NUMBER END LOCATION*  
0000354C  13F9 000040DB 000040E2  3724            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003556  0239 000F 000040E2      3725            ANDI.B   #$0F,VAR_BYTE_END
0000355E                          3726            
0000355E                          3727            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000355E  23C5 000040E6           3728            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003564  1439 000040E2           3729            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000356A                          3730            
0000356A                          3731            *INTITIALIZE FOR BIT SHIFTING
0000356A  41F9 000040E6           3732            LEA     VAR_TEMP_CLEANCOPY,A0
00003570  2639 000040E6           3733            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003576                          3734            
00003576                          3735  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003576  0C02 0000               3736            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000357A  6700 0008               3737            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000357E  E24B                    3738            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003580  5302                    3739            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003582  60F2                    3740            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003584                          3741                                               *change: NAME OF LABEL*
00003584                          3742  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003584  0283 00000007           3743            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000358A  0603 0030               3744            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000358E  6100 0222               3745            BSR     PUSH_STACK                *PUSH TO STACK
00003592                          3746            
00003592  163C 0029               3747            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003596  6100 021A               3748            BSR       PUSH_STACK
0000359A  163C 002B               3749            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000359E  6100 0212               3750            BSR       PUSH_STACK
000035A2                          3751            
000035A2  6000 01CE               3752            BRA       GET_DST_SUCCESS                   *RETURN 
000035A6                          3753  
000035A6                          3754            
000035A6                          3755            
000035A6                          3756                      
000035A6                          3757            *** Check if source ...  <ea> = -(An)       
000035A6                          3758  DEST_CHECK4    
000035A6  41F9 000040DA           3759            LEA     TEMP_REGISTER_FORMAT,A0
000035AC  1439 000040D8           3760            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000035B2  1082                    3761            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000035B4  0239 0010 000040DA      3762            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000035BC  0C39 0010 000040DA      3763            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000035C4  6700 0082               3764            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000035C8  0CB9 00000004 000040EA  3765            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000035D2  6600 0074               3766            BNE     DEST_CHECK7
000035D6                          3767            
000035D6                          3768            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000035D6  163C 0020               3769            MOVE.B    #' ',D3
000035DA  6100 01D6               3770            BSR       PUSH_STACK
000035DE  163C 002D               3771            MOVE.B    #'-',D3
000035E2  6100 01CE               3772            BSR       PUSH_STACK
000035E6  163C 0028               3773            MOVE.B    #'(',D3
000035EA  6100 01C6               3774            BSR       PUSH_STACK
000035EE  163C 0041               3775            MOVE.B    #'A',D3
000035F2  6100 01BE               3776            BSR       PUSH_STACK
000035F6                          3777  
000035F6                          3778            
000035F6                          3779            *FIND REGISTER NUMBER END LOCATION*  
000035F6  13F9 000040DB 000040E2  3780            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003600  0239 000F 000040E2      3781            AND.B   #$0F,VAR_BYTE_END
00003608                          3782            
00003608                          3783            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003608  23C5 000040E6           3784            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000360E  1439 000040E2           3785            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003614                          3786            
00003614                          3787            *INTITIALIZE FOR BIT SHIFTING
00003614  41F9 000040E6           3788            LEA     VAR_TEMP_CLEANCOPY,A0
0000361A  2639 000040E6           3789            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003620                          3790            
00003620                          3791  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003620  0C02 0000               3792            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003624  6700 0008               3793            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003628  E24B                    3794            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000362A  5302                    3795            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000362C  60F2                    3796            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
0000362E                          3797                                               *change: NAME OF LABEL*
0000362E                          3798  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
0000362E  0283 00000007           3799            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003634  0603 0030               3800            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003638  6100 0178               3801            BSR     PUSH_STACK                *PUSH TO STACK
0000363C                          3802            
0000363C  163C 0029               3803            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003640  6100 0170               3804            BSR       PUSH_STACK
00003644                          3805            
00003644  6000 012C               3806            BRA     GET_DST_SUCCESS                   *RETURN
00003648                          3807            
00003648                          3808                      
00003648                          3809            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003648                          3810  DEST_CHECK7    
00003648  0CB9 00000007 000040EA  3811            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003652  6600 011A               3812            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003656                          3813                   
00003656                          3814            *NEXT: (MODE == 111) 
00003656                          3815            *NOW: CHECK FOR SRC REGISTER 
00003656                          3816                  *(000 = (xxx).W)
00003656                          3817                  *(001 = (xxx).L)
00003656                          3818                  *(010 = #<data>)
00003656                          3819                  
00003656                          3820            *FIND REGISTER NUMBER END LOCATION*  
00003656  13F9 000040DB 000040E2  3821            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003660  0239 000F 000040E2      3822            AND.B   #$0F,VAR_BYTE_END
00003668                          3823            
00003668                          3824            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003668  23C5 000040E6           3825            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000366E  1439 000040E2           3826            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003674                          3827            
00003674                          3828            *INTITIALIZE FOR BIT SHIFTING
00003674  41F9 000040E6           3829            LEA     VAR_TEMP_CLEANCOPY,A0
0000367A  2C39 000040E6           3830            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003680                          3831  DEST_LOOP_SHIFTING7
00003680  0C02 0000               3832            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003684  6700 0008               3833            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003688  E24E                    3834            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000368A  5302                    3835            SUB.B   #1,D2                     *DECREMENT COUNTER
0000368C  60F2                    3836            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
0000368E                          3837  DEST_MASKING_NEXT7
0000368E  CCBC 00000007           3838            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003694                          3839           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003694                          3840            
00003694                          3841  DEST_CHECK_WORD  
00003694  41F9 000040DA           3842            LEA     TEMP_REGISTER_FORMAT,A0
0000369A  1439 000040D8           3843            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036A0  1082                    3844            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036A2  0239 0020 000040DA      3845            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000036AA  0C39 0020 000040DA      3846            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000036B2  6700 0026               3847            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000036B6  0C06 0000               3848            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
000036BA  6600 001E               3849            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
000036BE                          3850            *IT IS A WORD AT THIS POINT*
000036BE                          3851            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000036BE  163C 0020               3852            MOVE.B    #' ',D3
000036C2  6100 00EE               3853            BSR       PUSH_STACK
000036C6  163C 0024               3854            MOVE.B    #'$',D3
000036CA  6100 00E6               3855            BSR       PUSH_STACK
000036CE  321D                    3856            MOVE.W    (A5)+,D1
000036D0  7404                    3857            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000036D2  6100 DB26               3858            BSR       HEX2ASCII2STACK
000036D6  6000 009A               3859            BRA       GET_DST_SUCCESS
000036DA                          3860  
000036DA                          3861  DEST_CHECK_LONG
000036DA  41F9 000040DA           3862            LEA     TEMP_REGISTER_FORMAT,A0
000036E0  1439 000040D8           3863            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036E6  1082                    3864            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036E8  0239 0040 000040DA      3865            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000036F0  0C39 0040 000040DA      3866            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000036F8  6700 002E               3867            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000036FC  0C06 0001               3868            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003700  6600 0026               3869            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003704                          3870            *IT IS A WORD AT THIS POINT*
00003704                          3871            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003704  163C 0020               3872            MOVE.B    #' ',D3
00003708  6100 00A8               3873            BSR       PUSH_STACK
0000370C  163C 0024               3874            MOVE.B    #'$',D3
00003710  6100 00A0               3875            BSR       PUSH_STACK
00003714  321D                    3876            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003716  7404                    3877            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003718  6100 DAE0               3878            BSR       HEX2ASCII2STACK
0000371C  321D                    3879            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
0000371E  7404                    3880            MOVE.L    #4,D2          
00003720  6100 DAD8               3881            BSR       HEX2ASCII2STACK
00003724  6000 004C               3882            BRA     GET_DST_SUCCESS
00003728                          3883            
00003728                          3884  DEST_CHECK_IMMEDIATE
00003728  41F9 000040DA           3885            LEA     TEMP_REGISTER_FORMAT,A0
0000372E  1439 000040D8           3886            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003734  1082                    3887            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003736  0239 0080 000040DA      3888            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000373E  0C39 0080 000040DA      3889            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003746  6700 0026               3890            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000374A  0C06 0004               3891            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
0000374E  6600 001E               3892            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003752                          3893            
00003752                          3894            *IT IS A WORD AT THIS POINT*
00003752                          3895            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003752  163C 0020               3896            MOVE.B    #' ',D3
00003756  6100 005A               3897            BSR       PUSH_STACK
0000375A  163C 0023               3898            MOVE.B    #'#',D3
0000375E  6100 0052               3899            BSR       PUSH_STACK
00003762  321D                    3900            MOVE.W    (A5)+,D1
00003764  7404                    3901            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003766  6100 DA92               3902            BSR       HEX2ASCII2STACK
0000376A  6000 0006               3903            BRA       GET_DST_SUCCESS
0000376E                          3904            
0000376E                          3905  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
0000376E  7801                    3906            MOVE.L #1,D4
00003770  4E75                    3907            RTS
00003772                          3908  GET_DST_SUCCESS 
00003772  4E75                    3909            RTS
00003774                          3910  
00003774                          3911  
00003774                          3912  *---------------------------------------------------------------------------*
00003774                          3913  * STACK/QUEUE INTERFACE
00003774                          3914  *---------------------------------------------------------------------------*
00003774                          3915  PRINT_STACK
00003774  0C39 0000 000040D4      3916            CMP.B     #0,COUNTER
0000377C  6700 000E               3917            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003780                          3918            
00003780                          3919  PRINT_STACK_HELPER
00003780  6100 0038               3920            BSR      POP_STACK          *PRINTS ADDRESS
00003784  103C 0006               3921            MOVE.B   #6,D0              *Display single character in D1.B. 
00003788  4E4F                    3922            TRAP     #15             *ACTIVATES PRINT
0000378A                          3923  
0000378A  60E8                    3924            BRA       PRINT_STACK
0000378C                          3925  PRINT_STACK_RETURN
0000378C  4E75                    3926            RTS
0000378E                          3927            
0000378E                          3928            
0000378E                          3929  PRINT_QUEUE
0000378E  0C39 0000 000040D4      3930            CMP.B     #0,COUNTER
00003796  6700 0018               3931            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
0000379A                          3932            
0000379A                          3933  PRINT_QUEUE_HELPER
0000379A  33F9 000040D4 000040D6  3934            MOVE.W   COUNTER,QUEUE_COUNTER
000037A4  6100 0022               3935            BSR      POP_FRONT          *PRINTS ADDRESS
000037A8  103C 0006               3936            MOVE.B   #6,D0              *Display single character in D1.B. 
000037AC  4E4F                    3937            TRAP     #15             *ACTIVATES PRINT
000037AE                          3938  
000037AE  60DE                    3939            BRA       PRINT_QUEUE
000037B0                          3940  PRINT_QUEUE_RETURN
000037B0  4E75                    3941            RTS
000037B2                          3942            
000037B2                          3943  *PUSHES.W CONTENTS OF [D3] INTO STACK          
000037B2                          3944  PUSH_STACK
000037B2  1503                    3945              MOVE.B  D3,-(A2)
000037B4  6100 0058               3946              BSR     INCREMENT
000037B8  4E75                    3947              RTS
000037BA                          3948  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
000037BA                          3949  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
000037BA                          3950  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
000037BA                          3951  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
000037BA                          3952  *         TRAP        #15             *ACTIVATES PRINT
000037BA                          3953  POP_STACK
000037BA  BECA                    3954              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
000037BC  6700 0008               3955              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
000037C0  121A                    3956              MOVE.B  (A2)+,D1 
000037C2  6100 0052               3957              BSR     DECREMENT
000037C6                          3958  POP_RETURN
000037C6  4E75                    3959              RTS 
000037C8                          3960        
000037C8                          3961  *USE [A4] AS SECOND POINTER IN SHIFTING      
000037C8  0C39 0000 000040D6      3962  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000037D0  6700 0030               3963              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
000037D4                          3964              
000037D4                          3965              
000037D4                          3966              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
000037D4  347C 7000               3967              MOVEA.W #STACK,A2   *START A2 AT STACK
000037D8  0622 0000               3968              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
000037DC  384A                    3969              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
000037DE  0624 0000               3970              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
000037E2  1212                    3971              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
000037E4                          3972  POP_SHIFT_LOOP
000037E4  0C39 0000 000040D6      3973              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000037EC  6700 0014               3974              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
000037F0  1494                    3975              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
000037F2  0624 0000               3976              ADD.B   #0,-(A4)
000037F6  0622 0000               3977              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
000037FA  5339 000040D6           3978              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003800                          3979              
00003800  60E2                    3980              BRA     POP_SHIFT_LOOP
00003802                          3981                          
00003802                          3982  POP_FRONT_RETURN 
00003802                          3983              *RESET A2 BACK TO SP
00003802  347C 7000               3984              MOVEA.W #STACK,A2    
00003806  5339 000040D4           3985              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
0000380C  4E75                    3986              RTS   
0000380E                          3987  
0000380E                          3988  INCREMENT
0000380E  5239 000040D4           3989              ADD.B   #1, COUNTER
00003814  4E75                    3990              RTS           
00003816                          3991  DECREMENT
00003816  5339 000040D4           3992              SUB.B   #1, COUNTER
0000381C  4E75                    3993              RTS           
0000381E                          3994  CLEAR_STACK
0000381E  0C39 0000 000040D4      3995              CMP.B     #0,COUNTER
00003826  6700 0006               3996              BEQ       CLEAR_RETURN
0000382A  618E                    3997              BSR       POP_STACK
0000382C  60F0                    3998              BRA       CLEAR_STACK
0000382E                          3999   
0000382E                          4000  CLEAR_RETURN
0000382E  4E75                    4001              RTS    
00003830                          4002  *---------------------------------------------------------------------------*
00003830                          4003  * TERMINATE
00003830                          4004  *---------------------------------------------------------------------------*
00003830                          4005  TERMINATE   
00003830  43F9 00003BE0           4006              LEA     FINMSG,A1
00003836  103C 000E               4007              MOVE.B  #14,D0
0000383A  4E4F                    4008              TRAP    #15
0000383C                          4009  
0000383C  103C 0009               4010              MOVE.B  #9,D0
00003840  4E4F                    4011              TRAP    #15
00003842                          4012  
00003842                          4013  *---------------------------------------------------------------------------*
00003842                          4014  * Data storage                                                 
00003842                          4015  *---------------------------------------------------------------------------*  
00003842                          4016  WELCOME
00003842= 20 20 20 20 20 20 ...   4017              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00003892= 3D 3D 3D 3D 3D 20 ...   4018              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
000038E2= 3D 3D 3D 3D 3D 20 ...   4019              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003932                          4020      
00003932= 20 20 20 20 20 20 ...   4021              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00003982= 20 20 20 20 20 20 ...   4022              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
000039D2= 20 20 20 20 20 20 ...   4023              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003A22                          4024      
00003A22= 20 20 20 20 20 20 ...   4025              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00003A72= 3D 3D 3D 3D 3D 20 ...   4026              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00003AC2= 3D 3D 3D 3D 3D 20 ...   4027              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003B17                          4028  
00003B17                          4029  PROMPT_START
00003B17= 50 6C 65 61 73 65 ...   4030              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00003B46                          4031      
00003B46                          4032  PROMPT_END
00003B46= 50 6C 65 61 73 65 ...   4033              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00003B73= 0D 0A 48 69 74 20 ...   4034  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00003B9D= 57 6F 75 6C 64 20 ...   4035  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003BE0= 54 68 61 6E 6B 20 ...   4036  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003C0B= 45 72 72 6F 72 3A ...   4037  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003C2A= 45 72 72 6F 72 3A ...   4038  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003C4F= 45 72 72 6F 72 3A ...   4039  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003C7C                          4040  
00003C7C                          4041  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003CCC                          4042  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003D1C                          4043  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003D20                          4044  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003D24= 0D 0A 00                4045  ENDLINE_M   DC.B    CR,LF,0
00003D27                          4046  TMPINPUT    DS.B    80                      * temp store user input
00003D77                          4047  TMPOUTPUT   DS.B    80                      * temp store prog output
00003DC7= 20 20 20 4F 52 49 ...   4048  DISP_ORI_B  DC.B    '   ORI.B',0
00003DD0= 20 20 20 4F 52 49 ...   4049  DISP_ORI_W  DC.B    '   ORI.W',0
00003DD9= 20 20 20 4F 52 49 ...   4050  DISP_ORI_L  DC.B    '   ORI.L',0
00003DE2= 20 20 20 45 4F 52 ...   4051  DISP_EORI_B  DC.B    '   EORI.B',0
00003DEC= 20 20 20 45 4F 52 ...   4052  DISP_EORI_W  DC.B    '   EORI.W',0
00003DF6= 20 20 20 45 4F 52 ...   4053  DISP_EORI_L  DC.B    '   EORI.L',0
00003E00= 20 20 20 42 54 53 ...   4054  DISP_BTST   DC.B    '   BTST',0
00003E08= 20 20 20 43 4D 50 ...   4055  DISP_CMPI_B  DC.B    '   CMPI.B',0
00003E12= 20 20 20 43 4D 50 ...   4056  DISP_CMPI_W  DC.B    '   CMPI.W',0
00003E1C= 20 20 20 43 4D 50 ...   4057  DISP_CMPI_L  DC.B    '   CMPI.L',0
00003E26= 20 20 20 44 41 54 ...   4058  DISP_DATA   DC.B    '   DATA',0
00003E2E= 20 20 20 4D 4F 56 ...   4059  DISP_MOVE_B DC.B    '   MOVE.B',0
00003E38= 20 20 20 4D 4F 56 ...   4060  DISP_MOVE_W DC.B    '   MOVE.W',0
00003E42= 20 20 20 4D 4F 56 ...   4061  DISP_MOVE_L DC.B    '   MOVE.L',0
00003E4C= 20 20 20 52 54 53 00    4062  DISP_RTS    DC.B    '   RTS',0
00003E53= 20 20 20 4A 53 52 00    4063  DISP_JSR    DC.B    '   JSR',0
00003E5A= 20 20 20 4E 45 47 ...   4064  DISP_NEG_B    DC.B    '   NEG.B',0
00003E63= 20 20 20 4E 45 47 ...   4065  DISP_NEG_W    DC.B    '   NEG.W',0
00003E6C= 20 20 20 4E 45 47 ...   4066  DISP_NEG_L    DC.B    '   NEG.L',0
00003E75= 20 20 20 4E 4F 54 ...   4067  DISP_NOT_B  DC.B    '   NOT.B',0
00003E7E= 20 20 20 4E 4F 54 ...   4068  DISP_NOT_W  DC.B    '   NOT.W',0
00003E87= 20 20 20 4E 4F 54 ...   4069  DISP_NOT_L  DC.B    '   NOT.L',0
00003E90= 20 20 20 4C 45 41 00    4070  DISP_LEA    DC.B    '   LEA',0
00003E97= 20 20 20 4D 4F 56 ...   4071  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00003EA2= 20 20 20 4D 4F 56 ...   4072  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00003EAD= 20 20 20 41 44 44 ...   4073  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00003EB7= 20 20 20 41 44 44 ...   4074  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00003EC1= 20 20 20 41 44 44 ...   4075  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00003ECB= 20 20 20 44 49 56 ...   4076  DISP_DIVS   DC.B    '   DIVS',0
00003ED3= 20 20 20 53 55 42 ...   4077  DISP_SUB_B  DC.B    '   SUB.B',0
00003EDC= 20 20 20 53 55 42 ...   4078  DISP_SUB_W  DC.B    '   SUB.W',0
00003EE5= 20 20 20 53 55 42 ...   4079  DISP_SUB_L  DC.B    '   SUB.L',0
00003EEE= 20 20 20 53 55 42 ...   4080  DISP_SUBI_B  DC.B    '   SUBI.B',0
00003EF8= 20 20 20 53 55 42 ...   4081  DISP_SUBI_W  DC.B    '   SUBI.W',0
00003F02= 20 20 20 53 55 42 ...   4082  DISP_SUBI_L  DC.B    '   SUBI.L',0
00003F0C= 20 20 20 53 55 42 ...   4083  DISP_SUBA_W  DC.B    '   SUBA.W',0
00003F16= 20 20 20 53 55 42 ...   4084  DISP_SUBA_L  DC.B    '   SUBA.L',0
00003F20= 20 20 20 45 4F 52 ...   4085  DISP_EOR_B  DC.B    '   EOR.B',0
00003F29= 20 20 20 45 4F 52 ...   4086  DISP_EOR_W  DC.B    '   EOR.W',0
00003F32= 20 20 20 45 4F 52 ...   4087  DISP_EOR_L  DC.B    '   EOR.L',0
00003F3B= 20 20 20 43 4D 50 ...   4088  DISP_CMP_B  DC.B    '   CMP.B',0
00003F44= 20 20 20 43 4D 50 ...   4089  DISP_CMP_W  DC.B    '   CMP.W',0
00003F4D= 20 20 20 43 4D 50 ...   4090  DISP_CMP_L  DC.B    '   CMP.L',0
00003F56= 20 20 20 43 4D 50 ...   4091  DISP_CMPA_W  DC.B    '   CMPA.W',0
00003F60= 20 20 20 43 4D 50 ...   4092  DISP_CMPA_L  DC.B    '   CMPA.L',0
00003F6A= 20 20 20 4D 55 4C ...   4093  DISP_MULS_W DC.B    '   MULS.W',0
00003F74= 20 20 20 41 4E 44 ...   4094  DISP_AND_B  DC.B    '   AND.B',0
00003F7D= 20 20 20 41 4E 44 ...   4095  DISP_AND_W  DC.B    '   AND.W',0
00003F86= 20 20 20 41 4E 44 ...   4096  DISP_AND_L  DC.B    '   AND.L',0
00003F8F= 20 20 20 41 44 44 ...   4097  DISP_ADD_B  DC.B    '   ADD.B',0
00003F98= 20 20 20 41 44 44 ...   4098  DISP_ADD_W  DC.B    '   ADD.W',0
00003FA1= 20 20 20 41 44 44 ...   4099  DISP_ADD_L  DC.B    '   ADD.L',0
00003FAA= 20 20 20 41 44 44 ...   4100  DISP_ADDA_W DC.B    '   ADDA.W',0
00003FB4= 20 20 20 41 44 44 ...   4101  DISP_ADDA_L DC.B    '   ADDA.L',0
00003FBE= 20 20 20 4C 53 52 ...   4102  DISP_LSR_B  DC.B    '   LSR.B',0
00003FC7= 20 20 20 4C 53 4C ...   4103  DISP_LSL_B  DC.B    '   LSL.B',0
00003FD0= 20 20 20 4C 53 52 ...   4104  DISP_LSR_W  DC.B    '   LSR.W',0
00003FD9= 20 20 20 4C 53 4C ...   4105  DISP_LSL_W  DC.B    '   LSL.W',0
00003FE2= 20 20 20 4C 53 52 ...   4106  DISP_LSR_L  DC.B    '   LSR.L',0
00003FEB= 20 20 20 4C 53 4C ...   4107  DISP_LSL_L  DC.B    '   LSL.L',0
00003FF4= 20 20 20 41 53 52 ...   4108  DISP_ASR_B  DC.B    '   ASR.B',0
00003FFD= 20 20 20 41 53 4C ...   4109  DISP_ASL_B  DC.B    '   ASL.B',0
00004006= 20 20 20 41 53 52 ...   4110  DISP_ASR_W  DC.B    '   ASR.W',0
0000400F= 20 20 20 41 53 4C ...   4111  DISP_ASL_W  DC.B    '   ASL.W',0
00004018= 20 20 20 41 53 52 ...   4112  DISP_ASR_L  DC.B    '   ASR.L',0
00004021= 20 20 20 41 53 4C ...   4113  DISP_ASL_L  DC.B    '   ASL.L',0
0000402A= 20 20 20 52 4F 52 ...   4114  DISP_ROR_B  DC.B    '   ROR.B',0
00004033= 20 20 20 52 4F 4C ...   4115  DISP_ROL_B  DC.B    '   ROL.B',0
0000403C= 20 20 20 52 4F 52 ...   4116  DISP_ROR_W  DC.B    '   ROR.W',0
00004045= 20 20 20 52 4F 4C ...   4117  DISP_ROL_W  DC.B    '   ROL.W',0
0000404E= 20 20 20 52 4F 52 ...   4118  DISP_ROR_L  DC.B    '   ROR.L',0
00004057= 20 20 20 52 4F 4C ...   4119  DISP_ROL_L  DC.B    '   ROL.L',0
00004060= 20 20 20 42 52 41 00    4120  DISP_BRA    DC.B    '   BRA',0
00004067= 20 20 20 42 4C 54 00    4121  DISP_BLT    DC.B    '   BLT',0
0000406E= 20 20 20 42 45 51 00    4122  DISP_BEQ    DC.B    '   BEQ',0
00004075= 20 20 20 42 4E 45 00    4123  DISP_BNE    DC.B    '   BNE',0
0000407C= 20 20 20 42 48 49 00    4124  DISP_BHI    DC.B    '   BHI',0
00004083= 20 20 20 4D 4F 56 ...   4125  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
0000408E= 20 20 20 4D 4F 56 ...   4126  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004099                          4127  
00004099= 20 20 20 24 00          4128  DISP_HEX     DC.B    '   $',0
0000409E= 20 20 20 44 00          4129  DISP_D  DC.B    '   D',0
000040A3= 20 20 20 41 00          4130  DISP_A  DC.B    '   A',0
000040A8= 20 20 20 28 00          4131  DISP_OP  DC.B    '   (',0
000040AD= 29 00                   4132  DISP_CP  DC.B   ')',0
000040AF= 20 20 20 28 41 00       4133  DISP_AOP  DC.B    '   (A',0
000040B5                          4134  
000040B5= 20 20 20 2D 28 41 00    4135  DISP_PRE    DC.B    '   -(A',0
000040BC= 29 2B 00                4136  DISP_POST   DC.B    ')+',0
000040BF= 20 20 20 23 00          4137  DISP_LB DC.B    '   #',0
000040C4= 30 00                   4138  DISP_0  DC.B    '0',0
000040C6= 31 00                   4139  DISP_1  DC.B    '1',0
000040C8= 32 00                   4140  DISP_2  DC.B    '2',0
000040CA= 33 00                   4141  DISP_3  DC.B    '3',0
000040CC= 34 00                   4142  DISP_4  DC.B    '4',0
000040CE= 35 00                   4143  DISP_5  DC.B    '5',0
000040D0= 36 00                   4144  DISP_6  DC.B    '6',0
000040D2= 37 00                   4145  DISP_7  DC.B    '7',0
000040D4                          4146  
000040D4                          4147  *STACK INTERFACE VARIABLES*
000040D4                          4148  COUNTER         DS.W    1
000040D6                          4149  QUEUE_COUNTER   DS.W    1
000040D8                          4150  
000040D8                          4151  *EA DECODING INTERFACE VARIABLES* 
000040D8                          4152  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
000040D9                          4153  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
000040DA                          4154  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
000040DB                          4155  
000040DB                          4156  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
000040DB                          4157  * WORD + WORD = LONG
000040DB                          4158  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
000040DB                          4159  * A              + F            = AF         <= EXAMPLE
000040DB                          4160  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
000040DB                          4161  GET_DST_START_END    DS.B    1
000040DC                          4162  GET_SRC_START_END    DS.B    1
000040DD                          4163  
000040DD                          4164  *STORES THE START + END BITS HERE (FROM ABOVE)
000040DE                          4165  VAR_BYTE_START      DS.L    1
000040E2                          4166  VAR_BYTE_END        DS.L    1
000040E6                          4167  VAR_TEMP_CLEANCOPY  DS.L    1
000040EA                          4168  
000040EA                          4169  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
000040EE                          4170  
000040EE                          4171  *MORE FOR STACK USAGE*
000040EE= 2C 00                   4172  DISP_COMMA  DC.B    ',',0
000040F0= 20 20 20 00             4173  DISP_INDENT  DC.B    '   ',0
000040F4                          4174  
000040F4                          4175  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
000040F4                          4176  POINTER_WORD    DS.W       1
000040F6                          4177  
000040F6                          4178  
000040F6                          4179  
000040F6                          4180  *---------------------------------------------------------------------------*
000040F6                          4181  * Ends program
000040F6                          4182  *---------------------------------------------------------------------------*
000040F6                          4183              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1156
ASCII2HEX           1150
ASC_ERR             11B2
ASC_LOW             1194
ASC_NUM             11A4
ASC_SFT             11AC
ASC_UPP             119C
CHECK0              2F26
CHECK1              2FB0
CHECK2              303A
CHECK3              30D4
CHECK4              3176
CHECK7              3218
CHECK_IMMEDIATE     32F8
CHECK_LONG          32AA
CHECK_WORD          3264
CLEAR_RETURN        382E
CLEAR_STACK         381E
COUNTER             40D4
CR                  D
DECREMENT           3816
DEST_CHECK0         3356
DEST_CHECK1         33E0
DEST_CHECK2         346A
DEST_CHECK3         3504
DEST_CHECK4         35A6
DEST_CHECK7         3648
DEST_CHECK_IMMEDIATE  3728
DEST_CHECK_LONG     36DA
DEST_CHECK_WORD     3694
DEST_LOOP_SHIFTING  33C0
DEST_LOOP_SHIFTING1  344A
DEST_LOOP_SHIFTING2  34DC
DEST_LOOP_SHIFTING3  3576
DEST_LOOP_SHIFTING4  3620
DEST_LOOP_SHIFTING7  3680
DEST_MASKING_NEXT   33CE
DEST_MASKING_NEXT1  3458
DEST_MASKING_NEXT2  34EA
DEST_MASKING_NEXT3  3584
DEST_MASKING_NEXT4  362E
DEST_MASKING_NEXT7  368E
DEST_MODE           2ADE
DEST_REGISTER       2DAE
DEST_REGISTER_FORMAT  40D8
DISPLAY_30_LINES    12FE
DISP_0              40C4
DISP_1              40C6
DISP_2              40C8
DISP_3              40CA
DISP_4              40CC
DISP_5              40CE
DISP_6              40D0
DISP_7              40D2
DISP_A              40A3
DISP_ADDA_L         3FB4
DISP_ADDA_W         3FAA
DISP_ADDQ_B         3EAD
DISP_ADDQ_L         3EC1
DISP_ADDQ_W         3EB7
DISP_ADD_B          3F8F
DISP_ADD_L          3FA1
DISP_ADD_W          3F98
DISP_AND_B          3F74
DISP_AND_L          3F86
DISP_AND_W          3F7D
DISP_AOP            40AF
DISP_ASL_B          3FFD
DISP_ASL_L          4021
DISP_ASL_W          400F
DISP_ASR_B          3FF4
DISP_ASR_L          4018
DISP_ASR_W          4006
DISP_BEQ            406E
DISP_BHI            407C
DISP_BLT            4067
DISP_BNE            4075
DISP_BRA            4060
DISP_BTST           3E00
DISP_CMPA_L         3F60
DISP_CMPA_W         3F56
DISP_CMPI_B         3E08
DISP_CMPI_L         3E1C
DISP_CMPI_W         3E12
DISP_CMP_B          3F3B
DISP_CMP_L          3F4D
DISP_CMP_W          3F44
DISP_COMMA          40EE
DISP_CP             40AD
DISP_D              409E
DISP_DATA           3E26
DISP_DIVS           3ECB
DISP_EORI_B         3DE2
DISP_EORI_L         3DF6
DISP_EORI_W         3DEC
DISP_EOR_B          3F20
DISP_EOR_L          3F32
DISP_EOR_W          3F29
DISP_HEX            4099
DISP_INDENT         40F0
DISP_JSR            3E53
DISP_LB             40BF
DISP_LEA            3E90
DISP_LSL_B          3FC7
DISP_LSL_L          3FEB
DISP_LSL_W          3FD9
DISP_LSR_B          3FBE
DISP_LSR_L          3FE2
DISP_LSR_W          3FD0
DISP_MOVEA_L        408E
DISP_MOVEA_W        4083
DISP_MOVEM_L        3EA2
DISP_MOVEM_W        3E97
DISP_MOVE_B         3E2E
DISP_MOVE_L         3E42
DISP_MOVE_W         3E38
DISP_MULS_W         3F6A
DISP_NEG_B          3E5A
DISP_NEG_L          3E6C
DISP_NEG_W          3E63
DISP_NEXT           3B73
DISP_NOT_B          3E75
DISP_NOT_L          3E87
DISP_NOT_W          3E7E
DISP_OP             40A8
DISP_ORI_B          3DC7
DISP_ORI_L          3DD9
DISP_ORI_W          3DD0
DISP_POST           40BC
DISP_PRE            40B5
DISP_ROL_B          4033
DISP_ROL_L          4057
DISP_ROL_W          4045
DISP_ROR_B          402A
DISP_ROR_L          404E
DISP_ROR_W          403C
DISP_RTS            3E4C
DISP_SUBA_L         3F16
DISP_SUBA_W         3F0C
DISP_SUBI_B         3EEE
DISP_SUBI_L         3F02
DISP_SUBI_W         3EF8
DISP_SUB_B          3ED3
DISP_SUB_L          3EE5
DISP_SUB_W          3EDC
D_MODE000           2B80
D_MODE010           2BC8
D_MODE011           2C28
D_MODE100           2C48
D_MODE111           2C9A
EA_ARITH            2A78
EA_DATA             14DC
EA_GEN              2AC4
EA_MOVEA            2A9E
EA_NOSRC            2A64
ENDLINE_M           3D24
END_ADDR            109C
ERRMSG_1            3C0B
ERRMSG_3            3C2A
ERRMSG_5            3C4F
ERROR_1             1100
ERROR_2             1110
ERROR_3             1120
ERROR_4             1130
ERROR_5             1140
E_ADDR_HX           3D20
FINMSG              3BE0
GET_DST_FAILED      376E
GET_DST_START_END   40DB
GET_DST_SUCCESS     3772
GET_EA_EA_DEST      3344
GET_EA_EA_SRC       2F14
GET_SRC_FAILED      333E
GET_SRC_START_END   40DC
GET_SRC_SUCCESS     3342
HEX2ASCII           11B8
HEX2ASCII2STACK     11FA
HEX_CHAR            11E6
HEX_CONT            11EA
HEX_LOOP            11CC
IMMD_B              2D4E
IMMD_L              2D8E
IMMD_W              2D6E
IMMEDIATE           2D1E
INCREMENT           380E
INTRO               1028
IS_ODD              123E
IS_ODD_ERR          1254
JMPTABLE            132A
LF                  A
LONGMODE            2CF2
LOOP_SHIFTING       2F90
LOOP_SHIFTING1      301A
LOOP_SHIFTING2      30AC
LOOP_SHIFTING3      3146
LOOP_SHIFTING4      31F0
MAIN                125A
MASKING_NEXT        2F9E
MASKING_NEXT1       3028
MASKING_NEXT2       30BA
MASKING_NEXT3       3154
MASKING_NEXT4       31FE
MODE000             2B6C
MODE001             2B94
MODE010             2BA8
MODE011             2BE8
MODE100             2C08
MODE111             2C68
NEXTLINES           130C
OP0000              138A
OP0001              15B0
OP0010              161E
OP0011              171C
OP0100              1818
OP0101              19B2
OP0110              1A2E
OP0111              1ABC
OP1000              1AC0
OP1000_DIVS_DN_EA_OR_EA_DN  1ACE
OP1000_DIVS_RETURN  1BB2
OP1000_EA_DN_DIVS   1AFC
OP1000_PRINT_L_DIVS  1B6A
OP1000_PRINT_W_DIVS  1B22
OP1001              1BC8
OP1001_ADD_RETURN   1F16
OP1001_DETERMINE_DN_EA_OR_EA_DN  1CDE
OP1001_DN_EA        1D16
OP1001_EA_DN        1E16
OP1001_PRINT_B      1E3E
OP1001_PRINT_B2     1D3E
OP1001_PRINT_L      1ECE
OP1001_PRINT_L2     1DCE
OP1001_PRINT_W      1E86
OP1001_PRINT_W2     1D86
OP1001_SUBA_L       1BFA
OP1001_SUBA_W       1C6C
OP1010              1F84
OP1011              1F88
OP1100              2084
OP1100_AND_RETURN   23D4
OP1100_DETERMINE_DN_EA_OR_EA_DN  219A
OP1100_DN_EA        21D4
OP1100_EA_DN        22D4
OP1100_EA_DN_MULS   20E2
OP1100_MULS_DN_EA_OR_EA_DN  20B4
OP1100_MULS_RETURN  2198
OP1100_PRINT_B      22FC
OP1100_PRINT_B2     21FC
OP1100_PRINT_L      238C
OP1100_PRINT_L2     228C
OP1100_PRINT_L_MULS  2150
OP1100_PRINT_W      2344
OP1100_PRINT_W2     2244
OP1100_PRINT_W_MULS  2108
OP1101              23D6
OP1101_ADDA_L       2408
OP1101_ADDA_W       247A
OP1101_ADD_RETURN   2724
OP1101_DETERMINE_DN_EA_OR_EA_DN  24EC
OP1101_DN_EA        2524
OP1101_EA_DN        2624
OP1101_PRINT_B      264C
OP1101_PRINT_B2     254C
OP1101_PRINT_L      26DC
OP1101_PRINT_L2     25DC
OP1101_PRINT_W      2694
OP1101_PRINT_W2     2594
OP1110              27B2
OP1111              2A60
OP_ADDA_L           279A
OP_ADDA_W           2782
OP_ADDQ             19D2
OP_ADDQ_B           19F8
OP_ADDQ_L           1A1C
OP_ADDQ_W           1A0A
OP_ADD_B            273A
OP_ADD_L            276A
OP_ADD_W            2752
OP_ASL              2952
OP_ASL_B            2976
OP_ASL_L            2988
OP_ASL_W            299A
OP_ASR              28F8
OP_ASR_B            291C
OP_ASR_L            292E
OP_ASR_W            2940
OP_ASX              2814
OP_BEQ              1A92
OP_BHI              1A76
OP_BLT              1AAE
OP_BNE              1A84
OP_BRA              1AA0
OP_BTST             13FE
OP_CMPA_L           1FF4
OP_CMPA_W           1FE2
OP_CMPI             1504
OP_CMPI_B           1524
OP_CMPI_L           1548
OP_CMPI_W           1536
OP_CMP_B            2006
OP_CMP_L            2036
OP_CMP_W            201E
OP_DATA             14B8
OP_DIVS             1BB4
OP_EORI             140C
OP_EORI_B           142C
OP_EORI_L           1450
OP_EORI_W           143E
OP_EOR_B            204E
OP_EOR_L            2072
OP_EOR_W            2060
OP_JSR              1990
OP_LEA              18BE
OP_LSL              289E
OP_LSL_B            28C2
OP_LSL_L            28D4
OP_LSL_W            28E6
OP_LSR              2844
OP_LSR_B            2868
OP_LSR_L            287A
OP_LSR_W            288C
OP_LSX              27FC
OP_MOVEA_L          16AC
OP_MOVEA_W          17A8
OP_MOVEM_L          18AC
OP_MOVEM_W          189A
OP_MOVE_B           15B6
OP_MOVE_L           1644
OP_MOVE_W           1740
OP_MULS             20A6
OP_NEG              18D2
OP_NEG_B            18F2
OP_NEG_L            1922
OP_NEG_W            190A
OP_NOT              193A
OP_NOT_B            195A
OP_NOT_L            197E
OP_NOT_W            196C
OP_ORI              155A
OP_ORI_B            157A
OP_ORI_L            159E
OP_ORI_W            158C
OP_ROL              2A06
OP_ROL_B            2A2A
OP_ROL_L            2A3C
OP_ROL_W            2A4E
OP_ROR              29AC
OP_ROR_B            29D0
OP_ROR_L            29E2
OP_ROR_W            29F4
OP_ROX              282C
OP_RTS              19A4
OP_SUBA_L           1F72
OP_SUBA_W           1F60
OP_SUBI             1462
OP_SUBI_B           1482
OP_SUBI_L           14A6
OP_SUBI_W           1494
OP_SUB_B            1F18
OP_SUB_L            1F48
OP_SUB_W            1F30
OUTPUT_PROCESSED_DATA  12DE
POINTER_WORD        40F4
POP_FRONT           37C8
POP_FRONT_RETURN    3802
POP_RETURN          37C6
POP_SHIFT_LOOP      37E4
POP_STACK           37BA
PRINT_QUEUE         378E
PRINT_QUEUE_HELPER  379A
PRINT_QUEUE_RETURN  37B0
PRINT_STACK         3774
PRINT_STACK_HELPER  3780
PRINT_STACK_RETURN  378C
PROGLP              100A
PROMPT_END          3B46
PROMPT_START        3B17
PUSH_STACK          37B2
QUEUE_COUNTER       40D6
REG_0               2E62
REG_1               2E70
REG_2               2E7E
REG_3               2E8C
REG_4               2E9A
REG_5               2EA8
REG_6               2EB6
REG_7               2EC4
REPEAT              2ED2
REPEATMSG           3B9D
RETURN              11B6
SRC_LOOP_SHIFTING   3250
SRC_MASKING_NEXT    325E
SRC_MODE            2B22
SRC_REGISTER        2E0A
SRC_REGISTER_FORMAT  40D9
STACK               7000
STACK_HEX_CHAR      1228
STACK_HEX_CONT      122C
STACK_HEX_LOOP      120E
START               1004
START_ADDR          104A
S_ADDR_HX           3D1C
TEMP_REGISTER_FORMAT  40DA
TERMINATE           3830
TESTING             1036
TMPINPUT            3D27
TMPOUTPUT           3D77
VAR_BYTE_END        40E2
VAR_BYTE_START      40DE
VAR_LONG_ADDRESS_MODE_CHECK  40EA
VAR_TEMP_CLEANCOPY  40E6
VR_E_ADDR           3CCC
VR_S_ADDR           3C7C
WELCOME             3842
WORDMODE            2CC6
