00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 2:21:06 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 0000104A             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109C             38              JSR     END_ADDR
00001016  43F9 00003F08             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 0000125A             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003A26             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036                            53              
00001036  4681                      54           NOT.L   D1
00001038  4692                      55              NOT.L   (A2)
0000103A  469B                      56              NOT.L   (A3)+
0000103C  46A4                      57              NOT.L   -(A4)
0000103E  46B8 1234                 58              NOT.L   $1234
00001042  46B9 56768987             59              NOT.L   $56768987
00001048                            60              
00001048                            61  
00001048                            62  
00001048                            63  
00001048  4E75                      64              RTS
0000104A                            65  *---------------------------------------------------------------------------*
0000104A                            66  * START_ADDR: Compute the starting address
0000104A                            67  *---------------------------------------------------------------------------*
0000104A                            68  START_ADDR
0000104A                            69              * Output
0000104A  43F9 00003CFB             70              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001050  103C 000E                 71              MOVE.B  #14,D0                  * Display PROMPT_START
00001054  4E4F                      72              TRAP    #15
00001056                            73      
00001056                            74              * Input
00001056  43F9 00003E60             75              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105C  103C 0002                 76              MOVE.B  #2,D0                   * Ask user for input
00001060  4E4F                      77              TRAP    #15
00001062                            78              
00001062                            79              * Error Checking (length)
00001062  0C01 0000                 80              CMPI.B  #0, D1                  * Check if input length <= 0
00001066  6F00 0098                 81              BLE     ERROR_1
0000106A  0C01 0008                 82              CMPI.B  #8, D1                  * Check if input length > 8
0000106E  6E00 0090                 83              BGT     ERROR_1
00001072                            84              
00001072                            85              * Conversion & Storage
00001072  4EB9 00001150             86              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001078  0C07 0001                 87              CMPI.B  #1, D7                  * Check for error
0000107C  6700 0082                 88              BEQ     ERROR_1                 
00001080  23C1 00003F00             89              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001086                            90              
00001086                            91              * Error Checking (Odd)
00001086  43F9 00003F00             92              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108C  4EB9 0000123E             93              JSR     IS_ODD                  * Check if the input address is odd
00001092  0C07 0001                 94              CMPI.B  #1, D7                  * Check for error
00001096  6700 0088                 95              BEQ     ERROR_3
0000109A                            96              
0000109A                            97              * Return
0000109A  4E75                      98              RTS     
0000109C                            99  *---------------------------------------------------------------------------*
0000109C                           100  * END_ADDR: Compute the ending address
0000109C                           101  *---------------------------------------------------------------------------*
0000109C                           102  END_ADDR
0000109C                           103              * Output
0000109C  43F9 00003D2A            104              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A2  103C 000E                105              MOVE.B  #14,D0                  * Display PROMPT_END
000010A6  4E4F                     106              TRAP    #15
000010A8                           107  
000010A8                           108              * Input
000010A8  43F9 00003EB0            109              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AE  103C 0002                110              MOVE.B  #2,D0                   * Ask user for input
000010B2  4E4F                     111              TRAP    #15
000010B4                           112              
000010B4                           113              * Error Checking (length)
000010B4  0C01 0000                114              CMPI.B  #0, D1                  * Check if input length <= 0
000010B8  6F00 0056                115              BLE     ERROR_2
000010BC  0C01 0008                116              CMPI.B  #8, D1                  * Check if input length > 8
000010C0  6E00 004E                117              BGT     ERROR_2
000010C4                           118              
000010C4                           119              * Conversion & Storage
000010C4  4EB9 00001150            120              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010CA  0C07 0001                121              CMPI.B  #1, D7                  * Check for error
000010CE  6700 0040                122              BEQ     ERROR_2
000010D2  23C1 00003F04            123              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D8                           124              
000010D8                           125              * Error Checking (start > end case)
000010D8  2439 00003F00            126              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DE  B282                     127              CMP.L   D2, D1                  * Compare starting and ending address
000010E0  6300 005E                128              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E4                           129              
000010E4                           130              * Error Checking (Odd case)
000010E4  43F9 00003F04            131              LEA     E_ADDR_HX, A1           * Move the ending address
000010EA  4EB9 0000123E            132              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010F0  0C07 0001                133              CMPI.B  #1, D7                  * Check for an error flag
000010F4  6700 003A                134              BEQ     ERROR_4
000010F8                           135              
000010F8                           136              * Inputs are valid
000010F8  2A79 00003F00            137              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FE                           138              
000010FE  4E75                     139              RTS
00001100                           140              
00001100                           141  *---------------------------------------------------------------------------*
00001100                           142  * ERROR_1: Address error (Invalid starting address)
00001100                           143  *---------------------------------------------------------------------------*
00001100                           144  ERROR_1
00001100  43F9 00003DEF            145              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001106  103C 000E                146              MOVE.B  #14, D0                 * Display ERRMSG_1
0000110A  4E4F                     147              TRAP    #15
0000110C  4EF8 104A                148              JMP     START_ADDR              * Jump to START_ADDR
00001110                           149      
00001110                           150  *---------------------------------------------------------------------------*
00001110                           151  * ERROR_2: Address error (Invalid ending address)
00001110                           152  *---------------------------------------------------------------------------*
00001110                           153  ERROR_2
00001110  43F9 00003DEF            154              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001116  103C 000E                155              MOVE.B  #14, D0                 * Display ERRMSG_1
0000111A  4E4F                     156              TRAP    #15
0000111C  4EF8 109C                157              JMP     END_ADDR                * Jump to END_ADDR
00001120                           158  
00001120                           159  *---------------------------------------------------------------------------*
00001120                           160  * ERROR_3: Address error (Odd starting address)
00001120                           161  *---------------------------------------------------------------------------*
00001120                           162  ERROR_3
00001120  43F9 00003E0E            163              LEA     ERRMSG_3, A1
00001126  103C 000E                164              MOVE.B  #14, D0
0000112A  4E4F                     165              TRAP    #15
0000112C  4EF8 104A                166              JMP     START_ADDR
00001130                           167     
00001130                           168  *---------------------------------------------------------------------------*
00001130                           169  * ERROR_4: Address error (Odd ending address)
00001130                           170  *---------------------------------------------------------------------------*         
00001130                           171  ERROR_4
00001130  43F9 00003E0E            172              LEA     ERRMSG_3, A1
00001136  103C 000E                173              MOVE.B  #14, D0
0000113A  4E4F                     174              TRAP    #15
0000113C  4EF8 109C                175              JMP     END_ADDR
00001140                           176            
00001140                           177  *---------------------------------------------------------------------------*
00001140                           178  * ERROR_3: Address error (Ending address is less than starting address)
00001140                           179  *---------------------------------------------------------------------------*
00001140                           180  ERROR_5
00001140  43F9 00003E33            181              LEA     ERRMSG_5, A1
00001146  103C 000E                182              MOVE.B  #14, D0
0000114A  4E4F                     183              TRAP    #15
0000114C  4EF8 109C                184              JMP     END_ADDR
00001150                           185    
00001150                           186  *---------------------------------------------------------------------------*
00001150                           187  * ASCII2HEX: Convert ASCii to Hexadecimal
00001150                           188  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001150                           189  *---------------------------------------------------------------------------*
00001150  4281                     190  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001152  4287                     191              CLR.L   D7                      * Set the error flag to 0
00001154  4282                     192              CLR.L   D2                      * Clear D2 for temp storage
00001156                           193              
00001156  1419                     194  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001158  0C02 0000                195              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115C  6700 0058                196              BEQ     RETURN                  * If it's NULL, go to return
00001160  0C02 0066                197              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001164  6E00 004C                198              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001168  0C02 0061                199              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116C  6C00 0026                200              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001170  0C02 0046                201              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001174  6E00 003C                202              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001178  0C02 0041                203              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117C  6C00 001E                204              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001180  0C02 0039                205              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001184  6E00 002C                206              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001188  0C02 0030                207              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118C  6C00 0016                208              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
00001190  6000 0020                209              BRA     ASC_ERR                 * Invalid input
00001194                           210  
00001194  0442 0057                211  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001198  6000 0012                212              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119C                           213              
0000119C  0442 0037                214  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011A0  6000 000A                215              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A4                           216              
000011A4  0442 0030                217  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A8  6000 0002                218              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AC                           219              
000011AC  E981                     220  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AE  D202                     221              ADD.B   D2, D1                  * Add the converted input to D1
000011B0  60A4                     222              BRA     ASC2HXLP                * Loop
000011B2                           223  
000011B2  1E3C 0001                224  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B6  4E75                     225  RETURN      RTS     
000011B8                           226  
000011B8                           227  *---------------------------------------------------------------------------*
000011B8                           228  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011B8                           229  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011B8                           230  *---------------------------------------------------------------------------*
000011B8  0C02 0008                231  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011BC  6700 000E                232              BEQ     HEX_LOOP
000011C0  4841                     233              SWAP    D1
000011C2  0C02 0002                234              CMPI.B  #2,D2
000011C6  6600 0004                235              BNE     HEX_LOOP
000011CA  E189                     236              LSL.L   #8,D1
000011CC                           237             
000011CC  E999                     238  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011CE  2601                     239              MOVE.L  D1, D3                  * Move D1 to D3
000011D0  0283 0000000F            240              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011D6  0C03 0009                241              CMPI.B  #9, D3                  * Compare te digit
000011DA  6E00 000A                242              BGT     HEX_CHAR              
000011DE  0603 0030                243              ADDI.B  #48,D3                  * Add 48 for numerical output
000011E2  6000 0006                244              BRA     HEX_CONT
000011E6                           245              
000011E6  0603 0037                246  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011EA                           247  
000011EA  12C3                     248  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011EC  5342                     249              SUBI    #1, D2                  * Decrement the size
000011EE  0C02 0000                250              CMPI.B  #0, D2                  * Check if D2 is 0
000011F2  66D8                     251              BNE     HEX_LOOP                * Loop
000011F4  12BC 0000                252              MOVE.B  #$0,(A1)                * Null terminator
000011F8  4E75                     253              RTS
000011FA                           254  *---------------------------------------------------------------------------*
000011FA                           255  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
000011FA                           256  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011FA                           257  *---------------------------------------------------------------------------*
000011FA                           258  HEX2ASCII2STACK
000011FA  0C02 0008                259              CMPI.B  #8, D2                  * Check to see if the size is long
000011FE  6700 000E                260              BEQ     STACK_HEX_LOOP
00001202  4841                     261              SWAP    D1
00001204  0C02 0002                262              CMPI.B  #2,D2
00001208  6600 0004                263              BNE     STACK_HEX_LOOP
0000120C  E189                     264              LSL.L   #8,D1
0000120E                           265             
0000120E                           266  STACK_HEX_LOOP    
0000120E  E999                     267              ROL.L   #4, D1                  * Roll D1 to left
00001210  2601                     268              MOVE.L  D1, D3                  * Move D1 to D3
00001212  0283 0000000F            269              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001218  0C03 0009                270              CMPI.B  #9, D3                  * Compare te digit
0000121C  6E00 000A                271              BGT     STACK_HEX_CHAR              
00001220  0603 0030                272              ADDI.B  #48,D3                  * Add 48 for numerical output
00001224  6000 0006                273              BRA     STACK_HEX_CONT
00001228                           274              
00001228                           275  STACK_HEX_CHAR    
00001228  0603 0037                276              ADDI.B  #55,D3                  * Add 55 for character output
0000122C                           277  
0000122C                           278  STACK_HEX_CONT    
0000122C  6100 2768                279              BSR     PUSH_STACK              *PLACE INTO STACK
00001230  5342                     280              SUBI    #1, D2                  * Decrement the size
00001232  0C02 0000                281              CMPI.B  #0, D2                  * Check if D2 is 0
00001236  66D6                     282              BNE     STACK_HEX_LOOP                * Loop
00001238  12BC 0000                283              MOVE.B  #$0,(A1)                * Null terminator
0000123C  4E75                     284              RTS
0000123E                           285  
0000123E                           286  
0000123E                           287  *---------------------------------------------------------------------------*
0000123E                           288  * IS_ODD: Check whether the source address is odd
0000123E                           289  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000123E                           290  *---------------------------------------------------------------------------*
0000123E  4281                     291  IS_ODD      CLR.L   D1                      * Clear the result
00001240  4287                     292              CLR.L   D7                      * Set the error flag to 0
00001242  2211                     293              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001244  82FC 0002                294              DIVU    #2, D1                  * Divide the result by 2
00001248  4841                     295              SWAP    D1                      * Swap remainder with quotient
0000124A  0C01 0001                296              CMPI.B  #1, D1                  * Check for error
0000124E  6700 0004                297              BEQ     IS_ODD_ERR
00001252  4E75                     298              RTS
00001254                           299              
00001254  1E3C 0001                300  IS_ODD_ERR  MOVE.B  #1, D7
00001258  4E75                     301              RTS
0000125A                           302  
0000125A                           303  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
0000125A                           304  * MAIN                    
0000125A                           305  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
0000125A                           306  * A5: Processing address
0000125A                           307  *
0000125A                           308  * D3: USED FOR PUSHING INTO STACK
0000125A                           309  *     To push into stack => MOVE.W #DATA,D3 
0000125A                           310  *                           BSR    PUSH_STACK
0000125A                           311  *     To print stack     => BSR    PRINT_STACK 
0000125A                           312  *     To clear stack     => BSR    CLEAR_STACK
0000125A                           313  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
0000125A                           314  MAIN        
0000125A                           315              *initialize stack pointer
0000125A  33FC 0000 000042B8       316              MOVE.W  #0,COUNTER
00001262  347C 7000                317              MOVEA.W #STACK,A2
00001266  163C 0020                318              MOVE.B  #' ',D3
0000126A  6100 272A                319              BSR     PUSH_STACK
0000126E  6100 2726                320              BSR     PUSH_STACK
00001272  6100 2722                321              BSR     PUSH_STACK
00001276                           322              
00001276                           323              * clear registers for temp storage
00001276  4280                     324              CLR.L   D0                   
00001278  4281                     325              CLR.L   D1                   
0000127A  227C 00000000            326              MOVEA.L #0, A1                
00001280                           327              
00001280  220D                     328              MOVE.L  A5,D1                   * check to see if the address is fully read
00001282  23CD 00003F00            329              MOVE.L  A5,S_ADDR_HX
00001288  B2B9 00003F04            330              CMP.L   E_ADDR_HX,D1
0000128E  6C00 1E26                331              BGE     REPEAT                  * go to repeat for user action
00001292                           332  
00001292  43F9 00003F5B            333              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001298  143C 0008                334              MOVE.B  #8,D2                   * set the output size
0000129C  4EB8 11B8                335              JSR     HEX2ASCII               
000012A0  43F9 00003F5B            336              LEA     TMPOUTPUT,A1
000012A6  103C 000E                337              MOVE.B  #14,D0
000012AA  4E4F                     338              TRAP    #15
000012AC                           339              
000012AC  4285                     340              CLR.L    D5                      * clear the processing data
000012AE  3A1D                     341              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012B0                           342                                               * advance the current instruction pointer to the next
000012B0                           343                                               * instruction in memory
000012B0                           344  *----------------------------------------*
000012B0                           345  * Registers          
000012B0                           346  * [D1] - COPY OF D5
000012B0                           347  * [D5] - DATA TO BE PROCESSED
000012B0                           348  * [D6] - COUNTER FOR LINES PROCESSED
000012B0                           349  *
000012B0                           350  * [D4]      - ERROR FLAG BEFORE PRINTING
000012B0                           351  * [STACK]   - PRINTS PROCESS DATA
000012B0                           352  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012B0                           353  *
000012B0                           354  * [A1] - USED FOR JUMPING/PRINTING
000012B0                           355  *
000012B0                           356  *----------------------------------------*
000012B0                           357  
000012B0                           358              
000012B0                           359              *Processing the first 4 most significant bits 
000012B0  2205                     360              MOVE.L  D5,D1                    * copy the current processing data to D1
000012B2  143C 000C                361              MOVE.B  #12,D2                   * shift to right by 12 bits
000012B6  E469                     362              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012B8  C2FC 0006                363              MULU    #6,D1                    * form offset
000012BC  43F9 0000132A            364              LEA     JMPTABLE,A1              * index into table
000012C2  4EB1 1000                365              JSR     0(A1,D1)                 * jump indirect with index
000012C6                           366              
000012C6                           367              *SECURED EA*
000012C6  B83C 0001                368              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012CA  6600 0012                369              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012CE  6100 01E8                370              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012D2  6100 272E                371              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012D6  183C 0000                372              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012DA  6000 0022                373              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012DE                           374             
000012DE                           375  OUTPUT_PROCESSED_DATA       
000012DE  163C 000D                376              MOVE.B  #$D,D3                  *carriage return
000012E2  6100 26B2                377              BSR     PUSH_STACK
000012E6  163C 000A                378              MOVE.B  #$A,D3                  *new line feed
000012EA  6100 26AA                379              BSR     PUSH_STACK
000012EE  163C 0000                380              MOVE.B  #$0,D3                  *null
000012F2  6100 26A2                381              BSR     PUSH_STACK
000012F6                           382       
000012F6  6100 267A                383              BSR     PRINT_QUEUE
000012FA  183C 0000                384              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012FE                           385  DISPLAY_30_LINES
000012FE                           386              * display 30 lines per page
000012FE  5206                     387              ADDI.B  #1,D6
00001300  0C06 001E                388              CMPI.B  #30,D6
00001304  6C00 0006                389              BGE     NEXTLINES
00001308  6000 FF50                390              BRA     MAIN
0000130C                           391            
0000130C                           392  *---------------------------------------------------------------------------*
0000130C                           393  * NEXTLINES: receive input from user to print the next 30 lines
0000130C                           394  *---------------------------------------------------------------------------*  
0000130C  4206                     395  NEXTLINES   CLR.B   D6
0000130E  43F9 00003D57            396              LEA     DISP_NEXT,A1
00001314  103C 000E                397              MOVE.B  #14,D0
00001318  4E4F                     398              TRAP    #15
0000131A  43F9 00003F0B            399              LEA     TMPINPUT,A1
00001320  103C 0002                400              MOVE.B  #2,D0
00001324  4E4F                     401              TRAP    #15
00001326  4EF8 125A                402              JMP     MAIN
0000132A                           403    
0000132A                           404  *---------------------------------------------------------------------------*
0000132A                           405  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
0000132A                           406  *---------------------------------------------------------------------------*  
0000132A  4EF9 0000138A            407  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
00001330  4EF9 000015B0            408              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001336  4EF9 0000161E            409              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000133C  4EF9 0000171C            410              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
00001342  4EF9 00001818            411              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *NOT FINISHED - LEA,JSR,RTS,NEG - JOSEPH
00001348  4EF9 00001A6E            412              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
0000134E  4EF9 00001C12            413              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *FINISHED - LYN
00001354  4EF9 00001CA0            414              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
0000135A  4EF9 00001CA4            415              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
00001360  4EF9 00001DAC            416              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001366  4EF9 00002168            417              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
0000136C  4EF9 0000216C            418              JMP     OP1011  * CMP/EOR/CMPA
00001372  4EF9 00002268            419              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
00001378  4EF9 000025BA            420              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000137E  4EF9 00002996            421              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001384  4EF9 00002C44            422              JMP     OP1111  * Special/Reserved
0000138A                           423              
0000138A                           424  *---------------------------------------------------------------------------*
0000138A                           425  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
0000138A                           426  *---------------------------------------------------------------------------*           
0000138A                           427  OP0000                                                                                  
0000138A  4281                     428              CLR.L   D1          * to temporarily store the address to process
0000138C  4280                     429              CLR.L   D0  
0000138E  4284                     430              CLR.L   D4                 
00001390  227C 00000000            431              MOVEA.L #0, A1                
00001396                           432              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001396                           433              * Check if bit 11,10,9,8 are 0000)
00001396  2205                     434              MOVE.L  D5,D1
00001398  0281 00000F00            435              ANDI.L  #$0F00,D1
0000139E  0C81 00000000            436              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013A4  6700 01B4                437              BEQ     OP_ORI
000013A8                           438  
000013A8                           439              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013A8                           440              * check if bit 11,10,9,8 are 1100
000013A8  4281                     441              CLR.L   D1
000013AA  2205                     442              MOVE.L  D5,D1
000013AC  0281 00000F00            443              ANDI.L  #$0F00,D1
000013B2  0C81 00000C00            444              CMPI.L  #$0C00,D1
000013B8  6700 014A                445              BEQ     OP_CMPI
000013BC                           446              
000013BC                           447              * check for SUBI
000013BC  4281                     448              CLR.L   D1
000013BE  2205                     449              MOVE.L  D5,D1
000013C0  0281 00000F00            450              ANDI.L  #$0F00,D1
000013C6  0C81 00000400            451              CMPI.L  #$0400,D1
000013CC  6700 0094                452              BEQ     OP_SUBI
000013D0                           453              
000013D0                           454              * check for EORI
000013D0  4281                     455              CLR.L   D1
000013D2  2205                     456              MOVE.L  D5,D1
000013D4  0281 00000F00            457              ANDI.L  #$0F00,D1
000013DA  0C81 00000A00            458              CMPI.L  #$0A00,D1
000013E0  6700 002A                459              BEQ     OP_EORI
000013E4                           460              
000013E4                           461              * check for BTST
000013E4  4281                     462              CLR.L   D1
000013E6  2205                     463              MOVE.L  D5,D1
000013E8  EA99                     464              ROR.L   #5,D1
000013EA  0281 00000008            465              ANDI.L  #$8,D1
000013F0  0C01 0008                466              CMPI.B  #8,D1
000013F4  6700 0008                467              BEQ     OP_BTST
000013F8                           468  
000013F8                           469              * OP0000 series other than ORI/CMPI/BTST/EORI
000013F8  4EF9 000014B8            470              JMP     OP_DATA
000013FE                           471              
000013FE                           472  *---------------------------------------------------------------------------*
000013FE                           473  * OP_BTST: display BTST
000013FE                           474  *---------------------------------------------------------------------------* 
000013FE  43F9 00003FE4            475  OP_BTST     LEA     DISP_BTST,A1
00001404  103C 000E                476              MOVE.B  #14,D0
00001408  4E4F                     477              TRAP    #15
0000140A  4E75                     478              RTS
0000140C                           479  
0000140C                           480  *---------------------------------------------------------------------------*
0000140C                           481  * OP_EORI: decode and display EORI
0000140C                           482  *---------------------------------------------------------------------------* 
0000140C                           483  OP_EORI
0000140C  4281                     484              CLR.L   D1
0000140E  4284                     485              CLR.L   D4
00001410  2205                     486              MOVE.L  D5,D1
00001412  EC99                     487              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001414  0C01 0000                488              CMPI.B  #0,D1
00001418  6700 0012                489              BEQ     OP_EORI_B    * size is byte
0000141C  0C01 0001                490              CMPI.B  #1,D1
00001420  6700 001C                491              BEQ     OP_EORI_W    * size is word
00001424  0C01 0002                492              CMPI.B  #2,D1
00001428  6700 0026                493              BEQ     OP_EORI_L    * size is long
0000142C                           494  
0000142C                           495  OP_EORI_B    * size is byte    
0000142C  183C 0000                496              MOVE.B  #0,D4
00001430  43F9 00003FC6            497              LEA     DISP_EORI_B,A1
00001436  103C 000E                498              MOVE.B  #14,D0
0000143A  4E4F                     499              TRAP    #15
0000143C  4E75                     500              RTS
0000143E                           501              
0000143E                           502  OP_EORI_W    * size is word
0000143E  183C 0001                503              MOVE.B  #1,D4
00001442  43F9 00003FD0            504              LEA     DISP_EORI_W,A1
00001448  103C 000E                505              MOVE.B  #14,D0
0000144C  4E4F                     506              TRAP    #15
0000144E  4E75                     507              RTS
00001450                           508              
00001450                           509  OP_EORI_L    * size is long
00001450  183C 0002                510              MOVE.B  #2,D4
00001454  43F9 00003FDA            511              LEA     DISP_EORI_L,A1
0000145A  103C 000E                512              MOVE.B  #14,D0
0000145E  4E4F                     513              TRAP    #15
00001460  4E75                     514              RTS
00001462                           515              
00001462                           516  *---------------------------------------------------------------------------*
00001462                           517  * OP_SUBI: decode SUBI.B/.W/.L
00001462                           518  *---------------------------------------------------------------------------* 
00001462                           519  OP_SUBI
00001462  4281                     520              CLR.L   D1
00001464  4284                     521              CLR.L   D4
00001466  2205                     522              MOVE.L  D5,D1
00001468  EC99                     523              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000146A  0C01 0000                524              CMPI.B  #0,D1
0000146E  6700 0012                525              BEQ     OP_SUBI_B    * size is byte
00001472  0C01 0001                526              CMPI.B  #1,D1
00001476  6700 001C                527              BEQ     OP_SUBI_W    * size is word
0000147A  0C01 0002                528              CMPI.B  #2,D1
0000147E  6700 0026                529              BEQ     OP_SUBI_L    * size is long
00001482                           530  
00001482                           531  OP_SUBI_B    * size is byte    
00001482  183C 0000                532              MOVE.B  #0,D4
00001486  43F9 000040D2            533              LEA     DISP_SUBI_B,A1
0000148C  103C 000E                534              MOVE.B  #14,D0
00001490  4E4F                     535              TRAP    #15
00001492  4E75                     536              RTS
00001494                           537              
00001494                           538  OP_SUBI_W    * size is word
00001494  183C 0001                539              MOVE.B  #1,D4
00001498  43F9 000040DC            540              LEA     DISP_SUBI_W,A1
0000149E  103C 000E                541              MOVE.B  #14,D0
000014A2  4E4F                     542              TRAP    #15
000014A4  4E75                     543              RTS
000014A6                           544              
000014A6                           545  OP_SUBI_L    * size is long
000014A6  183C 0002                546              MOVE.B  #2,D4
000014AA  43F9 000040E6            547              LEA     DISP_SUBI_L,A1
000014B0  103C 000E                548              MOVE.B  #14,D0
000014B4  4E4F                     549              TRAP    #15
000014B6  4E75                     550              RTS
000014B8                           551              
000014B8                           552  *---------------------------------------------------------------------------*
000014B8                           553  * OP_DATA : unidentified opcode
000014B8                           554  *---------------------------------------------------------------------------* 
000014B8                           555  OP_DATA
000014B8  4280                     556              CLR.L   D0                   
000014BA  4281                     557              CLR.L   D1     
000014BC  4284                     558              CLR.L   D4                    
000014BE  227C 00000000            559              MOVEA.L #0, A1             
000014C4  4287                     560              CLR.L   D7
000014C6  1E3C 0001                561              MOVE.B  #1,D7                   * error flag is true
000014CA                           562              
000014CA  43F9 0000400A            563              LEA     DISP_DATA,A1
000014D0  103C 000E                564              MOVE.B  #14,D0
000014D4  4E4F                     565              TRAP    #15
000014D6                           566              
000014D6  4EF9 000014DC            567              JMP     EA_DATA
000014DC                           568             
000014DC                           569             
000014DC                           570  *---------------------------------------------------------------------------*
000014DC                           571  * EA_DATA
000014DC                           572  *---------------------------------------------------------------------------*       
000014DC  43F9 00003F5B            573  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014E2  2205                     574              MOVE.L  D5,D1           * transfer the processing data to D1
000014E4  7404                     575              MOVE.L  #4,D2           * set to word size
000014E6  4EB8 11B8                576              JSR     HEX2ASCII       * prepare output in ascii
000014EA  43F9 0000427D            577              LEA     DISP_HEX,A1     * display $ symbol
000014F0  103C 000E                578              MOVE.B  #14,D0      
000014F4  4E4F                     579              TRAP    #15
000014F6  43F9 00003F5B            580              LEA     TMPOUTPUT,A1    * display with a new line
000014FC  103C 000D                581              MOVE.B  #13,D0
00001500  4E4F                     582              TRAP    #15
00001502                           583  
00001502  4E75                     584              RTS
00001504                           585              
00001504                           586  *---------------------------------------------------------------------------*
00001504                           587  * OP_CMPI : decode CMPI and its size
00001504                           588  *---------------------------------------------------------------------------*          
00001504                           589  OP_CMPI
00001504  4281                     590              CLR.L   D1
00001506  4284                     591              CLR.L   D4
00001508  2205                     592              MOVE.L  D5,D1
0000150A  EC99                     593              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000150C  0C01 0000                594              CMPI.B  #0,D1
00001510  6700 0012                595              BEQ     OP_CMPI_B    * size is byte
00001514  0C01 0001                596              CMPI.B  #1,D1
00001518  6700 001C                597              BEQ     OP_CMPI_W    * size is word
0000151C  0C01 0002                598              CMPI.B  #2,D1
00001520  6700 0026                599              BEQ     OP_CMPI_L    * size is long
00001524                           600  
00001524                           601  OP_CMPI_B    * size is byte    
00001524  183C 0000                602              MOVE.B  #0,D4
00001528  43F9 00003FEC            603              LEA     DISP_CMPI_B,A1
0000152E  103C 000E                604              MOVE.B  #14,D0
00001532  4E4F                     605              TRAP    #15
00001534  4E75                     606              RTS
00001536                           607              
00001536                           608  OP_CMPI_W    * size is word
00001536  183C 0001                609              MOVE.B  #1,D4
0000153A  43F9 00003FF6            610              LEA     DISP_CMPI_W,A1
00001540  103C 000E                611              MOVE.B  #14,D0
00001544  4E4F                     612              TRAP    #15
00001546  4E75                     613              RTS
00001548                           614              
00001548                           615  OP_CMPI_L    * size is long
00001548  183C 0002                616              MOVE.B  #2,D4
0000154C  43F9 00004000            617              LEA     DISP_CMPI_L,A1
00001552  103C 000E                618              MOVE.B  #14,D0
00001556  4E4F                     619              TRAP    #15
00001558  4E75                     620              RTS
0000155A                           621   
0000155A                           622  *---------------------------------------------------------------------------*
0000155A                           623  * OP_ORI : decode ORI and its size
0000155A                           624  *---------------------------------------------------------------------------* 
0000155A                           625  OP_ORI      
0000155A  4281                     626              CLR.L   D1
0000155C  4284                     627              CLR.L   D4
0000155E  2205                     628              MOVE.L  D5,D1
00001560  EC99                     629              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001562  0C01 0000                630              CMPI.B  #0,D1
00001566  6700 0012                631              BEQ     OP_ORI_B    * size is byte
0000156A  0C01 0001                632              CMPI.B  #1,D1
0000156E  6700 001C                633              BEQ     OP_ORI_W    * size is word
00001572  0C01 0002                634              CMPI.B  #2,D1
00001576  6700 0026                635              BEQ     OP_ORI_L    * size is long
0000157A                           636  
0000157A                           637  OP_ORI_B    * size is byte    
0000157A  183C 0000                638              MOVE.B  #0,D4
0000157E  43F9 00003FAB            639              LEA     DISP_ORI_B,A1
00001584  103C 000E                640              MOVE.B  #14,D0
00001588  4E4F                     641              TRAP    #15
0000158A  4E75                     642              RTS
0000158C                           643              
0000158C                           644  OP_ORI_W    * size is word
0000158C  183C 0001                645              MOVE.B  #1,D4
00001590  43F9 00003FB4            646              LEA     DISP_ORI_W,A1
00001596  103C 000E                647              MOVE.B  #14,D0
0000159A  4E4F                     648              TRAP    #15
0000159C  4E75                     649              RTS
0000159E                           650              
0000159E                           651  OP_ORI_L    * size is long
0000159E  183C 0002                652              MOVE.B  #2,D4
000015A2  43F9 00003FBD            653              LEA     DISP_ORI_L,A1
000015A8  103C 000E                654              MOVE.B  #14,D0
000015AC  4E4F                     655              TRAP    #15
000015AE  4E75                     656              RTS
000015B0                           657          
000015B0                           658  *---------------------------------------------------------------------------*
000015B0                           659  * OP0001: MOVE.B
000015B0                           660  *---------------------------------------------------------------------------*
000015B0                           661  OP0001      
000015B0  4EF9 000015B6            662              JMP     OP_MOVE_B   * display MOVE.B
000015B6                           663              
000015B6                           664  *---------------------------------------------------------------------------*
000015B6                           665  * OP_MOVE_B: display MOVE_B and proceed to EA
000015B6                           666  *---------------------------------------------------------------------------*
000015B6                           667  OP_MOVE_B                                                                       
000015B6                           668             
000015B6                           669             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015B6  13FC 0082 000042BC       670             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015BE  13FC 0000 000042BD       671             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015C6                           672             
000015C6                           673             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015C6  13FC 00B9 000042BF       674             MOVE.B   #$B9,GET_DST_START_END
000015CE  13FC 0020 000042C0       675             MOVE.B   #$20,GET_SRC_START_END
000015D6                           676             
000015D6                           677              *CLEAR D3
000015D6  4283                     678              CLR.L   D3
000015D8                           679              *LOAD STACK WITH THIS OPMODE
000015D8  6100 23BC                680              BSR     PUSH_STACK
000015DC  163C 004D                681              MOVE.B  #'M',D3
000015E0  6100 23B4                682              BSR     PUSH_STACK
000015E4  163C 004F                683              MOVE.B  #'O',D3
000015E8  6100 23AC                684              BSR     PUSH_STACK
000015EC  163C 0056                685              MOVE.B  #'V',D3
000015F0  6100 23A4                686              BSR     PUSH_STACK
000015F4  163C 0045                687              MOVE.B  #'E',D3
000015F8  6100 239C                688              BSR     PUSH_STACK
000015FC  163C 002E                689              MOVE.B  #'.',D3
00001600  6100 2394                690              BSR     PUSH_STACK
00001604  163C 0042                691              MOVE.B  #'B',D3
00001608  6100 238C                692              BSR     PUSH_STACK
0000160C                           693              
0000160C  6100 1AEA                694              BSR     GET_EA_EA_SRC
00001610  163C 002C                695              MOVE.B  #',',D3
00001614  6100 2380                696              BSR     PUSH_STACK
00001618  6100 1F0E                697              BSR     GET_EA_EA_DEST
0000161C                           698              
0000161C  4E75                     699              RTS
0000161E                           700              
0000161E                           701             
0000161E                           702  *---------------------------------------------------------------------------*
0000161E                           703  * OP0010: decode MOVE.L/MOVEA.L
0000161E                           704  *---------------------------------------------------------------------------*
0000161E                           705  OP0010      
0000161E  183C 0002                706              MOVE.B  #2,D4
00001622  4280                     707              CLR.L   D0                     
00001624  4281                     708              CLR.L   D1                      
00001626  227C 00000000            709              MOVEA.L #0, A1                 
0000162C                           710              
0000162C  2205                     711              MOVE.L  D5,D1
0000162E  EA99                     712              ROR.L   #5,D1
00001630  0281 0000000E            713              ANDI.L  #$E,D1
00001636  0C01 0002                714              CMPI.B  #2,D1
0000163A  6700 0070                715              BEQ     OP_MOVEA_L
0000163E                           716  
0000163E  4EF9 00001644            717              JMP     OP_MOVE_L
00001644                           718             
00001644                           719  
00001644                           720  *---------------------------------------------------------------------------*
00001644                           721  * OP_MOVE_L: display MOVE_L and proceed to EA
00001644                           722  *---------------------------------------------------------------------------*
00001644                           723  OP_MOVE_L   
00001644                           724             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001644  13FC 0082 000042BC       725             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000164C  13FC 0000 000042BD       726             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001654                           727             
00001654                           728             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001654  13FC 00B9 000042BF       729             MOVE.B   #$B9,GET_DST_START_END
0000165C  13FC 0020 000042C0       730             MOVE.B   #$20,GET_SRC_START_END
00001664                           731             
00001664                           732              *CLEAR D3
00001664  4283                     733              CLR.L   D3
00001666                           734              *LOAD STACK WITH THIS OPMODE
00001666  6100 232E                735              BSR     PUSH_STACK
0000166A  163C 004D                736              MOVE.B  #'M',D3
0000166E  6100 2326                737              BSR     PUSH_STACK
00001672  163C 004F                738              MOVE.B  #'O',D3
00001676  6100 231E                739              BSR     PUSH_STACK
0000167A  163C 0056                740              MOVE.B  #'V',D3
0000167E  6100 2316                741              BSR     PUSH_STACK
00001682  163C 0045                742              MOVE.B  #'E',D3
00001686  6100 230E                743              BSR     PUSH_STACK
0000168A  163C 002E                744              MOVE.B  #'.',D3
0000168E  6100 2306                745              BSR     PUSH_STACK
00001692  163C 004C                746              MOVE.B  #'L',D3
00001696  6100 22FE                747              BSR     PUSH_STACK
0000169A                           748              
0000169A  6100 1A5C                749              BSR     GET_EA_EA_SRC
0000169E  163C 002C                750              MOVE.B  #',',D3
000016A2  6100 22F2                751              BSR     PUSH_STACK
000016A6  6100 1E80                752              BSR     GET_EA_EA_DEST
000016AA                           753              
000016AA  4E75                     754              RTS
000016AC                           755  
000016AC                           756  
000016AC                           757  *---------------------------------------------------------------------------*
000016AC                           758  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000016AC                           759  *---------------------------------------------------------------------------*
000016AC                           760  OP_MOVEA_L 
000016AC                           761             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016AC  13FC 00FD 000042BC       762             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016B4  13FC 0000 000042BD       763             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016BC                           764             
000016BC                           765             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016BC  13FC 00B9 000042BF       766             MOVE.B   #$B9,GET_DST_START_END
000016C4  13FC 0020 000042C0       767             MOVE.B   #$20,GET_SRC_START_END
000016CC                           768             
000016CC                           769              *CLEAR D3
000016CC  4283                     770              CLR.L   D3
000016CE                           771              *LOAD STACK WITH THIS OPMODE
000016CE  6100 22C6                772              BSR     PUSH_STACK
000016D2  163C 004D                773              MOVE.B  #'M',D3
000016D6  6100 22BE                774              BSR     PUSH_STACK
000016DA  163C 004F                775              MOVE.B  #'O',D3
000016DE  6100 22B6                776              BSR     PUSH_STACK
000016E2  163C 0056                777              MOVE.B  #'V',D3
000016E6  6100 22AE                778              BSR     PUSH_STACK
000016EA  163C 0045                779              MOVE.B  #'E',D3
000016EE  6100 22A6                780              BSR     PUSH_STACK           
000016F2  163C 0041                781              MOVE.B  #'A',D3
000016F6  6100 229E                782              BSR     PUSH_STACK
000016FA  163C 002E                783              MOVE.B  #'.',D3
000016FE  6100 2296                784              BSR     PUSH_STACK
00001702  163C 004C                785              MOVE.B  #'L',D3
00001706  6100 228E                786              BSR     PUSH_STACK
0000170A                           787              
0000170A  6100 19EC                788              BSR     GET_EA_EA_SRC
0000170E  163C 002C                789              MOVE.B  #',',D3
00001712  6100 2282                790              BSR     PUSH_STACK
00001716  6100 1E10                791              BSR     GET_EA_EA_DEST
0000171A                           792              
0000171A  4E75                     793              RTS
0000171C                           794  
0000171C                           795              
0000171C                           796  *---------------------------------------------------------------------------*
0000171C                           797  * OP0011: decode MOVE.W/MOVEA.W
0000171C                           798  *---------------------------------------------------------------------------*
0000171C                           799  OP0011      
0000171C  4280                     800              CLR.L   D0                      
0000171E  4281                     801              CLR.L   D1  
00001720  4284                     802              CLR.L   D4                   
00001722  227C 00000000            803              MOVEA.L #0, A1 
00001728                           804                
00001728  2205                     805              MOVE.L  D5,D1
0000172A  EC99                     806              ROR.L   #6,D1
0000172C  0281 00000007            807              ANDI.L  #$07,D1
00001732  0C01 0001                808              CMPI.B  #1,D1
00001736  6700 0070                809              BEQ     OP_MOVEA_W
0000173A                           810              
0000173A  4EF9 00001740            811              JMP     OP_MOVE_W
00001740                           812            
00001740                           813  *---------------------------------------------------------------------------*
00001740                           814  * OP_MOVE_W: display MOVE_W and proceed to EA
00001740                           815  *---------------------------------------------------------------------------*
00001740                           816  OP_MOVE_W   
00001740                           817             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001740  13FC 0082 000042BC       818             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001748  13FC 0000 000042BD       819             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001750                           820             
00001750                           821             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001750  13FC 00B9 000042BF       822             MOVE.B   #$B9,GET_DST_START_END
00001758  13FC 0020 000042C0       823             MOVE.B   #$20,GET_SRC_START_END
00001760                           824             
00001760                           825              *CLEAR D3
00001760  4283                     826              CLR.L   D3
00001762                           827              *LOAD STACK WITH THIS OPMODE
00001762  6100 2232                828              BSR     PUSH_STACK
00001766  163C 004D                829              MOVE.B  #'M',D3
0000176A  6100 222A                830              BSR     PUSH_STACK
0000176E  163C 004F                831              MOVE.B  #'O',D3
00001772  6100 2222                832              BSR     PUSH_STACK
00001776  163C 0056                833              MOVE.B  #'V',D3
0000177A  6100 221A                834              BSR     PUSH_STACK
0000177E  163C 0045                835              MOVE.B  #'E',D3
00001782  6100 2212                836              BSR     PUSH_STACK
00001786  163C 002E                837              MOVE.B  #'.',D3
0000178A  6100 220A                838              BSR     PUSH_STACK
0000178E  163C 0057                839              MOVE.B  #'W',D3
00001792  6100 2202                840              BSR     PUSH_STACK
00001796                           841              
00001796  6100 1960                842              BSR     GET_EA_EA_SRC
0000179A  163C 002C                843              MOVE.B  #',',D3
0000179E  6100 21F6                844              BSR     PUSH_STACK
000017A2  6100 1D84                845              BSR     GET_EA_EA_DEST
000017A6                           846              
000017A6  4E75                     847              RTS
000017A8                           848  
000017A8                           849  *---------------------------------------------------------------------------*
000017A8                           850  * OP_MOVEA_W: display MOVEA and proceed to EA
000017A8                           851  *---------------------------------------------------------------------------*
000017A8                           852  OP_MOVEA_W 
000017A8                           853             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017A8  13FC 00FD 000042BC       854             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000017B0  13FC 0000 000042BD       855             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017B8                           856             
000017B8                           857             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017B8  13FC 00B9 000042BF       858             MOVE.B   #$B9,GET_DST_START_END
000017C0  13FC 0020 000042C0       859             MOVE.B   #$20,GET_SRC_START_END
000017C8                           860             
000017C8                           861              *CLEAR D3
000017C8  4283                     862              CLR.L   D3
000017CA                           863              *LOAD STACK WITH THIS OPMODE
000017CA  6100 21CA                864              BSR     PUSH_STACK
000017CE  163C 004D                865              MOVE.B  #'M',D3
000017D2  6100 21C2                866              BSR     PUSH_STACK
000017D6  163C 004F                867              MOVE.B  #'O',D3
000017DA  6100 21BA                868              BSR     PUSH_STACK
000017DE  163C 0056                869              MOVE.B  #'V',D3
000017E2  6100 21B2                870              BSR     PUSH_STACK
000017E6  163C 0045                871              MOVE.B  #'E',D3
000017EA  6100 21AA                872              BSR     PUSH_STACK           
000017EE  163C 0041                873              MOVE.B  #'A',D3
000017F2  6100 21A2                874              BSR     PUSH_STACK
000017F6  163C 002E                875              MOVE.B  #'.',D3
000017FA  6100 219A                876              BSR     PUSH_STACK
000017FE  163C 0057                877              MOVE.B  #'W',D3
00001802  6100 2192                878              BSR     PUSH_STACK
00001806                           879              
00001806  6100 18F0                880              BSR     GET_EA_EA_SRC
0000180A  163C 002C                881              MOVE.B  #',',D3
0000180E  6100 2186                882              BSR     PUSH_STACK
00001812  6100 1D14                883              BSR     GET_EA_EA_DEST
00001816                           884            
00001816  4E75                     885              RTS
00001818                           886  *---------------------------------------------------------------------------*
00001818                           887  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001818                           888  *---------------------------------------------------------------------------*
00001818                           889  OP0100
00001818  4280                     890              CLR.L   D0                      
0000181A  4281                     891              CLR.L   D1  
0000181C  4284                     892              CLR.L   D4                      
0000181E  227C 00000000            893              MOVEA.L #0, A1                  
00001824  2205                     894              MOVE.L  D5,D1  
00001826                           895              
00001826                           896              * check for RTS
00001826  0C41 4E75                897              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
0000182A  6700 0228                898              BEQ     OP_RTS
0000182E                           899              
0000182E                           900              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
0000182E  4281                     901              CLR.L   D1 
00001830  2205                     902              MOVE.L  D5,D1  
00001832  0241 0F00                903              ANDI.W  #$0F00,D1
00001836  0C41 0E00                904              CMPI.W  #$0E00,D1
0000183A  6700 0204                905              BEQ     OP_JSR
0000183E                           906  
0000183E                           907              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000183E  4281                     908              CLR.L   D1 
00001840  2205                     909              MOVE.L  D5,D1  
00001842  0241 0F00                910              ANDI.W  #$0F00,D1
00001846  0C41 0400                911              CMPI.W  #$0400,D1
0000184A  6700 00E8                912              BEQ     OP_NEG
0000184E                           913              
0000184E                           914              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
0000184E  4281                     915              CLR.L   D1 
00001850  2205                     916              MOVE.L  D5,D1  
00001852  0241 0F00                917              ANDI.W  #$0F00,D1
00001856  0C41 0600                918              CMPI.W  #$0600,D1
0000185A  6700 015E                919              BEQ     OP_NOT
0000185E                           920              
0000185E                           921              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
0000185E  4281                     922              CLR.L   D1 
00001860  2205                     923              MOVE.L  D5,D1  
00001862  EC99                     924              ROR.L   #6,D1
00001864  0281 00000007            925              ANDI.L  #7,D1
0000186A  0C81 00000007            926              CMPI.L  #7,D1
00001870  6700 0054                927              BEQ     OP_LEA
00001874                           928              
00001874                           929              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001874  4281                     930              CLR.L   D1 
00001876  2205                     931              MOVE.L  D5,D1  
00001878  EB59                     932              ROL.W   #5,D1
0000187A  0C01 0001                933              CMPI.B  #1,D1
0000187E  6600 FC38                934              BNE     OP_DATA
00001882  E959                     935              ROL.W   #4,D1
00001884  0C01 0001                936              CMPI.B  #1,D1
00001888  6600 FC2E                937              BNE     OP_DATA
0000188C  E359                     938              ROL.W   #1,D1
0000188E  0C01 0000                939              CMPI.B  #0,D1
00001892  6700 000E                940              BEQ     OP_MOVEM_W
00001896  0C01 0001                941              CMPI.B  #1,D1
0000189A  6700 0018                942              BEQ     OP_MOVEM_L
0000189E  4EF8 14B8                943              JMP     OP_DATA
000018A2                           944  
000018A2                           945  *---------------------------------------------------------------------------*
000018A2                           946  * OP_MOVEM_W: display MOVEM_W
000018A2                           947  *---------------------------------------------------------------------------*    
000018A2                           948  OP_MOVEM_W  
000018A2  183C 0001                949              MOVE.B  #1,D4
000018A6  43F9 0000407B            950              LEA     DISP_MOVEM_W,A1
000018AC  103C 000E                951              MOVE.B  #14,D0
000018B0  4E4F                     952              TRAP    #15
000018B2  4E75                     953              RTS
000018B4                           954  
000018B4                           955  *---------------------------------------------------------------------------*
000018B4                           956  * OP_MOVEM_L: display MOVEM_L
000018B4                           957  *---------------------------------------------------------------------------*
000018B4                           958  OP_MOVEM_L  
000018B4  183C 0002                959              MOVE.B  #2,D4
000018B8  43F9 00004086            960              LEA     DISP_MOVEM_L,A1
000018BE  103C 000E                961              MOVE.B  #14,D0
000018C2  4E4F                     962              TRAP    #15
000018C4  4E75                     963              RTS
000018C6                           964     
000018C6                           965  *---------------------------------------------------------------------------*
000018C6                           966  * OP_LEA: decode and display LEA
000018C6                           967  *---------------------------------------------------------------------------*
000018C6                           968  OP_LEA      
000018C6  4281                     969               CLR.L   D1       
000018C8  4284                     970              CLR.L   D4                   
000018CA  227C 00000000            971              MOVEA.L #0, A1              
000018D0  2205                     972              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000018D2                           973              *CLEAR D3
000018D2  4283                     974              CLR.L   D3
000018D4                           975  
000018D4                           976  OP_LEA_DN_EA_OR_EA_DN 
000018D4                           977              *LOAD STACK WITH THIS OPMODE
000018D4  6100 20C0                978              BSR     PUSH_STACK
000018D8  163C 004C                979              MOVE.B  #'L',D3
000018DC  6100 20B8                980              BSR     PUSH_STACK
000018E0  163C 0045                981              MOVE.B  #'E',D3
000018E4  6100 20B0                982              BSR     PUSH_STACK
000018E8  163C 0041                983              MOVE.B  #'A',D3
000018EC  6100 20A8                984              BSR     PUSH_STACK
000018F0  2205                     985              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000018F2                           986          
000018F2                           987  
000018F2                           988  OP_PRINT_L_LEA
000018F2                           989                          
000018F2                           990              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018F2  13FC 0000 000042BC       991              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000018FA  13FC 009B 000042BD       992              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001902                           993             
00001902                           994              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001902  13FC 00B9 000042BF       995              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000190A  13FC 0020 000042C0       996              MOVE.B   #$20,GET_SRC_START_END
00001912                           997  
00001912                           998              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001912  0285 0000FE3F            999              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001918  0685 00000040           1000              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000191E                          1001  
0000191E  6100 17D8               1002              BSR     GET_EA_EA_SRC      *GETS <ea>
00001922  163C 002C               1003              MOVE.B  #',',D3
00001926  6100 206E               1004              BSR     PUSH_STACK           
0000192A  6100 1BFC               1005              BSR     GET_EA_EA_DEST       *GETS Dn    
0000192E                          1006  
0000192E                          1007              
0000192E  6000 0002               1008              BRA     OP_LEA_RETURN
00001932                          1009              
00001932                          1010  OP_LEA_RETURN
00001932  4E75                    1011              RTS
00001934                          1012              
00001934                          1013  
00001934                          1014  
00001934                          1015  *---------------------------------------------------------------------------*
00001934                          1016  * OP_NEG: decode and display NEG 
00001934                          1017  *---------------------------------------------------------------------------*
00001934                          1018  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001934  4281                    1019              CLR.L   D1
00001936  4284                    1020              CLR.L   D4
00001938  2205                    1021              MOVE.L  D5,D1
0000193A                          1022              
0000193A                          1023              *CLEAR D3
0000193A  4283                    1024              CLR.L   D3
0000193C                          1025              *LOAD STACK WITH THIS OPMODE
0000193C  6100 2058               1026              BSR     PUSH_STACK
00001940  163C 004E               1027              MOVE.B  #'N',D3
00001944  6100 2050               1028              BSR     PUSH_STACK
00001948  163C 0045               1029              MOVE.B  #'E',D3
0000194C  6100 2048               1030              BSR     PUSH_STACK
00001950  163C 0047               1031              MOVE.B  #'G',D3
00001954  6100 2040               1032              BSR     PUSH_STACK
00001958  163C 002E               1033              MOVE.B  #'.',D3
0000195C  6100 2038               1034              BSR     PUSH_STACK
00001960                          1035              
00001960                          1036              
00001960  EC99                    1037              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001962  0281 00000007           1038              ANDI.L  #$07,D1
00001968                          1039              
00001968  0C01 0000               1040              CMPI.B  #0,D1
0000196C  6700 0012               1041              BEQ     OP_NEG_B    * size is byte
00001970  0C01 0001               1042              CMPI.B  #1,D1
00001974  6700 0016               1043              BEQ     OP_NEG_W    * size is word
00001978  0C01 0002               1044              CMPI.B  #2,D1
0000197C  6700 001A               1045              BEQ     OP_NEG_L    * size is long
00001980                          1046                         
00001980                          1047  
00001980                          1048  OP_NEG_B    * size is byte   
00001980  163C 0042               1049              MOVE.B  #'B',D3
00001984  6100 2010               1050              BSR     PUSH_STACK
00001988  6000 001A               1051              BRA     OP_NEG_PRINT_EA
0000198C                          1052  
0000198C                          1053              
0000198C                          1054  OP_NEG_W    * size is word
0000198C  163C 0057               1055              MOVE.B  #'W',D3
00001990  6100 2004               1056              BSR     PUSH_STACK
00001994  6000 000E               1057              BRA     OP_NEG_PRINT_EA
00001998                          1058  
00001998                          1059              
00001998                          1060  OP_NEG_L    * size is long
00001998  163C 004C               1061              MOVE.B  #'L',D3
0000199C  6100 1FF8               1062              BSR     PUSH_STACK
000019A0  6000 0002               1063              BRA     OP_NEG_PRINT_EA
000019A4                          1064  
000019A4                          1065  
000019A4                          1066  OP_NEG_PRINT_EA
000019A4                          1067   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019A4  13FC 0082 000042BD      1068             MOVE.B   #$82,SRC_REGISTER_FORMAT
000019AC                          1069             
000019AC                          1070             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000019AC  13FC 0020 000042C0      1071             MOVE.B   #$20,GET_SRC_START_END
000019B4                          1072                         
000019B4                          1073  
000019B4  6100 1742               1074              BSR     GET_EA_EA_SRC
000019B8                          1075              
000019B8  4E75                    1076              RTS
000019BA                          1077  
000019BA                          1078  *---------------------------------------------------------------------------*
000019BA                          1079  * OP_NOT: decode and display NOT 
000019BA                          1080  *---------------------------------------------------------------------------*
000019BA                          1081  OP_NOT
000019BA  4281                    1082              CLR.L   D1
000019BC  4284                    1083              CLR.L   D4
000019BE  2205                    1084              MOVE.L  D5,D1
000019C0                          1085              
000019C0                          1086              *CLEAR D3
000019C0  4283                    1087              CLR.L   D3
000019C2                          1088              *LOAD STACK WITH THIS OPMODE
000019C2  6100 1FD2               1089              BSR     PUSH_STACK
000019C6  163C 004E               1090              MOVE.B  #'N',D3
000019CA  6100 1FCA               1091              BSR     PUSH_STACK
000019CE  163C 004F               1092              MOVE.B  #'O',D3
000019D2  6100 1FC2               1093              BSR     PUSH_STACK
000019D6  163C 0054               1094              MOVE.B  #'T',D3
000019DA  6100 1FBA               1095              BSR     PUSH_STACK
000019DE  163C 002E               1096              MOVE.B  #'.',D3
000019E2  6100 1FB2               1097              BSR     PUSH_STACK
000019E6                          1098              
000019E6                          1099              
000019E6  EC99                    1100              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000019E8  0281 00000007           1101              ANDI.L  #$07,D1
000019EE                          1102              
000019EE  0C01 0000               1103              CMPI.B  #0,D1
000019F2  6700 0012               1104              BEQ     OP_NOT_B    * size is byte
000019F6  0C01 0001               1105              CMPI.B  #1,D1
000019FA  6700 0016               1106              BEQ     OP_NOT_W    * size is word
000019FE  0C01 0002               1107              CMPI.B  #2,D1
00001A02  6700 001A               1108              BEQ     OP_NOT_L    * size is long
00001A06                          1109                         
00001A06                          1110  
00001A06                          1111  OP_NOT_B    * size is byte   
00001A06  163C 0042               1112              MOVE.B  #'B',D3
00001A0A  6100 1F8A               1113              BSR     PUSH_STACK
00001A0E  6000 001A               1114              BRA     OP_NOT_PRINT_EA
00001A12                          1115  
00001A12                          1116              
00001A12                          1117  OP_NOT_W    * size is word
00001A12  163C 0057               1118              MOVE.B  #'W',D3
00001A16  6100 1F7E               1119              BSR     PUSH_STACK
00001A1A  6000 000E               1120              BRA     OP_NOT_PRINT_EA
00001A1E                          1121  
00001A1E                          1122              
00001A1E                          1123  OP_NOT_L    * size is long
00001A1E  163C 004C               1124              MOVE.B  #'L',D3
00001A22  6100 1F72               1125              BSR     PUSH_STACK
00001A26  6000 0002               1126              BRA     OP_NOT_PRINT_EA
00001A2A                          1127  
00001A2A                          1128  
00001A2A                          1129  OP_NOT_PRINT_EA
00001A2A                          1130   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A2A  13FC 0082 000042BD      1131             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001A32                          1132             
00001A32                          1133             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A32  13FC 0020 000042C0      1134             MOVE.B   #$20,GET_SRC_START_END
00001A3A  6100 16BC               1135              BSR     GET_EA_EA_SRC
00001A3E                          1136              
00001A3E  4E75                    1137              RTS
00001A40                          1138  
00001A40                          1139  
00001A40                          1140  *---------------------------------------------------------------------------*
00001A40                          1141  * OP_JSR: display JSR     
00001A40                          1142  *---------------------------------------------------------------------------*
00001A40  43F9 00004037           1143  OP_JSR      LEA     DISP_JSR,A1
00001A46  103C 000E               1144              MOVE.B  #14,D0
00001A4A  4E4F                    1145              TRAP    #15
00001A4C  4EB9 00002C48           1146              JSR     EA_NOSRC
00001A52                          1147  
00001A52  4E75                    1148              RTS
00001A54                          1149  
00001A54                          1150  *---------------------------------------------------------------------------*
00001A54                          1151  * OP_RTS: display RTS     
00001A54                          1152  *---------------------------------------------------------------------------* 
00001A54                          1153  OP_RTS      
00001A54  163C 0052               1154              MOVE.B #'R',D3
00001A58  6100 1F3C               1155              BSR     PUSH_STACK
00001A5C  163C 0054               1156              MOVE.B #'T',D3
00001A60  6100 1F34               1157              BSR     PUSH_STACK
00001A64  163C 0053               1158              MOVE.B #'S',D3
00001A68  6100 1F2C               1159              BSR     PUSH_STACK
00001A6C  4E75                    1160              RTS
00001A6E                          1161  
00001A6E                          1162  *---------------------------------------------------------------------------*
00001A6E                          1163  * OP0101: decode ADDQ
00001A6E                          1164  *---------------------------------------------------------------------------* 
00001A6E                          1165  OP0101      
00001A6E                          1166             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A6E  13FC 0082 000042BC      1167             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A76  13FC 0080 000042BD      1168             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001A7E                          1169             
00001A7E                          1170             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A7E  13FC 00B9 000042BF      1171             MOVE.B   #$B9,GET_DST_START_END
00001A86  13FC 0020 000042C0      1172             MOVE.B   #$20,GET_SRC_START_END
00001A8E                          1173             
00001A8E                          1174              *CLEAR D3
00001A8E  4283                    1175              CLR.L   D3
00001A90                          1176              *LOAD STACK WITH THIS OPMODE
00001A90  6100 1F04               1177              BSR     PUSH_STACK
00001A94  163C 0041               1178              MOVE.B  #'A',D3
00001A98  6100 1EFC               1179              BSR     PUSH_STACK
00001A9C  163C 0044               1180              MOVE.B  #'D',D3
00001AA0  6100 1EF4               1181              BSR     PUSH_STACK
00001AA4  163C 0044               1182              MOVE.B  #'D',D3
00001AA8  6100 1EEC               1183              BSR     PUSH_STACK
00001AAC  163C 0051               1184              MOVE.B  #'Q',D3
00001AB0  6100 1EE4               1185              BSR     PUSH_STACK
00001AB4  163C 002E               1186              MOVE.B  #'.',D3
00001AB8  6100 1EDC               1187              BSR     PUSH_STACK
00001ABC                          1188              
00001ABC                          1189              *FIGURE OUT SIZE*
00001ABC                          1190              *00 = BYTE
00001ABC                          1191              *01 = WORD
00001ABC                          1192              *10 = LONG
00001ABC                          1193              * BITS 7&6
00001ABC                          1194              
00001ABC                          1195              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001ABC  2205                    1196              MOVE.L  D5,D1
00001ABE  EC99                    1197              ROR.L   #6,D1
00001AC0  0281 00000003           1198              ANDI.L  #$03,D1
00001AC6  0C01 0000               1199              CMPI.B  #%00,D1
00001ACA  6700 001E               1200              BEQ     OP0101_ADDQ_B
00001ACE  0281 00000003           1201              ANDI.L  #$03,D1
00001AD4  0C01 0001               1202              CMPI.B  #%01,D1
00001AD8  6700 001C               1203              BEQ     OP0101_ADDQ_W
00001ADC  0281 00000003           1204              ANDI.L  #$03,D1
00001AE2  0C01 0002               1205              CMPI.B  #%10,D1
00001AE6  6700 001A               1206              BEQ     OP0101_ADDQ_L
00001AEA                          1207            
00001AEA                          1208  OP0101_ADDQ_B
00001AEA                          1209              
00001AEA  163C 0042               1210              MOVE.B  #'B',D3
00001AEE  6100 1EA6               1211              BSR     PUSH_STACK
00001AF2  6000 0016               1212              BRA     OP0101_RETURN
00001AF6                          1213  OP0101_ADDQ_W
00001AF6                          1214              
00001AF6  163C 0057               1215              MOVE.B  #'W',D3
00001AFA  6100 1E9A               1216              BSR     PUSH_STACK
00001AFE  6000 000A               1217              BRA     OP0101_RETURN
00001B02                          1218  OP0101_ADDQ_L
00001B02                          1219              
00001B02  163C 004C               1220              MOVE.B  #'L',D3
00001B06  6100 1E8E               1221              BSR     PUSH_STACK
00001B0A                          1222  OP0101_RETURN            
00001B0A                          1223  
00001B0A                          1224              
00001B0A                          1225  *GET DATA FROM ADDQ AND PRINT #0-8
00001B0A  163C 0020               1226              MOVE.B  #' ',D3
00001B0E  6100 1E86               1227              BSR     PUSH_STACK
00001B12  163C 0023               1228              MOVE.B  #'#',D3
00001B16  6100 1E7E               1229              BSR     PUSH_STACK 
00001B1A                          1230  
00001B1A                          1231                       
00001B1A                          1232              *GET DATA #   
00001B1A  2205                    1233              MOVE.L  D5,D1
00001B1C  EC99                    1234              ROR.L   #6,D1            
00001B1E  E699                    1235              ROR.L   #3,D1
00001B20  0281 00000007           1236              ANDI.L  #$07,D1
00001B26                          1237              
00001B26  0C01 0000               1238              CMPI.B  #%000,D1
00001B2A  6700 009A               1239              BEQ     OP0101_ADDQ_B_8
00001B2E  0C01 0001               1240              CMPI.B  #%001,D1
00001B32  6700 003E               1241              BEQ     OP0101_ADDQ_B_1
00001B36  0C01 0002               1242              CMPI.B  #%010,D1
00001B3A  6700 0042               1243              BEQ     OP0101_ADDQ_B_2
00001B3E  0C01 0003               1244              CMPI.B  #%011,D1
00001B42  6700 0046               1245              BEQ     OP0101_ADDQ_B_3
00001B46  0C01 0004               1246              CMPI.B  #%100,D1
00001B4A  6700 004A               1247              BEQ     OP0101_ADDQ_B_4
00001B4E  0C01 0005               1248              CMPI.B  #%101,D1
00001B52  6700 004E               1249              BEQ     OP0101_ADDQ_B_5
00001B56  0C01 0006               1250              CMPI.B  #%110,D1
00001B5A  6700 0052               1251              BEQ     OP0101_ADDQ_B_6
00001B5E  0C01 0007               1252              CMPI.B  #%111,D1
00001B62  6700 0056               1253              BEQ     OP0101_ADDQ_B_7
00001B66                          1254              
00001B66                          1255  OP0101_ADDQ_B_0
00001B66  163C 0030               1256              MOVE.B  #'0',D3
00001B6A  6100 1E2A               1257              BSR     PUSH_STACK
00001B6E  6000 005E               1258              BRA     OP0101_RETURN2            
00001B72                          1259  OP0101_ADDQ_B_1
00001B72  163C 0031               1260              MOVE.B  #'1',D3
00001B76  6100 1E1E               1261              BSR     PUSH_STACK
00001B7A  6000 0052               1262              BRA     OP0101_RETURN2            
00001B7E                          1263  OP0101_ADDQ_B_2
00001B7E  163C 0032               1264              MOVE.B  #'2',D3
00001B82  6100 1E12               1265              BSR     PUSH_STACK
00001B86  6000 0046               1266              BRA     OP0101_RETURN2            
00001B8A                          1267  OP0101_ADDQ_B_3
00001B8A  163C 0033               1268              MOVE.B  #'3',D3
00001B8E  6100 1E06               1269              BSR     PUSH_STACK
00001B92  6000 003A               1270              BRA     OP0101_RETURN2            
00001B96                          1271  OP0101_ADDQ_B_4
00001B96  163C 0034               1272              MOVE.B  #'4',D3
00001B9A  6100 1DFA               1273              BSR     PUSH_STACK
00001B9E  6000 002E               1274              BRA     OP0101_RETURN2            
00001BA2                          1275  OP0101_ADDQ_B_5
00001BA2  163C 0035               1276              MOVE.B  #'5',D3
00001BA6  6100 1DEE               1277              BSR     PUSH_STACK
00001BAA  6000 0022               1278              BRA     OP0101_RETURN2
00001BAE                          1279  OP0101_ADDQ_B_6
00001BAE  163C 0036               1280              MOVE.B  #'6',D3
00001BB2  6100 1DE2               1281              BSR     PUSH_STACK
00001BB6  6000 0016               1282              BRA     OP0101_RETURN2
00001BBA                          1283  OP0101_ADDQ_B_7
00001BBA  163C 0037               1284              MOVE.B  #'7',D3
00001BBE  6100 1DD6               1285              BSR     PUSH_STACK
00001BC2  6000 000A               1286              BRA     OP0101_RETURN2
00001BC6                          1287  
00001BC6                          1288  OP0101_ADDQ_B_8
00001BC6  163C 0038               1289              MOVE.B  #'8',D3
00001BCA  6100 1DCA               1290              BSR     PUSH_STACK
00001BCE                          1291              
00001BCE                          1292  OP0101_RETURN2            
00001BCE  163C 002C               1293              MOVE.B  #',',D3
00001BD2  6100 1DC2               1294              BSR     PUSH_STACK
00001BD6  6100 1520               1295              BSR     GET_EA_EA_SRC
00001BDA                          1296              
00001BDA  4E75                    1297              RTS
00001BDC                          1298  
00001BDC                          1299  
00001BDC                          1300              
00001BDC                          1301  *---------------------------------------------------------------------------*
00001BDC                          1302  * OP_ADDQ: display ADDQ
00001BDC                          1303  *---------------------------------------------------------------------------*              
00001BDC                          1304  OP_ADDQ_B    * size is byte   
00001BDC  183C 0000               1305              MOVE.B  #0,D4 
00001BE0  43F9 00004091           1306              LEA     DISP_ADDQ_B,A1
00001BE6  103C 000E               1307              MOVE.B  #14,D0
00001BEA  4E4F                    1308              TRAP    #15
00001BEC  4E75                    1309              RTS
00001BEE                          1310              
00001BEE                          1311  OP_ADDQ_W    * size is word
00001BEE  183C 0001               1312              MOVE.B  #1,D4
00001BF2  43F9 0000409B           1313              LEA     DISP_ADDQ_W,A1
00001BF8  103C 000E               1314              MOVE.B  #14,D0
00001BFC  4E4F                    1315              TRAP    #15
00001BFE  4E75                    1316              RTS
00001C00                          1317              
00001C00                          1318  OP_ADDQ_L    * size is long
00001C00  183C 0002               1319              MOVE.B  #2,D4
00001C04  43F9 000040A5           1320              LEA     DISP_ADDQ_L,A1
00001C0A  103C 000E               1321              MOVE.B  #14,D0
00001C0E  4E4F                    1322              TRAP    #15
00001C10  4E75                    1323              RTS
00001C12                          1324  
00001C12                          1325  *---------------------------------------------------------------------------*
00001C12                          1326  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001C12                          1327  *---------------------------------------------------------------------------*              
00001C12  4280                    1328  OP0110      CLR.L   D0                  
00001C14  4281                    1329              CLR.L   D1   
00001C16  4284                    1330              CLR.L   D4                 
00001C18  227C 00000000           1331              MOVEA.L #0,A1
00001C1E  2205                    1332              MOVE.L  D5, D1                
00001C20  0281 000000FF           1333              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001C26  2205                    1334              MOVE.L  D5,D1                  
00001C28  0281 00000F00           1335              ANDI.L  #$0F00,D1
00001C2E                          1336                 
00001C2E  0C41 0000               1337              CMPI.W  #$0000,D1               * Check for BRA
00001C32  6700 0050               1338              BEQ     OP_BRA                  
00001C36                          1339                          
00001C36  0C41 0D00               1340              CMPI.W  #$0D00,D1               * Check for BLT
00001C3A  6700 0056               1341              BEQ     OP_BLT      
00001C3E                          1342  
00001C3E  0C41 0700               1343              CMPI.W  #$0700,D1               * Check for BEQ
00001C42  6700 0032               1344              BEQ     OP_BEQ      
00001C46                          1345  
00001C46  0C41 0600               1346              CMPI.W  #$0600,D1               * Check for BNE
00001C4A  6700 001C               1347              BEQ     OP_BNE  
00001C4E                          1348              
00001C4E  0C41 0200               1349              CMPI.W  #$0200,D1               * Check for BHI
00001C52  6700 0006               1350              BEQ     OP_BHI
00001C56                          1351  
00001C56  4EF8 14B8               1352              JMP     OP_DATA
00001C5A                          1353              
00001C5A  43F9 00004260           1354  OP_BHI      LEA     DISP_BHI,A1             
00001C60  103C 000E               1355              MOVE.B  #14,D0
00001C64  4E4F                    1356              TRAP    #15
00001C66  4E75                    1357              RTS
00001C68                          1358  
00001C68  43F9 00004259           1359  OP_BNE      LEA     DISP_BNE,A1             
00001C6E  103C 000E               1360              MOVE.B  #14,D0
00001C72  4E4F                    1361              TRAP    #15
00001C74  4E75                    1362              RTS
00001C76                          1363  
00001C76  43F9 00004252           1364  OP_BEQ      LEA     DISP_BEQ,A1             
00001C7C  103C 000E               1365              MOVE.B  #14,D0
00001C80  4E4F                    1366              TRAP    #15
00001C82  4E75                    1367              RTS          
00001C84                          1368                          
00001C84  43F9 00004244           1369  OP_BRA      LEA     DISP_BRA,A1             
00001C8A  103C 000E               1370              MOVE.B  #14,D0
00001C8E  4E4F                    1371              TRAP    #15
00001C90  4E75                    1372              RTS
00001C92                          1373              
00001C92  43F9 0000424B           1374  OP_BLT      LEA     DISP_BLT,A1          
00001C98  103C 000E               1375              MOVE.B  #14,D0
00001C9C  4E4F                    1376              TRAP    #15
00001C9E  4E75                    1377              RTS
00001CA0                          1378     
00001CA0                          1379  *---------------------------------------------------------------------------*
00001CA0                          1380  * OP0111 : MOVEQ not required
00001CA0                          1381  *---------------------------------------------------------------------------*           
00001CA0  4EF8 14B8               1382  OP0111      JMP     OP_DATA
00001CA4                          1383             
00001CA4                          1384  *---------------------------------------------------------------------------*
00001CA4                          1385  * OP1000 : decode DIVS
00001CA4                          1386  *---------------------------------------------------------------------------*           
00001CA4                          1387  OP1000                           
00001CA4  4281                    1388              CLR.L   D1       
00001CA6  4284                    1389              CLR.L   D4                   
00001CA8  227C 00000000           1390              MOVEA.L #0, A1              
00001CAE  2205                    1391              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001CB0                          1392              *CLEAR D3
00001CB0  4283                    1393              CLR.L   D3
00001CB2                          1394  
00001CB2                          1395  OP1000_DIVS_DN_EA_OR_EA_DN 
00001CB2                          1396              *LOAD STACK WITH THIS OPMODE
00001CB2  6100 1CE2               1397              BSR     PUSH_STACK
00001CB6  163C 0044               1398              MOVE.B  #'D',D3
00001CBA  6100 1CDA               1399              BSR     PUSH_STACK
00001CBE  163C 0049               1400              MOVE.B  #'I',D3
00001CC2  6100 1CD2               1401              BSR     PUSH_STACK
00001CC6  163C 0056               1402              MOVE.B  #'V',D3
00001CCA  6100 1CCA               1403              BSR     PUSH_STACK
00001CCE  163C 0053               1404              MOVE.B  #'S',D3
00001CD2  6100 1CC2               1405              BSR     PUSH_STACK
00001CD6  163C 002E               1406              MOVE.B  #'.',D3
00001CDA  6100 1CBA               1407              BSR     PUSH_STACK
00001CDE                          1408              
00001CDE  2205                    1409              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CE0                          1410              
00001CE0                          1411  OP1000_EA_DN_DIVS
00001CE0                          1412              *BITS (7 TO 6) 
00001CE0                          1413              *00 = .B
00001CE0                          1414              *01 = .W
00001CE0                          1415              *10 = .L 
00001CE0  2205                    1416              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001CE2  EC99                    1417              ROR.L   #6,D1
00001CE4  0281 00000003           1418              ANDI.L  #$03,D1
00001CEA  0C81 00000003           1419              CMPI.L  #%11,D1 *EQUALS .W
00001CF0  6700 0014               1420              BEQ     OP1000_PRINT_W_DIVS
00001CF4  0C81 00000000           1421              CMPI.L  #%00,D1 *EQUALS .L
00001CFA  6700 0052               1422              BEQ     OP1000_PRINT_L_DIVS
00001CFE                          1423              
00001CFE  183C 0001               1424              MOVE.B  #1,D4               *ERROR READ
00001D02  6000 0092               1425              BRA     OP1000_DIVS_RETURN
00001D06                          1426  OP1000_PRINT_W_DIVS
00001D06  163C 0057               1427              MOVE.B  #'W',D3
00001D0A  6100 1C8A               1428              BSR     PUSH_STACK
00001D0E                          1429  
00001D0E                          1430              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D0E  13FC 0000 000042BC      1431              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D16  13FC 0000 000042BD      1432              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D1E                          1433             
00001D1E                          1434              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D1E  13FC 00B9 000042BF      1435              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D26  13FC 0020 000042C0      1436              MOVE.B   #$20,GET_SRC_START_END
00001D2E                          1437  
00001D2E                          1438             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D2E  0285 0000FE3F           1439              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D34  0685 00000000           1440              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001D3A                          1441  
00001D3A                          1442              
00001D3A  6100 13BC               1443              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D3E  163C 002C               1444              MOVE.B  #',',D3
00001D42  6100 1C52               1445              BSR     PUSH_STACK
00001D46  6100 17E0               1446              BSR     GET_EA_EA_DEST       *GETS Dn    
00001D4A                          1447              
00001D4A  6000 004A               1448              BRA     OP1000_DIVS_RETURN
00001D4E                          1449  OP1000_PRINT_L_DIVS
00001D4E  163C 004C               1450              MOVE.B  #'L',D3
00001D52  6100 1C42               1451              BSR     PUSH_STACK
00001D56                          1452              
00001D56                          1453              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D56  13FC 0000 000042BC      1454              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D5E  13FC 0000 000042BD      1455              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D66                          1456             
00001D66                          1457              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D66  13FC 00B9 000042BF      1458              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D6E  13FC 0020 000042C0      1459              MOVE.B   #$20,GET_SRC_START_END
00001D76                          1460  
00001D76                          1461              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D76  0285 0000FE3F           1462              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D7C  0685 00000000           1463              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001D82                          1464  
00001D82                          1465                     
00001D82  6100 1374               1466              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D86  163C 002C               1467              MOVE.B  #',',D3
00001D8A  6100 1C0A               1468              BSR     PUSH_STACK                  
00001D8E  6100 1798               1469              BSR     GET_EA_EA_DEST       *GETS Dn    
00001D92                          1470  
00001D92                          1471              
00001D92  6000 0002               1472              BRA     OP1000_DIVS_RETURN
00001D96                          1473              
00001D96                          1474  OP1000_DIVS_RETURN
00001D96  4E75                    1475              RTS
00001D98                          1476              
00001D98                          1477  
00001D98                          1478  
00001D98                          1479  *---------------------------------------------------------------------------*
00001D98                          1480  * OP_DIVS: display DIVS and proceed to EA
00001D98                          1481  *---------------------------------------------------------------------------*  
00001D98  43F9 000040AF           1482  OP_DIVS     LEA     DISP_DIVS,A1
00001D9E  103C 000E               1483              MOVE.B  #14,D0
00001DA2  4E4F                    1484              TRAP    #15
00001DA4  4EF9 00002C5C           1485              JMP     EA_ARITH
00001DAA                          1486  
00001DAA  4E75                    1487              RTS
00001DAC                          1488              
00001DAC                          1489  *---------------------------------------------------------------------------*
00001DAC                          1490  * OP1001: decode SUB/SUBA
00001DAC                          1491  *---------------------------------------------------------------------------*      
00001DAC                          1492  OP1001      
00001DAC  4280                    1493              CLR.L   D0                  
00001DAE  4281                    1494              CLR.L   D1       
00001DB0  4284                    1495              CLR.L   D4                   
00001DB2  227C 00000000           1496              MOVEA.L #0, A1              
00001DB8  2205                    1497              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001DBA                          1498              
00001DBA                          1499              *CLEAR D3
00001DBA  4283                    1500              CLR.L   D3
00001DBC                          1501              
00001DBC                          1502              
00001DBC                          1503              
00001DBC                          1504              **INTEGRATING SUB.W/.L INTO THIS CODE**
00001DBC  2205                    1505              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001DBE                          1506              *BITS (INDEX 8) 
00001DBE                          1507              *0 = ADD.B/W/L <EA>,Dn
00001DBE                          1508              *1 = ADD.B/W/L Dn,<EA> 
00001DBE  EC99                    1509              ROR.L   #6,D1
00001DC0  0281 00000007           1510              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001DC6  0C81 00000007           1511              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001DCC  6700 0010               1512              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001DD0  0C81 00000003           1513              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001DD6  6700 0078               1514              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001DDA  6000 00E6               1515              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001DDE                          1516              
00001DDE                          1517  OP1001_SUBA_L
00001DDE                          1518              *LOAD STACK WITH THIS OPMODE
00001DDE  6100 1BB6               1519              BSR     PUSH_STACK
00001DE2  163C 0053               1520              MOVE.B  #'S',D3
00001DE6  6100 1BAE               1521              BSR     PUSH_STACK
00001DEA  163C 0055               1522              MOVE.B  #'U',D3
00001DEE  6100 1BA6               1523              BSR     PUSH_STACK
00001DF2  163C 0042               1524              MOVE.B  #'B',D3
00001DF6  6100 1B9E               1525              BSR     PUSH_STACK
00001DFA  163C 0041               1526              MOVE.B  #'A',D3
00001DFE  6100 1B96               1527              BSR     PUSH_STACK
00001E02  163C 002E               1528              MOVE.B  #'.',D3
00001E06  6100 1B8E               1529              BSR     PUSH_STACK
00001E0A  163C 004C               1530              MOVE.B  #'L',D3
00001E0E  6100 1B86               1531              BSR     PUSH_STACK
00001E12                          1532              
00001E12                          1533             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E12  13FC 0000 000042BC      1534             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E1A  13FC 0000 000042BD      1535             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E22                          1536             
00001E22                          1537             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E22  13FC 00B9 000042BF      1538             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E2A  13FC 0020 000042C0      1539             MOVE.B   #$20,GET_SRC_START_END
00001E32                          1540  
00001E32                          1541              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E32  0285 0000FE3F           1542              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E38  0685 00000040           1543              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E3E                          1544       
00001E3E                          1545              *PRINT <EA>,AN
00001E3E  6100 12B8               1546              BSR     GET_EA_EA_SRC       *GETS <ea>
00001E42  163C 002C               1547              MOVE.B  #',',D3
00001E46  6100 1B4E               1548              BSR     PUSH_STACK                     
00001E4A  6100 16DC               1549              BSR     GET_EA_EA_DEST      *GETS Dn
00001E4E                          1550  
00001E4E                          1551              
00001E4E                          1552              
00001E4E  4E75                    1553              RTS
00001E50                          1554  OP1001_SUBA_W
00001E50                          1555              *LOAD STACK WITH THIS OPMODE
00001E50  6100 1B44               1556              BSR     PUSH_STACK
00001E54  163C 0053               1557              MOVE.B  #'S',D3
00001E58  6100 1B3C               1558              BSR     PUSH_STACK
00001E5C  163C 0055               1559              MOVE.B  #'U',D3
00001E60  6100 1B34               1560              BSR     PUSH_STACK
00001E64  163C 0042               1561              MOVE.B  #'B',D3
00001E68  6100 1B2C               1562              BSR     PUSH_STACK
00001E6C  163C 0041               1563              MOVE.B  #'A',D3
00001E70  6100 1B24               1564              BSR     PUSH_STACK
00001E74  163C 002E               1565              MOVE.B  #'.',D3
00001E78  6100 1B1C               1566              BSR     PUSH_STACK
00001E7C  163C 0057               1567              MOVE.B  #'W',D3
00001E80  6100 1B14               1568              BSR     PUSH_STACK
00001E84                          1569              
00001E84                          1570             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E84  13FC 0000 000042BC      1571             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E8C  13FC 0000 000042BD      1572             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E94                          1573             
00001E94                          1574             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E94  13FC 00B9 000042BF      1575             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E9C  13FC 0020 000042C0      1576             MOVE.B   #$20,GET_SRC_START_END
00001EA4                          1577  
00001EA4                          1578              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001EA4  0285 0000FE3F           1579              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001EAA  0685 00000040           1580              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001EB0                          1581       
00001EB0                          1582              *PRINT <EA>,AN
00001EB0  6100 1246               1583              BSR     GET_EA_EA_SRC       *GETS <ea>
00001EB4  163C 002C               1584              MOVE.B  #',',D3
00001EB8  6100 1ADC               1585              BSR     PUSH_STACK                     
00001EBC  6100 166A               1586              BSR     GET_EA_EA_DEST      *GETS Dn
00001EC0                          1587  
00001EC0  4E75                    1588              RTS
00001EC2                          1589  
00001EC2                          1590  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001EC2                          1591              *LOAD STACK WITH THIS OPMODE
00001EC2  6100 1AD2               1592              BSR     PUSH_STACK
00001EC6  163C 0053               1593              MOVE.B  #'S',D3
00001ECA  6100 1ACA               1594              BSR     PUSH_STACK
00001ECE  163C 0055               1595              MOVE.B  #'U',D3
00001ED2  6100 1AC2               1596              BSR     PUSH_STACK
00001ED6  163C 0042               1597              MOVE.B  #'B',D3
00001EDA  6100 1ABA               1598              BSR     PUSH_STACK
00001EDE  163C 002E               1599              MOVE.B  #'.',D3
00001EE2  6100 1AB2               1600              BSR     PUSH_STACK
00001EE6                          1601              
00001EE6  2205                    1602              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001EE8                          1603              
00001EE8                          1604              *BITS (INDEX 8) 
00001EE8                          1605              *0 = ADD.B/W/L <EA>,Dn
00001EE8                          1606              *1 = ADD.B/W/L Dn,<EA> 
00001EE8  E099                    1607              ROR.L   #8,D1
00001EEA  0281 00000001           1608              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001EF0  0C81 00000000           1609              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001EF6  6700 0102               1610              BEQ     OP1001_EA_DN
00001EFA                          1611              *else procede to Dn_EA
00001EFA                          1612              
00001EFA                          1613  OP1001_DN_EA
00001EFA                          1614              *BITS (7 TO 6) 
00001EFA                          1615              *00 = .B
00001EFA                          1616              *01 = .W
00001EFA                          1617              *10 = .L 
00001EFA  2205                    1618              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001EFC  EC99                    1619              ROR.L   #6,D1
00001EFE  0281 00000003           1620              ANDI.L  #$03,D1
00001F04  0C81 00000000           1621              CMPI.L  #$00,D1 *EQUALS .B
00001F0A  6700 0016               1622              BEQ     OP1001_PRINT_B2
00001F0E  0C81 00000001           1623              CMPI.L  #$01,D1 *EQUALS .W
00001F14  6700 0054               1624              BEQ     OP1001_PRINT_W2
00001F18  0C81 00000002           1625              CMPI.L  #$02,D1 *EQUALS .L
00001F1E  6700 0092               1626              BEQ     OP1001_PRINT_L2
00001F22                          1627  OP1001_PRINT_B2
00001F22                          1628              *PUSH 'B'
00001F22  163C 0042               1629              MOVE.B  #'B',D3
00001F26  6100 1A6E               1630              BSR     PUSH_STACK
00001F2A                          1631             
00001F2A                          1632              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F2A  13FC 0000 000042BC      1633             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F32  13FC 0083 000042BD      1634             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F3A                          1635             
00001F3A                          1636             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F3A  13FC 00B9 000042BF      1637             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F42  13FC 0020 000042C0      1638             MOVE.B   #$20,GET_SRC_START_END
00001F4A                          1639  
00001F4A                          1640              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F4A  0285 0000FE3F           1641              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F50  0685 00000040           1642              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001F56                          1643       
00001F56  6100 15D0               1644              BSR     GET_EA_EA_DEST      *GETS Dn
00001F5A  163C 002C               1645              MOVE.B  #',',D3
00001F5E  6100 1A36               1646              BSR     PUSH_STACK                     
00001F62  6100 1194               1647              BSR     GET_EA_EA_SRC       *GETS <ea>
00001F66                          1648  
00001F66                          1649              
00001F66  6000 09A0               1650              BRA     OP1101_ADD_RETURN
00001F6A                          1651  OP1001_PRINT_W2
00001F6A  163C 0057               1652              MOVE.B  #'W',D3
00001F6E  6100 1A26               1653              BSR     PUSH_STACK
00001F72                          1654  
00001F72                          1655              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F72  13FC 0000 000042BC      1656              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F7A  13FC 0083 000042BD      1657              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F82                          1658             
00001F82                          1659              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F82  13FC 00B9 000042BF      1660              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F8A  13FC 0020 000042C0      1661              MOVE.B   #$20,GET_SRC_START_END
00001F92                          1662  
00001F92                          1663              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F92  0285 0000FE3F           1664              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F98  0685 00000040           1665              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001F9E                          1666  
00001F9E                          1667        
00001F9E  6100 1588               1668              BSR     GET_EA_EA_DEST      *GETS Dn
00001FA2  163C 002C               1669              MOVE.B  #',',D3
00001FA6  6100 19EE               1670              BSR     PUSH_STACK               
00001FAA  6100 114C               1671              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001FAE                          1672  
00001FAE                          1673  
00001FAE                          1674  
00001FAE  6000 0958               1675              BRA     OP1101_ADD_RETURN
00001FB2                          1676  OP1001_PRINT_L2 
00001FB2  163C 004C               1677              MOVE.B  #'L',D3
00001FB6  6100 19DE               1678              BSR     PUSH_STACK
00001FBA                          1679              
00001FBA                          1680              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001FBA  13FC 0000 000042BC      1681              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001FC2  13FC 0083 000042BD      1682              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001FCA                          1683             
00001FCA                          1684              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001FCA  13FC 00B9 000042BF      1685              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001FD2  13FC 0020 000042C0      1686              MOVE.B   #$20,GET_SRC_START_END
00001FDA                          1687  
00001FDA                          1688             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001FDA  0285 0000FE3F           1689              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001FE0  0685 00000040           1690              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001FE6                          1691  
00001FE6                          1692               
00001FE6  6100 1540               1693              BSR     GET_EA_EA_DEST       *GETS Dn
00001FEA  163C 002C               1694              MOVE.B  #',',D3
00001FEE  6100 19A6               1695              BSR     PUSH_STACK          
00001FF2  6100 1104               1696              BSR     GET_EA_EA_SRC        *GETS <ea>
00001FF6                          1697  
00001FF6  6000 0910               1698              BRA     OP1101_ADD_RETURN
00001FFA                          1699              
00001FFA                          1700  OP1001_EA_DN           
00001FFA                          1701              *BITS (7 TO 6) 
00001FFA                          1702              *00 = .B
00001FFA                          1703              *01 = .W
00001FFA                          1704              *10 = .L 
00001FFA  2205                    1705              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001FFC  EC99                    1706              ROR.L   #6,D1
00001FFE  0281 00000003           1707              ANDI.L  #$03,D1
00002004  0C81 00000000           1708              CMPI.L  #$00,D1 *EQUALS .B
0000200A  6700 0016               1709              BEQ     OP1001_PRINT_B
0000200E  0C81 00000001           1710              CMPI.L  #$01,D1 *EQUALS .W
00002014  6700 0054               1711              BEQ     OP1001_PRINT_W
00002018  0C81 00000002           1712              CMPI.L  #$02,D1 *EQUALS .L
0000201E  6700 0092               1713              BEQ     OP1001_PRINT_L
00002022                          1714  OP1001_PRINT_B
00002022  163C 0042               1715              MOVE.B  #'B',D3
00002026  6100 196E               1716              BSR     PUSH_STACK
0000202A                          1717                
0000202A                          1718              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000202A  13FC 0000 000042BC      1719              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002032  13FC 0002 000042BD      1720              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000203A                          1721             
0000203A                          1722              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000203A  13FC 00B9 000042BF      1723              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002042  13FC 0020 000042C0      1724              MOVE.B   #$20,GET_SRC_START_END
0000204A                          1725  
0000204A                          1726             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000204A  0285 0000FE3F           1727              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002050  0685 00000040           1728              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002056                          1729  
00002056                          1730              
00002056  6100 10A0               1731              BSR     GET_EA_EA_SRC      *GETS <ea>
0000205A  163C 002C               1732              MOVE.B  #',',D3
0000205E  6100 1936               1733              BSR     PUSH_STACK          
00002062  6100 14C4               1734              BSR     GET_EA_EA_DEST       *GETS Dn
00002066                          1735              
00002066  6000 08A0               1736              BRA     OP1101_ADD_RETURN
0000206A                          1737  OP1001_PRINT_W
0000206A  163C 0057               1738              MOVE.B  #'W',D3
0000206E  6100 1926               1739              BSR     PUSH_STACK
00002072                          1740  
00002072                          1741              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002072  13FC 0000 000042BC      1742              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000207A  13FC 0000 000042BD      1743              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002082                          1744             
00002082                          1745              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002082  13FC 00B9 000042BF      1746              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000208A  13FC 0020 000042C0      1747              MOVE.B   #$20,GET_SRC_START_END
00002092                          1748  
00002092                          1749             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002092  0285 0000FE3F           1750              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002098  0685 00000040           1751              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000209E                          1752  
0000209E                          1753              
0000209E  6100 1058               1754              BSR     GET_EA_EA_SRC      *GETS <ea>
000020A2  163C 002C               1755              MOVE.B  #',',D3
000020A6  6100 18EE               1756              BSR     PUSH_STACK
000020AA  6100 147C               1757              BSR     GET_EA_EA_DEST       *GETS Dn    
000020AE                          1758              
000020AE  6000 004A               1759              BRA     OP1001_ADD_RETURN
000020B2                          1760  OP1001_PRINT_L 
000020B2  163C 004C               1761              MOVE.B  #'L',D3
000020B6  6100 18DE               1762              BSR     PUSH_STACK
000020BA                          1763              
000020BA                          1764              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020BA  13FC 0000 000042BC      1765              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020C2  13FC 0000 000042BD      1766              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020CA                          1767             
000020CA                          1768              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020CA  13FC 00B9 000042BF      1769              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020D2  13FC 0020 000042C0      1770              MOVE.B   #$20,GET_SRC_START_END
000020DA                          1771  
000020DA                          1772              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000020DA  0285 0000FE3F           1773              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020E0  0685 00000040           1774              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000020E6                          1775  
000020E6                          1776                     
000020E6  6100 1010               1777              BSR     GET_EA_EA_SRC      *GETS <ea>
000020EA  163C 002C               1778              MOVE.B  #',',D3
000020EE  6100 18A6               1779              BSR     PUSH_STACK                  
000020F2  6100 1434               1780              BSR     GET_EA_EA_DEST       *GETS Dn    
000020F6                          1781  
000020F6                          1782              
000020F6  6000 0002               1783              BRA     OP1001_ADD_RETURN
000020FA                          1784              
000020FA                          1785  OP1001_ADD_RETURN
000020FA  4E75                    1786              RTS
000020FC                          1787  
000020FC                          1788    
000020FC                          1789  *---------------------------------------------------------------------------*
000020FC                          1790  * OP_SUB: display SUB and proceed to EA
000020FC                          1791  *---------------------------------------------------------------------------*            
000020FC  43F9 000040B7           1792  OP_SUB_B    LEA     DISP_SUB_B,A1
00002102  103C 000E               1793              MOVE.B  #14,D0
00002106  4E4F                    1794              TRAP    #15
00002108  183C 0000               1795              MOVE.B  #0,D4
0000210C  4EF9 00002CA8           1796              JMP     EA_GEN
00002112                          1797  
00002112  4E75                    1798              RTS
00002114                          1799  
00002114  43F9 000040C0           1800  OP_SUB_W    LEA     DISP_SUB_W,A1
0000211A  103C 000E               1801              MOVE.B  #14,D0
0000211E  4E4F                    1802              TRAP    #15
00002120  183C 0001               1803              MOVE.B  #1,D4
00002124  4EF9 00002CA8           1804              JMP     EA_GEN
0000212A                          1805  
0000212A  4E75                    1806              RTS
0000212C                          1807  
0000212C  43F9 000040C9           1808  OP_SUB_L    LEA     DISP_SUB_L,A1
00002132  103C 000E               1809              MOVE.B  #14,D0
00002136  4E4F                    1810              TRAP    #15
00002138  183C 0002               1811              MOVE.B  #2,D4
0000213C  4EF9 00002CA8           1812              JMP     EA_GEN
00002142                          1813  
00002142  4E75                    1814              RTS
00002144                          1815  
00002144                          1816  *---------------------------------------------------------------------------*
00002144                          1817  * OP_SUBA: display SUBA
00002144                          1818  *---------------------------------------------------------------------------*  
00002144  43F9 000040F0           1819  OP_SUBA_W   LEA     DISP_SUBA_W,A1
0000214A  103C 000E               1820              MOVE.B  #14,D0
0000214E  4E4F                    1821              TRAP    #15
00002150  183C 0001               1822              MOVE.B  #1,D4
00002154  4E75                    1823              RTS
00002156                          1824  
00002156  43F9 000040FA           1825  OP_SUBA_L   LEA     DISP_SUBA_L,A1
0000215C  103C 000E               1826              MOVE.B  #14,D0
00002160  4E4F                    1827              TRAP    #15
00002162  183C 0002               1828              MOVE.B  #2,D4
00002166  4E75                    1829              RTS         
00002168                          1830  *---------------------------------------------------------------------------*
00002168                          1831  * OP1010 : unassigned
00002168                          1832  *---------------------------------------------------------------------------*           
00002168  4EF8 14B8               1833  OP1010      JMP     OP_DATA
0000216C                          1834              
0000216C                          1835  *---------------------------------------------------------------------------*
0000216C                          1836  * OP1011 : decode CMP/EOR/CMPA
0000216C                          1837  *---------------------------------------------------------------------------*           
0000216C  4280                    1838  OP1011      CLR.L   D0                
0000216E  4281                    1839              CLR.L   D1            
00002170  4284                    1840              CLR.L   D4                   
00002172  227C 00000000           1841              MOVEA.L #0, A1               
00002178  2205                    1842              MOVE.L  D5,D1
0000217A  EA99                    1843              ROR.L   #5,D1
0000217C  0281 0000000E           1844              ANDI.L  #$E,D1
00002182  0C01 0000               1845              CMPI.B  #$0,D1
00002186  6700 0062               1846              BEQ     OP_CMP_B
0000218A  0C01 0002               1847              CMPI.B  #$2,D1
0000218E  6700 0072               1848              BEQ     OP_CMP_W
00002192  0C01 0004               1849              CMPI.B  #$4,D1
00002196  6700 0082               1850              BEQ     OP_CMP_L
0000219A  0C01 0008               1851              CMPI.B  #$8,D1
0000219E  6700 0092               1852              BEQ     OP_EOR_B
000021A2  0C01 000A               1853              CMPI.B  #$A,D1
000021A6  6700 009C               1854              BEQ     OP_EOR_W
000021AA  0C01 000C               1855              CMPI.B  #$C,D1
000021AE  6700 00A6               1856              BEQ     OP_EOR_L  
000021B2  0C01 0006               1857              CMPI.B  #$6,D1
000021B6  6700 000E               1858              BEQ     OP_CMPA_W
000021BA  0C01 000E               1859              CMPI.B  #$E,D1
000021BE  6700 0018               1860              BEQ     OP_CMPA_L 
000021C2                          1861  
000021C2  4EF8 14B8               1862              JMP     OP_DATA          
000021C6                          1863  
000021C6                          1864  *---------------------------------------------------------------------------*
000021C6                          1865  * OP_CMPA: display CMPA 
000021C6                          1866  *---------------------------------------------------------------------------
000021C6  43F9 0000413A           1867  OP_CMPA_W   LEA     DISP_CMPA_W,A1
000021CC  103C 000E               1868              MOVE.B  #14,D0
000021D0  4E4F                    1869              TRAP    #15
000021D2  183C 0001               1870              MOVE.B  #1,D4
000021D6  4E75                    1871              RTS
000021D8                          1872  
000021D8  43F9 00004144           1873  OP_CMPA_L   LEA     DISP_CMPA_L,A1
000021DE  103C 000E               1874              MOVE.B  #14,D0
000021E2  4E4F                    1875              TRAP    #15
000021E4  183C 0002               1876              MOVE.B  #2,D4
000021E8  4E75                    1877              RTS
000021EA                          1878  
000021EA                          1879  *---------------------------------------------------------------------------*
000021EA                          1880  * OP_CMP: display CMP and proceed to EA
000021EA                          1881  *---------------------------------------------------------------------------*  
000021EA  43F9 0000411F           1882  OP_CMP_B    LEA     DISP_CMP_B,A1
000021F0  103C 000E               1883              MOVE.B  #14,D0
000021F4  4E4F                    1884              TRAP    #15
000021F6  183C 0000               1885              MOVE.B  #0,D4
000021FA  4EF9 00002CA8           1886              JMP     EA_GEN
00002200                          1887  
00002200  4E75                    1888              RTS
00002202                          1889              
00002202  43F9 00004128           1890  OP_CMP_W    LEA     DISP_CMP_W,A1
00002208  103C 000E               1891              MOVE.B  #14,D0
0000220C  4E4F                    1892              TRAP    #15
0000220E  183C 0001               1893              MOVE.B  #1,D4
00002212  4EF9 00002CA8           1894              JMP     EA_GEN
00002218                          1895  
00002218  4E75                    1896              RTS
0000221A                          1897              
0000221A  43F9 00004131           1898  OP_CMP_L    LEA     DISP_CMP_L,A1
00002220  103C 000E               1899              MOVE.B  #14,D0
00002224  4E4F                    1900              TRAP    #15
00002226  183C 0002               1901              MOVE.B  #2,D4
0000222A  4EF9 00002CA8           1902              JMP     EA_GEN
00002230                          1903  
00002230  4E75                    1904              RTS
00002232                          1905              
00002232                          1906  *---------------------------------------------------------------------------*
00002232                          1907  * OP_EOR: display EOR
00002232                          1908  *---------------------------------------------------------------------------*  
00002232  43F9 00004104           1909  OP_EOR_B    LEA     DISP_EOR_B,A1
00002238  103C 000E               1910              MOVE.B  #14,D0
0000223C  4E4F                    1911              TRAP    #15
0000223E  183C 0000               1912              MOVE.B  #0,D4
00002242  4E75                    1913              RTS
00002244                          1914              
00002244  43F9 0000410D           1915  OP_EOR_W    LEA     DISP_EOR_W,A1
0000224A  103C 000E               1916              MOVE.B  #14,D0
0000224E  4E4F                    1917              TRAP    #15
00002250  183C 0001               1918              MOVE.B  #1,D4
00002254  4E75                    1919              RTS
00002256                          1920              
00002256  43F9 00004116           1921  OP_EOR_L    LEA     DISP_EOR_L,A1
0000225C  103C 000E               1922              MOVE.B  #14,D0
00002260  4E4F                    1923              TRAP    #15
00002262  183C 0002               1924              MOVE.B  #2,D4
00002266  4E75                    1925              RTS    
00002268                          1926  
00002268                          1927  *---------------------------------------------------------------------------*
00002268                          1928  * OP1100: Decode and display MULS/AND and proceed to EA
00002268                          1929  *---------------------------------------------------------------------------* 
00002268  4280                    1930  OP1100      CLR.L   D0                 
0000226A  4281                    1931              CLR.L   D1    
0000226C  4284                    1932              CLR.L   D4                
0000226E  227C 00000000           1933              MOVEA.L #0, A1        
00002274  2205                    1934              MOVE.L  D5,D1
00002276  EA89                    1935              LSR.L   #5,D1
00002278  0281 0000000E           1936              ANDI.L  #$E,D1
0000227E  0C41 000E               1937              CMPI.W  #$E,D1
00002282  6700 0006               1938              BEQ     OP_MULS
00002286  6000 00F6               1939              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000228A                          1940  
0000228A                          1941  OP_MULS                      
0000228A  4281                    1942              CLR.L   D1       
0000228C  4284                    1943              CLR.L   D4                   
0000228E  227C 00000000           1944              MOVEA.L #0, A1              
00002294  2205                    1945              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002296                          1946              *CLEAR D3
00002296  4283                    1947              CLR.L   D3
00002298                          1948  
00002298                          1949  OP1100_MULS_DN_EA_OR_EA_DN 
00002298                          1950              *LOAD STACK WITH THIS OPMODE
00002298  6100 16FC               1951              BSR     PUSH_STACK
0000229C  163C 004D               1952              MOVE.B  #'M',D3
000022A0  6100 16F4               1953              BSR     PUSH_STACK
000022A4  163C 0055               1954              MOVE.B  #'U',D3
000022A8  6100 16EC               1955              BSR     PUSH_STACK
000022AC  163C 004C               1956              MOVE.B  #'L',D3
000022B0  6100 16E4               1957              BSR     PUSH_STACK
000022B4  163C 0053               1958              MOVE.B  #'S',D3
000022B8  6100 16DC               1959              BSR     PUSH_STACK
000022BC  163C 002E               1960              MOVE.B  #'.',D3
000022C0  6100 16D4               1961              BSR     PUSH_STACK
000022C4                          1962              
000022C4  2205                    1963              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000022C6                          1964              
000022C6                          1965  OP1100_EA_DN_MULS           
000022C6                          1966              *BITS (7 TO 6) 
000022C6                          1967              *00 = .B
000022C6                          1968              *01 = .W
000022C6                          1969              *10 = .L 
000022C6  2205                    1970              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000022C8  EC99                    1971              ROR.L   #6,D1
000022CA  0281 00000003           1972              ANDI.L  #$03,D1
000022D0  0C81 00000003           1973              CMPI.L  #%11,D1 *EQUALS .W
000022D6  6700 0014               1974              BEQ     OP1100_PRINT_W_MULS
000022DA  0C81 00000000           1975              CMPI.L  #%00,D1 *EQUALS .L
000022E0  6700 0052               1976              BEQ     OP1100_PRINT_L_MULS
000022E4                          1977              
000022E4  183C 0001               1978              MOVE.B  #1,D4               *ERROR READ
000022E8  6000 0092               1979              BRA     OP1100_MULS_RETURN
000022EC                          1980  OP1100_PRINT_W_MULS
000022EC  163C 0057               1981              MOVE.B  #'W',D3
000022F0  6100 16A4               1982              BSR     PUSH_STACK
000022F4                          1983  
000022F4                          1984              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022F4  13FC 0000 000042BC      1985              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022FC  13FC 0000 000042BD      1986              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002304                          1987             
00002304                          1988              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002304  13FC 00B9 000042BF      1989              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000230C  13FC 0020 000042C0      1990              MOVE.B   #$20,GET_SRC_START_END
00002314                          1991  
00002314                          1992             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002314  0285 0000FE3F           1993              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000231A  0685 00000000           1994              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002320                          1995  
00002320                          1996              
00002320  6100 0DD6               1997              BSR     GET_EA_EA_SRC      *GETS <ea>
00002324  163C 002C               1998              MOVE.B  #',',D3
00002328  6100 166C               1999              BSR     PUSH_STACK
0000232C  6100 11FA               2000              BSR     GET_EA_EA_DEST       *GETS Dn    
00002330                          2001              
00002330  6000 004A               2002              BRA     OP1100_MULS_RETURN
00002334                          2003  OP1100_PRINT_L_MULS 
00002334  163C 004C               2004              MOVE.B  #'L',D3
00002338  6100 165C               2005              BSR     PUSH_STACK
0000233C                          2006              
0000233C                          2007              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000233C  13FC 0000 000042BC      2008              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002344  13FC 0000 000042BD      2009              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000234C                          2010             
0000234C                          2011              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000234C  13FC 00B9 000042BF      2012              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002354  13FC 0020 000042C0      2013              MOVE.B   #$20,GET_SRC_START_END
0000235C                          2014  
0000235C                          2015              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000235C  0285 0000FE3F           2016              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002362  0685 00000000           2017              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002368                          2018  
00002368                          2019                     
00002368  6100 0D8E               2020              BSR     GET_EA_EA_SRC      *GETS <ea>
0000236C  163C 002C               2021              MOVE.B  #',',D3
00002370  6100 1624               2022              BSR     PUSH_STACK                  
00002374  6100 11B2               2023              BSR     GET_EA_EA_DEST       *GETS Dn    
00002378                          2024  
00002378                          2025              
00002378  6000 0002               2026              BRA     OP1100_MULS_RETURN
0000237C                          2027              
0000237C                          2028  OP1100_MULS_RETURN
0000237C  4E75                    2029              RTS
0000237E                          2030              
0000237E                          2031  
0000237E                          2032  
0000237E                          2033  
0000237E                          2034  
0000237E                          2035  
0000237E                          2036  
0000237E                          2037  
0000237E                          2038  
0000237E                          2039  
0000237E                          2040  
0000237E                          2041  
0000237E                          2042  
0000237E                          2043  OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000237E                          2044              *LOAD STACK WITH THIS OPMODE
0000237E  4283                    2045              CLR.L   D3
00002380  6100 1614               2046              BSR     PUSH_STACK
00002384  163C 0041               2047              MOVE.B  #'A',D3
00002388  6100 160C               2048              BSR     PUSH_STACK
0000238C  163C 004E               2049              MOVE.B  #'N',D3
00002390  6100 1604               2050              BSR     PUSH_STACK
00002394  163C 0044               2051              MOVE.B  #'D',D3
00002398  6100 15FC               2052              BSR     PUSH_STACK
0000239C  163C 002E               2053              MOVE.B  #'.',D3
000023A0  6100 15F4               2054              BSR     PUSH_STACK
000023A4                          2055              
000023A4  2205                    2056              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000023A6                          2057              
000023A6                          2058              *BITS (INDEX 8) 
000023A6                          2059              *0 = ADD.B/W/L <EA>,Dn
000023A6                          2060              *1 = ADD.B/W/L Dn,<EA> 
000023A6  E099                    2061              ROR.L   #8,D1
000023A8  0281 00000001           2062              ANDI.L  #$01,D1     *MASKS WITH 00000001
000023AE  0C81 00000000           2063              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000023B4  6700 0102               2064              BEQ     OP1100_EA_DN
000023B8                          2065              *else procede to Dn_EA
000023B8                          2066              
000023B8                          2067  OP1100_DN_EA
000023B8                          2068              *BITS (7 TO 6) 
000023B8                          2069              *00 = .B
000023B8                          2070              *01 = .W
000023B8                          2071              *10 = .L 
000023B8  2205                    2072              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000023BA  EC99                    2073              ROR.L   #6,D1
000023BC  0281 00000003           2074              ANDI.L  #$03,D1
000023C2  0C81 00000000           2075              CMPI.L  #$00,D1 *EQUALS .B
000023C8  6700 0016               2076              BEQ     OP1100_PRINT_B2
000023CC  0C81 00000001           2077              CMPI.L  #$01,D1 *EQUALS .W
000023D2  6700 0054               2078              BEQ     OP1100_PRINT_W2
000023D6  0C81 00000002           2079              CMPI.L  #$02,D1 *EQUALS .L
000023DC  6700 0092               2080              BEQ     OP1100_PRINT_L2
000023E0                          2081  OP1100_PRINT_B2
000023E0                          2082              *PUSH 'B'
000023E0  163C 0042               2083              MOVE.B  #'B',D3
000023E4  6100 15B0               2084              BSR     PUSH_STACK
000023E8                          2085             
000023E8                          2086              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023E8  13FC 0000 000042BC      2087             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023F0  13FC 0083 000042BD      2088             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023F8                          2089             
000023F8                          2090             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023F8  13FC 00B9 000042BF      2091             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002400  13FC 0020 000042C0      2092             MOVE.B   #$20,GET_SRC_START_END
00002408                          2093  
00002408                          2094              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002408  0285 0000FE3F           2095              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000240E  0685 00000000           2096              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002414                          2097       
00002414  6100 1112               2098              BSR     GET_EA_EA_DEST      *GETS Dn
00002418  163C 002C               2099              MOVE.B  #',',D3
0000241C  6100 1578               2100              BSR     PUSH_STACK                     
00002420  6100 0CD6               2101              BSR     GET_EA_EA_SRC       *GETS <ea>
00002424                          2102  
00002424                          2103              
00002424  6000 0192               2104              BRA     OP1100_AND_RETURN
00002428                          2105  OP1100_PRINT_W2
00002428  163C 0057               2106              MOVE.B  #'W',D3
0000242C  6100 1568               2107              BSR     PUSH_STACK
00002430                          2108  
00002430                          2109              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002430  13FC 0000 000042BC      2110              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002438  13FC 0083 000042BD      2111              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002440                          2112             
00002440                          2113              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002440  13FC 00B9 000042BF      2114              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002448  13FC 0020 000042C0      2115              MOVE.B   #$20,GET_SRC_START_END
00002450                          2116  
00002450                          2117              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002450  0285 0000FE3F           2118              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002456  0685 00000000           2119              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
0000245C                          2120  
0000245C                          2121        
0000245C  6100 10CA               2122              BSR     GET_EA_EA_DEST      *GETS Dn
00002460  163C 002C               2123              MOVE.B  #',',D3
00002464  6100 1530               2124              BSR     PUSH_STACK               
00002468  6100 0C8E               2125              BSR     GET_EA_EA_SRC       *GETS <ea>       
0000246C                          2126  
0000246C                          2127  
0000246C                          2128  
0000246C  6000 049A               2129              BRA     OP1101_ADD_RETURN
00002470                          2130  OP1100_PRINT_L2 
00002470  163C 004C               2131              MOVE.B  #'L',D3
00002474  6100 1520               2132              BSR     PUSH_STACK
00002478                          2133              
00002478                          2134              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002478  13FC 0000 000042BC      2135              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002480  13FC 0083 000042BD      2136              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002488                          2137             
00002488                          2138              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002488  13FC 00B9 000042BF      2139              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002490  13FC 0020 000042C0      2140              MOVE.B   #$20,GET_SRC_START_END
00002498                          2141  
00002498                          2142             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002498  0285 0000FE3F           2143              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000249E  0685 00000000           2144              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024A4                          2145  
000024A4                          2146               
000024A4  6100 1082               2147              BSR     GET_EA_EA_DEST       *GETS Dn
000024A8  163C 002C               2148              MOVE.B  #',',D3
000024AC  6100 14E8               2149              BSR     PUSH_STACK          
000024B0  6100 0C46               2150              BSR     GET_EA_EA_SRC        *GETS <ea>
000024B4                          2151  
000024B4  6000 0102               2152              BRA     OP1100_AND_RETURN
000024B8                          2153              
000024B8                          2154  OP1100_EA_DN           
000024B8                          2155              *BITS (7 TO 6) 
000024B8                          2156              *00 = .B
000024B8                          2157              *01 = .W
000024B8                          2158              *10 = .L 
000024B8  2205                    2159              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000024BA  EC99                    2160              ROR.L   #6,D1
000024BC  0281 00000003           2161              ANDI.L  #$03,D1
000024C2  0C81 00000000           2162              CMPI.L  #$00,D1 *EQUALS .B
000024C8  6700 0016               2163              BEQ     OP1100_PRINT_B
000024CC  0C81 00000001           2164              CMPI.L  #$01,D1 *EQUALS .W
000024D2  6700 0054               2165              BEQ     OP1100_PRINT_W
000024D6  0C81 00000002           2166              CMPI.L  #$02,D1 *EQUALS .L
000024DC  6700 0092               2167              BEQ     OP1100_PRINT_L
000024E0                          2168  OP1100_PRINT_B
000024E0  163C 0042               2169              MOVE.B  #'B',D3
000024E4  6100 14B0               2170              BSR     PUSH_STACK
000024E8                          2171                
000024E8                          2172              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024E8  13FC 0000 000042BC      2173              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024F0  13FC 0002 000042BD      2174              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024F8                          2175             
000024F8                          2176              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024F8  13FC 00B9 000042BF      2177              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002500  13FC 0020 000042C0      2178              MOVE.B   #$20,GET_SRC_START_END
00002508                          2179  
00002508                          2180             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002508  0285 0000FE3F           2181              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000250E  0685 00000000           2182              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002514                          2183  
00002514                          2184              
00002514  6100 0BE2               2185              BSR     GET_EA_EA_SRC      *GETS <ea>
00002518  163C 002C               2186              MOVE.B  #',',D3
0000251C  6100 1478               2187              BSR     PUSH_STACK          
00002520  6100 1006               2188              BSR     GET_EA_EA_DEST       *GETS Dn
00002524                          2189              
00002524  6000 03E2               2190              BRA     OP1101_ADD_RETURN
00002528                          2191  OP1100_PRINT_W
00002528  163C 0057               2192              MOVE.B  #'W',D3
0000252C  6100 1468               2193              BSR     PUSH_STACK
00002530                          2194  
00002530                          2195              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002530  13FC 0000 000042BC      2196              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002538  13FC 0002 000042BD      2197              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002540                          2198             
00002540                          2199              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002540  13FC 00B9 000042BF      2200              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002548  13FC 0020 000042C0      2201              MOVE.B   #$20,GET_SRC_START_END
00002550                          2202  
00002550                          2203             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002550  0285 0000FE3F           2204              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002556  0685 00000000           2205              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000255C                          2206  
0000255C                          2207              
0000255C  6100 0B9A               2208              BSR     GET_EA_EA_SRC      *GETS <ea>
00002560  163C 002C               2209              MOVE.B  #',',D3
00002564  6100 1430               2210              BSR     PUSH_STACK
00002568  6100 0FBE               2211              BSR     GET_EA_EA_DEST       *GETS Dn    
0000256C                          2212              
0000256C  6000 FB8C               2213              BRA     OP1001_ADD_RETURN
00002570                          2214  OP1100_PRINT_L 
00002570  163C 004C               2215              MOVE.B  #'L',D3
00002574  6100 1420               2216              BSR     PUSH_STACK
00002578                          2217              
00002578                          2218              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002578  13FC 0000 000042BC      2219              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002580  13FC 0002 000042BD      2220              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002588                          2221             
00002588                          2222              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002588  13FC 00B9 000042BF      2223              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002590  13FC 0020 000042C0      2224              MOVE.B   #$20,GET_SRC_START_END
00002598                          2225  
00002598                          2226              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002598  0285 0000FE3F           2227              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000259E  0685 00000000           2228              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000025A4                          2229  
000025A4                          2230                     
000025A4  6100 0B52               2231              BSR     GET_EA_EA_SRC      *GETS <ea>
000025A8  163C 002C               2232              MOVE.B  #',',D3
000025AC  6100 13E8               2233              BSR     PUSH_STACK                  
000025B0  6100 0F76               2234              BSR     GET_EA_EA_DEST       *GETS Dn    
000025B4                          2235  
000025B4                          2236              
000025B4  6000 0002               2237              BRA     OP1100_AND_RETURN
000025B8                          2238              
000025B8                          2239  OP1100_AND_RETURN
000025B8  4E75                    2240              RTS
000025BA                          2241  
000025BA                          2242  
000025BA                          2243  *---------------------------------------------------------------------------*
000025BA                          2244  * OP1101: Decode ADD/ADDA
000025BA                          2245  *---------------------------------------------------------------------------* 
000025BA  4280                    2246  OP1101      CLR.L   D0                  
000025BC  4281                    2247              CLR.L   D1       
000025BE  4284                    2248              CLR.L   D4                   
000025C0  227C 00000000           2249              MOVEA.L #0, A1              
000025C6  2205                    2250              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000025C8                          2251              
000025C8                          2252              *CLEAR D3
000025C8  4283                    2253              CLR.L   D3
000025CA                          2254              
000025CA                          2255              
000025CA                          2256              
000025CA                          2257              **INTEGRATING ADDA.W/.L INTO THIS CODE**
000025CA  2205                    2258              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000025CC                          2259              *BITS (INDEX 8) 
000025CC                          2260              *0 = ADD.B/W/L <EA>,Dn
000025CC                          2261              *1 = ADD.B/W/L Dn,<EA> 
000025CC  EC99                    2262              ROR.L   #6,D1
000025CE  0281 00000007           2263              ANDI.L  #$07,D1                 *MASKS WITH 00000111
000025D4  0C81 00000007           2264              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
000025DA  6700 0010               2265              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
000025DE  0C81 00000003           2266              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
000025E4  6700 0078               2267              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
000025E8  6000 00E6               2268              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
000025EC                          2269              
000025EC                          2270  OP1101_ADDA_L
000025EC                          2271              *LOAD STACK WITH THIS OPMODE
000025EC  6100 13A8               2272              BSR     PUSH_STACK
000025F0  163C 0041               2273              MOVE.B  #'A',D3
000025F4  6100 13A0               2274              BSR     PUSH_STACK
000025F8  163C 0044               2275              MOVE.B  #'D',D3
000025FC  6100 1398               2276              BSR     PUSH_STACK
00002600  163C 0044               2277              MOVE.B  #'D',D3
00002604  6100 1390               2278              BSR     PUSH_STACK
00002608  163C 0041               2279              MOVE.B  #'A',D3
0000260C  6100 1388               2280              BSR     PUSH_STACK
00002610  163C 002E               2281              MOVE.B  #'.',D3
00002614  6100 1380               2282              BSR     PUSH_STACK
00002618  163C 004C               2283              MOVE.B  #'L',D3
0000261C  6100 1378               2284              BSR     PUSH_STACK
00002620                          2285              
00002620                          2286             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002620  13FC 0000 000042BC      2287             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002628  13FC 0000 000042BD      2288             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002630                          2289             
00002630                          2290             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002630  13FC 00B9 000042BF      2291             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002638  13FC 0020 000042C0      2292             MOVE.B   #$20,GET_SRC_START_END
00002640                          2293  
00002640                          2294              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002640  0285 0000FE3F           2295              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002646  0685 00000040           2296              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000264C                          2297       
0000264C                          2298              *PRINT <EA>,AN
0000264C  6100 0AAA               2299              BSR     GET_EA_EA_SRC       *GETS <ea>
00002650  163C 002C               2300              MOVE.B  #',',D3
00002654  6100 1340               2301              BSR     PUSH_STACK                     
00002658  6100 0ECE               2302              BSR     GET_EA_EA_DEST      *GETS Dn
0000265C                          2303  
0000265C                          2304              
0000265C                          2305              
0000265C  4E75                    2306              RTS
0000265E                          2307  OP1101_ADDA_W
0000265E                          2308              *LOAD STACK WITH THIS OPMODE
0000265E  6100 1336               2309              BSR     PUSH_STACK
00002662  163C 0041               2310              MOVE.B  #'A',D3
00002666  6100 132E               2311              BSR     PUSH_STACK
0000266A  163C 0044               2312              MOVE.B  #'D',D3
0000266E  6100 1326               2313              BSR     PUSH_STACK
00002672  163C 0044               2314              MOVE.B  #'D',D3
00002676  6100 131E               2315              BSR     PUSH_STACK
0000267A  163C 0041               2316              MOVE.B  #'A',D3
0000267E  6100 1316               2317              BSR     PUSH_STACK
00002682  163C 002E               2318              MOVE.B  #'.',D3
00002686  6100 130E               2319              BSR     PUSH_STACK
0000268A  163C 0057               2320              MOVE.B  #'W',D3
0000268E  6100 1306               2321              BSR     PUSH_STACK
00002692                          2322              
00002692                          2323             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002692  13FC 0000 000042BC      2324             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000269A  13FC 0000 000042BD      2325             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000026A2                          2326             
000026A2                          2327             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026A2  13FC 00B9 000042BF      2328             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000026AA  13FC 0020 000042C0      2329             MOVE.B   #$20,GET_SRC_START_END
000026B2                          2330  
000026B2                          2331              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026B2  0285 0000FE3F           2332              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026B8  0685 00000040           2333              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000026BE                          2334       
000026BE                          2335              *PRINT <EA>,AN
000026BE  6100 0A38               2336              BSR     GET_EA_EA_SRC       *GETS <ea>
000026C2  163C 002C               2337              MOVE.B  #',',D3
000026C6  6100 12CE               2338              BSR     PUSH_STACK                     
000026CA  6100 0E5C               2339              BSR     GET_EA_EA_DEST      *GETS Dn
000026CE                          2340  
000026CE  4E75                    2341              RTS
000026D0                          2342  
000026D0                          2343  OP1101_DETERMINE_DN_EA_OR_EA_DN 
000026D0                          2344              *LOAD STACK WITH THIS OPMODE
000026D0  6100 12C4               2345              BSR     PUSH_STACK
000026D4  163C 0041               2346              MOVE.B  #'A',D3
000026D8  6100 12BC               2347              BSR     PUSH_STACK
000026DC  163C 0044               2348              MOVE.B  #'D',D3
000026E0  6100 12B4               2349              BSR     PUSH_STACK
000026E4  163C 0044               2350              MOVE.B  #'D',D3
000026E8  6100 12AC               2351              BSR     PUSH_STACK
000026EC  163C 002E               2352              MOVE.B  #'.',D3
000026F0  6100 12A4               2353              BSR     PUSH_STACK
000026F4                          2354              
000026F4  2205                    2355              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000026F6                          2356              
000026F6                          2357              *BITS (INDEX 8) 
000026F6                          2358              *0 = ADD.B/W/L <EA>,Dn
000026F6                          2359              *1 = ADD.B/W/L Dn,<EA> 
000026F6  E099                    2360              ROR.L   #8,D1
000026F8  0281 00000001           2361              ANDI.L  #$01,D1     *MASKS WITH 00000001
000026FE  0C81 00000000           2362              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002704  6700 0102               2363              BEQ     OP1101_EA_DN
00002708                          2364              *else procede to Dn_EA
00002708                          2365              
00002708                          2366  OP1101_DN_EA
00002708                          2367              *BITS (7 TO 6) 
00002708                          2368              *00 = .B
00002708                          2369              *01 = .W
00002708                          2370              *10 = .L 
00002708  2205                    2371              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000270A  EC99                    2372              ROR.L   #6,D1
0000270C  0281 00000003           2373              ANDI.L  #$03,D1
00002712  0C81 00000000           2374              CMPI.L  #$00,D1 *EQUALS .B
00002718  6700 0016               2375              BEQ     OP1101_PRINT_B2
0000271C  0C81 00000001           2376              CMPI.L  #$01,D1 *EQUALS .W
00002722  6700 0054               2377              BEQ     OP1101_PRINT_W2
00002726  0C81 00000002           2378              CMPI.L  #$02,D1 *EQUALS .L
0000272C  6700 0092               2379              BEQ     OP1101_PRINT_L2
00002730                          2380  OP1101_PRINT_B2
00002730                          2381              *PUSH 'B'
00002730  163C 0042               2382              MOVE.B  #'B',D3
00002734  6100 1260               2383              BSR     PUSH_STACK
00002738                          2384             
00002738                          2385              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002738  13FC 0002 000042BC      2386             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002740  13FC 0083 000042BD      2387             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002748                          2388             
00002748                          2389             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002748  13FC 00B9 000042BF      2390             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002750  13FC 0020 000042C0      2391             MOVE.B   #$20,GET_SRC_START_END
00002758                          2392  
00002758                          2393              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002758  0285 0000FE3F           2394              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000275E  0685 00000000           2395              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002764                          2396       
00002764  6100 0DC2               2397              BSR     GET_EA_EA_DEST      *GETS Dn
00002768  163C 002C               2398              MOVE.B  #',',D3
0000276C  6100 1228               2399              BSR     PUSH_STACK                     
00002770  6100 0986               2400              BSR     GET_EA_EA_SRC       *GETS <ea>
00002774                          2401  
00002774                          2402              
00002774  6000 0192               2403              BRA     OP1101_ADD_RETURN
00002778                          2404  OP1101_PRINT_W2
00002778  163C 0057               2405              MOVE.B  #'W',D3
0000277C  6100 1218               2406              BSR     PUSH_STACK
00002780                          2407  
00002780                          2408              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002780  13FC 0000 000042BC      2409              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002788  13FC 0083 000042BD      2410              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002790                          2411             
00002790                          2412              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002790  13FC 00B9 000042BF      2413              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002798  13FC 0020 000042C0      2414              MOVE.B   #$20,GET_SRC_START_END
000027A0                          2415  
000027A0                          2416              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027A0  0285 0000FE3F           2417              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027A6  0685 00000000           2418              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027AC                          2419  
000027AC                          2420        
000027AC  6100 0D7A               2421              BSR     GET_EA_EA_DEST      *GETS Dn
000027B0  163C 002C               2422              MOVE.B  #',',D3
000027B4  6100 11E0               2423              BSR     PUSH_STACK               
000027B8  6100 093E               2424              BSR     GET_EA_EA_SRC       *GETS <ea>       
000027BC                          2425  
000027BC                          2426  
000027BC                          2427  
000027BC  6000 014A               2428              BRA     OP1101_ADD_RETURN
000027C0                          2429  OP1101_PRINT_L2 
000027C0  163C 004C               2430              MOVE.B  #'L',D3
000027C4  6100 11D0               2431              BSR     PUSH_STACK
000027C8                          2432              
000027C8                          2433              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000027C8  13FC 0000 000042BC      2434              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000027D0  13FC 0083 000042BD      2435              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000027D8                          2436             
000027D8                          2437              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000027D8  13FC 00B9 000042BF      2438              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000027E0  13FC 0020 000042C0      2439              MOVE.B   #$20,GET_SRC_START_END
000027E8                          2440  
000027E8                          2441             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027E8  0285 0000FE3F           2442              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027EE  0685 00000000           2443              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027F4                          2444  
000027F4                          2445               
000027F4  6100 0D32               2446              BSR     GET_EA_EA_DEST       *GETS Dn
000027F8  163C 002C               2447              MOVE.B  #',',D3
000027FC  6100 1198               2448              BSR     PUSH_STACK          
00002800  6100 08F6               2449              BSR     GET_EA_EA_SRC        *GETS <ea>
00002804                          2450  
00002804  6000 0102               2451              BRA     OP1101_ADD_RETURN
00002808                          2452              
00002808                          2453  OP1101_EA_DN           
00002808                          2454              *BITS (7 TO 6) 
00002808                          2455              *00 = .B
00002808                          2456              *01 = .W
00002808                          2457              *10 = .L 
00002808  2205                    2458              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000280A  EC99                    2459              ROR.L   #6,D1
0000280C  0281 00000003           2460              ANDI.L  #$03,D1
00002812  0C81 00000000           2461              CMPI.L  #$00,D1 *EQUALS .B
00002818  6700 0016               2462              BEQ     OP1101_PRINT_B
0000281C  0C81 00000001           2463              CMPI.L  #$01,D1 *EQUALS .W
00002822  6700 0054               2464              BEQ     OP1101_PRINT_W
00002826  0C81 00000002           2465              CMPI.L  #$02,D1 *EQUALS .L
0000282C  6700 0092               2466              BEQ     OP1101_PRINT_L
00002830                          2467  OP1101_PRINT_B
00002830  163C 0042               2468              MOVE.B  #'B',D3
00002834  6100 1160               2469              BSR     PUSH_STACK
00002838                          2470                
00002838                          2471              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002838  13FC 0002 000042BC      2472              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002840  13FC 0002 000042BD      2473              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002848                          2474             
00002848                          2475              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002848  13FC 00B9 000042BF      2476              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002850  13FC 0020 000042C0      2477              MOVE.B   #$20,GET_SRC_START_END
00002858                          2478  
00002858                          2479             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002858  0285 0000FE3F           2480              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000285E  0685 00000000           2481              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002864                          2482  
00002864                          2483              
00002864  6100 0892               2484              BSR     GET_EA_EA_SRC      *GETS <ea>
00002868  163C 002C               2485              MOVE.B  #',',D3
0000286C  6100 1128               2486              BSR     PUSH_STACK          
00002870  6100 0CB6               2487              BSR     GET_EA_EA_DEST       *GETS Dn
00002874                          2488              
00002874  6000 0092               2489              BRA     OP1101_ADD_RETURN
00002878                          2490  OP1101_PRINT_W
00002878  163C 0057               2491              MOVE.B  #'W',D3
0000287C  6100 1118               2492              BSR     PUSH_STACK
00002880                          2493  
00002880                          2494              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002880  13FC 0000 000042BC      2495              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002888  13FC 0000 000042BD      2496              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002890                          2497             
00002890                          2498              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002890  13FC 00B9 000042BF      2499              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002898  13FC 0020 000042C0      2500              MOVE.B   #$20,GET_SRC_START_END
000028A0                          2501  
000028A0                          2502             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028A0  0285 0000FE3F           2503              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028A6  0685 00000000           2504              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028AC                          2505  
000028AC                          2506              
000028AC  6100 084A               2507              BSR     GET_EA_EA_SRC      *GETS <ea>
000028B0  163C 002C               2508              MOVE.B  #',',D3
000028B4  6100 10E0               2509              BSR     PUSH_STACK
000028B8  6100 0C6E               2510              BSR     GET_EA_EA_DEST       *GETS Dn    
000028BC                          2511              
000028BC  6000 004A               2512              BRA     OP1101_ADD_RETURN
000028C0                          2513  OP1101_PRINT_L 
000028C0  163C 004C               2514              MOVE.B  #'L',D3
000028C4  6100 10D0               2515              BSR     PUSH_STACK
000028C8                          2516              
000028C8                          2517              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028C8  13FC 0000 000042BC      2518              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028D0  13FC 0000 000042BD      2519              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028D8                          2520             
000028D8                          2521              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028D8  13FC 00B9 000042BF      2522              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028E0  13FC 0020 000042C0      2523              MOVE.B   #$20,GET_SRC_START_END
000028E8                          2524  
000028E8                          2525              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028E8  0285 0000FE3F           2526              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028EE  0685 00000000           2527              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028F4                          2528  
000028F4                          2529                     
000028F4  6100 0802               2530              BSR     GET_EA_EA_SRC      *GETS <ea>
000028F8  163C 002C               2531              MOVE.B  #',',D3
000028FC  6100 1098               2532              BSR     PUSH_STACK                  
00002900  6100 0C26               2533              BSR     GET_EA_EA_DEST       *GETS Dn    
00002904                          2534  
00002904                          2535              
00002904  6000 0002               2536              BRA     OP1101_ADD_RETURN
00002908                          2537              
00002908                          2538  OP1101_ADD_RETURN
00002908  4E75                    2539              RTS
0000290A                          2540              
0000290A                          2541              *ADDW
0000290A  0C01 0006               2542              CMPI.B  #$6,D1
0000290E  6700 0056               2543              BEQ     OP_ADDA_W
00002912  0C01 000E               2544              CMPI.B  #$E,D1
00002916  6700 0066               2545              BEQ     OP_ADDA_L 
0000291A                          2546  
0000291A  4EF8 14B8               2547              JMP     OP_DATA  
0000291E                          2548            
0000291E                          2549  *---------------------------------------------------------------------------*
0000291E                          2550  * OP_ADD: display ADD and proceed to EA
0000291E                          2551  *---------------------------------------------------------------------------*  
0000291E  43F9 00004173           2552  OP_ADD_B    LEA     DISP_ADD_B,A1
00002924  103C 000E               2553              MOVE.B  #14,D0
00002928  4E4F                    2554              TRAP    #15
0000292A  183C 0000               2555              MOVE.B  #0,D4
0000292E  4EF9 00002CA8           2556              JMP     EA_GEN
00002934                          2557  
00002934  4E75                    2558              RTS
00002936                          2559  
00002936  43F9 0000417C           2560  OP_ADD_W    LEA     DISP_ADD_W,A1
0000293C  103C 000E               2561              MOVE.B  #14,D0
00002940  4E4F                    2562              TRAP    #15
00002942  183C 0001               2563              MOVE.B  #1,D4
00002946  4EF9 00002CA8           2564              JMP     EA_GEN
0000294C                          2565  
0000294C  4E75                    2566              RTS
0000294E                          2567  
0000294E  43F9 00004185           2568  OP_ADD_L    LEA     DISP_ADD_L,A1
00002954  103C 000E               2569              MOVE.B  #14,D0
00002958  4E4F                    2570              TRAP    #15
0000295A  183C 0002               2571              MOVE.B  #2,D4
0000295E  4EF9 00002CA8           2572              JMP     EA_GEN
00002964                          2573  
00002964  4E75                    2574              RTS
00002966                          2575  
00002966                          2576  *---------------------------------------------------------------------------*
00002966                          2577  * OP_ADDA: display ADDA and proceed to EA
00002966                          2578  *---------------------------------------------------------------------------*  
00002966  43F9 0000418E           2579  OP_ADDA_W   LEA     DISP_ADDA_W,A1
0000296C  103C 000E               2580              MOVE.B  #14,D0
00002970  4E4F                    2581              TRAP    #15
00002972  183C 0001               2582              MOVE.B  #1,D4
00002976  4EF9 00002CA8           2583              JMP     EA_GEN
0000297C                          2584  
0000297C  4E75                    2585              RTS
0000297E                          2586  
0000297E  43F9 00004198           2587  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002984  103C 000E               2588              MOVE.B  #14,D0
00002988  4E4F                    2589              TRAP    #15
0000298A  183C 0002               2590              MOVE.B  #2,D4
0000298E  4EF9 00002CA8           2591              JMP     EA_GEN
00002994                          2592  
00002994  4E75                    2593              RTS
00002996                          2594              
00002996                          2595  *---------------------------------------------------------------------------*
00002996                          2596  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002996                          2597  *---------------------------------------------------------------------------* 
00002996  4280                    2598  OP1110      CLR.L   D0                  
00002998  4281                    2599              CLR.L   D1   
0000299A  4284                    2600              CLR.L   D4                   
0000299C  227C 00000000           2601              MOVEA.L #0, A1                 
000029A2  2205                    2602              MOVE.L  D5,D1
000029A4                          2603              
000029A4                          2604              * check for LSX
000029A4  E699                    2605              ROR.L   #3,D1
000029A6  0281 00000001           2606              ANDI.L  #$1,D1
000029AC  0C01 0001               2607              CMPI.B  #1,D1
000029B0  6700 002E               2608              BEQ     OP_LSX
000029B4                          2609              
000029B4                          2610              * reset D1 and check for ASX
000029B4  4281                    2611              CLR.L   D1
000029B6  2205                    2612              MOVE.L  D5,D1
000029B8  E699                    2613              ROR.L   #3,D1
000029BA  0281 00000001           2614              ANDI.L  #$1,D1
000029C0  0C01 0000               2615              CMPI.B  #0,D1
000029C4  6700 0032               2616              BEQ     OP_ASX
000029C8                          2617  
000029C8                          2618              * reset D1 and check for ROX
000029C8  4281                    2619              CLR.L   D1
000029CA  2205                    2620              MOVE.L  D5,D1
000029CC  E699                    2621              ROR.L   #3,D1
000029CE  0281 00000001           2622              ANDI.L  #$1,D1
000029D4  0C01 0003               2623              CMPI.B  #3,D1
000029D8  6700 0036               2624              BEQ     OP_ROX
000029DC                          2625              
000029DC  4EF8 14B8               2626              JMP     OP_DATA
000029E0                          2627  
000029E0                          2628  *---------------------------------------------------------------------------*
000029E0                          2629  * OP_LSX: process LSR/LSL
000029E0                          2630  *---------------------------------------------------------------------------*            
000029E0  EA99                    2631  OP_LSX      ROR.L   #5,D1
000029E2  0281 00000001           2632              ANDI.L  #$1,D1
000029E8  0C01 0000               2633              CMPI.B  #0,D1
000029EC  6700 003A               2634              BEQ     OP_LSR
000029F0  0C01 0001               2635              CMPI.B  #1,D1
000029F4  6700 008C               2636              BEQ     OP_LSL
000029F8                          2637              
000029F8                          2638  *---------------------------------------------------------------------------*
000029F8                          2639  * OP_ASX: process ASR/ASL
000029F8                          2640  *---------------------------------------------------------------------------*  
000029F8  EA99                    2641  OP_ASX      ROR.L   #5,D1
000029FA  0281 00000001           2642              ANDI.L  #$1,D1
00002A00  0C01 0000               2643              CMPI.B  #0,D1
00002A04  6700 00D6               2644              BEQ     OP_ASR
00002A08  0C01 0001               2645              CMPI.B  #1,D1
00002A0C  6700 0128               2646              BEQ     OP_ASL
00002A10                          2647              
00002A10                          2648  *---------------------------------------------------------------------------*
00002A10                          2649  * OP_ROX: process ROR/ROL
00002A10                          2650  *---------------------------------------------------------------------------*  
00002A10  EA99                    2651  OP_ROX      ROR.L   #5,D1
00002A12  0281 00000001           2652              ANDI.L  #$1,D1
00002A18  0C01 0000               2653              CMPI.B  #0,D1
00002A1C  6700 0172               2654              BEQ     OP_ROR
00002A20  0C01 0001               2655              CMPI.B  #1,D1
00002A24  6700 01C4               2656              BEQ     OP_ROL
00002A28                          2657  
00002A28                          2658  *---------------------------------------------------------------------------*
00002A28                          2659  * OP_LSR: decode and display LSR
00002A28                          2660  *---------------------------------------------------------------------------*        
00002A28  E599                    2661  OP_LSR      ROL.L   #2,D1
00002A2A  0281 00000003           2662              ANDI.L  #$3,D1
00002A30  0C01 0000               2663              CMPI.B  #0,D1
00002A34  6700 0016               2664              BEQ     OP_LSR_B
00002A38  0C01 0001               2665              CMPI.B  #$1,D1
00002A3C  6700 0032               2666              BEQ     OP_LSR_W
00002A40  0C01 0002               2667              CMPI.B  #$2,D1
00002A44  6700 0018               2668              BEQ     OP_LSR_L
00002A48                          2669              
00002A48  4EF8 14B8               2670              JMP     OP_DATA
00002A4C                          2671  
00002A4C  43F9 000041A2           2672  OP_LSR_B    LEA     DISP_LSR_B,A1
00002A52  103C 000E               2673              MOVE.B  #14,D0
00002A56  4E4F                    2674              TRAP    #15
00002A58  183C 0000               2675              MOVE.B  #0,D4
00002A5C  4E75                    2676              RTS
00002A5E                          2677  
00002A5E  43F9 000041C6           2678  OP_LSR_L    LEA     DISP_LSR_L,A1
00002A64  103C 000E               2679              MOVE.B  #14,D0
00002A68  4E4F                    2680              TRAP    #15
00002A6A  183C 0002               2681              MOVE.B  #2,D4
00002A6E  4E75                    2682              RTS
00002A70                          2683  
00002A70  43F9 000041B4           2684  OP_LSR_W    LEA     DISP_LSR_W,A1
00002A76  103C 000E               2685              MOVE.B  #14,D0
00002A7A  4E4F                    2686              TRAP    #15
00002A7C  183C 0001               2687              MOVE.B  #1,D4
00002A80  4E75                    2688              RTS
00002A82                          2689   
00002A82                          2690  *---------------------------------------------------------------------------*
00002A82                          2691  * OP_LSL: decode and display LSL
00002A82                          2692  *---------------------------------------------------------------------------*             
00002A82  E599                    2693  OP_LSL      ROL.L   #2,D1
00002A84  0281 00000003           2694              ANDI.L  #$3,D1
00002A8A  0C01 0000               2695              CMPI.B  #0,D1
00002A8E  6700 0016               2696              BEQ     OP_LSL_B
00002A92  0C01 0001               2697              CMPI.B  #$1,D1
00002A96  6700 0032               2698              BEQ     OP_LSL_W
00002A9A  0C01 0002               2699              CMPI.B  #$2,D1
00002A9E  6700 0018               2700              BEQ     OP_LSL_L
00002AA2                          2701              
00002AA2  4EF8 14B8               2702              JMP OP_DATA
00002AA6                          2703  
00002AA6  43F9 000041AB           2704  OP_LSL_B    LEA     DISP_LSL_B,A1
00002AAC  103C 000E               2705              MOVE.B  #14,D0
00002AB0  4E4F                    2706              TRAP    #15
00002AB2  183C 0000               2707              MOVE.B  #0,D4
00002AB6  4E75                    2708              RTS
00002AB8                          2709  
00002AB8  43F9 000041CF           2710  OP_LSL_L    LEA     DISP_LSL_L,A1
00002ABE  103C 000E               2711              MOVE.B  #14,D0
00002AC2  4E4F                    2712              TRAP    #15
00002AC4  183C 0002               2713              MOVE.B  #2,D4
00002AC8  4E75                    2714              RTS
00002ACA                          2715  
00002ACA  43F9 000041BD           2716  OP_LSL_W    LEA     DISP_LSL_W,A1
00002AD0  103C 000E               2717              MOVE.B  #14,D0
00002AD4  4E4F                    2718              TRAP    #15
00002AD6  183C 0001               2719              MOVE.B  #1,D4
00002ADA  4E75                    2720              RTS
00002ADC                          2721   
00002ADC                          2722  *---------------------------------------------------------------------------*
00002ADC                          2723  * OP_ASR: decode and display ASR
00002ADC                          2724  *---------------------------------------------------------------------------*             
00002ADC  E599                    2725  OP_ASR      ROL.L   #2,D1
00002ADE  0281 00000003           2726              ANDI.L  #$3,D1
00002AE4  0C01 0000               2727              CMPI.B  #0,D1
00002AE8  6700 0016               2728              BEQ     OP_ASR_B
00002AEC  0C01 0001               2729              CMPI.B  #$1,D1
00002AF0  6700 0032               2730              BEQ     OP_ASR_W
00002AF4  0C01 0002               2731              CMPI.B  #$2,D1
00002AF8  6700 0018               2732              BEQ     OP_ASR_L
00002AFC                          2733              
00002AFC  4EF8 14B8               2734              JMP OP_DATA
00002B00                          2735  
00002B00  43F9 000041D8           2736  OP_ASR_B    LEA     DISP_ASR_B,A1
00002B06  103C 000E               2737              MOVE.B  #14,D0
00002B0A  4E4F                    2738              TRAP    #15
00002B0C  183C 0000               2739              MOVE.B  #0,D4
00002B10  4E75                    2740              RTS
00002B12                          2741  
00002B12  43F9 000041FC           2742  OP_ASR_L    LEA     DISP_ASR_L,A1
00002B18  103C 000E               2743              MOVE.B  #14,D0
00002B1C  4E4F                    2744              TRAP    #15
00002B1E  183C 0002               2745              MOVE.B  #2,D4
00002B22  4E75                    2746              RTS
00002B24                          2747  
00002B24  43F9 000041EA           2748  OP_ASR_W    LEA     DISP_ASR_W,A1
00002B2A  103C 000E               2749              MOVE.B  #14,D0
00002B2E  4E4F                    2750              TRAP    #15
00002B30  183C 0001               2751              MOVE.B  #1,D4
00002B34  4E75                    2752              RTS
00002B36                          2753       
00002B36                          2754  *---------------------------------------------------------------------------*
00002B36                          2755  * OP_ASL: decode and display ASL
00002B36                          2756  *---------------------------------------------------------------------------*         
00002B36  E599                    2757  OP_ASL      ROL.L   #2,D1
00002B38  0281 00000003           2758              ANDI.L  #$3,D1
00002B3E  0C01 0000               2759              CMPI.B  #0,D1
00002B42  6700 0016               2760              BEQ     OP_ASL_B
00002B46  0C01 0001               2761              CMPI.B  #$1,D1
00002B4A  6700 0032               2762              BEQ     OP_ASL_W
00002B4E  0C01 0002               2763              CMPI.B  #$2,D1
00002B52  6700 0018               2764              BEQ     OP_ASL_L
00002B56                          2765              
00002B56  4EF8 14B8               2766              JMP OP_DATA
00002B5A                          2767  
00002B5A  43F9 000041E1           2768  OP_ASL_B    LEA     DISP_ASL_B,A1
00002B60  103C 000E               2769              MOVE.B  #14,D0
00002B64  4E4F                    2770              TRAP    #15
00002B66  183C 0000               2771              MOVE.B  #0,D4
00002B6A  4E75                    2772              RTS
00002B6C                          2773  
00002B6C  43F9 00004205           2774  OP_ASL_L    LEA     DISP_ASL_L,A1
00002B72  103C 000E               2775              MOVE.B  #14,D0
00002B76  4E4F                    2776              TRAP    #15
00002B78  183C 0002               2777              MOVE.B  #2,D4
00002B7C  4E75                    2778              RTS
00002B7E                          2779  
00002B7E  43F9 000041F3           2780  OP_ASL_W    LEA     DISP_ASL_W,A1
00002B84  103C 000E               2781              MOVE.B  #14,D0
00002B88  4E4F                    2782              TRAP    #15
00002B8A  183C 0001               2783              MOVE.B  #1,D4
00002B8E  4E75                    2784              RTS
00002B90                          2785   
00002B90                          2786  *---------------------------------------------------------------------------*
00002B90                          2787  * OP_ROR: decode and display ROR
00002B90                          2788  *---------------------------------------------------------------------------*             
00002B90  E599                    2789  OP_ROR      ROL.L   #2,D1
00002B92  0281 00000003           2790              ANDI.L  #$3,D1
00002B98  0C01 0000               2791              CMPI.B  #0,D1
00002B9C  6700 0016               2792              BEQ     OP_ROR_B
00002BA0  0C01 0001               2793              CMPI.B  #$1,D1
00002BA4  6700 0032               2794              BEQ     OP_ROR_W
00002BA8  0C01 0002               2795              CMPI.B  #$2,D1
00002BAC  6700 0018               2796              BEQ     OP_ROR_L
00002BB0                          2797              
00002BB0  4EF8 14B8               2798              JMP OP_DATA
00002BB4                          2799  
00002BB4  43F9 0000420E           2800  OP_ROR_B    LEA     DISP_ROR_B,A1
00002BBA  103C 000E               2801              MOVE.B  #14,D0
00002BBE  4E4F                    2802              TRAP    #15
00002BC0  183C 0000               2803              MOVE.B  #0,D4
00002BC4  4E75                    2804              RTS
00002BC6                          2805  
00002BC6  43F9 00004232           2806  OP_ROR_L    LEA     DISP_ROR_L,A1
00002BCC  103C 000E               2807              MOVE.B  #14,D0
00002BD0  4E4F                    2808              TRAP    #15
00002BD2  183C 0002               2809              MOVE.B  #2,D4
00002BD6  4E75                    2810              RTS
00002BD8                          2811  
00002BD8  43F9 00004220           2812  OP_ROR_W    LEA     DISP_ROR_W,A1
00002BDE  103C 000E               2813              MOVE.B  #14,D0
00002BE2  4E4F                    2814              TRAP    #15
00002BE4  183C 0001               2815              MOVE.B  #1,D4
00002BE8  4E75                    2816              RTS
00002BEA                          2817  
00002BEA                          2818  *---------------------------------------------------------------------------*
00002BEA                          2819  * OP_ROL: decode and display ROL
00002BEA                          2820  *---------------------------------------------------------------------------*             
00002BEA  E599                    2821  OP_ROL      ROL.L   #2,D1
00002BEC  0281 00000003           2822              ANDI.L  #$3,D1
00002BF2  0C01 0000               2823              CMPI.B  #0,D1
00002BF6  6700 0016               2824              BEQ     OP_ROL_B
00002BFA  0C01 0001               2825              CMPI.B  #$1,D1
00002BFE  6700 0032               2826              BEQ     OP_ROL_W
00002C02  0C01 0002               2827              CMPI.B  #$2,D1
00002C06  6700 0018               2828              BEQ     OP_ROL_L
00002C0A                          2829              
00002C0A  4EF8 14B8               2830              JMP OP_DATA
00002C0E                          2831  
00002C0E                          2832  
00002C0E  43F9 00004217           2833  OP_ROL_B    LEA     DISP_ROL_B,A1
00002C14  103C 000E               2834              MOVE.B  #14,D0
00002C18  4E4F                    2835              TRAP    #15
00002C1A  183C 0000               2836              MOVE.B  #0,D4
00002C1E  4E75                    2837              RTS
00002C20                          2838  
00002C20  43F9 0000423B           2839  OP_ROL_L    LEA     DISP_ROL_L,A1
00002C26  103C 000E               2840              MOVE.B  #14,D0
00002C2A  4E4F                    2841              TRAP    #15
00002C2C  183C 0002               2842              MOVE.B  #2,D4
00002C30  4E75                    2843              RTS
00002C32                          2844  
00002C32  43F9 00004229           2845  OP_ROL_W    LEA     DISP_ROL_W,A1
00002C38  103C 000E               2846              MOVE.B  #14,D0
00002C3C  4E4F                    2847              TRAP    #15
00002C3E  183C 0001               2848              MOVE.B  #1,D4
00002C42  4E75                    2849              RTS
00002C44                          2850              
00002C44                          2851  *---------------------------------------------------------------------------*
00002C44                          2852  * OP1111 : Special reserved
00002C44                          2853  *---------------------------------------------------------------------------*           
00002C44  4EF8 14B8               2854  OP1111      JMP     OP_DATA
00002C48                          2855  
00002C48                          2856  *---------------------------------------------------------------------------*
00002C48                          2857  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00002C48                          2858  *---------------------------------------------------------------------------*
00002C48                          2859  EA_NOSRC    
00002C48  4EB9 00002D06           2860              JSR     SRC_MODE
00002C4E  43F9 00003F08           2861              LEA     ENDLINE_M,A1
00002C54  103C 000E               2862              MOVE.B  #14,D0
00002C58  4E4F                    2863              TRAP    #15
00002C5A  4E75                    2864              RTS
00002C5C                          2865              
00002C5C                          2866  *---------------------------------------------------------------------------*
00002C5C                          2867  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00002C5C                          2868  *---------------------------------------------------------------------------*
00002C5C                          2869  EA_ARITH
00002C5C  4EB9 00002D06           2870              JSR     SRC_MODE
00002C62  43F9 00004282           2871              LEA     DISP_D,A1
00002C68  103C 000E               2872              MOVE.B  #14,D0
00002C6C  4E4F                    2873              TRAP    #15
00002C6E  4EB9 00002F92           2874              JSR     DEST_REGISTER
00002C74  43F9 00003F08           2875              LEA     ENDLINE_M,A1
00002C7A  103C 000E               2876              MOVE.B  #14,D0
00002C7E  4E4F                    2877              TRAP    #15
00002C80  4E75                    2878              RTS
00002C82                          2879              
00002C82                          2880  *---------------------------------------------------------------------------*
00002C82                          2881  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00002C82                          2882  *---------------------------------------------------------------------------*
00002C82                          2883  EA_MOVEA
00002C82  4EB9 00002D06           2884              JSR     SRC_MODE
00002C88  43F9 00004293           2885              LEA     DISP_AOP,A1
00002C8E  103C 000E               2886              MOVE.B  #14,D0
00002C92  4E4F                    2887              TRAP    #15
00002C94  4EB9 00002F92           2888              JSR     DEST_REGISTER
00002C9A  43F9 00004291           2889              LEA     DISP_CP,A1
00002CA0  103C 000D               2890              MOVE.B  #13,D0
00002CA4  4E4F                    2891              TRAP    #15
00002CA6  4E75                    2892              RTS
00002CA8                          2893              
00002CA8                          2894  *---------------------------------------------------------------------------*
00002CA8                          2895  * EA_GEN: decode and display effective addresses for MOVE
00002CA8                          2896  *---------------------------------------------------------------------------*
00002CA8                          2897  EA_GEN          
00002CA8                          2898              * retrieve/display source mode/register
00002CA8  4EB9 00002D06           2899              JSR     SRC_MODE
00002CAE                          2900              
00002CAE                          2901              * retrieve/display destination mode/register
00002CAE  4EB9 00002CC2           2902              JSR     DEST_MODE
00002CB4                          2903              
00002CB4  43F9 00003F08           2904              LEA     ENDLINE_M,A1
00002CBA  103C 000E               2905              MOVE.B  #14,D0
00002CBE  4E4F                    2906              TRAP    #15
00002CC0                          2907              
00002CC0  4E75                    2908              RTS
00002CC2                          2909  
00002CC2                          2910  *---------------------------------------------------------------------------*
00002CC2                          2911  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002CC2                          2912  *---------------------------------------------------------------------------*           
00002CC2                          2913  DEST_MODE   
00002CC2                          2914              * clear registers to store temp data
00002CC2  4280                    2915              CLR.L   D0                      
00002CC4  4281                    2916              CLR.L   D1                      
00002CC6  207C 00000000           2917              MOVEA.L #0, A0                  
00002CCC  227C 00000000           2918              MOVEA.L #0, A1                  
00002CD2  2205                    2919              MOVE.L  D5,D1
00002CD4  EC89                    2920              LSR.L   #6,D1
00002CD6  0281 00000007           2921              ANDI.L  #$7,D1
00002CDC  0C01 0000               2922              CMPI.B  #0,D1   * Dn
00002CE0  6700 0082               2923              BEQ     D_MODE000
00002CE4  0C01 0002               2924              CMPI.B  #2,D1   * (An)
00002CE8  6700 00C2               2925              BEQ     D_MODE010
00002CEC  0C01 0003               2926              CMPI.B  #3,D1   * (An)+
00002CF0  6700 011A               2927              BEQ     D_MODE011
00002CF4  0C01 0004               2928              CMPI.B  #4,D1   * -(An)
00002CF8  6700 0132               2929              BEQ     D_MODE100
00002CFC  0C01 0007               2930              CMPI.B  #7,D1  * abs
00002D00  6700 017C               2931              BEQ     D_MODE111 
00002D04  4E75                    2932              RTS
00002D06                          2933  
00002D06                          2934  *---------------------------------------------------------------------------*
00002D06                          2935  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002D06                          2936  *---------------------------------------------------------------------------*  
00002D06                          2937  SRC_MODE    
00002D06                          2938              * clear registers to store temp data
00002D06  4280                    2939              CLR.L   D0                      
00002D08  4281                    2940              CLR.L   D1                      
00002D0A  207C 00000000           2941              MOVEA.L #0, A0                  
00002D10  227C 00000000           2942              MOVEA.L #0, A1                  
00002D16  2205                    2943              MOVE.L  D5,D1
00002D18  E489                    2944              LSR.L   #2,D1
00002D1A  0281 0000000E           2945              ANDI.L  #$E,D1
00002D20                          2946              
00002D20  0C01 0000               2947              CMPI.B  #0,D1   * Dn
00002D24  6700 002A               2948              BEQ     MODE000
00002D28  0C01 0002               2949              CMPI.B  #2,D1   * An 
00002D2C  6700 004A               2950              BEQ     MODE001
00002D30  0C01 0004               2951              CMPI.B  #4,D1   * (An)
00002D34  6700 0056               2952              BEQ     MODE010
00002D38  0C01 0006               2953              CMPI.B  #6,D1   * (An)+
00002D3C  6700 008E               2954              BEQ     MODE011
00002D40  0C01 0008               2955              CMPI.B  #8,D1   * -(An)
00002D44  6700 00A6               2956              BEQ     MODE100
00002D48  0C01 000F               2957              CMPI.B  #15,D1  * abs/immediate
00002D4C  6700 00FE               2958              BEQ     MODE111 
00002D50                          2959        
00002D50                          2960  *---------------------------------------------------------------------------*
00002D50                          2961  * MODE000: decode and display source mode Dn
00002D50                          2962  *---------------------------------------------------------------------------*           
00002D50                          2963  MODE000     *Dn
00002D50  43F9 00004282           2964              LEA     DISP_D,A1
00002D56  103C 000E               2965              MOVE.B  #14,D0
00002D5A  4E4F                    2966              TRAP    #15
00002D5C  4EB9 00002FEE           2967              JSR     SRC_REGISTER
00002D62  4E75                    2968              RTS
00002D64                          2969  
00002D64                          2970  *---------------------------------------------------------------------------*
00002D64                          2971  * D_MODE000: decode and display dest mode Dn
00002D64                          2972  *---------------------------------------------------------------------------*
00002D64                          2973  D_MODE000     *Dn
00002D64  43F9 00004282           2974              LEA     DISP_D,A1
00002D6A  103C 000E               2975              MOVE.B  #14,D0
00002D6E  4E4F                    2976              TRAP    #15
00002D70  4EB9 00002F92           2977              JSR     DEST_REGISTER
00002D76  4E75                    2978              RTS
00002D78                          2979  
00002D78                          2980  *---------------------------------------------------------------------------*
00002D78                          2981  * MODE001: decode and display source mode An
00002D78                          2982  *---------------------------------------------------------------------------* 
00002D78                          2983  MODE001 *An
00002D78  43F9 00004287           2984              LEA     DISP_A,A1
00002D7E  103C 000E               2985              MOVE.B  #14,D0
00002D82  4E4F                    2986              TRAP    #15
00002D84  4EB9 00002FEE           2987              JSR     SRC_REGISTER
00002D8A                          2988          
00002D8A  4E75                    2989              RTS
00002D8C                          2990  
00002D8C                          2991  *---------------------------------------------------------------------------*
00002D8C                          2992  * MODE010: decode and display source mode (An)
00002D8C                          2993  *---------------------------------------------------------------------------*    
00002D8C                          2994  MODE010 *(An)
00002D8C  43F9 00004293           2995              LEA     DISP_AOP,A1  *display (A
00002D92  103C 000E               2996              MOVE.B  #14,D0
00002D96  4E4F                    2997              TRAP    #15
00002D98                          2998  
00002D98  4EB9 00002FEE           2999              JSR     SRC_REGISTER * display register
00002D9E                          3000  
00002D9E  43F9 00004291           3001              LEA     DISP_CP,A1   *display )
00002DA4  103C 000E               3002              MOVE.B  #14,D0
00002DA8  4E4F                    3003              TRAP    #15
00002DAA                          3004              
00002DAA  4E75                    3005              RTS
00002DAC                          3006  
00002DAC                          3007  *---------------------------------------------------------------------------*
00002DAC                          3008  * D_MODE010: decode and display dest mode (An)
00002DAC                          3009  *---------------------------------------------------------------------------*
00002DAC                          3010  D_MODE010 *(An)
00002DAC  43F9 00004293           3011              LEA     DISP_AOP,A1  *display (A
00002DB2  103C 000E               3012              MOVE.B  #14,D0
00002DB6  4E4F                    3013              TRAP    #15
00002DB8                          3014     
00002DB8  4EB9 00002F92           3015              JSR     DEST_REGISTER * display register
00002DBE                          3016  
00002DBE  43F9 00004291           3017              LEA     DISP_CP,A1   *display )
00002DC4  103C 000E               3018              MOVE.B  #14,D0
00002DC8  4E4F                    3019              TRAP    #15
00002DCA                          3020              
00002DCA  4E75                    3021              RTS
00002DCC                          3022  
00002DCC                          3023  *---------------------------------------------------------------------------*
00002DCC                          3024  * MODE011: decode and display source mode (An)+
00002DCC                          3025  *---------------------------------------------------------------------------*
00002DCC                          3026  MODE011 *(An)+
00002DCC  43F9 00004293           3027              LEA     DISP_AOP,A1      *display (A
00002DD2  103C 000E               3028              MOVE.B  #14,D0
00002DD6  4E4F                    3029              TRAP    #15
00002DD8                          3030              
00002DD8  4EB9 00002FEE           3031              JSR     SRC_REGISTER    * display register
00002DDE                          3032  
00002DDE  43F9 000042A0           3033              LEA     DISP_POST,A1    *display )+
00002DE4  103C 000E               3034              MOVE.B  #14,D0
00002DE8  4E4F                    3035              TRAP    #15
00002DEA                          3036              
00002DEA  4E75                    3037              RTS
00002DEC                          3038              
00002DEC                          3039  *---------------------------------------------------------------------------*
00002DEC                          3040  * MODE100: decode and display source mode -(An)
00002DEC                          3041  *---------------------------------------------------------------------------*
00002DEC                          3042  MODE100 *-(An)
00002DEC  43F9 00004299           3043              LEA     DISP_PRE,A1    *display -(A
00002DF2  103C 000E               3044              MOVE.B  #14,D0
00002DF6  4E4F                    3045              TRAP    #15
00002DF8                          3046  
00002DF8  4EB9 00002FEE           3047              JSR     SRC_REGISTER    *display register
00002DFE                          3048  
00002DFE  43F9 00004291           3049              LEA     DISP_CP,A1   *display )
00002E04  103C 000E               3050              MOVE.B  #14,D0
00002E08  4E4F                    3051              TRAP    #15
00002E0A                          3052              
00002E0A  4E75                    3053              RTS
00002E0C                          3054  
00002E0C                          3055  *---------------------------------------------------------------------------*
00002E0C                          3056  * D_MODE011: decode and display dest mode (An)+
00002E0C                          3057  *---------------------------------------------------------------------------*
00002E0C                          3058  D_MODE011 *(An)+
00002E0C  43F9 00004293           3059              LEA     DISP_AOP,A1      *display (A
00002E12  103C 000E               3060              MOVE.B  #14,D0
00002E16  4E4F                    3061              TRAP    #15
00002E18                          3062  
00002E18  4EB9 00002F92           3063              JSR     DEST_REGISTER    * display register
00002E1E                          3064  
00002E1E  43F9 000042A0           3065              LEA     DISP_POST,A1    *display )+
00002E24  103C 000E               3066              MOVE.B  #14,D0
00002E28  4E4F                    3067              TRAP    #15
00002E2A                          3068              
00002E2A  4E75                    3069              RTS
00002E2C                          3070              
00002E2C                          3071  *---------------------------------------------------------------------------*
00002E2C                          3072  * D_MODE100: decode and display dest mode -(An)
00002E2C                          3073  *---------------------------------------------------------------------------*            
00002E2C                          3074  D_MODE100 *-(An)
00002E2C  43F9 00004299           3075              LEA     DISP_PRE,A1    *display -(A
00002E32  103C 000E               3076              MOVE.B  #14,D0
00002E36  4E4F                    3077              TRAP    #15
00002E38                          3078              
00002E38  4EB9 00002F92           3079              JSR     DEST_REGISTER    *display register
00002E3E                          3080  
00002E3E  43F9 00004291           3081              LEA     DISP_CP,A1   *display )
00002E44  103C 000E               3082              MOVE.B  #14,D0
00002E48  4E4F                    3083              TRAP    #15
00002E4A                          3084              
00002E4A  4E75                    3085              RTS
00002E4C                          3086  
00002E4C                          3087  *---------------------------------------------------------------------------*
00002E4C                          3088  * MODE111: decode and display source mode absolute/immediate
00002E4C                          3089  *---------------------------------------------------------------------------*
00002E4C                          3090  MODE111     * abs/immediate
00002E4C                          3091              * clear registers to store temp data
00002E4C  4280                    3092              CLR.L   D0                      
00002E4E  4281                    3093              CLR.L   D1                      
00002E50  207C 00000000           3094              MOVEA.L #0, A0                  
00002E56  227C 00000000           3095              MOVEA.L #0, A1                  
00002E5C  2205                    3096              MOVE.L  D5,D1
00002E5E                          3097              
00002E5E                          3098              * retrieve source register for MODE 111
00002E5E  E389                    3099              LSL.L   #1,D1   * shift the bits to left by 1
00002E60  0281 0000000E           3100              ANDI.L  #$E,D1  * mask the first 4 bits 
00002E66  0C01 0000               3101              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002E6A  6700 003E               3102              BEQ     WORDMODE
00002E6E  0C01 0002               3103              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002E72  6700 0062               3104              BEQ     LONGMODE
00002E76  0C01 0008               3105              CMPI.B  #8, D1  * if it's 1000, immediate data
00002E7A  6700 0086               3106              BEQ     IMMEDIATE
00002E7E                          3107       
00002E7E                          3108  *---------------------------------------------------------------------------*
00002E7E                          3109  * D_MODE111: decode and display dest mode absolute/immediate
00002E7E                          3110  *---------------------------------------------------------------------------*           
00002E7E                          3111  D_MODE111   * abs
00002E7E                          3112              * clear registers to store temp data
00002E7E  4280                    3113              CLR.L   D0                      
00002E80  4281                    3114              CLR.L   D1                      
00002E82  207C 00000000           3115              MOVEA.L #0, A0                  
00002E88  227C 00000000           3116              MOVEA.L #0, A1                  
00002E8E  2205                    3117              MOVE.L  D5,D1
00002E90                          3118              
00002E90                          3119              * retrieve dest register for MODE 111
00002E90  EC89                    3120              LSR.L   #6,D1   * shift the bits to right by 6
00002E92  E689                    3121              LSR.L   #3,D1   * shift the bits to right by extra 3
00002E94  0201 0001               3122              ANDI.B  #1,D1   * mask the first 2 bits 
00002E98  0C01 0000               3123              CMPI.B  #0, D1  * if it's 000, absolute word address
00002E9C  6700 000C               3124              BEQ     WORDMODE
00002EA0  0C01 0001               3125              CMPI.B  #1, D1  * if it's 001, absolute long address
00002EA4  6700 0030               3126              BEQ     LONGMODE
00002EA8                          3127              *JSR     OP_DATA *not sure..
00002EA8  4E75                    3128              RTS
00002EAA                          3129  
00002EAA                          3130  
00002EAA                          3131  *---------------------------------------------------------------------------*
00002EAA                          3132  * WORDMODE: absolute word address
00002EAA                          3133  *---------------------------------------------------------------------------*
00002EAA  43F9 0000427D           3134  WORDMODE    LEA     DISP_HEX,A1
00002EB0  103C 000E               3135              MOVE.B  #14,D0
00002EB4  4E4F                    3136              TRAP    #15
00002EB6                          3137              
00002EB6  4285                    3138              CLR.L   D5
00002EB8  3A1D                    3139              MOVE.W  (A5)+,D5
00002EBA                          3140              
00002EBA  43F9 00003F5B           3141              LEA     TMPOUTPUT,A1
00002EC0  2205                    3142              MOVE.L  D5,D1
00002EC2  7404                    3143              MOVE.L  #4,D2       *move word size 4
00002EC4  4EB8 11B8               3144              JSR     HEX2ASCII
00002EC8  43F9 00003F5B           3145              LEA     TMPOUTPUT,A1
00002ECE  103C 000E               3146              MOVE.B  #14,D0
00002ED2  4E4F                    3147              TRAP    #15
00002ED4                          3148              
00002ED4  4E75                    3149              RTS
00002ED6                          3150  
00002ED6                          3151  *---------------------------------------------------------------------------*
00002ED6                          3152  * LONGMODE: absolute long address
00002ED6                          3153  *---------------------------------------------------------------------------*
00002ED6  43F9 0000427D           3154  LONGMODE    LEA     DISP_HEX,A1
00002EDC  103C 000E               3155              MOVE.B  #14,D0
00002EE0  4E4F                    3156              TRAP    #15
00002EE2                          3157              
00002EE2  4285                    3158              CLR.L   D5
00002EE4  2A1D                    3159              MOVE.L  (A5)+,D5
00002EE6                          3160              
00002EE6  43F9 00003F5B           3161              LEA     TMPOUTPUT,A1
00002EEC  2205                    3162              MOVE.L  D5,D1
00002EEE  7408                    3163              MOVE.L  #8,D2           *move longword size 8
00002EF0  4EB8 11B8               3164              JSR     HEX2ASCII
00002EF4  43F9 00003F5B           3165              LEA     TMPOUTPUT,A1
00002EFA  103C 000E               3166              MOVE.B  #14,D0
00002EFE  4E4F                    3167              TRAP    #15
00002F00                          3168              
00002F00  4E75                    3169              RTS
00002F02                          3170  
00002F02                          3171  
00002F02                          3172  *---------------------------------------------------------------------------*
00002F02                          3173  * IMMEDIATE: immediate address
00002F02                          3174  *---------------------------------------------------------------------------*
00002F02  43F9 000042A3           3175  IMMEDIATE   LEA     DISP_LB,A1
00002F08  103C 000E               3176              MOVE.B  #14,D0
00002F0C  4E4F                    3177              TRAP    #15
00002F0E  43F9 0000427D           3178              LEA     DISP_HEX,A1
00002F14  103C 000E               3179              MOVE.B  #14,D0
00002F18  4E4F                    3180              TRAP    #15
00002F1A                          3181              
00002F1A                          3182              * check for size
00002F1A  0C04 0000               3183              CMPI.B  #0,D4
00002F1E  6700 0012               3184              BEQ     IMMD_B
00002F22  0C04 0001               3185              CMPI.B  #1,D4
00002F26  6700 002A               3186              BEQ     IMMD_W
00002F2A  0C04 0002               3187              CMPI.B  #2,D4
00002F2E  6700 0042               3188              BEQ     IMMD_L
00002F32                          3189  
00002F32                          3190  IMMD_B
00002F32  4285                    3191              CLR.L   D5
00002F34  3A1D                    3192              MOVE.W  (A5)+,D5
00002F36                          3193              
00002F36  43F9 00003F5B           3194              LEA     TMPOUTPUT,A1
00002F3C  2205                    3195              MOVE.L  D5,D1
00002F3E  7402                    3196              MOVE.L  #2,D2
00002F40  4EB8 11B8               3197              JSR     HEX2ASCII
00002F44  43F9 00003F5B           3198              LEA     TMPOUTPUT,A1
00002F4A  103C 000E               3199              MOVE.B  #14,D0
00002F4E  4E4F                    3200              TRAP    #15
00002F50  4E75                    3201              RTS
00002F52                          3202              
00002F52                          3203  IMMD_W
00002F52  4285                    3204              CLR.L   D5
00002F54  3A1D                    3205              MOVE.W  (A5)+,D5
00002F56                          3206              
00002F56  43F9 00003F5B           3207              LEA     TMPOUTPUT,A1
00002F5C  2205                    3208              MOVE.L  D5,D1
00002F5E  7404                    3209              MOVE.L  #4,D2
00002F60  4EB8 11B8               3210              JSR     HEX2ASCII
00002F64  43F9 00003F5B           3211              LEA     TMPOUTPUT,A1
00002F6A  103C 000E               3212              MOVE.B  #14,D0
00002F6E  4E4F                    3213              TRAP    #15
00002F70  4E75                    3214              RTS
00002F72                          3215              
00002F72                          3216  
00002F72                          3217  IMMD_L
00002F72  4285                    3218              CLR.L   D5
00002F74  3A1D                    3219              MOVE.W  (A5)+,D5
00002F76                          3220              
00002F76  43F9 00003F5B           3221              LEA     TMPOUTPUT,A1
00002F7C  2205                    3222              MOVE.L  D5,D1
00002F7E  7408                    3223              MOVE.L  #8,D2
00002F80  4EB8 11B8               3224              JSR     HEX2ASCII
00002F84  43F9 00003F5B           3225              LEA     TMPOUTPUT,A1
00002F8A  103C 000E               3226              MOVE.B  #14,D0
00002F8E  4E4F                    3227              TRAP    #15
00002F90  4E75                    3228              RTS
00002F92                          3229  
00002F92                          3230  
00002F92                          3231  *---------------------------------------------------------------------------*
00002F92                          3232  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00002F92                          3233  *---------------------------------------------------------------------------*
00002F92                          3234  DEST_REGISTER
00002F92                          3235              * clear registers to store temp data
00002F92  4280                    3236              CLR.L   D0                      
00002F94  4281                    3237              CLR.L   D1                      
00002F96  207C 00000000           3238              MOVEA.L #0, A0                  
00002F9C  227C 00000000           3239              MOVEA.L #0, A1 
00002FA2                          3240              
00002FA2  2205                    3241              MOVE.L  D5,D1
00002FA4  EC89                    3242              LSR.L   #6,D1
00002FA6  E689                    3243              LSR.L   #3,D1
00002FA8  0281 00000007           3244              ANDI.L  #7,D1
00002FAE                          3245              
00002FAE  0C01 0000               3246              CMPI.B  #0,D1
00002FB2  6700 0092               3247              BEQ     REG_0
00002FB6  0C01 0001               3248              CMPI.B  #1,D1
00002FBA  6700 0098               3249              BEQ     REG_1
00002FBE  0C01 0002               3250              CMPI.B  #2,D1
00002FC2  6700 009E               3251              BEQ     REG_2
00002FC6  0C01 0003               3252              CMPI.B  #3,D1
00002FCA  6700 00A4               3253              BEQ     REG_3
00002FCE  0C01 0004               3254              CMPI.B  #4,D1
00002FD2  6700 00AA               3255              BEQ     REG_4
00002FD6  0C01 0005               3256              CMPI.B  #5,D1
00002FDA  6700 00B0               3257              BEQ     REG_5
00002FDE  0C01 0006               3258              CMPI.B  #6,D1
00002FE2  6700 00B6               3259              BEQ     REG_6
00002FE6  0C01 0007               3260              CMPI.B  #7,D1
00002FEA  6700 00BC               3261              BEQ     REG_7
00002FEE                          3262  
00002FEE                          3263  *---------------------------------------------------------------------------*
00002FEE                          3264  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00002FEE                          3265  *---------------------------------------------------------------------------*           
00002FEE                          3266  SRC_REGISTER 
00002FEE                          3267              * clear registers to store temp data
00002FEE  4280                    3268              CLR.L   D0                      
00002FF0  4281                    3269              CLR.L   D1                      
00002FF2  207C 00000000           3270              MOVEA.L #0, A0                  
00002FF8  227C 00000000           3271              MOVEA.L #0, A1                  
00002FFE                          3272              
00002FFE  2205                    3273              MOVE.L  D5,D1   * temp store the processing data
00003000  0281 00000007           3274              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00003006                          3275              
00003006  0C01 0000               3276              CMPI.B  #0,D1
0000300A  6700 003A               3277              BEQ     REG_0
0000300E  0C01 0001               3278              CMPI.B  #1,D1
00003012  6700 0040               3279              BEQ     REG_1
00003016  0C01 0002               3280              CMPI.B  #2,D1
0000301A  6700 0046               3281              BEQ     REG_2
0000301E  0C01 0003               3282              CMPI.B  #3,D1
00003022  6700 004C               3283              BEQ     REG_3
00003026  0C01 0004               3284              CMPI.B  #4,D1
0000302A  6700 0052               3285              BEQ     REG_4
0000302E  0C01 0005               3286              CMPI.B  #5,D1
00003032  6700 0058               3287              BEQ     REG_5
00003036  0C01 0006               3288              CMPI.B  #6,D1
0000303A  6700 005E               3289              BEQ     REG_6
0000303E  0C01 0007               3290              CMPI.B  #7,D1
00003042  6700 0064               3291              BEQ     REG_7
00003046                          3292  
00003046                          3293  *---------------------------------------------------------------------------*
00003046                          3294  * REG_0 ~ REG_7: display register 0 to 7
00003046                          3295  *---------------------------------------------------------------------------*
00003046  43F9 000042A8           3296  REG_0       LEA     DISP_0,A1
0000304C  103C 000E               3297              MOVE.B  #14,D0
00003050  4E4F                    3298              TRAP    #15
00003052  4E75                    3299              RTS
00003054                          3300              
00003054  43F9 000042AA           3301  REG_1       LEA     DISP_1,A1
0000305A  103C 000E               3302              MOVE.B  #14,D0
0000305E  4E4F                    3303              TRAP    #15
00003060  4E75                    3304              RTS
00003062                          3305              
00003062                          3306  
00003062  43F9 000042AC           3307  REG_2       LEA     DISP_2,A1
00003068  103C 000E               3308              MOVE.B  #14,D0
0000306C  4E4F                    3309              TRAP    #15
0000306E  4E75                    3310              RTS
00003070                          3311            
00003070  43F9 000042AE           3312  REG_3       LEA     DISP_3,A1
00003076  103C 000E               3313              MOVE.B  #14,D0
0000307A  4E4F                    3314              TRAP    #15
0000307C  4E75                    3315              RTS
0000307E                          3316              
0000307E  43F9 000042B0           3317  REG_4       LEA     DISP_4,A1
00003084  103C 000E               3318              MOVE.B  #14,D0
00003088  4E4F                    3319              TRAP    #15
0000308A  4E75                    3320              RTS
0000308C                          3321              
0000308C  43F9 000042B2           3322  REG_5       LEA     DISP_5,A1
00003092  103C 000E               3323              MOVE.B  #14,D0
00003096  4E4F                    3324              TRAP    #15
00003098  4E75                    3325              RTS
0000309A                          3326              
0000309A  43F9 000042B4           3327  REG_6       LEA     DISP_6,A1
000030A0  103C 000E               3328              MOVE.B  #14,D0
000030A4  4E4F                    3329              TRAP    #15
000030A6  4E75                    3330              RTS
000030A8                          3331              
000030A8  43F9 000042B6           3332  REG_7       LEA     DISP_7,A1
000030AE  103C 000E               3333              MOVE.B  #14,D0
000030B2  4E4F                    3334              TRAP    #15
000030B4  4E75                    3335              RTS
000030B6                          3336              
000030B6                          3337  *---------------------------------------------------------------------------*
000030B6                          3338  * REPEAT : Ask user whether they wish to run the program again
000030B6                          3339  *---------------------------------------------------------------------------*           
000030B6  4246                    3340  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
000030B8  43F9 00003D81           3341              LEA     REPEATMSG,A1
000030BE  103C 000E               3342              MOVE.B  #14,D0
000030C2  4E4F                    3343              TRAP    #15
000030C4                          3344              
000030C4  43F9 00003F0B           3345              LEA     TMPINPUT,A1             * allocate space to temp store user input
000030CA  103C 0002               3346              MOVE.B  #2,D0
000030CE  4E4F                    3347              TRAP    #15
000030D0                          3348  
000030D0  0C01 0001               3349              CMPI.B  #1,D1                   * check for length of user input
000030D4  66E0                    3350              BNE     REPEAT                  * return to the beginning of the function if unequal
000030D6                          3351              
000030D6  0C11 0059               3352              CMPI.B  #$59,(A1)               * compare the input with Y    
000030DA  6700 DF2E               3353              BEQ     PROGLP                  * repeat the program
000030DE                          3354              
000030DE  0C11 0079               3355              CMPI.B  #$79,(A1)               * compare the input with y    
000030E2  6700 DF26               3356              BEQ     PROGLP                  * repeat the program
000030E6                          3357              
000030E6  0C11 004E               3358              CMPI.B  #$4E,(A1)               * compare the input with N    
000030EA  6700 0928               3359              BEQ     TERMINATE               * finish program
000030EE                          3360              
000030EE  0C11 006E               3361              CMPI.B  #$6E,(A1)               * compare the input with n    
000030F2  6700 0920               3362              BEQ     TERMINATE               * finish program
000030F6                          3363              
000030F6  60BE                    3364              BRA     REPEAT                  * invalid input/repeat the function
000030F8                          3365  
000030F8                          3366  *---------------------------------------------------------------------------*
000030F8                          3367  * EA DECODING INTERFACE
000030F8                          3368  * [A0] - RESERVED FOR USE
000030F8                          3369  * [D2] - RESERVED FOR USE
000030F8                          3370  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
000030F8                          3371  *---------------------------------------------------------------------------*
000030F8                          3372  GET_EA_EA_SRC
000030F8                          3373      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000030F8                          3374      
000030F8                          3375      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000030F8  2405                    3376      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000030FA  E68A                    3377      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
000030FC  23C2 000042CE           3378      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003102  7407                    3379      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003104  C5B9 000042CE           3380      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000310A                          3381                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000310A                          3382      
0000310A                          3383      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000310A                          3384      *DESTINATION REGISTER FORMAT STANDARD         *
0000310A                          3385      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000310A                          3386      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000310A                          3387      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000310A                          3388      *0 - Dn                                       *
0000310A                          3389      *1 - An                                       *
0000310A                          3390      *2 - (An)                                     *
0000310A                          3391      *3 - (An)+                                    *
0000310A                          3392      *4 - -(An)                                    *
0000310A                          3393      *5 - (XXX).W                                  *
0000310A                          3394      *6 - (XXX).L                                  *
0000310A                          3395      *7 - #<data>                                  *
0000310A                          3396      ***********************************************
0000310A                          3397      
0000310A                          3398      *** Check if source ...  <ea> = Dn
0000310A                          3399  CHECK0    
0000310A  41F9 000042BE           3400            LEA     TEMP_REGISTER_FORMAT,A0
00003110  1439 000042BD           3401            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003116  1082                    3402            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003118  0239 0001 000042BE      3403            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003120  0C39 0001 000042BE      3404            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003128  6700 006A               3405            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000312C  0CB9 00000000 000042CE  3406            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003136  6600 005C               3407            BNE     CHECK1
0000313A                          3408            
0000313A                          3409            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000313A  163C 0020               3410            MOVE.B    #' ',D3
0000313E  6100 0856               3411            BSR       PUSH_STACK
00003142  163C 0044               3412            MOVE.B    #'D',D3
00003146  6100 084E               3413            BSR       PUSH_STACK
0000314A                          3414  
0000314A                          3415            *FIND REGISTER NUMBER END LOCATION*  
0000314A  13F9 000042C0 000042C6  3416            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003154  0239 000F 000042C6      3417            AND.B   #$0F,VAR_BYTE_END
0000315C                          3418            
0000315C                          3419            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000315C  23C5 000042CA           3420            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003162  1439 000042C6           3421            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003168                          3422            
00003168                          3423            *INTITIALIZE FOR BIT SHIFTING
00003168  41F9 000042CA           3424            LEA     VAR_TEMP_CLEANCOPY,A0
0000316E  2639 000042CA           3425            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003174                          3426  LOOP_SHIFTING
00003174  0C02 0000               3427            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003178  6700 0008               3428            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000317C  E24B                    3429            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000317E  5302                    3430            SUB.B   #1,D2                     *DECREMENT COUNTER
00003180  60F2                    3431            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00003182                          3432  MASKING_NEXT
00003182  C6BC 00000007           3433            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003188  0603 0030               3434            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000318C  6100 0808               3435            BSR     PUSH_STACK                *PUSH TO STACK
00003190                          3436            
00003190  6000 0394               3437            BRA     GET_SRC_SUCCESS           *RETURN          
00003194                          3438            
00003194                          3439            
00003194                          3440            *** Check if source ...  <ea> = An
00003194  41F9 000042BE           3441  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
0000319A  1439 000042BD           3442            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000031A0  1082                    3443            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000031A2  0239 0002 000042BE      3444            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000031AA  0C39 0002 000042BE      3445            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000031B2  6700 006A               3446            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000031B6  0CB9 00000001 000042CE  3447            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
000031C0  6600 005C               3448            BNE     CHECK2
000031C4                          3449            
000031C4                          3450            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000031C4  163C 0020               3451            MOVE.B    #' ',D3
000031C8  6100 07CC               3452            BSR       PUSH_STACK
000031CC  163C 0041               3453            MOVE.B    #'A',D3
000031D0  6100 07C4               3454            BSR       PUSH_STACK
000031D4                          3455  
000031D4                          3456            
000031D4                          3457            *FIND REGISTER NUMBER END LOCATION*  
000031D4  13F9 000042C0 000042C6  3458            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000031DE  0239 000F 000042C6      3459            AND.B   #$0F,VAR_BYTE_END
000031E6                          3460            
000031E6                          3461            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000031E6  23C5 000042CA           3462            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000031EC  1439 000042C6           3463            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
000031F2                          3464            
000031F2                          3465            *INTITIALIZE FOR BIT SHIFTING
000031F2  41F9 000042CA           3466            LEA     VAR_TEMP_CLEANCOPY,A0
000031F8  2639 000042CA           3467            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000031FE                          3468  LOOP_SHIFTING1
000031FE  0C02 0000               3469            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003202  6700 0008               3470            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003206  E24B                    3471            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003208  5302                    3472            SUB.B   #1,D2                     *DECREMENT COUNTER
0000320A  60F2                    3473            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
0000320C                          3474  MASKING_NEXT1
0000320C  C6BC 00000007           3475            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003212  0603 0030               3476            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003216  6100 077E               3477            BSR     PUSH_STACK                *PUSH TO STACK
0000321A                          3478            
0000321A  6000 030A               3479            BRA     GET_SRC_SUCCESS                   *RETURN 
0000321E                          3480            
0000321E                          3481            
0000321E                          3482            
0000321E                          3483            
0000321E                          3484            *** Check if source ...  <ea> = (An)       
0000321E  41F9 000042BE           3485  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003224  1439 000042BD           3486            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000322A  1082                    3487            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000322C  0239 0004 000042BE      3488            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003234  0C39 0004 000042BE      3489            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
0000323C  6700 007A               3490            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003240  0CB9 00000002 000042CE  3491            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000324A  6600 006C               3492            BNE     CHECK3
0000324E                          3493            
0000324E                          3494            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000324E  163C 0020               3495            MOVE.B    #' ',D3
00003252  6100 0742               3496            BSR       PUSH_STACK
00003256  163C 0028               3497            MOVE.B    #'(',D3
0000325A  6100 073A               3498            BSR       PUSH_STACK
0000325E  163C 0041               3499            MOVE.B    #'A',D3
00003262  6100 0732               3500            BSR       PUSH_STACK
00003266                          3501  
00003266                          3502            
00003266                          3503            *FIND REGISTER NUMBER END LOCATION*  
00003266  13F9 000042C0 000042C6  3504            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003270  0239 000F 000042C6      3505            AND.B   #$0F,VAR_BYTE_END
00003278                          3506            
00003278                          3507            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003278  23C5 000042CA           3508            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000327E  1439 000042C6           3509            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003284                          3510            
00003284                          3511            *INTITIALIZE FOR BIT SHIFTING
00003284  41F9 000042CA           3512            LEA     VAR_TEMP_CLEANCOPY,A0
0000328A  2639 000042CA           3513            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003290                          3514  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003290  0C02 0000               3515            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003294  6700 0008               3516            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003298  E24B                    3517            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000329A  5302                    3518            SUB.B   #1,D2                     *DECREMENT COUNTER
0000329C  60F2                    3519            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
0000329E                          3520  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
0000329E  0283 00000007           3521            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000032A4  0603 0030               3522            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000032A8  6100 06EC               3523            BSR     PUSH_STACK                *PUSH TO STACK
000032AC                          3524            
000032AC  163C 0029               3525            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000032B0  6100 06E4               3526            BSR       PUSH_STACK
000032B4                          3527            
000032B4  6000 0270               3528            BRA     GET_SRC_SUCCESS                   *RETURN 
000032B8                          3529  
000032B8                          3530            
000032B8                          3531            
000032B8                          3532                      
000032B8                          3533  *** Check if source ...  <ea> = (An)+       
000032B8  41F9 000042BE           3534  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000032BE  1439 000042BD           3535            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000032C4  1082                    3536            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000032C6  0239 0008 000042BE      3537            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000032CE  0C39 0008 000042BE      3538            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
000032D6  6700 0082               3539            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000032DA  0CB9 00000003 000042CE  3540            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000032E4  6600 0074               3541            BNE     CHECK4
000032E8                          3542            
000032E8                          3543            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000032E8  163C 0020               3544            MOVE.B    #' ',D3
000032EC  6100 06A8               3545            BSR       PUSH_STACK
000032F0  163C 0028               3546            MOVE.B    #'(',D3
000032F4  6100 06A0               3547            BSR       PUSH_STACK
000032F8  163C 0041               3548            MOVE.B    #'A',D3
000032FC  6100 0698               3549            BSR       PUSH_STACK
00003300                          3550  
00003300                          3551            
00003300                          3552            *FIND REGISTER NUMBER END LOCATION*  
00003300  13F9 000042C0 000042C6  3553            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000330A  0239 000F 000042C6      3554            ANDI.B   #$0F,VAR_BYTE_END
00003312                          3555            
00003312                          3556            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003312  23C5 000042CA           3557            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003318  1439 000042C6           3558            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000331E                          3559            
0000331E                          3560            *INTITIALIZE FOR BIT SHIFTING
0000331E  41F9 000042CA           3561            LEA     VAR_TEMP_CLEANCOPY,A0
00003324  2639 000042CA           3562            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000332A                          3563            
0000332A                          3564  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000332A  0C02 0000               3565            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000332E  6700 0008               3566            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003332  E24B                    3567            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003334  5302                    3568            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003336  60F2                    3569            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003338                          3570                                               *change: NAME OF LABEL*
00003338                          3571  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003338  0283 00000007           3572            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000333E  0603 0030               3573            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003342  6100 0652               3574            BSR     PUSH_STACK                *PUSH TO STACK
00003346                          3575            
00003346  163C 0029               3576            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000334A  6100 064A               3577            BSR       PUSH_STACK
0000334E  163C 002B               3578            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003352  6100 0642               3579            BSR       PUSH_STACK
00003356                          3580            
00003356  6000 01CE               3581            BRA       GET_SRC_SUCCESS                   *RETURN 
0000335A                          3582  
0000335A                          3583            
0000335A                          3584            
0000335A                          3585                      
0000335A                          3586            *** Check if source ...  <ea> = -(An)       
0000335A  41F9 000042BE           3587  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003360  1439 000042BD           3588            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003366  1082                    3589            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003368  0239 0010 000042BE      3590            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003370  0C39 0010 000042BE      3591            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003378  6700 0082               3592            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000337C  0CB9 00000004 000042CE  3593            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003386  6600 0074               3594            BNE     CHECK7
0000338A                          3595            
0000338A                          3596            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000338A  163C 0020               3597            MOVE.B    #' ',D3
0000338E  6100 0606               3598            BSR       PUSH_STACK
00003392  163C 002D               3599            MOVE.B    #'-',D3
00003396  6100 05FE               3600            BSR       PUSH_STACK
0000339A  163C 0028               3601            MOVE.B    #'(',D3
0000339E  6100 05F6               3602            BSR       PUSH_STACK
000033A2  163C 0041               3603            MOVE.B    #'A',D3
000033A6  6100 05EE               3604            BSR       PUSH_STACK
000033AA                          3605  
000033AA                          3606            
000033AA                          3607            *FIND REGISTER NUMBER END LOCATION*  
000033AA  13F9 000042C0 000042C6  3608            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000033B4  0239 000F 000042C6      3609            AND.B   #$0F,VAR_BYTE_END
000033BC                          3610            
000033BC                          3611            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000033BC  23C5 000042CA           3612            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000033C2  1439 000042C6           3613            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000033C8                          3614            
000033C8                          3615            *INTITIALIZE FOR BIT SHIFTING
000033C8  41F9 000042CA           3616            LEA     VAR_TEMP_CLEANCOPY,A0
000033CE  2639 000042CA           3617            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000033D4                          3618            
000033D4                          3619  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
000033D4  0C02 0000               3620            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000033D8  6700 0008               3621            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000033DC  E24B                    3622            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000033DE  5302                    3623            SUBI.B   #1,D2                     *DECREMENT COUNTER
000033E0  60F2                    3624            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
000033E2                          3625                                               *change: NAME OF LABEL*
000033E2                          3626  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
000033E2  0283 00000007           3627            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000033E8  0603 0030               3628            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000033EC  6100 05A8               3629            BSR     PUSH_STACK                *PUSH TO STACK
000033F0                          3630            
000033F0  163C 0029               3631            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000033F4  6100 05A0               3632            BSR       PUSH_STACK
000033F8                          3633            
000033F8  6000 012C               3634            BRA     GET_SRC_SUCCESS                   *RETURN
000033FC                          3635            
000033FC                          3636                      
000033FC                          3637            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000033FC  0CB9 00000007 000042CE  3638  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003406  6600 011A               3639            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
0000340A                          3640                   
0000340A                          3641            *NEXT: (MODE == 111) 
0000340A                          3642            *NOW: CHECK FOR SRC REGISTER 
0000340A                          3643                  *(000 = (xxx).W)
0000340A                          3644                  *(001 = (xxx).L)
0000340A                          3645                  *(010 = #<data>)
0000340A                          3646                  
0000340A                          3647            *FIND REGISTER NUMBER END LOCATION*  
0000340A  13F9 000042C0 000042C6  3648            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003414  0239 000F 000042C6      3649            AND.B   #$0F,VAR_BYTE_END
0000341C                          3650            
0000341C                          3651            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000341C  23C5 000042CA           3652            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003422  1439 000042C6           3653            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003428                          3654            
00003428                          3655            *INTITIALIZE FOR BIT SHIFTING
00003428  41F9 000042CA           3656            LEA     VAR_TEMP_CLEANCOPY,A0
0000342E  2C39 000042CA           3657            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003434                          3658  SRC_LOOP_SHIFTING
00003434  0C02 0000               3659            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003438  6700 0008               3660            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000343C  E24E                    3661            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000343E  5302                    3662            SUB.B   #1,D2                     *DECREMENT COUNTER
00003440  60F2                    3663            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003442                          3664  SRC_MASKING_NEXT
00003442  CCBC 00000007           3665            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003448                          3666           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003448                          3667           
00003448                          3668  CHECK_WORD  
00003448  41F9 000042BE           3669            LEA     TEMP_REGISTER_FORMAT,A0
0000344E  1439 000042BD           3670            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003454  1082                    3671            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003456  0239 0020 000042BE      3672            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
0000345E  0C39 0020 000042BE      3673            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003466  6700 0026               3674            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000346A  0C06 0000               3675            CMPI.B  #0,D6                          
0000346E  6600 001E               3676            BNE     CHECK_LONG 
00003472                          3677            
00003472                          3678            *IT IS A WORD AT THIS POINT*
00003472                          3679            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003472  163C 0020               3680            MOVE.B    #' ',D3
00003476  6100 051E               3681            BSR       PUSH_STACK
0000347A  163C 0024               3682            MOVE.B    #'$',D3
0000347E  6100 0516               3683            BSR       PUSH_STACK
00003482  321D                    3684            MOVE.W    (A5)+,D1
00003484  7404                    3685            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003486  6100 DD72               3686            BSR       HEX2ASCII2STACK
0000348A  6000 009A               3687            BRA     GET_SRC_SUCCESS
0000348E                          3688  
0000348E                          3689  CHECK_LONG
0000348E  41F9 000042BE           3690            LEA     TEMP_REGISTER_FORMAT,A0
00003494  1439 000042BD           3691            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000349A  1082                    3692            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000349C  0239 0040 000042BE      3693            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000034A4  0C39 0040 000042BE      3694            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000034AC  6700 002E               3695            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000034B0  0C06 0001               3696            CMPI.B  #1,D6                          
000034B4  6600 0026               3697            BNE     CHECK_IMMEDIATE  
000034B8                          3698  
000034B8                          3699            *IT IS A WORD AT THIS POINT*
000034B8                          3700            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000034B8  163C 0020               3701            MOVE.B    #' ',D3
000034BC  6100 04D8               3702            BSR       PUSH_STACK
000034C0  163C 0024               3703            MOVE.B    #'$',D3
000034C4  6100 04D0               3704            BSR       PUSH_STACK
000034C8  321D                    3705            MOVE.W    (A5)+,D1
000034CA  7404                    3706            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000034CC  6100 DD2C               3707            BSR       HEX2ASCII2STACK
000034D0  321D                    3708            MOVE.W    (A5)+,D1
000034D2  7404                    3709            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000034D4  6100 DD24               3710            BSR       HEX2ASCII2STACK
000034D8  6000 004C               3711            BRA     GET_SRC_SUCCESS
000034DC                          3712            
000034DC                          3713  CHECK_IMMEDIATE
000034DC  41F9 000042BE           3714            LEA     TEMP_REGISTER_FORMAT,A0
000034E2  1439 000042BD           3715            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000034E8  1082                    3716            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000034EA  0239 0080 000042BE      3717            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000034F2  0C39 0080 000042BE      3718            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000034FA  6700 0026               3719            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000034FE  0C06 0004               3720            CMPI.B  #4,D6                          
00003502  6600 001E               3721            BNE     GET_SRC_FAILED 
00003506                          3722  
00003506                          3723            *IT IS A WORD AT THIS POINT*
00003506                          3724            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003506  163C 0020               3725            MOVE.B    #' ',D3
0000350A  6100 048A               3726            BSR       PUSH_STACK
0000350E  163C 0023               3727            MOVE.B    #'#',D3
00003512  6100 0482               3728            BSR       PUSH_STACK
00003516  321D                    3729            MOVE.W    (A5)+,D1
00003518  7404                    3730            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000351A  6100 DCDE               3731            BSR       HEX2ASCII2STACK
0000351E  6000 0006               3732            BRA     GET_SRC_SUCCESS
00003522                          3733            
00003522                          3734  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003522  7801                    3735            MOVE.L #1,D4
00003524  4E75                    3736            RTS
00003526                          3737  GET_SRC_SUCCESS 
00003526  4E75                    3738            RTS
00003528                          3739                                 
00003528                          3740      
00003528                          3741  
00003528                          3742  
00003528                          3743  
00003528                          3744  
00003528                          3745  
00003528                          3746  
00003528                          3747  GET_EA_EA_DEST
00003528                          3748  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003528                          3749      
00003528                          3750      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003528  2405                    3751      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000352A  EC8A                    3752      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
0000352C  23C2 000042CE           3753      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003532  7407                    3754      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003534  C5B9 000042CE           3755      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000353A                          3756                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000353A                          3757      
0000353A                          3758      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000353A                          3759      *DESTINATION REGISTER FORMAT STANDARD         *
0000353A                          3760      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000353A                          3761      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000353A                          3762      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000353A                          3763      *0 - Dn                                       *
0000353A                          3764      *1 - An                                       *
0000353A                          3765      *2 - (An)                                     *
0000353A                          3766      *3 - (An)+                                    *
0000353A                          3767      *4 - -(An)                                    *
0000353A                          3768      *5 - (XXX).W                                  *
0000353A                          3769      *6 - (XXX).L                                  *
0000353A                          3770      *7 - #<data>                                  *
0000353A                          3771      ***********************************************
0000353A                          3772      
0000353A                          3773      *** Check if source ...  <ea> = Dn
0000353A                          3774  DEST_CHECK0    
0000353A  41F9 000042BE           3775            LEA     TEMP_REGISTER_FORMAT,A0
00003540  1439 000042BC           3776            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003546  1082                    3777            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003548  0239 0001 000042BE      3778            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003550  0C39 0001 000042BE      3779            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003558  6700 006A               3780            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000355C  0CB9 00000000 000042CE  3781            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003566  6600 005C               3782            BNE     DEST_CHECK1
0000356A                          3783            
0000356A                          3784            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000356A  163C 0020               3785            MOVE.B    #' ',D3
0000356E  6100 0426               3786            BSR       PUSH_STACK
00003572  163C 0044               3787            MOVE.B    #'D',D3
00003576  6100 041E               3788            BSR       PUSH_STACK
0000357A                          3789  
0000357A                          3790            *FIND REGISTER NUMBER END LOCATION*  
0000357A  13F9 000042BF 000042C6  3791            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003584  0239 000F 000042C6      3792            AND.B   #$0F,VAR_BYTE_END
0000358C                          3793            
0000358C                          3794            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000358C  23C5 000042CA           3795            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003592  1439 000042C6           3796            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003598                          3797            
00003598                          3798            *INTITIALIZE FOR BIT SHIFTING
00003598  41F9 000042CA           3799            LEA     VAR_TEMP_CLEANCOPY,A0
0000359E  2639 000042CA           3800            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000035A4                          3801  DEST_LOOP_SHIFTING
000035A4  0C02 0000               3802            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000035A8  6700 0008               3803            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000035AC  E24B                    3804            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000035AE  5302                    3805            SUB.B   #1,D2                     *DECREMENT COUNTER
000035B0  60F2                    3806            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
000035B2                          3807  DEST_MASKING_NEXT
000035B2  C6BC 00000007           3808            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000035B8  0603 0030               3809            ADD.B   #$30,D3                   *CONVERT TO CHAR
000035BC  6100 03D8               3810            BSR     PUSH_STACK                *PUSH TO STACK
000035C0                          3811            
000035C0  6000 0394               3812            BRA     GET_DST_SUCCESS           *RETURN          
000035C4                          3813            
000035C4                          3814            
000035C4                          3815            *** Check if source ...  <ea> = An
000035C4                          3816  DEST_CHECK1    
000035C4  41F9 000042BE           3817            LEA     TEMP_REGISTER_FORMAT,A0
000035CA  1439 000042BC           3818            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000035D0  1082                    3819            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000035D2  0239 0002 000042BE      3820            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000035DA  0C39 0002 000042BE      3821            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000035E2  6700 006A               3822            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000035E6  0CB9 00000001 000042CE  3823            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
000035F0  6600 005C               3824            BNE     DEST_CHECK2
000035F4                          3825            
000035F4                          3826            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000035F4  163C 0020               3827            MOVE.B    #' ',D3
000035F8  6100 039C               3828            BSR       PUSH_STACK
000035FC  163C 0041               3829            MOVE.B    #'A',D3
00003600  6100 0394               3830            BSR       PUSH_STACK
00003604                          3831  
00003604                          3832            
00003604                          3833            *FIND REGISTER NUMBER END LOCATION*  
00003604  13F9 000042BF 000042C6  3834            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000360E  0239 000F 000042C6      3835            AND.B   #$0F,VAR_BYTE_END
00003616                          3836            
00003616                          3837            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003616  23C5 000042CA           3838            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000361C  1439 000042C6           3839            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003622                          3840            
00003622                          3841            *INTITIALIZE FOR BIT SHIFTING
00003622  41F9 000042CA           3842            LEA     VAR_TEMP_CLEANCOPY,A0
00003628  2639 000042CA           3843            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000362E                          3844  DEST_LOOP_SHIFTING1
0000362E  0C02 0000               3845            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003632  6700 0008               3846            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003636  E24B                    3847            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003638  5302                    3848            SUB.B   #1,D2                     *DECREMENT COUNTER
0000363A  60F2                    3849            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
0000363C                          3850  DEST_MASKING_NEXT1
0000363C  C6BC 00000007           3851            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003642  0603 0030               3852            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003646  6100 034E               3853            BSR     PUSH_STACK                *PUSH TO STACK
0000364A                          3854            
0000364A  6000 030A               3855            BRA     GET_DST_SUCCESS                   *RETURN 
0000364E                          3856            
0000364E                          3857            
0000364E                          3858            
0000364E                          3859            
0000364E                          3860            *** Check if source ...  <ea> = (An)       
0000364E                          3861  DEST_CHECK2    
0000364E  41F9 000042BE           3862            LEA     TEMP_REGISTER_FORMAT,A0
00003654  1439 000042BC           3863            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000365A  1082                    3864            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000365C  0239 0004 000042BE      3865            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003664  0C39 0004 000042BE      3866            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
0000366C  6700 007A               3867            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003670  0CB9 00000002 000042CE  3868            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000367A  6600 006C               3869            BNE     DEST_CHECK3
0000367E                          3870            
0000367E                          3871            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000367E  163C 0020               3872            MOVE.B    #' ',D3
00003682  6100 0312               3873            BSR       PUSH_STACK
00003686  163C 0028               3874            MOVE.B    #'(',D3
0000368A  6100 030A               3875            BSR       PUSH_STACK
0000368E  163C 0041               3876            MOVE.B    #'A',D3
00003692  6100 0302               3877            BSR       PUSH_STACK
00003696                          3878  
00003696                          3879            
00003696                          3880            *FIND REGISTER NUMBER END LOCATION*  
00003696  13F9 000042BF 000042C6  3881            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000036A0  0239 000F 000042C6      3882            AND.B   #$0F,VAR_BYTE_END
000036A8                          3883            
000036A8                          3884            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036A8  23C5 000042CA           3885            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000036AE  1439 000042C6           3886            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000036B4                          3887            
000036B4                          3888            *INTITIALIZE FOR BIT SHIFTING
000036B4  41F9 000042CA           3889            LEA     VAR_TEMP_CLEANCOPY,A0
000036BA  2639 000042CA           3890            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000036C0                          3891  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000036C0  0C02 0000               3892            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000036C4  6700 0008               3893            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000036C8  E24B                    3894            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000036CA  5302                    3895            SUB.B   #1,D2                     *DECREMENT COUNTER
000036CC  60F2                    3896            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000036CE                          3897  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000036CE  0283 00000007           3898            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000036D4  0603 0030               3899            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000036D8  6100 02BC               3900            BSR     PUSH_STACK                *PUSH TO STACK
000036DC                          3901            
000036DC  163C 0029               3902            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000036E0  6100 02B4               3903            BSR       PUSH_STACK
000036E4                          3904            
000036E4  6000 0270               3905            BRA     GET_DST_SUCCESS                   *RETURN 
000036E8                          3906  
000036E8                          3907            
000036E8                          3908            
000036E8                          3909                      
000036E8                          3910  *** Check if source ...  <ea> = (An)+       
000036E8  41F9 000042BE           3911  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000036EE  1439 000042BC           3912            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036F4  1082                    3913            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036F6  0239 0008 000042BE      3914            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000036FE  0C39 0008 000042BE      3915            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003706  6700 0082               3916            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000370A  0CB9 00000003 000042CE  3917            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003714  6600 0074               3918            BNE     DEST_CHECK4
00003718                          3919            
00003718                          3920            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003718  163C 0020               3921            MOVE.B    #' ',D3
0000371C  6100 0278               3922            BSR       PUSH_STACK
00003720  163C 0028               3923            MOVE.B    #'(',D3
00003724  6100 0270               3924            BSR       PUSH_STACK
00003728  163C 0041               3925            MOVE.B    #'A',D3
0000372C  6100 0268               3926            BSR       PUSH_STACK
00003730                          3927  
00003730                          3928            
00003730                          3929            *FIND REGISTER NUMBER END LOCATION*  
00003730  13F9 000042BF 000042C6  3930            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000373A  0239 000F 000042C6      3931            ANDI.B   #$0F,VAR_BYTE_END
00003742                          3932            
00003742                          3933            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003742  23C5 000042CA           3934            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003748  1439 000042C6           3935            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000374E                          3936            
0000374E                          3937            *INTITIALIZE FOR BIT SHIFTING
0000374E  41F9 000042CA           3938            LEA     VAR_TEMP_CLEANCOPY,A0
00003754  2639 000042CA           3939            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000375A                          3940            
0000375A                          3941  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000375A  0C02 0000               3942            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000375E  6700 0008               3943            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003762  E24B                    3944            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003764  5302                    3945            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003766  60F2                    3946            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003768                          3947                                               *change: NAME OF LABEL*
00003768                          3948  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003768  0283 00000007           3949            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000376E  0603 0030               3950            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003772  6100 0222               3951            BSR     PUSH_STACK                *PUSH TO STACK
00003776                          3952            
00003776  163C 0029               3953            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000377A  6100 021A               3954            BSR       PUSH_STACK
0000377E  163C 002B               3955            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003782  6100 0212               3956            BSR       PUSH_STACK
00003786                          3957            
00003786  6000 01CE               3958            BRA       GET_DST_SUCCESS                   *RETURN 
0000378A                          3959  
0000378A                          3960            
0000378A                          3961            
0000378A                          3962                      
0000378A                          3963            *** Check if source ...  <ea> = -(An)       
0000378A                          3964  DEST_CHECK4    
0000378A  41F9 000042BE           3965            LEA     TEMP_REGISTER_FORMAT,A0
00003790  1439 000042BC           3966            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003796  1082                    3967            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003798  0239 0010 000042BE      3968            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000037A0  0C39 0010 000042BE      3969            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000037A8  6700 0082               3970            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000037AC  0CB9 00000004 000042CE  3971            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000037B6  6600 0074               3972            BNE     DEST_CHECK7
000037BA                          3973            
000037BA                          3974            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000037BA  163C 0020               3975            MOVE.B    #' ',D3
000037BE  6100 01D6               3976            BSR       PUSH_STACK
000037C2  163C 002D               3977            MOVE.B    #'-',D3
000037C6  6100 01CE               3978            BSR       PUSH_STACK
000037CA  163C 0028               3979            MOVE.B    #'(',D3
000037CE  6100 01C6               3980            BSR       PUSH_STACK
000037D2  163C 0041               3981            MOVE.B    #'A',D3
000037D6  6100 01BE               3982            BSR       PUSH_STACK
000037DA                          3983  
000037DA                          3984            
000037DA                          3985            *FIND REGISTER NUMBER END LOCATION*  
000037DA  13F9 000042BF 000042C6  3986            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000037E4  0239 000F 000042C6      3987            AND.B   #$0F,VAR_BYTE_END
000037EC                          3988            
000037EC                          3989            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037EC  23C5 000042CA           3990            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037F2  1439 000042C6           3991            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000037F8                          3992            
000037F8                          3993            *INTITIALIZE FOR BIT SHIFTING
000037F8  41F9 000042CA           3994            LEA     VAR_TEMP_CLEANCOPY,A0
000037FE  2639 000042CA           3995            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003804                          3996            
00003804                          3997  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003804  0C02 0000               3998            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003808  6700 0008               3999            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000380C  E24B                    4000            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000380E  5302                    4001            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003810  60F2                    4002            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003812                          4003                                               *change: NAME OF LABEL*
00003812                          4004  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003812  0283 00000007           4005            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003818  0603 0030               4006            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000381C  6100 0178               4007            BSR     PUSH_STACK                *PUSH TO STACK
00003820                          4008            
00003820  163C 0029               4009            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003824  6100 0170               4010            BSR       PUSH_STACK
00003828                          4011            
00003828  6000 012C               4012            BRA     GET_DST_SUCCESS                   *RETURN
0000382C                          4013            
0000382C                          4014                      
0000382C                          4015            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000382C                          4016  DEST_CHECK7    
0000382C  0CB9 00000007 000042CE  4017            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003836  6600 011A               4018            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
0000383A                          4019                   
0000383A                          4020            *NEXT: (MODE == 111) 
0000383A                          4021            *NOW: CHECK FOR SRC REGISTER 
0000383A                          4022                  *(000 = (xxx).W)
0000383A                          4023                  *(001 = (xxx).L)
0000383A                          4024                  *(010 = #<data>)
0000383A                          4025                  
0000383A                          4026            *FIND REGISTER NUMBER END LOCATION*  
0000383A  13F9 000042BF 000042C6  4027            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003844  0239 000F 000042C6      4028            AND.B   #$0F,VAR_BYTE_END
0000384C                          4029            
0000384C                          4030            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000384C  23C5 000042CA           4031            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003852  1439 000042C6           4032            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003858                          4033            
00003858                          4034            *INTITIALIZE FOR BIT SHIFTING
00003858  41F9 000042CA           4035            LEA     VAR_TEMP_CLEANCOPY,A0
0000385E  2C39 000042CA           4036            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003864                          4037  DEST_LOOP_SHIFTING7
00003864  0C02 0000               4038            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003868  6700 0008               4039            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000386C  E24E                    4040            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000386E  5302                    4041            SUB.B   #1,D2                     *DECREMENT COUNTER
00003870  60F2                    4042            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003872                          4043  DEST_MASKING_NEXT7
00003872  CCBC 00000007           4044            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003878                          4045           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003878                          4046            
00003878                          4047  DEST_CHECK_WORD  
00003878  41F9 000042BE           4048            LEA     TEMP_REGISTER_FORMAT,A0
0000387E  1439 000042BC           4049            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003884  1082                    4050            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003886  0239 0020 000042BE      4051            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
0000388E  0C39 0020 000042BE      4052            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003896  6700 0026               4053            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000389A  0C06 0000               4054            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
0000389E  6600 001E               4055            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
000038A2                          4056            *IT IS A WORD AT THIS POINT*
000038A2                          4057            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000038A2  163C 0020               4058            MOVE.B    #' ',D3
000038A6  6100 00EE               4059            BSR       PUSH_STACK
000038AA  163C 0024               4060            MOVE.B    #'$',D3
000038AE  6100 00E6               4061            BSR       PUSH_STACK
000038B2  321D                    4062            MOVE.W    (A5)+,D1
000038B4  7404                    4063            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000038B6  6100 D942               4064            BSR       HEX2ASCII2STACK
000038BA  6000 009A               4065            BRA       GET_DST_SUCCESS
000038BE                          4066  
000038BE                          4067  DEST_CHECK_LONG
000038BE  41F9 000042BE           4068            LEA     TEMP_REGISTER_FORMAT,A0
000038C4  1439 000042BC           4069            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000038CA  1082                    4070            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000038CC  0239 0040 000042BE      4071            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000038D4  0C39 0040 000042BE      4072            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000038DC  6700 002E               4073            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000038E0  0C06 0001               4074            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
000038E4  6600 0026               4075            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
000038E8                          4076            *IT IS A WORD AT THIS POINT*
000038E8                          4077            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000038E8  163C 0020               4078            MOVE.B    #' ',D3
000038EC  6100 00A8               4079            BSR       PUSH_STACK
000038F0  163C 0024               4080            MOVE.B    #'$',D3
000038F4  6100 00A0               4081            BSR       PUSH_STACK
000038F8  321D                    4082            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
000038FA  7404                    4083            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
000038FC  6100 D8FC               4084            BSR       HEX2ASCII2STACK
00003900  321D                    4085            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003902  7404                    4086            MOVE.L    #4,D2          
00003904  6100 D8F4               4087            BSR       HEX2ASCII2STACK
00003908  6000 004C               4088            BRA     GET_DST_SUCCESS
0000390C                          4089            
0000390C                          4090  DEST_CHECK_IMMEDIATE
0000390C  41F9 000042BE           4091            LEA     TEMP_REGISTER_FORMAT,A0
00003912  1439 000042BC           4092            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003918  1082                    4093            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000391A  0239 0080 000042BE      4094            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003922  0C39 0080 000042BE      4095            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000392A  6700 0026               4096            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000392E  0C06 0004               4097            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003932  6600 001E               4098            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003936                          4099            
00003936                          4100            *IT IS A WORD AT THIS POINT*
00003936                          4101            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003936  163C 0020               4102            MOVE.B    #' ',D3
0000393A  6100 005A               4103            BSR       PUSH_STACK
0000393E  163C 0023               4104            MOVE.B    #'#',D3
00003942  6100 0052               4105            BSR       PUSH_STACK
00003946  321D                    4106            MOVE.W    (A5)+,D1
00003948  7404                    4107            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000394A  6100 D8AE               4108            BSR       HEX2ASCII2STACK
0000394E  6000 0006               4109            BRA       GET_DST_SUCCESS
00003952                          4110            
00003952                          4111  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003952  7801                    4112            MOVE.L #1,D4
00003954  4E75                    4113            RTS
00003956                          4114  GET_DST_SUCCESS 
00003956  4E75                    4115            RTS
00003958                          4116  
00003958                          4117  
00003958                          4118  *---------------------------------------------------------------------------*
00003958                          4119  * STACK/QUEUE INTERFACE
00003958                          4120  *---------------------------------------------------------------------------*
00003958                          4121  PRINT_STACK
00003958  0C39 0000 000042B8      4122            CMP.B     #0,COUNTER
00003960  6700 000E               4123            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003964                          4124            
00003964                          4125  PRINT_STACK_HELPER
00003964  6100 0038               4126            BSR      POP_STACK          *PRINTS ADDRESS
00003968  103C 0006               4127            MOVE.B   #6,D0              *Display single character in D1.B. 
0000396C  4E4F                    4128            TRAP     #15             *ACTIVATES PRINT
0000396E                          4129  
0000396E  60E8                    4130            BRA       PRINT_STACK
00003970                          4131  PRINT_STACK_RETURN
00003970  4E75                    4132            RTS
00003972                          4133            
00003972                          4134            
00003972                          4135  PRINT_QUEUE
00003972  0C39 0000 000042B8      4136            CMP.B     #0,COUNTER
0000397A  6700 0018               4137            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
0000397E                          4138            
0000397E                          4139  PRINT_QUEUE_HELPER
0000397E  33F9 000042B8 000042BA  4140            MOVE.W   COUNTER,QUEUE_COUNTER
00003988  6100 0022               4141            BSR      POP_FRONT          *PRINTS ADDRESS
0000398C  103C 0006               4142            MOVE.B   #6,D0              *Display single character in D1.B. 
00003990  4E4F                    4143            TRAP     #15             *ACTIVATES PRINT
00003992                          4144  
00003992  60DE                    4145            BRA       PRINT_QUEUE
00003994                          4146  PRINT_QUEUE_RETURN
00003994  4E75                    4147            RTS
00003996                          4148            
00003996                          4149  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003996                          4150  PUSH_STACK
00003996  1503                    4151              MOVE.B  D3,-(A2)
00003998  6100 0058               4152              BSR     INCREMENT
0000399C  4E75                    4153              RTS
0000399E                          4154  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
0000399E                          4155  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
0000399E                          4156  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
0000399E                          4157  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
0000399E                          4158  *         TRAP        #15             *ACTIVATES PRINT
0000399E                          4159  POP_STACK
0000399E  BECA                    4160              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
000039A0  6700 0008               4161              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
000039A4  121A                    4162              MOVE.B  (A2)+,D1 
000039A6  6100 0052               4163              BSR     DECREMENT
000039AA                          4164  POP_RETURN
000039AA  4E75                    4165              RTS 
000039AC                          4166        
000039AC                          4167  *USE [A4] AS SECOND POINTER IN SHIFTING      
000039AC  0C39 0000 000042BA      4168  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000039B4  6700 0030               4169              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
000039B8                          4170              
000039B8                          4171              
000039B8                          4172              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
000039B8  347C 7000               4173              MOVEA.W #STACK,A2   *START A2 AT STACK
000039BC  0622 0000               4174              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
000039C0  384A                    4175              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
000039C2  0624 0000               4176              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
000039C6  1212                    4177              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
000039C8                          4178  POP_SHIFT_LOOP
000039C8  0C39 0000 000042BA      4179              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000039D0  6700 0014               4180              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
000039D4  1494                    4181              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
000039D6  0624 0000               4182              ADD.B   #0,-(A4)
000039DA  0622 0000               4183              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
000039DE  5339 000042BA           4184              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
000039E4                          4185              
000039E4  60E2                    4186              BRA     POP_SHIFT_LOOP
000039E6                          4187                          
000039E6                          4188  POP_FRONT_RETURN 
000039E6                          4189              *RESET A2 BACK TO SP
000039E6  347C 7000               4190              MOVEA.W #STACK,A2    
000039EA  5339 000042B8           4191              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
000039F0  4E75                    4192              RTS   
000039F2                          4193  
000039F2                          4194  INCREMENT
000039F2  5239 000042B8           4195              ADD.B   #1, COUNTER
000039F8  4E75                    4196              RTS           
000039FA                          4197  DECREMENT
000039FA  5339 000042B8           4198              SUB.B   #1, COUNTER
00003A00  4E75                    4199              RTS           
00003A02                          4200  CLEAR_STACK
00003A02  0C39 0000 000042B8      4201              CMP.B     #0,COUNTER
00003A0A  6700 0006               4202              BEQ       CLEAR_RETURN
00003A0E  618E                    4203              BSR       POP_STACK
00003A10  60F0                    4204              BRA       CLEAR_STACK
00003A12                          4205   
00003A12                          4206  CLEAR_RETURN
00003A12  4E75                    4207              RTS    
00003A14                          4208  *---------------------------------------------------------------------------*
00003A14                          4209  * TERMINATE
00003A14                          4210  *---------------------------------------------------------------------------*
00003A14                          4211  TERMINATE   
00003A14  43F9 00003DC4           4212              LEA     FINMSG,A1
00003A1A  103C 000E               4213              MOVE.B  #14,D0
00003A1E  4E4F                    4214              TRAP    #15
00003A20                          4215  
00003A20  103C 0009               4216              MOVE.B  #9,D0
00003A24  4E4F                    4217              TRAP    #15
00003A26                          4218  
00003A26                          4219  *---------------------------------------------------------------------------*
00003A26                          4220  * Data storage                                                 
00003A26                          4221  *---------------------------------------------------------------------------*  
00003A26                          4222  WELCOME
00003A26= 20 20 20 20 20 20 ...   4223              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00003A76= 3D 3D 3D 3D 3D 20 ...   4224              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003AC6= 3D 3D 3D 3D 3D 20 ...   4225              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003B16                          4226      
00003B16= 20 20 20 20 20 20 ...   4227              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00003B66= 20 20 20 20 20 20 ...   4228              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00003BB6= 20 20 20 20 20 20 ...   4229              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003C06                          4230      
00003C06= 20 20 20 20 20 20 ...   4231              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00003C56= 3D 3D 3D 3D 3D 20 ...   4232              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00003CA6= 3D 3D 3D 3D 3D 20 ...   4233              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003CFB                          4234  
00003CFB                          4235  PROMPT_START
00003CFB= 50 6C 65 61 73 65 ...   4236              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00003D2A                          4237      
00003D2A                          4238  PROMPT_END
00003D2A= 50 6C 65 61 73 65 ...   4239              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00003D57= 0D 0A 48 69 74 20 ...   4240  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00003D81= 57 6F 75 6C 64 20 ...   4241  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003DC4= 54 68 61 6E 6B 20 ...   4242  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003DEF= 45 72 72 6F 72 3A ...   4243  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003E0E= 45 72 72 6F 72 3A ...   4244  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003E33= 45 72 72 6F 72 3A ...   4245  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003E60                          4246  
00003E60                          4247  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003EB0                          4248  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003F00                          4249  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003F04                          4250  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003F08= 0D 0A 00                4251  ENDLINE_M   DC.B    CR,LF,0
00003F0B                          4252  TMPINPUT    DS.B    80                      * temp store user input
00003F5B                          4253  TMPOUTPUT   DS.B    80                      * temp store prog output
00003FAB= 20 20 20 4F 52 49 ...   4254  DISP_ORI_B  DC.B    '   ORI.B',0
00003FB4= 20 20 20 4F 52 49 ...   4255  DISP_ORI_W  DC.B    '   ORI.W',0
00003FBD= 20 20 20 4F 52 49 ...   4256  DISP_ORI_L  DC.B    '   ORI.L',0
00003FC6= 20 20 20 45 4F 52 ...   4257  DISP_EORI_B  DC.B    '   EORI.B',0
00003FD0= 20 20 20 45 4F 52 ...   4258  DISP_EORI_W  DC.B    '   EORI.W',0
00003FDA= 20 20 20 45 4F 52 ...   4259  DISP_EORI_L  DC.B    '   EORI.L',0
00003FE4= 20 20 20 42 54 53 ...   4260  DISP_BTST   DC.B    '   BTST',0
00003FEC= 20 20 20 43 4D 50 ...   4261  DISP_CMPI_B  DC.B    '   CMPI.B',0
00003FF6= 20 20 20 43 4D 50 ...   4262  DISP_CMPI_W  DC.B    '   CMPI.W',0
00004000= 20 20 20 43 4D 50 ...   4263  DISP_CMPI_L  DC.B    '   CMPI.L',0
0000400A= 20 20 20 44 41 54 ...   4264  DISP_DATA   DC.B    '   DATA',0
00004012= 20 20 20 4D 4F 56 ...   4265  DISP_MOVE_B DC.B    '   MOVE.B',0
0000401C= 20 20 20 4D 4F 56 ...   4266  DISP_MOVE_W DC.B    '   MOVE.W',0
00004026= 20 20 20 4D 4F 56 ...   4267  DISP_MOVE_L DC.B    '   MOVE.L',0
00004030= 20 20 20 52 54 53 00    4268  DISP_RTS    DC.B    '   RTS',0
00004037= 20 20 20 4A 53 52 00    4269  DISP_JSR    DC.B    '   JSR',0
0000403E= 20 20 20 4E 45 47 ...   4270  DISP_NEG_B    DC.B    '   NEG.B',0
00004047= 20 20 20 4E 45 47 ...   4271  DISP_NEG_W    DC.B    '   NEG.W',0
00004050= 20 20 20 4E 45 47 ...   4272  DISP_NEG_L    DC.B    '   NEG.L',0
00004059= 20 20 20 4E 4F 54 ...   4273  DISP_NOT_B  DC.B    '   NOT.B',0
00004062= 20 20 20 4E 4F 54 ...   4274  DISP_NOT_W  DC.B    '   NOT.W',0
0000406B= 20 20 20 4E 4F 54 ...   4275  DISP_NOT_L  DC.B    '   NOT.L',0
00004074= 20 20 20 4C 45 41 00    4276  DISP_LEA    DC.B    '   LEA',0
0000407B= 20 20 20 4D 4F 56 ...   4277  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004086= 20 20 20 4D 4F 56 ...   4278  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00004091= 20 20 20 41 44 44 ...   4279  DISP_ADDQ_B DC.B    '   ADDQ.B',0
0000409B= 20 20 20 41 44 44 ...   4280  DISP_ADDQ_W DC.B    '   ADDQ.W',0
000040A5= 20 20 20 41 44 44 ...   4281  DISP_ADDQ_L DC.B    '   ADDQ.L',0
000040AF= 20 20 20 44 49 56 ...   4282  DISP_DIVS   DC.B    '   DIVS',0
000040B7= 20 20 20 53 55 42 ...   4283  DISP_SUB_B  DC.B    '   SUB.B',0
000040C0= 20 20 20 53 55 42 ...   4284  DISP_SUB_W  DC.B    '   SUB.W',0
000040C9= 20 20 20 53 55 42 ...   4285  DISP_SUB_L  DC.B    '   SUB.L',0
000040D2= 20 20 20 53 55 42 ...   4286  DISP_SUBI_B  DC.B    '   SUBI.B',0
000040DC= 20 20 20 53 55 42 ...   4287  DISP_SUBI_W  DC.B    '   SUBI.W',0
000040E6= 20 20 20 53 55 42 ...   4288  DISP_SUBI_L  DC.B    '   SUBI.L',0
000040F0= 20 20 20 53 55 42 ...   4289  DISP_SUBA_W  DC.B    '   SUBA.W',0
000040FA= 20 20 20 53 55 42 ...   4290  DISP_SUBA_L  DC.B    '   SUBA.L',0
00004104= 20 20 20 45 4F 52 ...   4291  DISP_EOR_B  DC.B    '   EOR.B',0
0000410D= 20 20 20 45 4F 52 ...   4292  DISP_EOR_W  DC.B    '   EOR.W',0
00004116= 20 20 20 45 4F 52 ...   4293  DISP_EOR_L  DC.B    '   EOR.L',0
0000411F= 20 20 20 43 4D 50 ...   4294  DISP_CMP_B  DC.B    '   CMP.B',0
00004128= 20 20 20 43 4D 50 ...   4295  DISP_CMP_W  DC.B    '   CMP.W',0
00004131= 20 20 20 43 4D 50 ...   4296  DISP_CMP_L  DC.B    '   CMP.L',0
0000413A= 20 20 20 43 4D 50 ...   4297  DISP_CMPA_W  DC.B    '   CMPA.W',0
00004144= 20 20 20 43 4D 50 ...   4298  DISP_CMPA_L  DC.B    '   CMPA.L',0
0000414E= 20 20 20 4D 55 4C ...   4299  DISP_MULS_W DC.B    '   MULS.W',0
00004158= 20 20 20 41 4E 44 ...   4300  DISP_AND_B  DC.B    '   AND.B',0
00004161= 20 20 20 41 4E 44 ...   4301  DISP_AND_W  DC.B    '   AND.W',0
0000416A= 20 20 20 41 4E 44 ...   4302  DISP_AND_L  DC.B    '   AND.L',0
00004173= 20 20 20 41 44 44 ...   4303  DISP_ADD_B  DC.B    '   ADD.B',0
0000417C= 20 20 20 41 44 44 ...   4304  DISP_ADD_W  DC.B    '   ADD.W',0
00004185= 20 20 20 41 44 44 ...   4305  DISP_ADD_L  DC.B    '   ADD.L',0
0000418E= 20 20 20 41 44 44 ...   4306  DISP_ADDA_W DC.B    '   ADDA.W',0
00004198= 20 20 20 41 44 44 ...   4307  DISP_ADDA_L DC.B    '   ADDA.L',0
000041A2= 20 20 20 4C 53 52 ...   4308  DISP_LSR_B  DC.B    '   LSR.B',0
000041AB= 20 20 20 4C 53 4C ...   4309  DISP_LSL_B  DC.B    '   LSL.B',0
000041B4= 20 20 20 4C 53 52 ...   4310  DISP_LSR_W  DC.B    '   LSR.W',0
000041BD= 20 20 20 4C 53 4C ...   4311  DISP_LSL_W  DC.B    '   LSL.W',0
000041C6= 20 20 20 4C 53 52 ...   4312  DISP_LSR_L  DC.B    '   LSR.L',0
000041CF= 20 20 20 4C 53 4C ...   4313  DISP_LSL_L  DC.B    '   LSL.L',0
000041D8= 20 20 20 41 53 52 ...   4314  DISP_ASR_B  DC.B    '   ASR.B',0
000041E1= 20 20 20 41 53 4C ...   4315  DISP_ASL_B  DC.B    '   ASL.B',0
000041EA= 20 20 20 41 53 52 ...   4316  DISP_ASR_W  DC.B    '   ASR.W',0
000041F3= 20 20 20 41 53 4C ...   4317  DISP_ASL_W  DC.B    '   ASL.W',0
000041FC= 20 20 20 41 53 52 ...   4318  DISP_ASR_L  DC.B    '   ASR.L',0
00004205= 20 20 20 41 53 4C ...   4319  DISP_ASL_L  DC.B    '   ASL.L',0
0000420E= 20 20 20 52 4F 52 ...   4320  DISP_ROR_B  DC.B    '   ROR.B',0
00004217= 20 20 20 52 4F 4C ...   4321  DISP_ROL_B  DC.B    '   ROL.B',0
00004220= 20 20 20 52 4F 52 ...   4322  DISP_ROR_W  DC.B    '   ROR.W',0
00004229= 20 20 20 52 4F 4C ...   4323  DISP_ROL_W  DC.B    '   ROL.W',0
00004232= 20 20 20 52 4F 52 ...   4324  DISP_ROR_L  DC.B    '   ROR.L',0
0000423B= 20 20 20 52 4F 4C ...   4325  DISP_ROL_L  DC.B    '   ROL.L',0
00004244= 20 20 20 42 52 41 00    4326  DISP_BRA    DC.B    '   BRA',0
0000424B= 20 20 20 42 4C 54 00    4327  DISP_BLT    DC.B    '   BLT',0
00004252= 20 20 20 42 45 51 00    4328  DISP_BEQ    DC.B    '   BEQ',0
00004259= 20 20 20 42 4E 45 00    4329  DISP_BNE    DC.B    '   BNE',0
00004260= 20 20 20 42 48 49 00    4330  DISP_BHI    DC.B    '   BHI',0
00004267= 20 20 20 4D 4F 56 ...   4331  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004272= 20 20 20 4D 4F 56 ...   4332  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
0000427D                          4333  
0000427D= 20 20 20 24 00          4334  DISP_HEX     DC.B    '   $',0
00004282= 20 20 20 44 00          4335  DISP_D  DC.B    '   D',0
00004287= 20 20 20 41 00          4336  DISP_A  DC.B    '   A',0
0000428C= 20 20 20 28 00          4337  DISP_OP  DC.B    '   (',0
00004291= 29 00                   4338  DISP_CP  DC.B   ')',0
00004293= 20 20 20 28 41 00       4339  DISP_AOP  DC.B    '   (A',0
00004299                          4340  
00004299= 20 20 20 2D 28 41 00    4341  DISP_PRE    DC.B    '   -(A',0
000042A0= 29 2B 00                4342  DISP_POST   DC.B    ')+',0
000042A3= 20 20 20 23 00          4343  DISP_LB DC.B    '   #',0
000042A8= 30 00                   4344  DISP_0  DC.B    '0',0
000042AA= 31 00                   4345  DISP_1  DC.B    '1',0
000042AC= 32 00                   4346  DISP_2  DC.B    '2',0
000042AE= 33 00                   4347  DISP_3  DC.B    '3',0
000042B0= 34 00                   4348  DISP_4  DC.B    '4',0
000042B2= 35 00                   4349  DISP_5  DC.B    '5',0
000042B4= 36 00                   4350  DISP_6  DC.B    '6',0
000042B6= 37 00                   4351  DISP_7  DC.B    '7',0
000042B8                          4352  
000042B8                          4353  *STACK INTERFACE VARIABLES*
000042B8                          4354  COUNTER         DS.W    1
000042BA                          4355  QUEUE_COUNTER   DS.W    1
000042BC                          4356  
000042BC                          4357  *EA DECODING INTERFACE VARIABLES* 
000042BC                          4358  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
000042BD                          4359  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
000042BE                          4360  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
000042BF                          4361  
000042BF                          4362  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
000042BF                          4363  * WORD + WORD = LONG
000042BF                          4364  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
000042BF                          4365  * A              + F            = AF         <= EXAMPLE
000042BF                          4366  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
000042BF                          4367  GET_DST_START_END    DS.B    1
000042C0                          4368  GET_SRC_START_END    DS.B    1
000042C1                          4369  
000042C1                          4370  *STORES THE START + END BITS HERE (FROM ABOVE)
000042C2                          4371  VAR_BYTE_START      DS.L    1
000042C6                          4372  VAR_BYTE_END        DS.L    1
000042CA                          4373  VAR_TEMP_CLEANCOPY  DS.L    1
000042CE                          4374  
000042CE                          4375  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
000042D2                          4376  
000042D2                          4377  *MORE FOR STACK USAGE*
000042D2= 2C 00                   4378  DISP_COMMA  DC.B    ',',0
000042D4= 20 20 20 00             4379  DISP_INDENT  DC.B    '   ',0
000042D8                          4380  
000042D8                          4381  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
000042D8                          4382  POINTER_WORD    DS.W       1
000042DA                          4383  
000042DA                          4384  
000042DA                          4385  
000042DA                          4386  *---------------------------------------------------------------------------*
000042DA                          4387  * Ends program
000042DA                          4388  *---------------------------------------------------------------------------*
000042DA                          4389              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1156
ASCII2HEX           1150
ASC_ERR             11B2
ASC_LOW             1194
ASC_NUM             11A4
ASC_SFT             11AC
ASC_UPP             119C
CHECK0              310A
CHECK1              3194
CHECK2              321E
CHECK3              32B8
CHECK4              335A
CHECK7              33FC
CHECK_IMMEDIATE     34DC
CHECK_LONG          348E
CHECK_WORD          3448
CLEAR_RETURN        3A12
CLEAR_STACK         3A02
COUNTER             42B8
CR                  D
DECREMENT           39FA
DEST_CHECK0         353A
DEST_CHECK1         35C4
DEST_CHECK2         364E
DEST_CHECK3         36E8
DEST_CHECK4         378A
DEST_CHECK7         382C
DEST_CHECK_IMMEDIATE  390C
DEST_CHECK_LONG     38BE
DEST_CHECK_WORD     3878
DEST_LOOP_SHIFTING  35A4
DEST_LOOP_SHIFTING1  362E
DEST_LOOP_SHIFTING2  36C0
DEST_LOOP_SHIFTING3  375A
DEST_LOOP_SHIFTING4  3804
DEST_LOOP_SHIFTING7  3864
DEST_MASKING_NEXT   35B2
DEST_MASKING_NEXT1  363C
DEST_MASKING_NEXT2  36CE
DEST_MASKING_NEXT3  3768
DEST_MASKING_NEXT4  3812
DEST_MASKING_NEXT7  3872
DEST_MODE           2CC2
DEST_REGISTER       2F92
DEST_REGISTER_FORMAT  42BC
DISPLAY_30_LINES    12FE
DISP_0              42A8
DISP_1              42AA
DISP_2              42AC
DISP_3              42AE
DISP_4              42B0
DISP_5              42B2
DISP_6              42B4
DISP_7              42B6
DISP_A              4287
DISP_ADDA_L         4198
DISP_ADDA_W         418E
DISP_ADDQ_B         4091
DISP_ADDQ_L         40A5
DISP_ADDQ_W         409B
DISP_ADD_B          4173
DISP_ADD_L          4185
DISP_ADD_W          417C
DISP_AND_B          4158
DISP_AND_L          416A
DISP_AND_W          4161
DISP_AOP            4293
DISP_ASL_B          41E1
DISP_ASL_L          4205
DISP_ASL_W          41F3
DISP_ASR_B          41D8
DISP_ASR_L          41FC
DISP_ASR_W          41EA
DISP_BEQ            4252
DISP_BHI            4260
DISP_BLT            424B
DISP_BNE            4259
DISP_BRA            4244
DISP_BTST           3FE4
DISP_CMPA_L         4144
DISP_CMPA_W         413A
DISP_CMPI_B         3FEC
DISP_CMPI_L         4000
DISP_CMPI_W         3FF6
DISP_CMP_B          411F
DISP_CMP_L          4131
DISP_CMP_W          4128
DISP_COMMA          42D2
DISP_CP             4291
DISP_D              4282
DISP_DATA           400A
DISP_DIVS           40AF
DISP_EORI_B         3FC6
DISP_EORI_L         3FDA
DISP_EORI_W         3FD0
DISP_EOR_B          4104
DISP_EOR_L          4116
DISP_EOR_W          410D
DISP_HEX            427D
DISP_INDENT         42D4
DISP_JSR            4037
DISP_LB             42A3
DISP_LEA            4074
DISP_LSL_B          41AB
DISP_LSL_L          41CF
DISP_LSL_W          41BD
DISP_LSR_B          41A2
DISP_LSR_L          41C6
DISP_LSR_W          41B4
DISP_MOVEA_L        4272
DISP_MOVEA_W        4267
DISP_MOVEM_L        4086
DISP_MOVEM_W        407B
DISP_MOVE_B         4012
DISP_MOVE_L         4026
DISP_MOVE_W         401C
DISP_MULS_W         414E
DISP_NEG_B          403E
DISP_NEG_L          4050
DISP_NEG_W          4047
DISP_NEXT           3D57
DISP_NOT_B          4059
DISP_NOT_L          406B
DISP_NOT_W          4062
DISP_OP             428C
DISP_ORI_B          3FAB
DISP_ORI_L          3FBD
DISP_ORI_W          3FB4
DISP_POST           42A0
DISP_PRE            4299
DISP_ROL_B          4217
DISP_ROL_L          423B
DISP_ROL_W          4229
DISP_ROR_B          420E
DISP_ROR_L          4232
DISP_ROR_W          4220
DISP_RTS            4030
DISP_SUBA_L         40FA
DISP_SUBA_W         40F0
DISP_SUBI_B         40D2
DISP_SUBI_L         40E6
DISP_SUBI_W         40DC
DISP_SUB_B          40B7
DISP_SUB_L          40C9
DISP_SUB_W          40C0
D_MODE000           2D64
D_MODE010           2DAC
D_MODE011           2E0C
D_MODE100           2E2C
D_MODE111           2E7E
EA_ARITH            2C5C
EA_DATA             14DC
EA_GEN              2CA8
EA_MOVEA            2C82
EA_NOSRC            2C48
ENDLINE_M           3F08
END_ADDR            109C
ERRMSG_1            3DEF
ERRMSG_3            3E0E
ERRMSG_5            3E33
ERROR_1             1100
ERROR_2             1110
ERROR_3             1120
ERROR_4             1130
ERROR_5             1140
E_ADDR_HX           3F04
FINMSG              3DC4
GET_DST_FAILED      3952
GET_DST_START_END   42BF
GET_DST_SUCCESS     3956
GET_EA_EA_DEST      3528
GET_EA_EA_SRC       30F8
GET_SRC_FAILED      3522
GET_SRC_START_END   42C0
GET_SRC_SUCCESS     3526
HEX2ASCII           11B8
HEX2ASCII2STACK     11FA
HEX_CHAR            11E6
HEX_CONT            11EA
HEX_LOOP            11CC
IMMD_B              2F32
IMMD_L              2F72
IMMD_W              2F52
IMMEDIATE           2F02
INCREMENT           39F2
INTRO               1028
IS_ODD              123E
IS_ODD_ERR          1254
JMPTABLE            132A
LF                  A
LONGMODE            2ED6
LOOP_SHIFTING       3174
LOOP_SHIFTING1      31FE
LOOP_SHIFTING2      3290
LOOP_SHIFTING3      332A
LOOP_SHIFTING4      33D4
MAIN                125A
MASKING_NEXT        3182
MASKING_NEXT1       320C
MASKING_NEXT2       329E
MASKING_NEXT3       3338
MASKING_NEXT4       33E2
MODE000             2D50
MODE001             2D78
MODE010             2D8C
MODE011             2DCC
MODE100             2DEC
MODE111             2E4C
NEXTLINES           130C
OP0000              138A
OP0001              15B0
OP0010              161E
OP0011              171C
OP0100              1818
OP0101              1A6E
OP0101_ADDQ_B       1AEA
OP0101_ADDQ_B_0     1B66
OP0101_ADDQ_B_1     1B72
OP0101_ADDQ_B_2     1B7E
OP0101_ADDQ_B_3     1B8A
OP0101_ADDQ_B_4     1B96
OP0101_ADDQ_B_5     1BA2
OP0101_ADDQ_B_6     1BAE
OP0101_ADDQ_B_7     1BBA
OP0101_ADDQ_B_8     1BC6
OP0101_ADDQ_L       1B02
OP0101_ADDQ_W       1AF6
OP0101_RETURN       1B0A
OP0101_RETURN2      1BCE
OP0110              1C12
OP0111              1CA0
OP1000              1CA4
OP1000_DIVS_DN_EA_OR_EA_DN  1CB2
OP1000_DIVS_RETURN  1D96
OP1000_EA_DN_DIVS   1CE0
OP1000_PRINT_L_DIVS  1D4E
OP1000_PRINT_W_DIVS  1D06
OP1001              1DAC
OP1001_ADD_RETURN   20FA
OP1001_DETERMINE_DN_EA_OR_EA_DN  1EC2
OP1001_DN_EA        1EFA
OP1001_EA_DN        1FFA
OP1001_PRINT_B      2022
OP1001_PRINT_B2     1F22
OP1001_PRINT_L      20B2
OP1001_PRINT_L2     1FB2
OP1001_PRINT_W      206A
OP1001_PRINT_W2     1F6A
OP1001_SUBA_L       1DDE
OP1001_SUBA_W       1E50
OP1010              2168
OP1011              216C
OP1100              2268
OP1100_AND_RETURN   25B8
OP1100_DETERMINE_DN_EA_OR_EA_DN  237E
OP1100_DN_EA        23B8
OP1100_EA_DN        24B8
OP1100_EA_DN_MULS   22C6
OP1100_MULS_DN_EA_OR_EA_DN  2298
OP1100_MULS_RETURN  237C
OP1100_PRINT_B      24E0
OP1100_PRINT_B2     23E0
OP1100_PRINT_L      2570
OP1100_PRINT_L2     2470
OP1100_PRINT_L_MULS  2334
OP1100_PRINT_W      2528
OP1100_PRINT_W2     2428
OP1100_PRINT_W_MULS  22EC
OP1101              25BA
OP1101_ADDA_L       25EC
OP1101_ADDA_W       265E
OP1101_ADD_RETURN   2908
OP1101_DETERMINE_DN_EA_OR_EA_DN  26D0
OP1101_DN_EA        2708
OP1101_EA_DN        2808
OP1101_PRINT_B      2830
OP1101_PRINT_B2     2730
OP1101_PRINT_L      28C0
OP1101_PRINT_L2     27C0
OP1101_PRINT_W      2878
OP1101_PRINT_W2     2778
OP1110              2996
OP1111              2C44
OP_ADDA_L           297E
OP_ADDA_W           2966
OP_ADDQ_B           1BDC
OP_ADDQ_L           1C00
OP_ADDQ_W           1BEE
OP_ADD_B            291E
OP_ADD_L            294E
OP_ADD_W            2936
OP_ASL              2B36
OP_ASL_B            2B5A
OP_ASL_L            2B6C
OP_ASL_W            2B7E
OP_ASR              2ADC
OP_ASR_B            2B00
OP_ASR_L            2B12
OP_ASR_W            2B24
OP_ASX              29F8
OP_BEQ              1C76
OP_BHI              1C5A
OP_BLT              1C92
OP_BNE              1C68
OP_BRA              1C84
OP_BTST             13FE
OP_CMPA_L           21D8
OP_CMPA_W           21C6
OP_CMPI             1504
OP_CMPI_B           1524
OP_CMPI_L           1548
OP_CMPI_W           1536
OP_CMP_B            21EA
OP_CMP_L            221A
OP_CMP_W            2202
OP_DATA             14B8
OP_DIVS             1D98
OP_EORI             140C
OP_EORI_B           142C
OP_EORI_L           1450
OP_EORI_W           143E
OP_EOR_B            2232
OP_EOR_L            2256
OP_EOR_W            2244
OP_JSR              1A40
OP_LEA              18C6
OP_LEA_DN_EA_OR_EA_DN  18D4
OP_LEA_RETURN       1932
OP_LSL              2A82
OP_LSL_B            2AA6
OP_LSL_L            2AB8
OP_LSL_W            2ACA
OP_LSR              2A28
OP_LSR_B            2A4C
OP_LSR_L            2A5E
OP_LSR_W            2A70
OP_LSX              29E0
OP_MOVEA_L          16AC
OP_MOVEA_W          17A8
OP_MOVEM_L          18B4
OP_MOVEM_W          18A2
OP_MOVE_B           15B6
OP_MOVE_L           1644
OP_MOVE_W           1740
OP_MULS             228A
OP_NEG              1934
OP_NEG_B            1980
OP_NEG_L            1998
OP_NEG_PRINT_EA     19A4
OP_NEG_W            198C
OP_NOT              19BA
OP_NOT_B            1A06
OP_NOT_L            1A1E
OP_NOT_PRINT_EA     1A2A
OP_NOT_W            1A12
OP_ORI              155A
OP_ORI_B            157A
OP_ORI_L            159E
OP_ORI_W            158C
OP_PRINT_L_LEA      18F2
OP_ROL              2BEA
OP_ROL_B            2C0E
OP_ROL_L            2C20
OP_ROL_W            2C32
OP_ROR              2B90
OP_ROR_B            2BB4
OP_ROR_L            2BC6
OP_ROR_W            2BD8
OP_ROX              2A10
OP_RTS              1A54
OP_SUBA_L           2156
OP_SUBA_W           2144
OP_SUBI             1462
OP_SUBI_B           1482
OP_SUBI_L           14A6
OP_SUBI_W           1494
OP_SUB_B            20FC
OP_SUB_L            212C
OP_SUB_W            2114
OUTPUT_PROCESSED_DATA  12DE
POINTER_WORD        42D8
POP_FRONT           39AC
POP_FRONT_RETURN    39E6
POP_RETURN          39AA
POP_SHIFT_LOOP      39C8
POP_STACK           399E
PRINT_QUEUE         3972
PRINT_QUEUE_HELPER  397E
PRINT_QUEUE_RETURN  3994
PRINT_STACK         3958
PRINT_STACK_HELPER  3964
PRINT_STACK_RETURN  3970
PROGLP              100A
PROMPT_END          3D2A
PROMPT_START        3CFB
PUSH_STACK          3996
QUEUE_COUNTER       42BA
REG_0               3046
REG_1               3054
REG_2               3062
REG_3               3070
REG_4               307E
REG_5               308C
REG_6               309A
REG_7               30A8
REPEAT              30B6
REPEATMSG           3D81
RETURN              11B6
SRC_LOOP_SHIFTING   3434
SRC_MASKING_NEXT    3442
SRC_MODE            2D06
SRC_REGISTER        2FEE
SRC_REGISTER_FORMAT  42BD
STACK               7000
STACK_HEX_CHAR      1228
STACK_HEX_CONT      122C
STACK_HEX_LOOP      120E
START               1004
START_ADDR          104A
S_ADDR_HX           3F00
TEMP_REGISTER_FORMAT  42BE
TERMINATE           3A14
TESTING             1036
TMPINPUT            3F0B
TMPOUTPUT           3F5B
VAR_BYTE_END        42C6
VAR_BYTE_START      42C2
VAR_LONG_ADDRESS_MODE_CHECK  42CE
VAR_TEMP_CLEANCOPY  42CA
VR_E_ADDR           3EB0
VR_S_ADDR           3E60
WELCOME             3A26
WORDMODE            2EAA
