00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 12:54:46 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001044             37  PROGLP      JSR     START_ADDR
00001010  4EB9 00001096             38              JSR     END_ADDR
00001016  43F9 00003D80             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 00001254             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 0000389E             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  49D4                      53              LEA  (A4),A4
00001038  4DF8 3331                 54              LEA  $3331,A6
0000103C  4FF9 44444441             55              LEA  $44444441,A7
00001042                            56              
00001042                            57  
00001042                            58              
00001042  4E75                      59              RTS
00001044                            60  *---------------------------------------------------------------------------*
00001044                            61  * START_ADDR: Compute the starting address
00001044                            62  *---------------------------------------------------------------------------*
00001044                            63  START_ADDR
00001044                            64              * Output
00001044  43F9 00003B73             65              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000104A  103C 000E                 66              MOVE.B  #14,D0                  * Display PROMPT_START
0000104E  4E4F                      67              TRAP    #15
00001050                            68      
00001050                            69              * Input
00001050  43F9 00003CD8             70              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
00001056  103C 0002                 71              MOVE.B  #2,D0                   * Ask user for input
0000105A  4E4F                      72              TRAP    #15
0000105C                            73              
0000105C                            74              * Error Checking (length)
0000105C  0C01 0000                 75              CMPI.B  #0, D1                  * Check if input length <= 0
00001060  6F00 0098                 76              BLE     ERROR_1
00001064  0C01 0008                 77              CMPI.B  #8, D1                  * Check if input length > 8
00001068  6E00 0090                 78              BGT     ERROR_1
0000106C                            79              
0000106C                            80              * Conversion & Storage
0000106C  4EB9 0000114A             81              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001072  0C07 0001                 82              CMPI.B  #1, D7                  * Check for error
00001076  6700 0082                 83              BEQ     ERROR_1                 
0000107A  23C1 00003D78             84              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001080                            85              
00001080                            86              * Error Checking (Odd)
00001080  43F9 00003D78             87              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
00001086  4EB9 00001238             88              JSR     IS_ODD                  * Check if the input address is odd
0000108C  0C07 0001                 89              CMPI.B  #1, D7                  * Check for error
00001090  6700 0088                 90              BEQ     ERROR_3
00001094                            91              
00001094                            92              * Return
00001094  4E75                      93              RTS     
00001096                            94  *---------------------------------------------------------------------------*
00001096                            95  * END_ADDR: Compute the ending address
00001096                            96  *---------------------------------------------------------------------------*
00001096                            97  END_ADDR
00001096                            98              * Output
00001096  43F9 00003BA2             99              LEA     PROMPT_END,A1           * Load PROMPT_END
0000109C  103C 000E                100              MOVE.B  #14,D0                  * Display PROMPT_END
000010A0  4E4F                     101              TRAP    #15
000010A2                           102  
000010A2                           103              * Input
000010A2  43F9 00003D28            104              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010A8  103C 0002                105              MOVE.B  #2,D0                   * Ask user for input
000010AC  4E4F                     106              TRAP    #15
000010AE                           107              
000010AE                           108              * Error Checking (length)
000010AE  0C01 0000                109              CMPI.B  #0, D1                  * Check if input length <= 0
000010B2  6F00 0056                110              BLE     ERROR_2
000010B6  0C01 0008                111              CMPI.B  #8, D1                  * Check if input length > 8
000010BA  6E00 004E                112              BGT     ERROR_2
000010BE                           113              
000010BE                           114              * Conversion & Storage
000010BE  4EB9 0000114A            115              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010C4  0C07 0001                116              CMPI.B  #1, D7                  * Check for error
000010C8  6700 0040                117              BEQ     ERROR_2
000010CC  23C1 00003D7C            118              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D2                           119              
000010D2                           120              * Error Checking (start > end case)
000010D2  2439 00003D78            121              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010D8  B282                     122              CMP.L   D2, D1                  * Compare starting and ending address
000010DA  6300 005E                123              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010DE                           124              
000010DE                           125              * Error Checking (Odd case)
000010DE  43F9 00003D7C            126              LEA     E_ADDR_HX, A1           * Move the ending address
000010E4  4EB9 00001238            127              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010EA  0C07 0001                128              CMPI.B  #1, D7                  * Check for an error flag
000010EE  6700 003A                129              BEQ     ERROR_4
000010F2                           130              
000010F2                           131              * Inputs are valid
000010F2  2A79 00003D78            132              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010F8                           133              
000010F8  4E75                     134              RTS
000010FA                           135              
000010FA                           136  *---------------------------------------------------------------------------*
000010FA                           137  * ERROR_1: Address error (Invalid starting address)
000010FA                           138  *---------------------------------------------------------------------------*
000010FA                           139  ERROR_1
000010FA  43F9 00003C67            140              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001100  103C 000E                141              MOVE.B  #14, D0                 * Display ERRMSG_1
00001104  4E4F                     142              TRAP    #15
00001106  4EF8 1044                143              JMP     START_ADDR              * Jump to START_ADDR
0000110A                           144      
0000110A                           145  *---------------------------------------------------------------------------*
0000110A                           146  * ERROR_2: Address error (Invalid ending address)
0000110A                           147  *---------------------------------------------------------------------------*
0000110A                           148  ERROR_2
0000110A  43F9 00003C67            149              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001110  103C 000E                150              MOVE.B  #14, D0                 * Display ERRMSG_1
00001114  4E4F                     151              TRAP    #15
00001116  4EF8 1096                152              JMP     END_ADDR                * Jump to END_ADDR
0000111A                           153  
0000111A                           154  *---------------------------------------------------------------------------*
0000111A                           155  * ERROR_3: Address error (Odd starting address)
0000111A                           156  *---------------------------------------------------------------------------*
0000111A                           157  ERROR_3
0000111A  43F9 00003C86            158              LEA     ERRMSG_3, A1
00001120  103C 000E                159              MOVE.B  #14, D0
00001124  4E4F                     160              TRAP    #15
00001126  4EF8 1044                161              JMP     START_ADDR
0000112A                           162     
0000112A                           163  *---------------------------------------------------------------------------*
0000112A                           164  * ERROR_4: Address error (Odd ending address)
0000112A                           165  *---------------------------------------------------------------------------*         
0000112A                           166  ERROR_4
0000112A  43F9 00003C86            167              LEA     ERRMSG_3, A1
00001130  103C 000E                168              MOVE.B  #14, D0
00001134  4E4F                     169              TRAP    #15
00001136  4EF8 1096                170              JMP     END_ADDR
0000113A                           171            
0000113A                           172  *---------------------------------------------------------------------------*
0000113A                           173  * ERROR_3: Address error (Ending address is less than starting address)
0000113A                           174  *---------------------------------------------------------------------------*
0000113A                           175  ERROR_5
0000113A  43F9 00003CAB            176              LEA     ERRMSG_5, A1
00001140  103C 000E                177              MOVE.B  #14, D0
00001144  4E4F                     178              TRAP    #15
00001146  4EF8 1096                179              JMP     END_ADDR
0000114A                           180    
0000114A                           181  *---------------------------------------------------------------------------*
0000114A                           182  * ASCII2HEX: Convert ASCii to Hexadecimal
0000114A                           183  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000114A                           184  *---------------------------------------------------------------------------*
0000114A  4281                     185  ASCII2HEX   CLR.L   D1                      * Clear the destination 
0000114C  4287                     186              CLR.L   D7                      * Set the error flag to 0
0000114E  4282                     187              CLR.L   D2                      * Clear D2 for temp storage
00001150                           188              
00001150  1419                     189  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001152  0C02 0000                190              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
00001156  6700 0058                191              BEQ     RETURN                  * If it's NULL, go to return
0000115A  0C02 0066                192              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
0000115E  6E00 004C                193              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001162  0C02 0061                194              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
00001166  6C00 0026                195              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000116A  0C02 0046                196              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
0000116E  6E00 003C                197              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001172  0C02 0041                198              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
00001176  6C00 001E                199              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000117A  0C02 0039                200              CMPI.B  #57, D2                 * Decimal value of 9 is 57
0000117E  6E00 002C                201              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001182  0C02 0030                202              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
00001186  6C00 0016                203              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000118A  6000 0020                204              BRA     ASC_ERR                 * Invalid input
0000118E                           205  
0000118E  0442 0057                206  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001192  6000 0012                207              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
00001196                           208              
00001196  0442 0037                209  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000119A  6000 000A                210              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119E                           211              
0000119E  0442 0030                212  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A2  6000 0002                213              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A6                           214              
000011A6  E981                     215  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011A8  D202                     216              ADD.B   D2, D1                  * Add the converted input to D1
000011AA  60A4                     217              BRA     ASC2HXLP                * Loop
000011AC                           218  
000011AC  1E3C 0001                219  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B0  4E75                     220  RETURN      RTS     
000011B2                           221  
000011B2                           222  *---------------------------------------------------------------------------*
000011B2                           223  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011B2                           224  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011B2                           225  *---------------------------------------------------------------------------*
000011B2  0C02 0008                226  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011B6  6700 000E                227              BEQ     HEX_LOOP
000011BA  4841                     228              SWAP    D1
000011BC  0C02 0002                229              CMPI.B  #2,D2
000011C0  6600 0004                230              BNE     HEX_LOOP
000011C4  E189                     231              LSL.L   #8,D1
000011C6                           232             
000011C6  E999                     233  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011C8  2601                     234              MOVE.L  D1, D3                  * Move D1 to D3
000011CA  0283 0000000F            235              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011D0  0C03 0009                236              CMPI.B  #9, D3                  * Compare te digit
000011D4  6E00 000A                237              BGT     HEX_CHAR              
000011D8  0603 0030                238              ADDI.B  #48,D3                  * Add 48 for numerical output
000011DC  6000 0006                239              BRA     HEX_CONT
000011E0                           240              
000011E0  0603 0037                241  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011E4                           242  
000011E4  12C3                     243  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011E6  5342                     244              SUBI    #1, D2                  * Decrement the size
000011E8  0C02 0000                245              CMPI.B  #0, D2                  * Check if D2 is 0
000011EC  66D8                     246              BNE     HEX_LOOP                * Loop
000011EE  12BC 0000                247              MOVE.B  #$0,(A1)                * Null terminator
000011F2  4E75                     248              RTS
000011F4                           249  *---------------------------------------------------------------------------*
000011F4                           250  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
000011F4                           251  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011F4                           252  *---------------------------------------------------------------------------*
000011F4                           253  HEX2ASCII2STACK
000011F4  0C02 0008                254              CMPI.B  #8, D2                  * Check to see if the size is long
000011F8  6700 000E                255              BEQ     STACK_HEX_LOOP
000011FC  4841                     256              SWAP    D1
000011FE  0C02 0002                257              CMPI.B  #2,D2
00001202  6600 0004                258              BNE     STACK_HEX_LOOP
00001206  E189                     259              LSL.L   #8,D1
00001208                           260             
00001208                           261  STACK_HEX_LOOP    
00001208  E999                     262              ROL.L   #4, D1                  * Roll D1 to left
0000120A  2601                     263              MOVE.L  D1, D3                  * Move D1 to D3
0000120C  0283 0000000F            264              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001212  0C03 0009                265              CMPI.B  #9, D3                  * Compare te digit
00001216  6E00 000A                266              BGT     STACK_HEX_CHAR              
0000121A  0603 0030                267              ADDI.B  #48,D3                  * Add 48 for numerical output
0000121E  6000 0006                268              BRA     STACK_HEX_CONT
00001222                           269              
00001222                           270  STACK_HEX_CHAR    
00001222  0603 0037                271              ADDI.B  #55,D3                  * Add 55 for character output
00001226                           272  
00001226                           273  STACK_HEX_CONT    
00001226  6100 25E6                274              BSR     PUSH_STACK              *PLACE INTO STACK
0000122A  5342                     275              SUBI    #1, D2                  * Decrement the size
0000122C  0C02 0000                276              CMPI.B  #0, D2                  * Check if D2 is 0
00001230  66D6                     277              BNE     STACK_HEX_LOOP                * Loop
00001232  12BC 0000                278              MOVE.B  #$0,(A1)                * Null terminator
00001236  4E75                     279              RTS
00001238                           280  
00001238                           281  
00001238                           282  *---------------------------------------------------------------------------*
00001238                           283  * IS_ODD: Check whether the source address is odd
00001238                           284  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
00001238                           285  *---------------------------------------------------------------------------*
00001238  4281                     286  IS_ODD      CLR.L   D1                      * Clear the result
0000123A  4287                     287              CLR.L   D7                      * Set the error flag to 0
0000123C  2211                     288              MOVE.L  (A1),D1                * Temp store the checking address to D1
0000123E  82FC 0002                289              DIVU    #2, D1                  * Divide the result by 2
00001242  4841                     290              SWAP    D1                      * Swap remainder with quotient
00001244  0C01 0001                291              CMPI.B  #1, D1                  * Check for error
00001248  6700 0004                292              BEQ     IS_ODD_ERR
0000124C  4E75                     293              RTS
0000124E                           294              
0000124E  1E3C 0001                295  IS_ODD_ERR  MOVE.B  #1, D7
00001252  4E75                     296              RTS
00001254                           297  
00001254                           298  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
00001254                           299  * MAIN                    
00001254                           300  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
00001254                           301  * A5: Processing address
00001254                           302  *
00001254                           303  * D3: USED FOR PUSHING INTO STACK
00001254                           304  *     To push into stack => MOVE.W #DATA,D3 
00001254                           305  *                           BSR    PUSH_STACK
00001254                           306  *     To print stack     => BSR    PRINT_STACK 
00001254                           307  *     To clear stack     => BSR    CLEAR_STACK
00001254                           308  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
00001254                           309  MAIN        
00001254                           310              *initialize stack pointer
00001254  33FC 0000 00004130       311              MOVE.W  #0,COUNTER
0000125C  347C 7000                312              MOVEA.W #STACK,A2
00001260  163C 0020                313              MOVE.B  #' ',D3
00001264  6100 25A8                314              BSR     PUSH_STACK
00001268  6100 25A4                315              BSR     PUSH_STACK
0000126C  6100 25A0                316              BSR     PUSH_STACK
00001270                           317              
00001270                           318              * clear registers for temp storage
00001270  4280                     319              CLR.L   D0                   
00001272  4281                     320              CLR.L   D1                   
00001274  227C 00000000            321              MOVEA.L #0, A1                
0000127A                           322              
0000127A  220D                     323              MOVE.L  A5,D1                   * check to see if the address is fully read
0000127C  23CD 00003D78            324              MOVE.L  A5,S_ADDR_HX
00001282  B2B9 00003D7C            325              CMP.L   E_ADDR_HX,D1
00001288  6C00 1CA4                326              BGE     REPEAT                  * go to repeat for user action
0000128C                           327  
0000128C  43F9 00003DD3            328              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001292  143C 0008                329              MOVE.B  #8,D2                   * set the output size
00001296  4EB8 11B2                330              JSR     HEX2ASCII               
0000129A  43F9 00003DD3            331              LEA     TMPOUTPUT,A1
000012A0  103C 000E                332              MOVE.B  #14,D0
000012A4  4E4F                     333              TRAP    #15
000012A6                           334              
000012A6  4285                     335              CLR.L    D5                      * clear the processing data
000012A8  3A1D                     336              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012AA                           337                                               * advance the current instruction pointer to the next
000012AA                           338                                               * instruction in memory
000012AA                           339  *----------------------------------------*
000012AA                           340  * Registers          
000012AA                           341  * [D1] - COPY OF D5
000012AA                           342  * [D5] - DATA TO BE PROCESSED
000012AA                           343  * [D6] - COUNTER FOR LINES PROCESSED
000012AA                           344  *
000012AA                           345  * [D4]      - ERROR FLAG BEFORE PRINTING
000012AA                           346  * [STACK]   - PRINTS PROCESS DATA
000012AA                           347  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012AA                           348  *
000012AA                           349  * [A1] - USED FOR JUMPING/PRINTING
000012AA                           350  *
000012AA                           351  *----------------------------------------*
000012AA                           352  
000012AA                           353              
000012AA                           354              *Processing the first 4 most significant bits 
000012AA  2205                     355              MOVE.L  D5,D1                    * copy the current processing data to D1
000012AC  143C 000C                356              MOVE.B  #12,D2                   * shift to right by 12 bits
000012B0  E469                     357              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012B2  C2FC 0006                358              MULU    #6,D1                    * form offset
000012B6  43F9 00001324            359              LEA     JMPTABLE,A1              * index into table
000012BC  4EB1 1000                360              JSR     0(A1,D1)                 * jump indirect with index
000012C0                           361              
000012C0                           362              *SECURED EA*
000012C0  B83C 0001                363              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012C4  6600 0012                364              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012C8  6100 01E8                365              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012CC  6100 25AC                366              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012D0  183C 0000                367              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012D4  6000 0022                368              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012D8                           369             
000012D8                           370  OUTPUT_PROCESSED_DATA       
000012D8  163C 000D                371              MOVE.B  #$D,D3                  *carriage return
000012DC  6100 2530                372              BSR     PUSH_STACK
000012E0  163C 000A                373              MOVE.B  #$A,D3                  *new line feed
000012E4  6100 2528                374              BSR     PUSH_STACK
000012E8  163C 0000                375              MOVE.B  #$0,D3                  *null
000012EC  6100 2520                376              BSR     PUSH_STACK
000012F0                           377       
000012F0  6100 24F8                378              BSR     PRINT_QUEUE
000012F4  183C 0000                379              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012F8                           380  DISPLAY_30_LINES
000012F8                           381              * display 30 lines per page
000012F8  5206                     382              ADDI.B  #1,D6
000012FA  0C06 001E                383              CMPI.B  #30,D6
000012FE  6C00 0006                384              BGE     NEXTLINES
00001302  6000 FF50                385              BRA     MAIN
00001306                           386            
00001306                           387  *---------------------------------------------------------------------------*
00001306                           388  * NEXTLINES: receive input from user to print the next 30 lines
00001306                           389  *---------------------------------------------------------------------------*  
00001306  4206                     390  NEXTLINES   CLR.B   D6
00001308  43F9 00003BCF            391              LEA     DISP_NEXT,A1
0000130E  103C 000E                392              MOVE.B  #14,D0
00001312  4E4F                     393              TRAP    #15
00001314  43F9 00003D83            394              LEA     TMPINPUT,A1
0000131A  103C 0002                395              MOVE.B  #2,D0
0000131E  4E4F                     396              TRAP    #15
00001320  4EF8 1254                397              JMP     MAIN
00001324                           398    
00001324                           399  *---------------------------------------------------------------------------*
00001324                           400  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001324                           401  *---------------------------------------------------------------------------*  
00001324  4EF9 00001384            402  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
0000132A  4EF9 000015AA            403              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001330  4EF9 00001618            404              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
00001336  4EF9 00001716            405              JMP     OP0011  * MOVE.W/MOVEA.W
0000133C  4EF9 00001812            406              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *WORKING ON LEA - JOSEPH
00001342  4EF9 00001A0E            407              JMP     OP0101  * ADDQ  
00001348  4EF9 00001A8A            408              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)
0000134E  4EF9 00001B18            409              JMP     OP0111  * MOVEQ (unassigned)
00001354  4EF9 00001B1C            410              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
0000135A  4EF9 00001C24            411              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001360  4EF9 00001FE0            412              JMP     OP1010  * Unassigned 
00001366  4EF9 00001FE4            413              JMP     OP1011  * CMP/EOR/CMPA
0000136C  4EF9 000020E0            414              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
00001372  4EF9 00002432            415              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
00001378  4EF9 0000280E            416              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
0000137E  4EF9 00002ABC            417              JMP     OP1111  * Special/Reserved
00001384                           418              
00001384                           419  *---------------------------------------------------------------------------*
00001384                           420  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
00001384                           421  *---------------------------------------------------------------------------*           
00001384                           422  OP0000                                                                                  
00001384  4281                     423              CLR.L   D1          * to temporarily store the address to process
00001386  4280                     424              CLR.L   D0  
00001388  4284                     425              CLR.L   D4                 
0000138A  227C 00000000            426              MOVEA.L #0, A1                
00001390                           427              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001390                           428              * Check if bit 11,10,9,8 are 0000)
00001390  2205                     429              MOVE.L  D5,D1
00001392  0281 00000F00            430              ANDI.L  #$0F00,D1
00001398  0C81 00000000            431              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
0000139E  6700 01B4                432              BEQ     OP_ORI
000013A2                           433  
000013A2                           434              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013A2                           435              * check if bit 11,10,9,8 are 1100
000013A2  4281                     436              CLR.L   D1
000013A4  2205                     437              MOVE.L  D5,D1
000013A6  0281 00000F00            438              ANDI.L  #$0F00,D1
000013AC  0C81 00000C00            439              CMPI.L  #$0C00,D1
000013B2  6700 014A                440              BEQ     OP_CMPI
000013B6                           441              
000013B6                           442              * check for SUBI
000013B6  4281                     443              CLR.L   D1
000013B8  2205                     444              MOVE.L  D5,D1
000013BA  0281 00000F00            445              ANDI.L  #$0F00,D1
000013C0  0C81 00000400            446              CMPI.L  #$0400,D1
000013C6  6700 0094                447              BEQ     OP_SUBI
000013CA                           448              
000013CA                           449              * check for EORI
000013CA  4281                     450              CLR.L   D1
000013CC  2205                     451              MOVE.L  D5,D1
000013CE  0281 00000F00            452              ANDI.L  #$0F00,D1
000013D4  0C81 00000A00            453              CMPI.L  #$0A00,D1
000013DA  6700 002A                454              BEQ     OP_EORI
000013DE                           455              
000013DE                           456              * check for BTST
000013DE  4281                     457              CLR.L   D1
000013E0  2205                     458              MOVE.L  D5,D1
000013E2  EA99                     459              ROR.L   #5,D1
000013E4  0281 00000008            460              ANDI.L  #$8,D1
000013EA  0C01 0008                461              CMPI.B  #8,D1
000013EE  6700 0008                462              BEQ     OP_BTST
000013F2                           463  
000013F2                           464              * OP0000 series other than ORI/CMPI/BTST/EORI
000013F2  4EF9 000014B2            465              JMP     OP_DATA
000013F8                           466              
000013F8                           467  *---------------------------------------------------------------------------*
000013F8                           468  * OP_BTST: display BTST
000013F8                           469  *---------------------------------------------------------------------------* 
000013F8  43F9 00003E5C            470  OP_BTST     LEA     DISP_BTST,A1
000013FE  103C 000E                471              MOVE.B  #14,D0
00001402  4E4F                     472              TRAP    #15
00001404  4E75                     473              RTS
00001406                           474  
00001406                           475  *---------------------------------------------------------------------------*
00001406                           476  * OP_EORI: decode and display EORI
00001406                           477  *---------------------------------------------------------------------------* 
00001406                           478  OP_EORI
00001406  4281                     479              CLR.L   D1
00001408  4284                     480              CLR.L   D4
0000140A  2205                     481              MOVE.L  D5,D1
0000140C  EC99                     482              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000140E  0C01 0000                483              CMPI.B  #0,D1
00001412  6700 0012                484              BEQ     OP_EORI_B    * size is byte
00001416  0C01 0001                485              CMPI.B  #1,D1
0000141A  6700 001C                486              BEQ     OP_EORI_W    * size is word
0000141E  0C01 0002                487              CMPI.B  #2,D1
00001422  6700 0026                488              BEQ     OP_EORI_L    * size is long
00001426                           489  
00001426                           490  OP_EORI_B    * size is byte    
00001426  183C 0000                491              MOVE.B  #0,D4
0000142A  43F9 00003E3E            492              LEA     DISP_EORI_B,A1
00001430  103C 000E                493              MOVE.B  #14,D0
00001434  4E4F                     494              TRAP    #15
00001436  4E75                     495              RTS
00001438                           496              
00001438                           497  OP_EORI_W    * size is word
00001438  183C 0001                498              MOVE.B  #1,D4
0000143C  43F9 00003E48            499              LEA     DISP_EORI_W,A1
00001442  103C 000E                500              MOVE.B  #14,D0
00001446  4E4F                     501              TRAP    #15
00001448  4E75                     502              RTS
0000144A                           503              
0000144A                           504  OP_EORI_L    * size is long
0000144A  183C 0002                505              MOVE.B  #2,D4
0000144E  43F9 00003E52            506              LEA     DISP_EORI_L,A1
00001454  103C 000E                507              MOVE.B  #14,D0
00001458  4E4F                     508              TRAP    #15
0000145A  4E75                     509              RTS
0000145C                           510              
0000145C                           511  *---------------------------------------------------------------------------*
0000145C                           512  * OP_SUBI: decode SUBI.B/.W/.L
0000145C                           513  *---------------------------------------------------------------------------* 
0000145C                           514  OP_SUBI
0000145C  4281                     515              CLR.L   D1
0000145E  4284                     516              CLR.L   D4
00001460  2205                     517              MOVE.L  D5,D1
00001462  EC99                     518              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001464  0C01 0000                519              CMPI.B  #0,D1
00001468  6700 0012                520              BEQ     OP_SUBI_B    * size is byte
0000146C  0C01 0001                521              CMPI.B  #1,D1
00001470  6700 001C                522              BEQ     OP_SUBI_W    * size is word
00001474  0C01 0002                523              CMPI.B  #2,D1
00001478  6700 0026                524              BEQ     OP_SUBI_L    * size is long
0000147C                           525  
0000147C                           526  OP_SUBI_B    * size is byte    
0000147C  183C 0000                527              MOVE.B  #0,D4
00001480  43F9 00003F4A            528              LEA     DISP_SUBI_B,A1
00001486  103C 000E                529              MOVE.B  #14,D0
0000148A  4E4F                     530              TRAP    #15
0000148C  4E75                     531              RTS
0000148E                           532              
0000148E                           533  OP_SUBI_W    * size is word
0000148E  183C 0001                534              MOVE.B  #1,D4
00001492  43F9 00003F54            535              LEA     DISP_SUBI_W,A1
00001498  103C 000E                536              MOVE.B  #14,D0
0000149C  4E4F                     537              TRAP    #15
0000149E  4E75                     538              RTS
000014A0                           539              
000014A0                           540  OP_SUBI_L    * size is long
000014A0  183C 0002                541              MOVE.B  #2,D4
000014A4  43F9 00003F5E            542              LEA     DISP_SUBI_L,A1
000014AA  103C 000E                543              MOVE.B  #14,D0
000014AE  4E4F                     544              TRAP    #15
000014B0  4E75                     545              RTS
000014B2                           546              
000014B2                           547  *---------------------------------------------------------------------------*
000014B2                           548  * OP_DATA : unidentified opcode
000014B2                           549  *---------------------------------------------------------------------------* 
000014B2                           550  OP_DATA
000014B2  4280                     551              CLR.L   D0                   
000014B4  4281                     552              CLR.L   D1     
000014B6  4284                     553              CLR.L   D4                    
000014B8  227C 00000000            554              MOVEA.L #0, A1             
000014BE  4287                     555              CLR.L   D7
000014C0  1E3C 0001                556              MOVE.B  #1,D7                   * error flag is true
000014C4                           557              
000014C4  43F9 00003E82            558              LEA     DISP_DATA,A1
000014CA  103C 000E                559              MOVE.B  #14,D0
000014CE  4E4F                     560              TRAP    #15
000014D0                           561              
000014D0  4EF9 000014D6            562              JMP     EA_DATA
000014D6                           563             
000014D6                           564             
000014D6                           565  *---------------------------------------------------------------------------*
000014D6                           566  * EA_DATA
000014D6                           567  *---------------------------------------------------------------------------*       
000014D6  43F9 00003DD3            568  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014DC  2205                     569              MOVE.L  D5,D1           * transfer the processing data to D1
000014DE  7404                     570              MOVE.L  #4,D2           * set to word size
000014E0  4EB8 11B2                571              JSR     HEX2ASCII       * prepare output in ascii
000014E4  43F9 000040F5            572              LEA     DISP_HEX,A1     * display $ symbol
000014EA  103C 000E                573              MOVE.B  #14,D0      
000014EE  4E4F                     574              TRAP    #15
000014F0  43F9 00003DD3            575              LEA     TMPOUTPUT,A1    * display with a new line
000014F6  103C 000D                576              MOVE.B  #13,D0
000014FA  4E4F                     577              TRAP    #15
000014FC                           578  
000014FC  4E75                     579              RTS
000014FE                           580              
000014FE                           581  *---------------------------------------------------------------------------*
000014FE                           582  * OP_CMPI : decode CMPI and its size
000014FE                           583  *---------------------------------------------------------------------------*          
000014FE                           584  OP_CMPI
000014FE  4281                     585              CLR.L   D1
00001500  4284                     586              CLR.L   D4
00001502  2205                     587              MOVE.L  D5,D1
00001504  EC99                     588              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001506  0C01 0000                589              CMPI.B  #0,D1
0000150A  6700 0012                590              BEQ     OP_CMPI_B    * size is byte
0000150E  0C01 0001                591              CMPI.B  #1,D1
00001512  6700 001C                592              BEQ     OP_CMPI_W    * size is word
00001516  0C01 0002                593              CMPI.B  #2,D1
0000151A  6700 0026                594              BEQ     OP_CMPI_L    * size is long
0000151E                           595  
0000151E                           596  OP_CMPI_B    * size is byte    
0000151E  183C 0000                597              MOVE.B  #0,D4
00001522  43F9 00003E64            598              LEA     DISP_CMPI_B,A1
00001528  103C 000E                599              MOVE.B  #14,D0
0000152C  4E4F                     600              TRAP    #15
0000152E  4E75                     601              RTS
00001530                           602              
00001530                           603  OP_CMPI_W    * size is word
00001530  183C 0001                604              MOVE.B  #1,D4
00001534  43F9 00003E6E            605              LEA     DISP_CMPI_W,A1
0000153A  103C 000E                606              MOVE.B  #14,D0
0000153E  4E4F                     607              TRAP    #15
00001540  4E75                     608              RTS
00001542                           609              
00001542                           610  OP_CMPI_L    * size is long
00001542  183C 0002                611              MOVE.B  #2,D4
00001546  43F9 00003E78            612              LEA     DISP_CMPI_L,A1
0000154C  103C 000E                613              MOVE.B  #14,D0
00001550  4E4F                     614              TRAP    #15
00001552  4E75                     615              RTS
00001554                           616   
00001554                           617  *---------------------------------------------------------------------------*
00001554                           618  * OP_ORI : decode ORI and its size
00001554                           619  *---------------------------------------------------------------------------* 
00001554                           620  OP_ORI      
00001554  4281                     621              CLR.L   D1
00001556  4284                     622              CLR.L   D4
00001558  2205                     623              MOVE.L  D5,D1
0000155A  EC99                     624              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000155C  0C01 0000                625              CMPI.B  #0,D1
00001560  6700 0012                626              BEQ     OP_ORI_B    * size is byte
00001564  0C01 0001                627              CMPI.B  #1,D1
00001568  6700 001C                628              BEQ     OP_ORI_W    * size is word
0000156C  0C01 0002                629              CMPI.B  #2,D1
00001570  6700 0026                630              BEQ     OP_ORI_L    * size is long
00001574                           631  
00001574                           632  OP_ORI_B    * size is byte    
00001574  183C 0000                633              MOVE.B  #0,D4
00001578  43F9 00003E23            634              LEA     DISP_ORI_B,A1
0000157E  103C 000E                635              MOVE.B  #14,D0
00001582  4E4F                     636              TRAP    #15
00001584  4E75                     637              RTS
00001586                           638              
00001586                           639  OP_ORI_W    * size is word
00001586  183C 0001                640              MOVE.B  #1,D4
0000158A  43F9 00003E2C            641              LEA     DISP_ORI_W,A1
00001590  103C 000E                642              MOVE.B  #14,D0
00001594  4E4F                     643              TRAP    #15
00001596  4E75                     644              RTS
00001598                           645              
00001598                           646  OP_ORI_L    * size is long
00001598  183C 0002                647              MOVE.B  #2,D4
0000159C  43F9 00003E35            648              LEA     DISP_ORI_L,A1
000015A2  103C 000E                649              MOVE.B  #14,D0
000015A6  4E4F                     650              TRAP    #15
000015A8  4E75                     651              RTS
000015AA                           652          
000015AA                           653  *---------------------------------------------------------------------------*
000015AA                           654  * OP0001: MOVE.B
000015AA                           655  *---------------------------------------------------------------------------*
000015AA                           656  OP0001      
000015AA  4EF9 000015B0            657              JMP     OP_MOVE_B   * display MOVE.B
000015B0                           658              
000015B0                           659  *---------------------------------------------------------------------------*
000015B0                           660  * OP_MOVE_B: display MOVE_B and proceed to EA
000015B0                           661  *---------------------------------------------------------------------------*
000015B0                           662  OP_MOVE_B                                                                       
000015B0                           663             
000015B0                           664             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015B0  13FC 0082 00004134       665             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015B8  13FC 0000 00004135       666             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015C0                           667             
000015C0                           668             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015C0  13FC 00B9 00004137       669             MOVE.B   #$B9,GET_DST_START_END
000015C8  13FC 0020 00004138       670             MOVE.B   #$20,GET_SRC_START_END
000015D0                           671             
000015D0                           672              *CLEAR D3
000015D0  4283                     673              CLR.L   D3
000015D2                           674              *LOAD STACK WITH THIS OPMODE
000015D2  6100 223A                675              BSR     PUSH_STACK
000015D6  163C 004D                676              MOVE.B  #'M',D3
000015DA  6100 2232                677              BSR     PUSH_STACK
000015DE  163C 004F                678              MOVE.B  #'O',D3
000015E2  6100 222A                679              BSR     PUSH_STACK
000015E6  163C 0056                680              MOVE.B  #'V',D3
000015EA  6100 2222                681              BSR     PUSH_STACK
000015EE  163C 0045                682              MOVE.B  #'E',D3
000015F2  6100 221A                683              BSR     PUSH_STACK
000015F6  163C 002E                684              MOVE.B  #'.',D3
000015FA  6100 2212                685              BSR     PUSH_STACK
000015FE  163C 0042                686              MOVE.B  #'B',D3
00001602  6100 220A                687              BSR     PUSH_STACK
00001606                           688              
00001606  6100 1968                689              BSR     GET_EA_EA_SRC
0000160A  163C 002C                690              MOVE.B  #',',D3
0000160E  6100 21FE                691              BSR     PUSH_STACK
00001612  6100 1D8C                692              BSR     GET_EA_EA_DEST
00001616                           693              
00001616  4E75                     694              RTS
00001618                           695              
00001618                           696             
00001618                           697  *---------------------------------------------------------------------------*
00001618                           698  * OP0010: decode MOVE.L/MOVEA.L
00001618                           699  *---------------------------------------------------------------------------*
00001618                           700  OP0010      
00001618  183C 0002                701              MOVE.B  #2,D4
0000161C  4280                     702              CLR.L   D0                     
0000161E  4281                     703              CLR.L   D1                      
00001620  227C 00000000            704              MOVEA.L #0, A1                 
00001626                           705              
00001626  2205                     706              MOVE.L  D5,D1
00001628  EA99                     707              ROR.L   #5,D1
0000162A  0281 0000000E            708              ANDI.L  #$E,D1
00001630  0C01 0002                709              CMPI.B  #2,D1
00001634  6700 0070                710              BEQ     OP_MOVEA_L
00001638                           711  
00001638  4EF9 0000163E            712              JMP     OP_MOVE_L
0000163E                           713             
0000163E                           714  
0000163E                           715  *---------------------------------------------------------------------------*
0000163E                           716  * OP_MOVE_L: display MOVE_L and proceed to EA
0000163E                           717  *---------------------------------------------------------------------------*
0000163E                           718  OP_MOVE_L   
0000163E                           719             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000163E  13FC 0082 00004134       720             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001646  13FC 0000 00004135       721             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000164E                           722             
0000164E                           723             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000164E  13FC 00B9 00004137       724             MOVE.B   #$B9,GET_DST_START_END
00001656  13FC 0020 00004138       725             MOVE.B   #$20,GET_SRC_START_END
0000165E                           726             
0000165E                           727              *CLEAR D3
0000165E  4283                     728              CLR.L   D3
00001660                           729              *LOAD STACK WITH THIS OPMODE
00001660  6100 21AC                730              BSR     PUSH_STACK
00001664  163C 004D                731              MOVE.B  #'M',D3
00001668  6100 21A4                732              BSR     PUSH_STACK
0000166C  163C 004F                733              MOVE.B  #'O',D3
00001670  6100 219C                734              BSR     PUSH_STACK
00001674  163C 0056                735              MOVE.B  #'V',D3
00001678  6100 2194                736              BSR     PUSH_STACK
0000167C  163C 0045                737              MOVE.B  #'E',D3
00001680  6100 218C                738              BSR     PUSH_STACK
00001684  163C 002E                739              MOVE.B  #'.',D3
00001688  6100 2184                740              BSR     PUSH_STACK
0000168C  163C 004C                741              MOVE.B  #'L',D3
00001690  6100 217C                742              BSR     PUSH_STACK
00001694                           743              
00001694  6100 18DA                744              BSR     GET_EA_EA_SRC
00001698  163C 002C                745              MOVE.B  #',',D3
0000169C  6100 2170                746              BSR     PUSH_STACK
000016A0  6100 1CFE                747              BSR     GET_EA_EA_DEST
000016A4                           748              
000016A4  4E75                     749              RTS
000016A6                           750  
000016A6                           751  
000016A6                           752  *---------------------------------------------------------------------------*
000016A6                           753  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000016A6                           754  *---------------------------------------------------------------------------*
000016A6                           755  OP_MOVEA_L 
000016A6                           756             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016A6  13FC 00FD 00004134       757             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016AE  13FC 0000 00004135       758             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016B6                           759             
000016B6                           760             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016B6  13FC 00B9 00004137       761             MOVE.B   #$B9,GET_DST_START_END
000016BE  13FC 0020 00004138       762             MOVE.B   #$20,GET_SRC_START_END
000016C6                           763             
000016C6                           764              *CLEAR D3
000016C6  4283                     765              CLR.L   D3
000016C8                           766              *LOAD STACK WITH THIS OPMODE
000016C8  6100 2144                767              BSR     PUSH_STACK
000016CC  163C 004D                768              MOVE.B  #'M',D3
000016D0  6100 213C                769              BSR     PUSH_STACK
000016D4  163C 004F                770              MOVE.B  #'O',D3
000016D8  6100 2134                771              BSR     PUSH_STACK
000016DC  163C 0056                772              MOVE.B  #'V',D3
000016E0  6100 212C                773              BSR     PUSH_STACK
000016E4  163C 0045                774              MOVE.B  #'E',D3
000016E8  6100 2124                775              BSR     PUSH_STACK           
000016EC  163C 0041                776              MOVE.B  #'A',D3
000016F0  6100 211C                777              BSR     PUSH_STACK
000016F4  163C 002E                778              MOVE.B  #'.',D3
000016F8  6100 2114                779              BSR     PUSH_STACK
000016FC  163C 004C                780              MOVE.B  #'L',D3
00001700  6100 210C                781              BSR     PUSH_STACK
00001704                           782              
00001704  6100 186A                783              BSR     GET_EA_EA_SRC
00001708  163C 002C                784              MOVE.B  #',',D3
0000170C  6100 2100                785              BSR     PUSH_STACK
00001710  6100 1C8E                786              BSR     GET_EA_EA_DEST
00001714                           787              
00001714  4E75                     788              RTS
00001716                           789  
00001716                           790              
00001716                           791  *---------------------------------------------------------------------------*
00001716                           792  * OP0011: decode MOVE.W/MOVEA.W
00001716                           793  *---------------------------------------------------------------------------*
00001716                           794  OP0011      
00001716  4280                     795              CLR.L   D0                      
00001718  4281                     796              CLR.L   D1  
0000171A  4284                     797              CLR.L   D4                   
0000171C  227C 00000000            798              MOVEA.L #0, A1 
00001722                           799                
00001722  2205                     800              MOVE.L  D5,D1
00001724  EC99                     801              ROR.L   #6,D1
00001726  0281 00000007            802              ANDI.L  #$07,D1
0000172C  0C01 0001                803              CMPI.B  #1,D1
00001730  6700 0070                804              BEQ     OP_MOVEA_W
00001734                           805              
00001734  4EF9 0000173A            806              JMP     OP_MOVE_W
0000173A                           807            
0000173A                           808  *---------------------------------------------------------------------------*
0000173A                           809  * OP_MOVE_W: display MOVE_W and proceed to EA
0000173A                           810  *---------------------------------------------------------------------------*
0000173A                           811  OP_MOVE_W   
0000173A                           812             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000173A  13FC 0082 00004134       813             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001742  13FC 0000 00004135       814             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000174A                           815             
0000174A                           816             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000174A  13FC 00B9 00004137       817             MOVE.B   #$B9,GET_DST_START_END
00001752  13FC 0020 00004138       818             MOVE.B   #$20,GET_SRC_START_END
0000175A                           819             
0000175A                           820              *CLEAR D3
0000175A  4283                     821              CLR.L   D3
0000175C                           822              *LOAD STACK WITH THIS OPMODE
0000175C  6100 20B0                823              BSR     PUSH_STACK
00001760  163C 004D                824              MOVE.B  #'M',D3
00001764  6100 20A8                825              BSR     PUSH_STACK
00001768  163C 004F                826              MOVE.B  #'O',D3
0000176C  6100 20A0                827              BSR     PUSH_STACK
00001770  163C 0056                828              MOVE.B  #'V',D3
00001774  6100 2098                829              BSR     PUSH_STACK
00001778  163C 0045                830              MOVE.B  #'E',D3
0000177C  6100 2090                831              BSR     PUSH_STACK
00001780  163C 002E                832              MOVE.B  #'.',D3
00001784  6100 2088                833              BSR     PUSH_STACK
00001788  163C 0057                834              MOVE.B  #'W',D3
0000178C  6100 2080                835              BSR     PUSH_STACK
00001790                           836              
00001790  6100 17DE                837              BSR     GET_EA_EA_SRC
00001794  163C 002C                838              MOVE.B  #',',D3
00001798  6100 2074                839              BSR     PUSH_STACK
0000179C  6100 1C02                840              BSR     GET_EA_EA_DEST
000017A0                           841              
000017A0  4E75                     842              RTS
000017A2                           843  
000017A2                           844  *---------------------------------------------------------------------------*
000017A2                           845  * OP_MOVEA_W: display MOVEA and proceed to EA
000017A2                           846  *---------------------------------------------------------------------------*
000017A2                           847  OP_MOVEA_W 
000017A2                           848             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017A2  13FC 00FD 00004134       849             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000017AA  13FC 0000 00004135       850             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017B2                           851             
000017B2                           852             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017B2  13FC 00B9 00004137       853             MOVE.B   #$B9,GET_DST_START_END
000017BA  13FC 0020 00004138       854             MOVE.B   #$20,GET_SRC_START_END
000017C2                           855             
000017C2                           856              *CLEAR D3
000017C2  4283                     857              CLR.L   D3
000017C4                           858              *LOAD STACK WITH THIS OPMODE
000017C4  6100 2048                859              BSR     PUSH_STACK
000017C8  163C 004D                860              MOVE.B  #'M',D3
000017CC  6100 2040                861              BSR     PUSH_STACK
000017D0  163C 004F                862              MOVE.B  #'O',D3
000017D4  6100 2038                863              BSR     PUSH_STACK
000017D8  163C 0056                864              MOVE.B  #'V',D3
000017DC  6100 2030                865              BSR     PUSH_STACK
000017E0  163C 0045                866              MOVE.B  #'E',D3
000017E4  6100 2028                867              BSR     PUSH_STACK           
000017E8  163C 0041                868              MOVE.B  #'A',D3
000017EC  6100 2020                869              BSR     PUSH_STACK
000017F0  163C 002E                870              MOVE.B  #'.',D3
000017F4  6100 2018                871              BSR     PUSH_STACK
000017F8  163C 0057                872              MOVE.B  #'W',D3
000017FC  6100 2010                873              BSR     PUSH_STACK
00001800                           874              
00001800  6100 176E                875              BSR     GET_EA_EA_SRC
00001804  163C 002C                876              MOVE.B  #',',D3
00001808  6100 2004                877              BSR     PUSH_STACK
0000180C  6100 1B92                878              BSR     GET_EA_EA_DEST
00001810                           879            
00001810  4E75                     880              RTS
00001812                           881  *---------------------------------------------------------------------------*
00001812                           882  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001812                           883  *---------------------------------------------------------------------------*
00001812                           884  OP0100
00001812  4280                     885              CLR.L   D0                      
00001814  4281                     886              CLR.L   D1  
00001816  4284                     887              CLR.L   D4                      
00001818  227C 00000000            888              MOVEA.L #0, A1                  
0000181E  2205                     889              MOVE.L  D5,D1  
00001820                           890              
00001820                           891              * check for RTS
00001820  0C41 4E75                892              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001824  6700 01DA                893              BEQ     OP_RTS
00001828                           894              
00001828                           895              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001828  4281                     896              CLR.L   D1 
0000182A  2205                     897              MOVE.L  D5,D1  
0000182C  0241 0F00                898              ANDI.W  #$0F00,D1
00001830  0C41 0E00                899              CMPI.W  #$0E00,D1
00001834  6700 01B6                900              BEQ     OP_JSR
00001838                           901  
00001838                           902              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001838  4281                     903              CLR.L   D1 
0000183A  2205                     904              MOVE.L  D5,D1  
0000183C  0241 0F00                905              ANDI.W  #$0F00,D1
00001840  0C41 0400                906              CMPI.W  #$0400,D1
00001844  6700 00E8                907              BEQ     OP_NEG
00001848                           908              
00001848                           909              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001848  4281                     910              CLR.L   D1 
0000184A  2205                     911              MOVE.L  D5,D1  
0000184C  0241 0F00                912              ANDI.W  #$0F00,D1
00001850  0C41 0600                913              CMPI.W  #$0600,D1
00001854  6700 0140                914              BEQ     OP_NOT
00001858                           915              
00001858                           916              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001858  4281                     917              CLR.L   D1 
0000185A  2205                     918              MOVE.L  D5,D1  
0000185C  EC99                     919              ROR.L   #6,D1
0000185E  0281 00000007            920              ANDI.L  #7,D1
00001864  0C81 00000007            921              CMPI.L  #7,D1
0000186A  6700 0054                922              BEQ     OP_LEA
0000186E                           923              
0000186E                           924              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
0000186E  4281                     925              CLR.L   D1 
00001870  2205                     926              MOVE.L  D5,D1  
00001872  EB59                     927              ROL.W   #5,D1
00001874  0C01 0001                928              CMPI.B  #1,D1
00001878  6600 FC38                929              BNE     OP_DATA
0000187C  E959                     930              ROL.W   #4,D1
0000187E  0C01 0001                931              CMPI.B  #1,D1
00001882  6600 FC2E                932              BNE     OP_DATA
00001886  E359                     933              ROL.W   #1,D1
00001888  0C01 0000                934              CMPI.B  #0,D1
0000188C  6700 000E                935              BEQ     OP_MOVEM_W
00001890  0C01 0001                936              CMPI.B  #1,D1
00001894  6700 0018                937              BEQ     OP_MOVEM_L
00001898  4EF8 14B2                938              JMP     OP_DATA
0000189C                           939  
0000189C                           940  *---------------------------------------------------------------------------*
0000189C                           941  * OP_MOVEM_W: display MOVEM_W
0000189C                           942  *---------------------------------------------------------------------------*    
0000189C                           943  OP_MOVEM_W  
0000189C  183C 0001                944              MOVE.B  #1,D4
000018A0  43F9 00003EF3            945              LEA     DISP_MOVEM_W,A1
000018A6  103C 000E                946              MOVE.B  #14,D0
000018AA  4E4F                     947              TRAP    #15
000018AC  4E75                     948              RTS
000018AE                           949  
000018AE                           950  *---------------------------------------------------------------------------*
000018AE                           951  * OP_MOVEM_L: display MOVEM_L
000018AE                           952  *---------------------------------------------------------------------------*
000018AE                           953  OP_MOVEM_L  
000018AE  183C 0002                954              MOVE.B  #2,D4
000018B2  43F9 00003EFE            955              LEA     DISP_MOVEM_L,A1
000018B8  103C 000E                956              MOVE.B  #14,D0
000018BC  4E4F                     957              TRAP    #15
000018BE  4E75                     958              RTS
000018C0                           959     
000018C0                           960  *---------------------------------------------------------------------------*
000018C0                           961  * OP_LEA: decode and display LEA
000018C0                           962  *---------------------------------------------------------------------------*
000018C0                           963  OP_LEA      
000018C0  4281                     964               CLR.L   D1       
000018C2  4284                     965              CLR.L   D4                   
000018C4  227C 00000000            966              MOVEA.L #0, A1              
000018CA  2205                     967              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000018CC                           968              *CLEAR D3
000018CC  4283                     969              CLR.L   D3
000018CE                           970  
000018CE                           971  OP_LEA_DN_EA_OR_EA_DN 
000018CE                           972              *LOAD STACK WITH THIS OPMODE
000018CE  6100 1F3E                973              BSR     PUSH_STACK
000018D2  163C 004C                974              MOVE.B  #'L',D3
000018D6  6100 1F36                975              BSR     PUSH_STACK
000018DA  163C 0045                976              MOVE.B  #'E',D3
000018DE  6100 1F2E                977              BSR     PUSH_STACK
000018E2  163C 0041                978              MOVE.B  #'A',D3
000018E6  6100 1F26                979              BSR     PUSH_STACK
000018EA  2205                     980              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000018EC                           981          
000018EC                           982  
000018EC                           983  OP_PRINT_L_LEA
000018EC                           984                          
000018EC                           985              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018EC  13FC 0000 00004134       986              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000018F4  13FC 009B 00004135       987              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000018FC                           988             
000018FC                           989              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000018FC  13FC 00B9 00004137       990              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001904  13FC 0020 00004138       991              MOVE.B   #$20,GET_SRC_START_END
0000190C                           992  
0000190C                           993              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000190C  0285 0000FE3F            994              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001912  0685 00000040            995              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001918                           996  
00001918  6100 1656                997              BSR     GET_EA_EA_SRC      *GETS <ea>
0000191C  163C 002C                998              MOVE.B  #',',D3
00001920  6100 1EEC                999              BSR     PUSH_STACK           
00001924  6100 1A7A               1000              BSR     GET_EA_EA_DEST       *GETS Dn    
00001928                          1001  
00001928                          1002              
00001928  6000 0002               1003              BRA     OP_LEA_RETURN
0000192C                          1004              
0000192C                          1005  OP_LEA_RETURN
0000192C  4E75                    1006              RTS
0000192E                          1007              
0000192E                          1008  
0000192E                          1009  
0000192E                          1010  *---------------------------------------------------------------------------*
0000192E                          1011  * OP_NEG: decode and display NEG 
0000192E                          1012  *---------------------------------------------------------------------------*
0000192E                          1013  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000192E  4281                    1014              CLR.L   D1
00001930  4284                    1015              CLR.L   D4
00001932  2205                    1016              MOVE.L  D5,D1
00001934  EC99                    1017              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001936  0C01 0000               1018              CMPI.B  #0,D1
0000193A  6700 0012               1019              BEQ     OP_NEG_B    * size is byte
0000193E  0C01 0001               1020              CMPI.B  #1,D1
00001942  6700 0022               1021              BEQ     OP_NEG_W    * size is word
00001946  0C01 0002               1022              CMPI.B  #2,D1
0000194A  6700 0032               1023              BEQ     OP_NEG_L    * size is long
0000194E                          1024                         
0000194E                          1025  OP_NEG_B    * size is byte   
0000194E  183C 0000               1026              MOVE.B  #0,D4 
00001952  43F9 00003EB6           1027              LEA     DISP_NEG_B,A1
00001958  103C 000E               1028              MOVE.B  #14,D0
0000195C  4E4F                    1029              TRAP    #15
0000195E                          1030              
0000195E  4EB9 00002AC0           1031              JSR     EA_NOSRC
00001964  4E75                    1032              RTS
00001966                          1033              
00001966                          1034  OP_NEG_W    * size is word
00001966  183C 0001               1035              MOVE.B  #1,D4
0000196A  43F9 00003EBF           1036              LEA     DISP_NEG_W,A1
00001970  103C 000E               1037              MOVE.B  #14,D0
00001974  4E4F                    1038              TRAP    #15
00001976  4EB9 00002AC0           1039              JSR     EA_NOSRC
0000197C  4E75                    1040              RTS
0000197E                          1041              
0000197E                          1042  OP_NEG_L    * size is long
0000197E  183C 0002               1043              MOVE.B  #2,D4
00001982  43F9 00003EC8           1044              LEA     DISP_NEG_L,A1
00001988  103C 000E               1045              MOVE.B  #14,D0
0000198C  4E4F                    1046              TRAP    #15
0000198E  4EB9 00002AC0           1047              JSR     EA_NOSRC
00001994                          1048              
00001994  4E75                    1049              RTS
00001996                          1050  
00001996                          1051  *---------------------------------------------------------------------------*
00001996                          1052  * OP_NOT: decode and display NOT 
00001996                          1053  *---------------------------------------------------------------------------*
00001996                          1054  OP_NOT
00001996  4281                    1055              CLR.L   D1
00001998  4284                    1056              CLR.L   D4
0000199A  2205                    1057              MOVE.L  D5,D1
0000199C  EC99                    1058              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000199E  0C01 0000               1059              CMPI.B  #0,D1
000019A2  6700 0012               1060              BEQ     OP_NOT_B    * size is byte
000019A6  0C01 0001               1061              CMPI.B  #1,D1
000019AA  6700 001C               1062              BEQ     OP_NOT_W    * size is word
000019AE  0C01 0002               1063              CMPI.B  #2,D1
000019B2  6700 0026               1064              BEQ     OP_NOT_L    * size is long
000019B6                          1065                         
000019B6                          1066  OP_NOT_B    * size is byte   
000019B6  183C 0000               1067              MOVE.B  #0,D4 
000019BA  43F9 00003ED1           1068              LEA     DISP_NOT_B,A1
000019C0  103C 000E               1069              MOVE.B  #14,D0
000019C4  4E4F                    1070              TRAP    #15
000019C6  4E75                    1071              RTS
000019C8                          1072              
000019C8                          1073  OP_NOT_W    * size is word
000019C8  183C 0001               1074              MOVE.B  #1,D4
000019CC  43F9 00003EDA           1075              LEA     DISP_NOT_W,A1
000019D2  103C 000E               1076              MOVE.B  #14,D0
000019D6  4E4F                    1077              TRAP    #15
000019D8  4E75                    1078              RTS
000019DA                          1079              
000019DA                          1080  OP_NOT_L    * size is long
000019DA  183C 0002               1081              MOVE.B  #2,D4
000019DE  43F9 00003EE3           1082              LEA     DISP_NOT_L,A1
000019E4  103C 000E               1083              MOVE.B  #14,D0
000019E8  4E4F                    1084              TRAP    #15
000019EA  4E75                    1085              RTS
000019EC                          1086  
000019EC                          1087  *---------------------------------------------------------------------------*
000019EC                          1088  * OP_JSR: display JSR     
000019EC                          1089  *---------------------------------------------------------------------------*
000019EC  43F9 00003EAF           1090  OP_JSR      LEA     DISP_JSR,A1
000019F2  103C 000E               1091              MOVE.B  #14,D0
000019F6  4E4F                    1092              TRAP    #15
000019F8  4EB9 00002AC0           1093              JSR     EA_NOSRC
000019FE                          1094  
000019FE  4E75                    1095              RTS
00001A00                          1096  
00001A00                          1097  *---------------------------------------------------------------------------*
00001A00                          1098  * OP_RTS: display RTS     
00001A00                          1099  *---------------------------------------------------------------------------* 
00001A00  43F9 00003EA8           1100  OP_RTS      LEA     DISP_RTS,A1
00001A06  103C 000E               1101              MOVE.B  #14,D0
00001A0A  4E4F                    1102              TRAP    #15
00001A0C  4E75                    1103              RTS
00001A0E                          1104  
00001A0E                          1105  *---------------------------------------------------------------------------*
00001A0E                          1106  * OP0101: decode ADDQ
00001A0E                          1107  *---------------------------------------------------------------------------* 
00001A0E  4280                    1108  OP0101      CLR.L   D0               * clear registers for temp storage       
00001A10  4281                    1109              CLR.L   D1
00001A12  4284                    1110              CLR.L   D4                  
00001A14  227C 00000000           1111              MOVEA.L #0, A1  
00001A1A                          1112              
00001A1A  2205                    1113              MOVE.L  D5,D1           * copy the processing data 
00001A1C  E089                    1114              LSR.L   #8,D1           * shift to right by 8 bits to check the value of bit 8
00001A1E  0201 0001               1115              ANDI.B  #$1,D1          * mask all bits except the last 2 bits
00001A22  0C01 0000               1116              CMPI.B  #0,D1           * if the value is 0, it's ADDQ
00001A26  6700 0006               1117              BEQ     OP_ADDQ
00001A2A                          1118              
00001A2A  4EF8 14B2               1119              JMP     OP_DATA
00001A2E                          1120       
00001A2E  4281                    1121  OP_ADDQ     CLR.L   D1
00001A30  2205                    1122              MOVE.L  D5,D1
00001A32  EC99                    1123              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001A34  0281 00000003           1124              ANDI.L  #$3,D1
00001A3A  0C01 0000               1125              CMPI.B  #0,D1
00001A3E  6700 0014               1126              BEQ     OP_ADDQ_B    * size is byte
00001A42  0C41 0001               1127              CMPI.W  #1,D1
00001A46  6700 001E               1128              BEQ     OP_ADDQ_W    * size is word
00001A4A  0C81 00000002           1129              CMPI.L  #2,D1
00001A50  6700 0026               1130              BEQ     OP_ADDQ_L    * size is long
00001A54                          1131              
00001A54                          1132  *---------------------------------------------------------------------------*
00001A54                          1133  * OP_ADDQ: display ADDQ
00001A54                          1134  *---------------------------------------------------------------------------*              
00001A54                          1135  OP_ADDQ_B    * size is byte   
00001A54  183C 0000               1136              MOVE.B  #0,D4 
00001A58  43F9 00003F09           1137              LEA     DISP_ADDQ_B,A1
00001A5E  103C 000E               1138              MOVE.B  #14,D0
00001A62  4E4F                    1139              TRAP    #15
00001A64  4E75                    1140              RTS
00001A66                          1141              
00001A66                          1142  OP_ADDQ_W    * size is word
00001A66  183C 0001               1143              MOVE.B  #1,D4
00001A6A  43F9 00003F13           1144              LEA     DISP_ADDQ_W,A1
00001A70  103C 000E               1145              MOVE.B  #14,D0
00001A74  4E4F                    1146              TRAP    #15
00001A76  4E75                    1147              RTS
00001A78                          1148              
00001A78                          1149  OP_ADDQ_L    * size is long
00001A78  183C 0002               1150              MOVE.B  #2,D4
00001A7C  43F9 00003F1D           1151              LEA     DISP_ADDQ_L,A1
00001A82  103C 000E               1152              MOVE.B  #14,D0
00001A86  4E4F                    1153              TRAP    #15
00001A88  4E75                    1154              RTS
00001A8A                          1155  
00001A8A                          1156  *---------------------------------------------------------------------------*
00001A8A                          1157  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001A8A                          1158  *---------------------------------------------------------------------------*              
00001A8A  4280                    1159  OP0110      CLR.L   D0                  
00001A8C  4281                    1160              CLR.L   D1   
00001A8E  4284                    1161              CLR.L   D4                 
00001A90  227C 00000000           1162              MOVEA.L #0,A1
00001A96  2205                    1163              MOVE.L  D5, D1                
00001A98  0281 000000FF           1164              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001A9E  2205                    1165              MOVE.L  D5,D1                  
00001AA0  0281 00000F00           1166              ANDI.L  #$0F00,D1
00001AA6                          1167                 
00001AA6  0C41 0000               1168              CMPI.W  #$0000,D1               * Check for BRA
00001AAA  6700 0050               1169              BEQ     OP_BRA                  
00001AAE                          1170                          
00001AAE  0C41 0D00               1171              CMPI.W  #$0D00,D1               * Check for BLT
00001AB2  6700 0056               1172              BEQ     OP_BLT      
00001AB6                          1173  
00001AB6  0C41 0700               1174              CMPI.W  #$0700,D1               * Check for BEQ
00001ABA  6700 0032               1175              BEQ     OP_BEQ      
00001ABE                          1176  
00001ABE  0C41 0600               1177              CMPI.W  #$0600,D1               * Check for BNE
00001AC2  6700 001C               1178              BEQ     OP_BNE  
00001AC6                          1179              
00001AC6  0C41 0200               1180              CMPI.W  #$0200,D1               * Check for BHI
00001ACA  6700 0006               1181              BEQ     OP_BHI
00001ACE                          1182  
00001ACE  4EF8 14B2               1183              JMP     OP_DATA
00001AD2                          1184              
00001AD2  43F9 000040D8           1185  OP_BHI      LEA     DISP_BHI,A1             
00001AD8  103C 000E               1186              MOVE.B  #14,D0
00001ADC  4E4F                    1187              TRAP    #15
00001ADE  4E75                    1188              RTS
00001AE0                          1189  
00001AE0  43F9 000040D1           1190  OP_BNE      LEA     DISP_BNE,A1             
00001AE6  103C 000E               1191              MOVE.B  #14,D0
00001AEA  4E4F                    1192              TRAP    #15
00001AEC  4E75                    1193              RTS
00001AEE                          1194  
00001AEE  43F9 000040CA           1195  OP_BEQ      LEA     DISP_BEQ,A1             
00001AF4  103C 000E               1196              MOVE.B  #14,D0
00001AF8  4E4F                    1197              TRAP    #15
00001AFA  4E75                    1198              RTS          
00001AFC                          1199                          
00001AFC  43F9 000040BC           1200  OP_BRA      LEA     DISP_BRA,A1             
00001B02  103C 000E               1201              MOVE.B  #14,D0
00001B06  4E4F                    1202              TRAP    #15
00001B08  4E75                    1203              RTS
00001B0A                          1204              
00001B0A  43F9 000040C3           1205  OP_BLT      LEA     DISP_BLT,A1          
00001B10  103C 000E               1206              MOVE.B  #14,D0
00001B14  4E4F                    1207              TRAP    #15
00001B16  4E75                    1208              RTS
00001B18                          1209     
00001B18                          1210  *---------------------------------------------------------------------------*
00001B18                          1211  * OP0111 : MOVEQ not required
00001B18                          1212  *---------------------------------------------------------------------------*           
00001B18  4EF8 14B2               1213  OP0111      JMP     OP_DATA
00001B1C                          1214             
00001B1C                          1215  *---------------------------------------------------------------------------*
00001B1C                          1216  * OP1000 : decode DIVS
00001B1C                          1217  *---------------------------------------------------------------------------*           
00001B1C                          1218  OP1000                           
00001B1C  4281                    1219              CLR.L   D1       
00001B1E  4284                    1220              CLR.L   D4                   
00001B20  227C 00000000           1221              MOVEA.L #0, A1              
00001B26  2205                    1222              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001B28                          1223              *CLEAR D3
00001B28  4283                    1224              CLR.L   D3
00001B2A                          1225  
00001B2A                          1226  OP1000_DIVS_DN_EA_OR_EA_DN 
00001B2A                          1227              *LOAD STACK WITH THIS OPMODE
00001B2A  6100 1CE2               1228              BSR     PUSH_STACK
00001B2E  163C 0044               1229              MOVE.B  #'D',D3
00001B32  6100 1CDA               1230              BSR     PUSH_STACK
00001B36  163C 0049               1231              MOVE.B  #'I',D3
00001B3A  6100 1CD2               1232              BSR     PUSH_STACK
00001B3E  163C 0056               1233              MOVE.B  #'V',D3
00001B42  6100 1CCA               1234              BSR     PUSH_STACK
00001B46  163C 0053               1235              MOVE.B  #'S',D3
00001B4A  6100 1CC2               1236              BSR     PUSH_STACK
00001B4E  163C 002E               1237              MOVE.B  #'.',D3
00001B52  6100 1CBA               1238              BSR     PUSH_STACK
00001B56                          1239              
00001B56  2205                    1240              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001B58                          1241              
00001B58                          1242  OP1000_EA_DN_DIVS
00001B58                          1243              *BITS (7 TO 6) 
00001B58                          1244              *00 = .B
00001B58                          1245              *01 = .W
00001B58                          1246              *10 = .L 
00001B58  2205                    1247              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001B5A  EC99                    1248              ROR.L   #6,D1
00001B5C  0281 00000003           1249              ANDI.L  #$03,D1
00001B62  0C81 00000003           1250              CMPI.L  #%11,D1 *EQUALS .W
00001B68  6700 0014               1251              BEQ     OP1000_PRINT_W_DIVS
00001B6C  0C81 00000000           1252              CMPI.L  #%00,D1 *EQUALS .L
00001B72  6700 0052               1253              BEQ     OP1000_PRINT_L_DIVS
00001B76                          1254              
00001B76  183C 0001               1255              MOVE.B  #1,D4               *ERROR READ
00001B7A  6000 0092               1256              BRA     OP1000_DIVS_RETURN
00001B7E                          1257  OP1000_PRINT_W_DIVS
00001B7E  163C 0057               1258              MOVE.B  #'W',D3
00001B82  6100 1C8A               1259              BSR     PUSH_STACK
00001B86                          1260  
00001B86                          1261              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B86  13FC 0000 00004134      1262              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B8E  13FC 0000 00004135      1263              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B96                          1264             
00001B96                          1265              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B96  13FC 00B9 00004137      1266              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B9E  13FC 0020 00004138      1267              MOVE.B   #$20,GET_SRC_START_END
00001BA6                          1268  
00001BA6                          1269             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001BA6  0285 0000FE3F           1270              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001BAC  0685 00000000           1271              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001BB2                          1272  
00001BB2                          1273              
00001BB2  6100 13BC               1274              BSR     GET_EA_EA_SRC      *GETS <ea>
00001BB6  163C 002C               1275              MOVE.B  #',',D3
00001BBA  6100 1C52               1276              BSR     PUSH_STACK
00001BBE  6100 17E0               1277              BSR     GET_EA_EA_DEST       *GETS Dn    
00001BC2                          1278              
00001BC2  6000 004A               1279              BRA     OP1000_DIVS_RETURN
00001BC6                          1280  OP1000_PRINT_L_DIVS
00001BC6  163C 004C               1281              MOVE.B  #'L',D3
00001BCA  6100 1C42               1282              BSR     PUSH_STACK
00001BCE                          1283              
00001BCE                          1284              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001BCE  13FC 0000 00004134      1285              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001BD6  13FC 0000 00004135      1286              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001BDE                          1287             
00001BDE                          1288              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001BDE  13FC 00B9 00004137      1289              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001BE6  13FC 0020 00004138      1290              MOVE.B   #$20,GET_SRC_START_END
00001BEE                          1291  
00001BEE                          1292              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001BEE  0285 0000FE3F           1293              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001BF4  0685 00000000           1294              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001BFA                          1295  
00001BFA                          1296                     
00001BFA  6100 1374               1297              BSR     GET_EA_EA_SRC      *GETS <ea>
00001BFE  163C 002C               1298              MOVE.B  #',',D3
00001C02  6100 1C0A               1299              BSR     PUSH_STACK                  
00001C06  6100 1798               1300              BSR     GET_EA_EA_DEST       *GETS Dn    
00001C0A                          1301  
00001C0A                          1302              
00001C0A  6000 0002               1303              BRA     OP1000_DIVS_RETURN
00001C0E                          1304              
00001C0E                          1305  OP1000_DIVS_RETURN
00001C0E  4E75                    1306              RTS
00001C10                          1307              
00001C10                          1308  
00001C10                          1309  
00001C10                          1310  *---------------------------------------------------------------------------*
00001C10                          1311  * OP_DIVS: display DIVS and proceed to EA
00001C10                          1312  *---------------------------------------------------------------------------*  
00001C10  43F9 00003F27           1313  OP_DIVS     LEA     DISP_DIVS,A1
00001C16  103C 000E               1314              MOVE.B  #14,D0
00001C1A  4E4F                    1315              TRAP    #15
00001C1C  4EF9 00002AD4           1316              JMP     EA_ARITH
00001C22                          1317  
00001C22  4E75                    1318              RTS
00001C24                          1319              
00001C24                          1320  *---------------------------------------------------------------------------*
00001C24                          1321  * OP1001: decode SUB/SUBA
00001C24                          1322  *---------------------------------------------------------------------------*      
00001C24                          1323  OP1001      
00001C24  4280                    1324              CLR.L   D0                  
00001C26  4281                    1325              CLR.L   D1       
00001C28  4284                    1326              CLR.L   D4                   
00001C2A  227C 00000000           1327              MOVEA.L #0, A1              
00001C30  2205                    1328              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C32                          1329              
00001C32                          1330              *CLEAR D3
00001C32  4283                    1331              CLR.L   D3
00001C34                          1332              
00001C34                          1333              
00001C34                          1334              
00001C34                          1335              **INTEGRATING SUB.W/.L INTO THIS CODE**
00001C34  2205                    1336              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001C36                          1337              *BITS (INDEX 8) 
00001C36                          1338              *0 = ADD.B/W/L <EA>,Dn
00001C36                          1339              *1 = ADD.B/W/L Dn,<EA> 
00001C36  EC99                    1340              ROR.L   #6,D1
00001C38  0281 00000007           1341              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001C3E  0C81 00000007           1342              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001C44  6700 0010               1343              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001C48  0C81 00000003           1344              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001C4E  6700 0078               1345              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001C52  6000 00E6               1346              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001C56                          1347              
00001C56                          1348  OP1001_SUBA_L
00001C56                          1349              *LOAD STACK WITH THIS OPMODE
00001C56  6100 1BB6               1350              BSR     PUSH_STACK
00001C5A  163C 0053               1351              MOVE.B  #'S',D3
00001C5E  6100 1BAE               1352              BSR     PUSH_STACK
00001C62  163C 0055               1353              MOVE.B  #'U',D3
00001C66  6100 1BA6               1354              BSR     PUSH_STACK
00001C6A  163C 0042               1355              MOVE.B  #'B',D3
00001C6E  6100 1B9E               1356              BSR     PUSH_STACK
00001C72  163C 0041               1357              MOVE.B  #'A',D3
00001C76  6100 1B96               1358              BSR     PUSH_STACK
00001C7A  163C 002E               1359              MOVE.B  #'.',D3
00001C7E  6100 1B8E               1360              BSR     PUSH_STACK
00001C82  163C 004C               1361              MOVE.B  #'L',D3
00001C86  6100 1B86               1362              BSR     PUSH_STACK
00001C8A                          1363              
00001C8A                          1364             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C8A  13FC 0000 00004134      1365             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C92  13FC 0000 00004135      1366             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C9A                          1367             
00001C9A                          1368             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C9A  13FC 00B9 00004137      1369             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CA2  13FC 0020 00004138      1370             MOVE.B   #$20,GET_SRC_START_END
00001CAA                          1371  
00001CAA                          1372              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CAA  0285 0000FE3F           1373              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CB0  0685 00000040           1374              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001CB6                          1375       
00001CB6                          1376              *PRINT <EA>,AN
00001CB6  6100 12B8               1377              BSR     GET_EA_EA_SRC       *GETS <ea>
00001CBA  163C 002C               1378              MOVE.B  #',',D3
00001CBE  6100 1B4E               1379              BSR     PUSH_STACK                     
00001CC2  6100 16DC               1380              BSR     GET_EA_EA_DEST      *GETS Dn
00001CC6                          1381  
00001CC6                          1382              
00001CC6                          1383              
00001CC6  4E75                    1384              RTS
00001CC8                          1385  OP1001_SUBA_W
00001CC8                          1386              *LOAD STACK WITH THIS OPMODE
00001CC8  6100 1B44               1387              BSR     PUSH_STACK
00001CCC  163C 0053               1388              MOVE.B  #'S',D3
00001CD0  6100 1B3C               1389              BSR     PUSH_STACK
00001CD4  163C 0055               1390              MOVE.B  #'U',D3
00001CD8  6100 1B34               1391              BSR     PUSH_STACK
00001CDC  163C 0042               1392              MOVE.B  #'B',D3
00001CE0  6100 1B2C               1393              BSR     PUSH_STACK
00001CE4  163C 0041               1394              MOVE.B  #'A',D3
00001CE8  6100 1B24               1395              BSR     PUSH_STACK
00001CEC  163C 002E               1396              MOVE.B  #'.',D3
00001CF0  6100 1B1C               1397              BSR     PUSH_STACK
00001CF4  163C 0057               1398              MOVE.B  #'W',D3
00001CF8  6100 1B14               1399              BSR     PUSH_STACK
00001CFC                          1400              
00001CFC                          1401             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CFC  13FC 0000 00004134      1402             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D04  13FC 0000 00004135      1403             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D0C                          1404             
00001D0C                          1405             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D0C  13FC 00B9 00004137      1406             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D14  13FC 0020 00004138      1407             MOVE.B   #$20,GET_SRC_START_END
00001D1C                          1408  
00001D1C                          1409              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D1C  0285 0000FE3F           1410              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D22  0685 00000040           1411              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001D28                          1412       
00001D28                          1413              *PRINT <EA>,AN
00001D28  6100 1246               1414              BSR     GET_EA_EA_SRC       *GETS <ea>
00001D2C  163C 002C               1415              MOVE.B  #',',D3
00001D30  6100 1ADC               1416              BSR     PUSH_STACK                     
00001D34  6100 166A               1417              BSR     GET_EA_EA_DEST      *GETS Dn
00001D38                          1418  
00001D38  4E75                    1419              RTS
00001D3A                          1420  
00001D3A                          1421  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001D3A                          1422              *LOAD STACK WITH THIS OPMODE
00001D3A  6100 1AD2               1423              BSR     PUSH_STACK
00001D3E  163C 0053               1424              MOVE.B  #'S',D3
00001D42  6100 1ACA               1425              BSR     PUSH_STACK
00001D46  163C 0055               1426              MOVE.B  #'U',D3
00001D4A  6100 1AC2               1427              BSR     PUSH_STACK
00001D4E  163C 0042               1428              MOVE.B  #'B',D3
00001D52  6100 1ABA               1429              BSR     PUSH_STACK
00001D56  163C 002E               1430              MOVE.B  #'.',D3
00001D5A  6100 1AB2               1431              BSR     PUSH_STACK
00001D5E                          1432              
00001D5E  2205                    1433              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001D60                          1434              
00001D60                          1435              *BITS (INDEX 8) 
00001D60                          1436              *0 = ADD.B/W/L <EA>,Dn
00001D60                          1437              *1 = ADD.B/W/L Dn,<EA> 
00001D60  E099                    1438              ROR.L   #8,D1
00001D62  0281 00000001           1439              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001D68  0C81 00000000           1440              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001D6E  6700 0102               1441              BEQ     OP1001_EA_DN
00001D72                          1442              *else procede to Dn_EA
00001D72                          1443              
00001D72                          1444  OP1001_DN_EA
00001D72                          1445              *BITS (7 TO 6) 
00001D72                          1446              *00 = .B
00001D72                          1447              *01 = .W
00001D72                          1448              *10 = .L 
00001D72  2205                    1449              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001D74  EC99                    1450              ROR.L   #6,D1
00001D76  0281 00000003           1451              ANDI.L  #$03,D1
00001D7C  0C81 00000000           1452              CMPI.L  #$00,D1 *EQUALS .B
00001D82  6700 0016               1453              BEQ     OP1001_PRINT_B2
00001D86  0C81 00000001           1454              CMPI.L  #$01,D1 *EQUALS .W
00001D8C  6700 0054               1455              BEQ     OP1001_PRINT_W2
00001D90  0C81 00000002           1456              CMPI.L  #$02,D1 *EQUALS .L
00001D96  6700 0092               1457              BEQ     OP1001_PRINT_L2
00001D9A                          1458  OP1001_PRINT_B2
00001D9A                          1459              *PUSH 'B'
00001D9A  163C 0042               1460              MOVE.B  #'B',D3
00001D9E  6100 1A6E               1461              BSR     PUSH_STACK
00001DA2                          1462             
00001DA2                          1463              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DA2  13FC 0000 00004134      1464             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001DAA  13FC 0083 00004135      1465             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001DB2                          1466             
00001DB2                          1467             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DB2  13FC 00B9 00004137      1468             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DBA  13FC 0020 00004138      1469             MOVE.B   #$20,GET_SRC_START_END
00001DC2                          1470  
00001DC2                          1471              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DC2  0285 0000FE3F           1472              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DC8  0685 00000040           1473              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001DCE                          1474       
00001DCE  6100 15D0               1475              BSR     GET_EA_EA_DEST      *GETS Dn
00001DD2  163C 002C               1476              MOVE.B  #',',D3
00001DD6  6100 1A36               1477              BSR     PUSH_STACK                     
00001DDA  6100 1194               1478              BSR     GET_EA_EA_SRC       *GETS <ea>
00001DDE                          1479  
00001DDE                          1480              
00001DDE  6000 09A0               1481              BRA     OP1101_ADD_RETURN
00001DE2                          1482  OP1001_PRINT_W2
00001DE2  163C 0057               1483              MOVE.B  #'W',D3
00001DE6  6100 1A26               1484              BSR     PUSH_STACK
00001DEA                          1485  
00001DEA                          1486              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DEA  13FC 0000 00004134      1487              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001DF2  13FC 0083 00004135      1488              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001DFA                          1489             
00001DFA                          1490              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DFA  13FC 00B9 00004137      1491              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E02  13FC 0020 00004138      1492              MOVE.B   #$20,GET_SRC_START_END
00001E0A                          1493  
00001E0A                          1494              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E0A  0285 0000FE3F           1495              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E10  0685 00000040           1496              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001E16                          1497  
00001E16                          1498        
00001E16  6100 1588               1499              BSR     GET_EA_EA_DEST      *GETS Dn
00001E1A  163C 002C               1500              MOVE.B  #',',D3
00001E1E  6100 19EE               1501              BSR     PUSH_STACK               
00001E22  6100 114C               1502              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001E26                          1503  
00001E26                          1504  
00001E26                          1505  
00001E26  6000 0958               1506              BRA     OP1101_ADD_RETURN
00001E2A                          1507  OP1001_PRINT_L2 
00001E2A  163C 004C               1508              MOVE.B  #'L',D3
00001E2E  6100 19DE               1509              BSR     PUSH_STACK
00001E32                          1510              
00001E32                          1511              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E32  13FC 0000 00004134      1512              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E3A  13FC 0083 00004135      1513              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E42                          1514             
00001E42                          1515              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E42  13FC 00B9 00004137      1516              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E4A  13FC 0020 00004138      1517              MOVE.B   #$20,GET_SRC_START_END
00001E52                          1518  
00001E52                          1519             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E52  0285 0000FE3F           1520              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E58  0685 00000040           1521              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E5E                          1522  
00001E5E                          1523               
00001E5E  6100 1540               1524              BSR     GET_EA_EA_DEST       *GETS Dn
00001E62  163C 002C               1525              MOVE.B  #',',D3
00001E66  6100 19A6               1526              BSR     PUSH_STACK          
00001E6A  6100 1104               1527              BSR     GET_EA_EA_SRC        *GETS <ea>
00001E6E                          1528  
00001E6E  6000 0910               1529              BRA     OP1101_ADD_RETURN
00001E72                          1530              
00001E72                          1531  OP1001_EA_DN           
00001E72                          1532              *BITS (7 TO 6) 
00001E72                          1533              *00 = .B
00001E72                          1534              *01 = .W
00001E72                          1535              *10 = .L 
00001E72  2205                    1536              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001E74  EC99                    1537              ROR.L   #6,D1
00001E76  0281 00000003           1538              ANDI.L  #$03,D1
00001E7C  0C81 00000000           1539              CMPI.L  #$00,D1 *EQUALS .B
00001E82  6700 0016               1540              BEQ     OP1001_PRINT_B
00001E86  0C81 00000001           1541              CMPI.L  #$01,D1 *EQUALS .W
00001E8C  6700 0054               1542              BEQ     OP1001_PRINT_W
00001E90  0C81 00000002           1543              CMPI.L  #$02,D1 *EQUALS .L
00001E96  6700 0092               1544              BEQ     OP1001_PRINT_L
00001E9A                          1545  OP1001_PRINT_B
00001E9A  163C 0042               1546              MOVE.B  #'B',D3
00001E9E  6100 196E               1547              BSR     PUSH_STACK
00001EA2                          1548                
00001EA2                          1549              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001EA2  13FC 0000 00004134      1550              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001EAA  13FC 0002 00004135      1551              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001EB2                          1552             
00001EB2                          1553              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001EB2  13FC 00B9 00004137      1554              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001EBA  13FC 0020 00004138      1555              MOVE.B   #$20,GET_SRC_START_END
00001EC2                          1556  
00001EC2                          1557             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001EC2  0285 0000FE3F           1558              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001EC8  0685 00000040           1559              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00001ECE                          1560  
00001ECE                          1561              
00001ECE  6100 10A0               1562              BSR     GET_EA_EA_SRC      *GETS <ea>
00001ED2  163C 002C               1563              MOVE.B  #',',D3
00001ED6  6100 1936               1564              BSR     PUSH_STACK          
00001EDA  6100 14C4               1565              BSR     GET_EA_EA_DEST       *GETS Dn
00001EDE                          1566              
00001EDE  6000 08A0               1567              BRA     OP1101_ADD_RETURN
00001EE2                          1568  OP1001_PRINT_W
00001EE2  163C 0057               1569              MOVE.B  #'W',D3
00001EE6  6100 1926               1570              BSR     PUSH_STACK
00001EEA                          1571  
00001EEA                          1572              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001EEA  13FC 0000 00004134      1573              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001EF2  13FC 0000 00004135      1574              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001EFA                          1575             
00001EFA                          1576              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001EFA  13FC 00B9 00004137      1577              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F02  13FC 0020 00004138      1578              MOVE.B   #$20,GET_SRC_START_END
00001F0A                          1579  
00001F0A                          1580             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F0A  0285 0000FE3F           1581              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F10  0685 00000040           1582              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001F16                          1583  
00001F16                          1584              
00001F16  6100 1058               1585              BSR     GET_EA_EA_SRC      *GETS <ea>
00001F1A  163C 002C               1586              MOVE.B  #',',D3
00001F1E  6100 18EE               1587              BSR     PUSH_STACK
00001F22  6100 147C               1588              BSR     GET_EA_EA_DEST       *GETS Dn    
00001F26                          1589              
00001F26  6000 004A               1590              BRA     OP1001_ADD_RETURN
00001F2A                          1591  OP1001_PRINT_L 
00001F2A  163C 004C               1592              MOVE.B  #'L',D3
00001F2E  6100 18DE               1593              BSR     PUSH_STACK
00001F32                          1594              
00001F32                          1595              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F32  13FC 0000 00004134      1596              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F3A  13FC 0000 00004135      1597              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F42                          1598             
00001F42                          1599              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F42  13FC 00B9 00004137      1600              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F4A  13FC 0020 00004138      1601              MOVE.B   #$20,GET_SRC_START_END
00001F52                          1602  
00001F52                          1603              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F52  0285 0000FE3F           1604              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F58  0685 00000040           1605              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001F5E                          1606  
00001F5E                          1607                     
00001F5E  6100 1010               1608              BSR     GET_EA_EA_SRC      *GETS <ea>
00001F62  163C 002C               1609              MOVE.B  #',',D3
00001F66  6100 18A6               1610              BSR     PUSH_STACK                  
00001F6A  6100 1434               1611              BSR     GET_EA_EA_DEST       *GETS Dn    
00001F6E                          1612  
00001F6E                          1613              
00001F6E  6000 0002               1614              BRA     OP1001_ADD_RETURN
00001F72                          1615              
00001F72                          1616  OP1001_ADD_RETURN
00001F72  4E75                    1617              RTS
00001F74                          1618  
00001F74                          1619    
00001F74                          1620  *---------------------------------------------------------------------------*
00001F74                          1621  * OP_SUB: display SUB and proceed to EA
00001F74                          1622  *---------------------------------------------------------------------------*            
00001F74  43F9 00003F2F           1623  OP_SUB_B    LEA     DISP_SUB_B,A1
00001F7A  103C 000E               1624              MOVE.B  #14,D0
00001F7E  4E4F                    1625              TRAP    #15
00001F80  183C 0000               1626              MOVE.B  #0,D4
00001F84  4EF9 00002B20           1627              JMP     EA_GEN
00001F8A                          1628  
00001F8A  4E75                    1629              RTS
00001F8C                          1630  
00001F8C  43F9 00003F38           1631  OP_SUB_W    LEA     DISP_SUB_W,A1
00001F92  103C 000E               1632              MOVE.B  #14,D0
00001F96  4E4F                    1633              TRAP    #15
00001F98  183C 0001               1634              MOVE.B  #1,D4
00001F9C  4EF9 00002B20           1635              JMP     EA_GEN
00001FA2                          1636  
00001FA2  4E75                    1637              RTS
00001FA4                          1638  
00001FA4  43F9 00003F41           1639  OP_SUB_L    LEA     DISP_SUB_L,A1
00001FAA  103C 000E               1640              MOVE.B  #14,D0
00001FAE  4E4F                    1641              TRAP    #15
00001FB0  183C 0002               1642              MOVE.B  #2,D4
00001FB4  4EF9 00002B20           1643              JMP     EA_GEN
00001FBA                          1644  
00001FBA  4E75                    1645              RTS
00001FBC                          1646  
00001FBC                          1647  *---------------------------------------------------------------------------*
00001FBC                          1648  * OP_SUBA: display SUBA
00001FBC                          1649  *---------------------------------------------------------------------------*  
00001FBC  43F9 00003F68           1650  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00001FC2  103C 000E               1651              MOVE.B  #14,D0
00001FC6  4E4F                    1652              TRAP    #15
00001FC8  183C 0001               1653              MOVE.B  #1,D4
00001FCC  4E75                    1654              RTS
00001FCE                          1655  
00001FCE  43F9 00003F72           1656  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00001FD4  103C 000E               1657              MOVE.B  #14,D0
00001FD8  4E4F                    1658              TRAP    #15
00001FDA  183C 0002               1659              MOVE.B  #2,D4
00001FDE  4E75                    1660              RTS         
00001FE0                          1661  *---------------------------------------------------------------------------*
00001FE0                          1662  * OP1010 : unassigned
00001FE0                          1663  *---------------------------------------------------------------------------*           
00001FE0  4EF8 14B2               1664  OP1010      JMP     OP_DATA
00001FE4                          1665              
00001FE4                          1666  *---------------------------------------------------------------------------*
00001FE4                          1667  * OP1011 : decode CMP/EOR/CMPA
00001FE4                          1668  *---------------------------------------------------------------------------*           
00001FE4  4280                    1669  OP1011      CLR.L   D0                
00001FE6  4281                    1670              CLR.L   D1            
00001FE8  4284                    1671              CLR.L   D4                   
00001FEA  227C 00000000           1672              MOVEA.L #0, A1               
00001FF0  2205                    1673              MOVE.L  D5,D1
00001FF2  EA99                    1674              ROR.L   #5,D1
00001FF4  0281 0000000E           1675              ANDI.L  #$E,D1
00001FFA  0C01 0000               1676              CMPI.B  #$0,D1
00001FFE  6700 0062               1677              BEQ     OP_CMP_B
00002002  0C01 0002               1678              CMPI.B  #$2,D1
00002006  6700 0072               1679              BEQ     OP_CMP_W
0000200A  0C01 0004               1680              CMPI.B  #$4,D1
0000200E  6700 0082               1681              BEQ     OP_CMP_L
00002012  0C01 0008               1682              CMPI.B  #$8,D1
00002016  6700 0092               1683              BEQ     OP_EOR_B
0000201A  0C01 000A               1684              CMPI.B  #$A,D1
0000201E  6700 009C               1685              BEQ     OP_EOR_W
00002022  0C01 000C               1686              CMPI.B  #$C,D1
00002026  6700 00A6               1687              BEQ     OP_EOR_L  
0000202A  0C01 0006               1688              CMPI.B  #$6,D1
0000202E  6700 000E               1689              BEQ     OP_CMPA_W
00002032  0C01 000E               1690              CMPI.B  #$E,D1
00002036  6700 0018               1691              BEQ     OP_CMPA_L 
0000203A                          1692  
0000203A  4EF8 14B2               1693              JMP     OP_DATA          
0000203E                          1694  
0000203E                          1695  *---------------------------------------------------------------------------*
0000203E                          1696  * OP_CMPA: display CMPA 
0000203E                          1697  *---------------------------------------------------------------------------
0000203E  43F9 00003FB2           1698  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00002044  103C 000E               1699              MOVE.B  #14,D0
00002048  4E4F                    1700              TRAP    #15
0000204A  183C 0001               1701              MOVE.B  #1,D4
0000204E  4E75                    1702              RTS
00002050                          1703  
00002050  43F9 00003FBC           1704  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002056  103C 000E               1705              MOVE.B  #14,D0
0000205A  4E4F                    1706              TRAP    #15
0000205C  183C 0002               1707              MOVE.B  #2,D4
00002060  4E75                    1708              RTS
00002062                          1709  
00002062                          1710  *---------------------------------------------------------------------------*
00002062                          1711  * OP_CMP: display CMP and proceed to EA
00002062                          1712  *---------------------------------------------------------------------------*  
00002062  43F9 00003F97           1713  OP_CMP_B    LEA     DISP_CMP_B,A1
00002068  103C 000E               1714              MOVE.B  #14,D0
0000206C  4E4F                    1715              TRAP    #15
0000206E  183C 0000               1716              MOVE.B  #0,D4
00002072  4EF9 00002B20           1717              JMP     EA_GEN
00002078                          1718  
00002078  4E75                    1719              RTS
0000207A                          1720              
0000207A  43F9 00003FA0           1721  OP_CMP_W    LEA     DISP_CMP_W,A1
00002080  103C 000E               1722              MOVE.B  #14,D0
00002084  4E4F                    1723              TRAP    #15
00002086  183C 0001               1724              MOVE.B  #1,D4
0000208A  4EF9 00002B20           1725              JMP     EA_GEN
00002090                          1726  
00002090  4E75                    1727              RTS
00002092                          1728              
00002092  43F9 00003FA9           1729  OP_CMP_L    LEA     DISP_CMP_L,A1
00002098  103C 000E               1730              MOVE.B  #14,D0
0000209C  4E4F                    1731              TRAP    #15
0000209E  183C 0002               1732              MOVE.B  #2,D4
000020A2  4EF9 00002B20           1733              JMP     EA_GEN
000020A8                          1734  
000020A8  4E75                    1735              RTS
000020AA                          1736              
000020AA                          1737  *---------------------------------------------------------------------------*
000020AA                          1738  * OP_EOR: display EOR
000020AA                          1739  *---------------------------------------------------------------------------*  
000020AA  43F9 00003F7C           1740  OP_EOR_B    LEA     DISP_EOR_B,A1
000020B0  103C 000E               1741              MOVE.B  #14,D0
000020B4  4E4F                    1742              TRAP    #15
000020B6  183C 0000               1743              MOVE.B  #0,D4
000020BA  4E75                    1744              RTS
000020BC                          1745              
000020BC  43F9 00003F85           1746  OP_EOR_W    LEA     DISP_EOR_W,A1
000020C2  103C 000E               1747              MOVE.B  #14,D0
000020C6  4E4F                    1748              TRAP    #15
000020C8  183C 0001               1749              MOVE.B  #1,D4
000020CC  4E75                    1750              RTS
000020CE                          1751              
000020CE  43F9 00003F8E           1752  OP_EOR_L    LEA     DISP_EOR_L,A1
000020D4  103C 000E               1753              MOVE.B  #14,D0
000020D8  4E4F                    1754              TRAP    #15
000020DA  183C 0002               1755              MOVE.B  #2,D4
000020DE  4E75                    1756              RTS    
000020E0                          1757  
000020E0                          1758  *---------------------------------------------------------------------------*
000020E0                          1759  * OP1100: Decode and display MULS/AND and proceed to EA
000020E0                          1760  *---------------------------------------------------------------------------* 
000020E0  4280                    1761  OP1100      CLR.L   D0                 
000020E2  4281                    1762              CLR.L   D1    
000020E4  4284                    1763              CLR.L   D4                
000020E6  227C 00000000           1764              MOVEA.L #0, A1        
000020EC  2205                    1765              MOVE.L  D5,D1
000020EE  EA89                    1766              LSR.L   #5,D1
000020F0  0281 0000000E           1767              ANDI.L  #$E,D1
000020F6  0C41 000E               1768              CMPI.W  #$E,D1
000020FA  6700 0006               1769              BEQ     OP_MULS
000020FE  6000 00F6               1770              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002102                          1771  
00002102                          1772  OP_MULS                      
00002102  4281                    1773              CLR.L   D1       
00002104  4284                    1774              CLR.L   D4                   
00002106  227C 00000000           1775              MOVEA.L #0, A1              
0000210C  2205                    1776              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000210E                          1777              *CLEAR D3
0000210E  4283                    1778              CLR.L   D3
00002110                          1779  
00002110                          1780  OP1100_MULS_DN_EA_OR_EA_DN 
00002110                          1781              *LOAD STACK WITH THIS OPMODE
00002110  6100 16FC               1782              BSR     PUSH_STACK
00002114  163C 004D               1783              MOVE.B  #'M',D3
00002118  6100 16F4               1784              BSR     PUSH_STACK
0000211C  163C 0055               1785              MOVE.B  #'U',D3
00002120  6100 16EC               1786              BSR     PUSH_STACK
00002124  163C 004C               1787              MOVE.B  #'L',D3
00002128  6100 16E4               1788              BSR     PUSH_STACK
0000212C  163C 0053               1789              MOVE.B  #'S',D3
00002130  6100 16DC               1790              BSR     PUSH_STACK
00002134  163C 002E               1791              MOVE.B  #'.',D3
00002138  6100 16D4               1792              BSR     PUSH_STACK
0000213C                          1793              
0000213C  2205                    1794              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000213E                          1795              
0000213E                          1796  OP1100_EA_DN_MULS           
0000213E                          1797              *BITS (7 TO 6) 
0000213E                          1798              *00 = .B
0000213E                          1799              *01 = .W
0000213E                          1800              *10 = .L 
0000213E  2205                    1801              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002140  EC99                    1802              ROR.L   #6,D1
00002142  0281 00000003           1803              ANDI.L  #$03,D1
00002148  0C81 00000003           1804              CMPI.L  #%11,D1 *EQUALS .W
0000214E  6700 0014               1805              BEQ     OP1100_PRINT_W_MULS
00002152  0C81 00000000           1806              CMPI.L  #%00,D1 *EQUALS .L
00002158  6700 0052               1807              BEQ     OP1100_PRINT_L_MULS
0000215C                          1808              
0000215C  183C 0001               1809              MOVE.B  #1,D4               *ERROR READ
00002160  6000 0092               1810              BRA     OP1100_MULS_RETURN
00002164                          1811  OP1100_PRINT_W_MULS
00002164  163C 0057               1812              MOVE.B  #'W',D3
00002168  6100 16A4               1813              BSR     PUSH_STACK
0000216C                          1814  
0000216C                          1815              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000216C  13FC 0000 00004134      1816              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002174  13FC 0000 00004135      1817              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000217C                          1818             
0000217C                          1819              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000217C  13FC 00B9 00004137      1820              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002184  13FC 0020 00004138      1821              MOVE.B   #$20,GET_SRC_START_END
0000218C                          1822  
0000218C                          1823             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000218C  0285 0000FE3F           1824              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002192  0685 00000000           1825              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002198                          1826  
00002198                          1827              
00002198  6100 0DD6               1828              BSR     GET_EA_EA_SRC      *GETS <ea>
0000219C  163C 002C               1829              MOVE.B  #',',D3
000021A0  6100 166C               1830              BSR     PUSH_STACK
000021A4  6100 11FA               1831              BSR     GET_EA_EA_DEST       *GETS Dn    
000021A8                          1832              
000021A8  6000 004A               1833              BRA     OP1100_MULS_RETURN
000021AC                          1834  OP1100_PRINT_L_MULS 
000021AC  163C 004C               1835              MOVE.B  #'L',D3
000021B0  6100 165C               1836              BSR     PUSH_STACK
000021B4                          1837              
000021B4                          1838              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021B4  13FC 0000 00004134      1839              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021BC  13FC 0000 00004135      1840              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021C4                          1841             
000021C4                          1842              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021C4  13FC 00B9 00004137      1843              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021CC  13FC 0020 00004138      1844              MOVE.B   #$20,GET_SRC_START_END
000021D4                          1845  
000021D4                          1846              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021D4  0285 0000FE3F           1847              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021DA  0685 00000000           1848              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021E0                          1849  
000021E0                          1850                     
000021E0  6100 0D8E               1851              BSR     GET_EA_EA_SRC      *GETS <ea>
000021E4  163C 002C               1852              MOVE.B  #',',D3
000021E8  6100 1624               1853              BSR     PUSH_STACK                  
000021EC  6100 11B2               1854              BSR     GET_EA_EA_DEST       *GETS Dn    
000021F0                          1855  
000021F0                          1856              
000021F0  6000 0002               1857              BRA     OP1100_MULS_RETURN
000021F4                          1858              
000021F4                          1859  OP1100_MULS_RETURN
000021F4  4E75                    1860              RTS
000021F6                          1861              
000021F6                          1862  
000021F6                          1863  
000021F6                          1864  
000021F6                          1865  
000021F6                          1866  
000021F6                          1867  
000021F6                          1868  
000021F6                          1869  
000021F6                          1870  
000021F6                          1871  
000021F6                          1872  
000021F6                          1873  
000021F6                          1874  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000021F6                          1875              *LOAD STACK WITH THIS OPMODE
000021F6  4283                    1876              CLR.L   D3
000021F8  6100 1614               1877              BSR     PUSH_STACK
000021FC  163C 0041               1878              MOVE.B  #'A',D3
00002200  6100 160C               1879              BSR     PUSH_STACK
00002204  163C 004E               1880              MOVE.B  #'N',D3
00002208  6100 1604               1881              BSR     PUSH_STACK
0000220C  163C 0044               1882              MOVE.B  #'D',D3
00002210  6100 15FC               1883              BSR     PUSH_STACK
00002214  163C 002E               1884              MOVE.B  #'.',D3
00002218  6100 15F4               1885              BSR     PUSH_STACK
0000221C                          1886              
0000221C  2205                    1887              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000221E                          1888              
0000221E                          1889              *BITS (INDEX 8) 
0000221E                          1890              *0 = ADD.B/W/L <EA>,Dn
0000221E                          1891              *1 = ADD.B/W/L Dn,<EA> 
0000221E  E099                    1892              ROR.L   #8,D1
00002220  0281 00000001           1893              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002226  0C81 00000000           1894              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000222C  6700 0102               1895              BEQ     OP1100_EA_DN
00002230                          1896              *else procede to Dn_EA
00002230                          1897              
00002230                          1898  OP1100_DN_EA
00002230                          1899              *BITS (7 TO 6) 
00002230                          1900              *00 = .B
00002230                          1901              *01 = .W
00002230                          1902              *10 = .L 
00002230  2205                    1903              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002232  EC99                    1904              ROR.L   #6,D1
00002234  0281 00000003           1905              ANDI.L  #$03,D1
0000223A  0C81 00000000           1906              CMPI.L  #$00,D1 *EQUALS .B
00002240  6700 0016               1907              BEQ     OP1100_PRINT_B2
00002244  0C81 00000001           1908              CMPI.L  #$01,D1 *EQUALS .W
0000224A  6700 0054               1909              BEQ     OP1100_PRINT_W2
0000224E  0C81 00000002           1910              CMPI.L  #$02,D1 *EQUALS .L
00002254  6700 0092               1911              BEQ     OP1100_PRINT_L2
00002258                          1912  OP1100_PRINT_B2
00002258                          1913              *PUSH 'B'
00002258  163C 0042               1914              MOVE.B  #'B',D3
0000225C  6100 15B0               1915              BSR     PUSH_STACK
00002260                          1916             
00002260                          1917              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002260  13FC 0000 00004134      1918             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002268  13FC 0083 00004135      1919             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002270                          1920             
00002270                          1921             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002270  13FC 00B9 00004137      1922             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002278  13FC 0020 00004138      1923             MOVE.B   #$20,GET_SRC_START_END
00002280                          1924  
00002280                          1925              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002280  0285 0000FE3F           1926              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002286  0685 00000000           1927              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000228C                          1928       
0000228C  6100 1112               1929              BSR     GET_EA_EA_DEST      *GETS Dn
00002290  163C 002C               1930              MOVE.B  #',',D3
00002294  6100 1578               1931              BSR     PUSH_STACK                     
00002298  6100 0CD6               1932              BSR     GET_EA_EA_SRC       *GETS <ea>
0000229C                          1933  
0000229C                          1934              
0000229C  6000 0192               1935              BRA     OP1100_AND_RETURN
000022A0                          1936  OP1100_PRINT_W2
000022A0  163C 0057               1937              MOVE.B  #'W',D3
000022A4  6100 1568               1938              BSR     PUSH_STACK
000022A8                          1939  
000022A8                          1940              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022A8  13FC 0000 00004134      1941              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022B0  13FC 0083 00004135      1942              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022B8                          1943             
000022B8                          1944              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022B8  13FC 00B9 00004137      1945              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022C0  13FC 0020 00004138      1946              MOVE.B   #$20,GET_SRC_START_END
000022C8                          1947  
000022C8                          1948              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022C8  0285 0000FE3F           1949              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022CE  0685 00000000           1950              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000022D4                          1951  
000022D4                          1952        
000022D4  6100 10CA               1953              BSR     GET_EA_EA_DEST      *GETS Dn
000022D8  163C 002C               1954              MOVE.B  #',',D3
000022DC  6100 1530               1955              BSR     PUSH_STACK               
000022E0  6100 0C8E               1956              BSR     GET_EA_EA_SRC       *GETS <ea>       
000022E4                          1957  
000022E4                          1958  
000022E4                          1959  
000022E4  6000 049A               1960              BRA     OP1101_ADD_RETURN
000022E8                          1961  OP1100_PRINT_L2 
000022E8  163C 004C               1962              MOVE.B  #'L',D3
000022EC  6100 1520               1963              BSR     PUSH_STACK
000022F0                          1964              
000022F0                          1965              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022F0  13FC 0000 00004134      1966              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022F8  13FC 0083 00004135      1967              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002300                          1968             
00002300                          1969              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002300  13FC 00B9 00004137      1970              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002308  13FC 0020 00004138      1971              MOVE.B   #$20,GET_SRC_START_END
00002310                          1972  
00002310                          1973             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002310  0285 0000FE3F           1974              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002316  0685 00000000           1975              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000231C                          1976  
0000231C                          1977               
0000231C  6100 1082               1978              BSR     GET_EA_EA_DEST       *GETS Dn
00002320  163C 002C               1979              MOVE.B  #',',D3
00002324  6100 14E8               1980              BSR     PUSH_STACK          
00002328  6100 0C46               1981              BSR     GET_EA_EA_SRC        *GETS <ea>
0000232C                          1982  
0000232C  6000 0102               1983              BRA     OP1100_AND_RETURN
00002330                          1984              
00002330                          1985  OP1100_EA_DN           
00002330                          1986              *BITS (7 TO 6) 
00002330                          1987              *00 = .B
00002330                          1988              *01 = .W
00002330                          1989              *10 = .L 
00002330  2205                    1990              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002332  EC99                    1991              ROR.L   #6,D1
00002334  0281 00000003           1992              ANDI.L  #$03,D1
0000233A  0C81 00000000           1993              CMPI.L  #$00,D1 *EQUALS .B
00002340  6700 0016               1994              BEQ     OP1100_PRINT_B
00002344  0C81 00000001           1995              CMPI.L  #$01,D1 *EQUALS .W
0000234A  6700 0054               1996              BEQ     OP1100_PRINT_W
0000234E  0C81 00000002           1997              CMPI.L  #$02,D1 *EQUALS .L
00002354  6700 0092               1998              BEQ     OP1100_PRINT_L
00002358                          1999  OP1100_PRINT_B
00002358  163C 0042               2000              MOVE.B  #'B',D3
0000235C  6100 14B0               2001              BSR     PUSH_STACK
00002360                          2002                
00002360                          2003              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002360  13FC 0000 00004134      2004              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002368  13FC 0002 00004135      2005              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002370                          2006             
00002370                          2007              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002370  13FC 00B9 00004137      2008              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002378  13FC 0020 00004138      2009              MOVE.B   #$20,GET_SRC_START_END
00002380                          2010  
00002380                          2011             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002380  0285 0000FE3F           2012              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002386  0685 00000000           2013              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
0000238C                          2014  
0000238C                          2015              
0000238C  6100 0BE2               2016              BSR     GET_EA_EA_SRC      *GETS <ea>
00002390  163C 002C               2017              MOVE.B  #',',D3
00002394  6100 1478               2018              BSR     PUSH_STACK          
00002398  6100 1006               2019              BSR     GET_EA_EA_DEST       *GETS Dn
0000239C                          2020              
0000239C  6000 03E2               2021              BRA     OP1101_ADD_RETURN
000023A0                          2022  OP1100_PRINT_W
000023A0  163C 0057               2023              MOVE.B  #'W',D3
000023A4  6100 1468               2024              BSR     PUSH_STACK
000023A8                          2025  
000023A8                          2026              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023A8  13FC 0000 00004134      2027              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023B0  13FC 0002 00004135      2028              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023B8                          2029             
000023B8                          2030              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023B8  13FC 00B9 00004137      2031              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023C0  13FC 0020 00004138      2032              MOVE.B   #$20,GET_SRC_START_END
000023C8                          2033  
000023C8                          2034             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023C8  0285 0000FE3F           2035              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023CE  0685 00000000           2036              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023D4                          2037  
000023D4                          2038              
000023D4  6100 0B9A               2039              BSR     GET_EA_EA_SRC      *GETS <ea>
000023D8  163C 002C               2040              MOVE.B  #',',D3
000023DC  6100 1430               2041              BSR     PUSH_STACK
000023E0  6100 0FBE               2042              BSR     GET_EA_EA_DEST       *GETS Dn    
000023E4                          2043              
000023E4  6000 FB8C               2044              BRA     OP1001_ADD_RETURN
000023E8                          2045  OP1100_PRINT_L 
000023E8  163C 004C               2046              MOVE.B  #'L',D3
000023EC  6100 1420               2047              BSR     PUSH_STACK
000023F0                          2048              
000023F0                          2049              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023F0  13FC 0000 00004134      2050              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023F8  13FC 0002 00004135      2051              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002400                          2052             
00002400                          2053              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002400  13FC 00B9 00004137      2054              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002408  13FC 0020 00004138      2055              MOVE.B   #$20,GET_SRC_START_END
00002410                          2056  
00002410                          2057              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002410  0285 0000FE3F           2058              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002416  0685 00000000           2059              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000241C                          2060  
0000241C                          2061                     
0000241C  6100 0B52               2062              BSR     GET_EA_EA_SRC      *GETS <ea>
00002420  163C 002C               2063              MOVE.B  #',',D3
00002424  6100 13E8               2064              BSR     PUSH_STACK                  
00002428  6100 0F76               2065              BSR     GET_EA_EA_DEST       *GETS Dn    
0000242C                          2066  
0000242C                          2067              
0000242C  6000 0002               2068              BRA     OP1100_AND_RETURN
00002430                          2069              
00002430                          2070  OP1100_AND_RETURN
00002430  4E75                    2071              RTS
00002432                          2072  
00002432                          2073  
00002432                          2074  *---------------------------------------------------------------------------*
00002432                          2075  * OP1101: Decode ADD/ADDA
00002432                          2076  *---------------------------------------------------------------------------* 
00002432  4280                    2077  OP1101      CLR.L   D0                  
00002434  4281                    2078              CLR.L   D1       
00002436  4284                    2079              CLR.L   D4                   
00002438  227C 00000000           2080              MOVEA.L #0, A1              
0000243E  2205                    2081              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002440                          2082              
00002440                          2083              *CLEAR D3
00002440  4283                    2084              CLR.L   D3
00002442                          2085              
00002442                          2086              
00002442                          2087              
00002442                          2088              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002442  2205                    2089              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002444                          2090              *BITS (INDEX 8) 
00002444                          2091              *0 = ADD.B/W/L <EA>,Dn
00002444                          2092              *1 = ADD.B/W/L Dn,<EA> 
00002444  EC99                    2093              ROR.L   #6,D1
00002446  0281 00000007           2094              ANDI.L  #$07,D1                 *MASKS WITH 00000111
0000244C  0C81 00000007           2095              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002452  6700 0010               2096              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002456  0C81 00000003           2097              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
0000245C  6700 0078               2098              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002460  6000 00E6               2099              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002464                          2100              
00002464                          2101  OP1101_ADDA_L
00002464                          2102              *LOAD STACK WITH THIS OPMODE
00002464  6100 13A8               2103              BSR     PUSH_STACK
00002468  163C 0041               2104              MOVE.B  #'A',D3
0000246C  6100 13A0               2105              BSR     PUSH_STACK
00002470  163C 0044               2106              MOVE.B  #'D',D3
00002474  6100 1398               2107              BSR     PUSH_STACK
00002478  163C 0044               2108              MOVE.B  #'D',D3
0000247C  6100 1390               2109              BSR     PUSH_STACK
00002480  163C 0041               2110              MOVE.B  #'A',D3
00002484  6100 1388               2111              BSR     PUSH_STACK
00002488  163C 002E               2112              MOVE.B  #'.',D3
0000248C  6100 1380               2113              BSR     PUSH_STACK
00002490  163C 004C               2114              MOVE.B  #'L',D3
00002494  6100 1378               2115              BSR     PUSH_STACK
00002498                          2116              
00002498                          2117             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002498  13FC 0000 00004134      2118             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024A0  13FC 0000 00004135      2119             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024A8                          2120             
000024A8                          2121             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024A8  13FC 00B9 00004137      2122             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024B0  13FC 0020 00004138      2123             MOVE.B   #$20,GET_SRC_START_END
000024B8                          2124  
000024B8                          2125              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024B8  0285 0000FE3F           2126              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024BE  0685 00000040           2127              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024C4                          2128       
000024C4                          2129              *PRINT <EA>,AN
000024C4  6100 0AAA               2130              BSR     GET_EA_EA_SRC       *GETS <ea>
000024C8  163C 002C               2131              MOVE.B  #',',D3
000024CC  6100 1340               2132              BSR     PUSH_STACK                     
000024D0  6100 0ECE               2133              BSR     GET_EA_EA_DEST      *GETS Dn
000024D4                          2134  
000024D4                          2135              
000024D4                          2136              
000024D4  4E75                    2137              RTS
000024D6                          2138  OP1101_ADDA_W
000024D6                          2139              *LOAD STACK WITH THIS OPMODE
000024D6  6100 1336               2140              BSR     PUSH_STACK
000024DA  163C 0041               2141              MOVE.B  #'A',D3
000024DE  6100 132E               2142              BSR     PUSH_STACK
000024E2  163C 0044               2143              MOVE.B  #'D',D3
000024E6  6100 1326               2144              BSR     PUSH_STACK
000024EA  163C 0044               2145              MOVE.B  #'D',D3
000024EE  6100 131E               2146              BSR     PUSH_STACK
000024F2  163C 0041               2147              MOVE.B  #'A',D3
000024F6  6100 1316               2148              BSR     PUSH_STACK
000024FA  163C 002E               2149              MOVE.B  #'.',D3
000024FE  6100 130E               2150              BSR     PUSH_STACK
00002502  163C 0057               2151              MOVE.B  #'W',D3
00002506  6100 1306               2152              BSR     PUSH_STACK
0000250A                          2153              
0000250A                          2154             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000250A  13FC 0000 00004134      2155             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002512  13FC 0000 00004135      2156             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000251A                          2157             
0000251A                          2158             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000251A  13FC 00B9 00004137      2159             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002522  13FC 0020 00004138      2160             MOVE.B   #$20,GET_SRC_START_END
0000252A                          2161  
0000252A                          2162              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000252A  0285 0000FE3F           2163              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002530  0685 00000040           2164              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002536                          2165       
00002536                          2166              *PRINT <EA>,AN
00002536  6100 0A38               2167              BSR     GET_EA_EA_SRC       *GETS <ea>
0000253A  163C 002C               2168              MOVE.B  #',',D3
0000253E  6100 12CE               2169              BSR     PUSH_STACK                     
00002542  6100 0E5C               2170              BSR     GET_EA_EA_DEST      *GETS Dn
00002546                          2171  
00002546  4E75                    2172              RTS
00002548                          2173  
00002548                          2174  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002548                          2175              *LOAD STACK WITH THIS OPMODE
00002548  6100 12C4               2176              BSR     PUSH_STACK
0000254C  163C 0041               2177              MOVE.B  #'A',D3
00002550  6100 12BC               2178              BSR     PUSH_STACK
00002554  163C 0044               2179              MOVE.B  #'D',D3
00002558  6100 12B4               2180              BSR     PUSH_STACK
0000255C  163C 0044               2181              MOVE.B  #'D',D3
00002560  6100 12AC               2182              BSR     PUSH_STACK
00002564  163C 002E               2183              MOVE.B  #'.',D3
00002568  6100 12A4               2184              BSR     PUSH_STACK
0000256C                          2185              
0000256C  2205                    2186              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000256E                          2187              
0000256E                          2188              *BITS (INDEX 8) 
0000256E                          2189              *0 = ADD.B/W/L <EA>,Dn
0000256E                          2190              *1 = ADD.B/W/L Dn,<EA> 
0000256E  E099                    2191              ROR.L   #8,D1
00002570  0281 00000001           2192              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002576  0C81 00000000           2193              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000257C  6700 0102               2194              BEQ     OP1101_EA_DN
00002580                          2195              *else procede to Dn_EA
00002580                          2196              
00002580                          2197  OP1101_DN_EA
00002580                          2198              *BITS (7 TO 6) 
00002580                          2199              *00 = .B
00002580                          2200              *01 = .W
00002580                          2201              *10 = .L 
00002580  2205                    2202              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002582  EC99                    2203              ROR.L   #6,D1
00002584  0281 00000003           2204              ANDI.L  #$03,D1
0000258A  0C81 00000000           2205              CMPI.L  #$00,D1 *EQUALS .B
00002590  6700 0016               2206              BEQ     OP1101_PRINT_B2
00002594  0C81 00000001           2207              CMPI.L  #$01,D1 *EQUALS .W
0000259A  6700 0054               2208              BEQ     OP1101_PRINT_W2
0000259E  0C81 00000002           2209              CMPI.L  #$02,D1 *EQUALS .L
000025A4  6700 0092               2210              BEQ     OP1101_PRINT_L2
000025A8                          2211  OP1101_PRINT_B2
000025A8                          2212              *PUSH 'B'
000025A8  163C 0042               2213              MOVE.B  #'B',D3
000025AC  6100 1260               2214              BSR     PUSH_STACK
000025B0                          2215             
000025B0                          2216              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025B0  13FC 0002 00004134      2217             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025B8  13FC 0083 00004135      2218             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025C0                          2219             
000025C0                          2220             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025C0  13FC 00B9 00004137      2221             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025C8  13FC 0020 00004138      2222             MOVE.B   #$20,GET_SRC_START_END
000025D0                          2223  
000025D0                          2224              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025D0  0285 0000FE3F           2225              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000025D6  0685 00000000           2226              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000025DC                          2227       
000025DC  6100 0DC2               2228              BSR     GET_EA_EA_DEST      *GETS Dn
000025E0  163C 002C               2229              MOVE.B  #',',D3
000025E4  6100 1228               2230              BSR     PUSH_STACK                     
000025E8  6100 0986               2231              BSR     GET_EA_EA_SRC       *GETS <ea>
000025EC                          2232  
000025EC                          2233              
000025EC  6000 0192               2234              BRA     OP1101_ADD_RETURN
000025F0                          2235  OP1101_PRINT_W2
000025F0  163C 0057               2236              MOVE.B  #'W',D3
000025F4  6100 1218               2237              BSR     PUSH_STACK
000025F8                          2238  
000025F8                          2239              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025F8  13FC 0000 00004134      2240              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002600  13FC 0083 00004135      2241              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002608                          2242             
00002608                          2243              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002608  13FC 00B9 00004137      2244              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002610  13FC 0020 00004138      2245              MOVE.B   #$20,GET_SRC_START_END
00002618                          2246  
00002618                          2247              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002618  0285 0000FE3F           2248              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000261E  0685 00000000           2249              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002624                          2250  
00002624                          2251        
00002624  6100 0D7A               2252              BSR     GET_EA_EA_DEST      *GETS Dn
00002628  163C 002C               2253              MOVE.B  #',',D3
0000262C  6100 11E0               2254              BSR     PUSH_STACK               
00002630  6100 093E               2255              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002634                          2256  
00002634                          2257  
00002634                          2258  
00002634  6000 014A               2259              BRA     OP1101_ADD_RETURN
00002638                          2260  OP1101_PRINT_L2 
00002638  163C 004C               2261              MOVE.B  #'L',D3
0000263C  6100 11D0               2262              BSR     PUSH_STACK
00002640                          2263              
00002640                          2264              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002640  13FC 0000 00004134      2265              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002648  13FC 0083 00004135      2266              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002650                          2267             
00002650                          2268              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002650  13FC 00B9 00004137      2269              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002658  13FC 0020 00004138      2270              MOVE.B   #$20,GET_SRC_START_END
00002660                          2271  
00002660                          2272             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002660  0285 0000FE3F           2273              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002666  0685 00000000           2274              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000266C                          2275  
0000266C                          2276               
0000266C  6100 0D32               2277              BSR     GET_EA_EA_DEST       *GETS Dn
00002670  163C 002C               2278              MOVE.B  #',',D3
00002674  6100 1198               2279              BSR     PUSH_STACK          
00002678  6100 08F6               2280              BSR     GET_EA_EA_SRC        *GETS <ea>
0000267C                          2281  
0000267C  6000 0102               2282              BRA     OP1101_ADD_RETURN
00002680                          2283              
00002680                          2284  OP1101_EA_DN           
00002680                          2285              *BITS (7 TO 6) 
00002680                          2286              *00 = .B
00002680                          2287              *01 = .W
00002680                          2288              *10 = .L 
00002680  2205                    2289              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002682  EC99                    2290              ROR.L   #6,D1
00002684  0281 00000003           2291              ANDI.L  #$03,D1
0000268A  0C81 00000000           2292              CMPI.L  #$00,D1 *EQUALS .B
00002690  6700 0016               2293              BEQ     OP1101_PRINT_B
00002694  0C81 00000001           2294              CMPI.L  #$01,D1 *EQUALS .W
0000269A  6700 0054               2295              BEQ     OP1101_PRINT_W
0000269E  0C81 00000002           2296              CMPI.L  #$02,D1 *EQUALS .L
000026A4  6700 0092               2297              BEQ     OP1101_PRINT_L
000026A8                          2298  OP1101_PRINT_B
000026A8  163C 0042               2299              MOVE.B  #'B',D3
000026AC  6100 1160               2300              BSR     PUSH_STACK
000026B0                          2301                
000026B0                          2302              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026B0  13FC 0002 00004134      2303              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000026B8  13FC 0002 00004135      2304              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000026C0                          2305             
000026C0                          2306              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026C0  13FC 00B9 00004137      2307              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000026C8  13FC 0020 00004138      2308              MOVE.B   #$20,GET_SRC_START_END
000026D0                          2309  
000026D0                          2310             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026D0  0285 0000FE3F           2311              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026D6  0685 00000000           2312              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026DC                          2313  
000026DC                          2314              
000026DC  6100 0892               2315              BSR     GET_EA_EA_SRC      *GETS <ea>
000026E0  163C 002C               2316              MOVE.B  #',',D3
000026E4  6100 1128               2317              BSR     PUSH_STACK          
000026E8  6100 0CB6               2318              BSR     GET_EA_EA_DEST       *GETS Dn
000026EC                          2319              
000026EC  6000 0092               2320              BRA     OP1101_ADD_RETURN
000026F0                          2321  OP1101_PRINT_W
000026F0  163C 0057               2322              MOVE.B  #'W',D3
000026F4  6100 1118               2323              BSR     PUSH_STACK
000026F8                          2324  
000026F8                          2325              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026F8  13FC 0000 00004134      2326              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002700  13FC 0000 00004135      2327              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002708                          2328             
00002708                          2329              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002708  13FC 00B9 00004137      2330              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002710  13FC 0020 00004138      2331              MOVE.B   #$20,GET_SRC_START_END
00002718                          2332  
00002718                          2333             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002718  0285 0000FE3F           2334              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000271E  0685 00000000           2335              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002724                          2336  
00002724                          2337              
00002724  6100 084A               2338              BSR     GET_EA_EA_SRC      *GETS <ea>
00002728  163C 002C               2339              MOVE.B  #',',D3
0000272C  6100 10E0               2340              BSR     PUSH_STACK
00002730  6100 0C6E               2341              BSR     GET_EA_EA_DEST       *GETS Dn    
00002734                          2342              
00002734  6000 004A               2343              BRA     OP1101_ADD_RETURN
00002738                          2344  OP1101_PRINT_L 
00002738  163C 004C               2345              MOVE.B  #'L',D3
0000273C  6100 10D0               2346              BSR     PUSH_STACK
00002740                          2347              
00002740                          2348              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002740  13FC 0000 00004134      2349              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002748  13FC 0000 00004135      2350              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002750                          2351             
00002750                          2352              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002750  13FC 00B9 00004137      2353              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002758  13FC 0020 00004138      2354              MOVE.B   #$20,GET_SRC_START_END
00002760                          2355  
00002760                          2356              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002760  0285 0000FE3F           2357              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002766  0685 00000000           2358              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000276C                          2359  
0000276C                          2360                     
0000276C  6100 0802               2361              BSR     GET_EA_EA_SRC      *GETS <ea>
00002770  163C 002C               2362              MOVE.B  #',',D3
00002774  6100 1098               2363              BSR     PUSH_STACK                  
00002778  6100 0C26               2364              BSR     GET_EA_EA_DEST       *GETS Dn    
0000277C                          2365  
0000277C                          2366              
0000277C  6000 0002               2367              BRA     OP1101_ADD_RETURN
00002780                          2368              
00002780                          2369  OP1101_ADD_RETURN
00002780  4E75                    2370              RTS
00002782                          2371              
00002782                          2372              *ADDW
00002782  0C01 0006               2373              CMPI.B  #$6,D1
00002786  6700 0056               2374              BEQ     OP_ADDA_W
0000278A  0C01 000E               2375              CMPI.B  #$E,D1
0000278E  6700 0066               2376              BEQ     OP_ADDA_L 
00002792                          2377  
00002792  4EF8 14B2               2378              JMP     OP_DATA  
00002796                          2379            
00002796                          2380  *---------------------------------------------------------------------------*
00002796                          2381  * OP_ADD: display ADD and proceed to EA
00002796                          2382  *---------------------------------------------------------------------------*  
00002796  43F9 00003FEB           2383  OP_ADD_B    LEA     DISP_ADD_B,A1
0000279C  103C 000E               2384              MOVE.B  #14,D0
000027A0  4E4F                    2385              TRAP    #15
000027A2  183C 0000               2386              MOVE.B  #0,D4
000027A6  4EF9 00002B20           2387              JMP     EA_GEN
000027AC                          2388  
000027AC  4E75                    2389              RTS
000027AE                          2390  
000027AE  43F9 00003FF4           2391  OP_ADD_W    LEA     DISP_ADD_W,A1
000027B4  103C 000E               2392              MOVE.B  #14,D0
000027B8  4E4F                    2393              TRAP    #15
000027BA  183C 0001               2394              MOVE.B  #1,D4
000027BE  4EF9 00002B20           2395              JMP     EA_GEN
000027C4                          2396  
000027C4  4E75                    2397              RTS
000027C6                          2398  
000027C6  43F9 00003FFD           2399  OP_ADD_L    LEA     DISP_ADD_L,A1
000027CC  103C 000E               2400              MOVE.B  #14,D0
000027D0  4E4F                    2401              TRAP    #15
000027D2  183C 0002               2402              MOVE.B  #2,D4
000027D6  4EF9 00002B20           2403              JMP     EA_GEN
000027DC                          2404  
000027DC  4E75                    2405              RTS
000027DE                          2406  
000027DE                          2407  *---------------------------------------------------------------------------*
000027DE                          2408  * OP_ADDA: display ADDA and proceed to EA
000027DE                          2409  *---------------------------------------------------------------------------*  
000027DE  43F9 00004006           2410  OP_ADDA_W   LEA     DISP_ADDA_W,A1
000027E4  103C 000E               2411              MOVE.B  #14,D0
000027E8  4E4F                    2412              TRAP    #15
000027EA  183C 0001               2413              MOVE.B  #1,D4
000027EE  4EF9 00002B20           2414              JMP     EA_GEN
000027F4                          2415  
000027F4  4E75                    2416              RTS
000027F6                          2417  
000027F6  43F9 00004010           2418  OP_ADDA_L   LEA     DISP_ADDA_L,A1
000027FC  103C 000E               2419              MOVE.B  #14,D0
00002800  4E4F                    2420              TRAP    #15
00002802  183C 0002               2421              MOVE.B  #2,D4
00002806  4EF9 00002B20           2422              JMP     EA_GEN
0000280C                          2423  
0000280C  4E75                    2424              RTS
0000280E                          2425              
0000280E                          2426  *---------------------------------------------------------------------------*
0000280E                          2427  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
0000280E                          2428  *---------------------------------------------------------------------------* 
0000280E  4280                    2429  OP1110      CLR.L   D0                  
00002810  4281                    2430              CLR.L   D1   
00002812  4284                    2431              CLR.L   D4                   
00002814  227C 00000000           2432              MOVEA.L #0, A1                 
0000281A  2205                    2433              MOVE.L  D5,D1
0000281C                          2434              
0000281C                          2435              * check for LSX
0000281C  E699                    2436              ROR.L   #3,D1
0000281E  0281 00000001           2437              ANDI.L  #$1,D1
00002824  0C01 0001               2438              CMPI.B  #1,D1
00002828  6700 002E               2439              BEQ     OP_LSX
0000282C                          2440              
0000282C                          2441              * reset D1 and check for ASX
0000282C  4281                    2442              CLR.L   D1
0000282E  2205                    2443              MOVE.L  D5,D1
00002830  E699                    2444              ROR.L   #3,D1
00002832  0281 00000001           2445              ANDI.L  #$1,D1
00002838  0C01 0000               2446              CMPI.B  #0,D1
0000283C  6700 0032               2447              BEQ     OP_ASX
00002840                          2448  
00002840                          2449              * reset D1 and check for ROX
00002840  4281                    2450              CLR.L   D1
00002842  2205                    2451              MOVE.L  D5,D1
00002844  E699                    2452              ROR.L   #3,D1
00002846  0281 00000001           2453              ANDI.L  #$1,D1
0000284C  0C01 0003               2454              CMPI.B  #3,D1
00002850  6700 0036               2455              BEQ     OP_ROX
00002854                          2456              
00002854  4EF8 14B2               2457              JMP     OP_DATA
00002858                          2458  
00002858                          2459  *---------------------------------------------------------------------------*
00002858                          2460  * OP_LSX: process LSR/LSL
00002858                          2461  *---------------------------------------------------------------------------*            
00002858  EA99                    2462  OP_LSX      ROR.L   #5,D1
0000285A  0281 00000001           2463              ANDI.L  #$1,D1
00002860  0C01 0000               2464              CMPI.B  #0,D1
00002864  6700 003A               2465              BEQ     OP_LSR
00002868  0C01 0001               2466              CMPI.B  #1,D1
0000286C  6700 008C               2467              BEQ     OP_LSL
00002870                          2468              
00002870                          2469  *---------------------------------------------------------------------------*
00002870                          2470  * OP_ASX: process ASR/ASL
00002870                          2471  *---------------------------------------------------------------------------*  
00002870  EA99                    2472  OP_ASX      ROR.L   #5,D1
00002872  0281 00000001           2473              ANDI.L  #$1,D1
00002878  0C01 0000               2474              CMPI.B  #0,D1
0000287C  6700 00D6               2475              BEQ     OP_ASR
00002880  0C01 0001               2476              CMPI.B  #1,D1
00002884  6700 0128               2477              BEQ     OP_ASL
00002888                          2478              
00002888                          2479  *---------------------------------------------------------------------------*
00002888                          2480  * OP_ROX: process ROR/ROL
00002888                          2481  *---------------------------------------------------------------------------*  
00002888  EA99                    2482  OP_ROX      ROR.L   #5,D1
0000288A  0281 00000001           2483              ANDI.L  #$1,D1
00002890  0C01 0000               2484              CMPI.B  #0,D1
00002894  6700 0172               2485              BEQ     OP_ROR
00002898  0C01 0001               2486              CMPI.B  #1,D1
0000289C  6700 01C4               2487              BEQ     OP_ROL
000028A0                          2488  
000028A0                          2489  *---------------------------------------------------------------------------*
000028A0                          2490  * OP_LSR: decode and display LSR
000028A0                          2491  *---------------------------------------------------------------------------*        
000028A0  E599                    2492  OP_LSR      ROL.L   #2,D1
000028A2  0281 00000003           2493              ANDI.L  #$3,D1
000028A8  0C01 0000               2494              CMPI.B  #0,D1
000028AC  6700 0016               2495              BEQ     OP_LSR_B
000028B0  0C01 0001               2496              CMPI.B  #$1,D1
000028B4  6700 0032               2497              BEQ     OP_LSR_W
000028B8  0C01 0002               2498              CMPI.B  #$2,D1
000028BC  6700 0018               2499              BEQ     OP_LSR_L
000028C0                          2500              
000028C0  4EF8 14B2               2501              JMP     OP_DATA
000028C4                          2502  
000028C4  43F9 0000401A           2503  OP_LSR_B    LEA     DISP_LSR_B,A1
000028CA  103C 000E               2504              MOVE.B  #14,D0
000028CE  4E4F                    2505              TRAP    #15
000028D0  183C 0000               2506              MOVE.B  #0,D4
000028D4  4E75                    2507              RTS
000028D6                          2508  
000028D6  43F9 0000403E           2509  OP_LSR_L    LEA     DISP_LSR_L,A1
000028DC  103C 000E               2510              MOVE.B  #14,D0
000028E0  4E4F                    2511              TRAP    #15
000028E2  183C 0002               2512              MOVE.B  #2,D4
000028E6  4E75                    2513              RTS
000028E8                          2514  
000028E8  43F9 0000402C           2515  OP_LSR_W    LEA     DISP_LSR_W,A1
000028EE  103C 000E               2516              MOVE.B  #14,D0
000028F2  4E4F                    2517              TRAP    #15
000028F4  183C 0001               2518              MOVE.B  #1,D4
000028F8  4E75                    2519              RTS
000028FA                          2520   
000028FA                          2521  *---------------------------------------------------------------------------*
000028FA                          2522  * OP_LSL: decode and display LSL
000028FA                          2523  *---------------------------------------------------------------------------*             
000028FA  E599                    2524  OP_LSL      ROL.L   #2,D1
000028FC  0281 00000003           2525              ANDI.L  #$3,D1
00002902  0C01 0000               2526              CMPI.B  #0,D1
00002906  6700 0016               2527              BEQ     OP_LSL_B
0000290A  0C01 0001               2528              CMPI.B  #$1,D1
0000290E  6700 0032               2529              BEQ     OP_LSL_W
00002912  0C01 0002               2530              CMPI.B  #$2,D1
00002916  6700 0018               2531              BEQ     OP_LSL_L
0000291A                          2532              
0000291A  4EF8 14B2               2533              JMP OP_DATA
0000291E                          2534  
0000291E  43F9 00004023           2535  OP_LSL_B    LEA     DISP_LSL_B,A1
00002924  103C 000E               2536              MOVE.B  #14,D0
00002928  4E4F                    2537              TRAP    #15
0000292A  183C 0000               2538              MOVE.B  #0,D4
0000292E  4E75                    2539              RTS
00002930                          2540  
00002930  43F9 00004047           2541  OP_LSL_L    LEA     DISP_LSL_L,A1
00002936  103C 000E               2542              MOVE.B  #14,D0
0000293A  4E4F                    2543              TRAP    #15
0000293C  183C 0002               2544              MOVE.B  #2,D4
00002940  4E75                    2545              RTS
00002942                          2546  
00002942  43F9 00004035           2547  OP_LSL_W    LEA     DISP_LSL_W,A1
00002948  103C 000E               2548              MOVE.B  #14,D0
0000294C  4E4F                    2549              TRAP    #15
0000294E  183C 0001               2550              MOVE.B  #1,D4
00002952  4E75                    2551              RTS
00002954                          2552   
00002954                          2553  *---------------------------------------------------------------------------*
00002954                          2554  * OP_ASR: decode and display ASR
00002954                          2555  *---------------------------------------------------------------------------*             
00002954  E599                    2556  OP_ASR      ROL.L   #2,D1
00002956  0281 00000003           2557              ANDI.L  #$3,D1
0000295C  0C01 0000               2558              CMPI.B  #0,D1
00002960  6700 0016               2559              BEQ     OP_ASR_B
00002964  0C01 0001               2560              CMPI.B  #$1,D1
00002968  6700 0032               2561              BEQ     OP_ASR_W
0000296C  0C01 0002               2562              CMPI.B  #$2,D1
00002970  6700 0018               2563              BEQ     OP_ASR_L
00002974                          2564              
00002974  4EF8 14B2               2565              JMP OP_DATA
00002978                          2566  
00002978  43F9 00004050           2567  OP_ASR_B    LEA     DISP_ASR_B,A1
0000297E  103C 000E               2568              MOVE.B  #14,D0
00002982  4E4F                    2569              TRAP    #15
00002984  183C 0000               2570              MOVE.B  #0,D4
00002988  4E75                    2571              RTS
0000298A                          2572  
0000298A  43F9 00004074           2573  OP_ASR_L    LEA     DISP_ASR_L,A1
00002990  103C 000E               2574              MOVE.B  #14,D0
00002994  4E4F                    2575              TRAP    #15
00002996  183C 0002               2576              MOVE.B  #2,D4
0000299A  4E75                    2577              RTS
0000299C                          2578  
0000299C  43F9 00004062           2579  OP_ASR_W    LEA     DISP_ASR_W,A1
000029A2  103C 000E               2580              MOVE.B  #14,D0
000029A6  4E4F                    2581              TRAP    #15
000029A8  183C 0001               2582              MOVE.B  #1,D4
000029AC  4E75                    2583              RTS
000029AE                          2584       
000029AE                          2585  *---------------------------------------------------------------------------*
000029AE                          2586  * OP_ASL: decode and display ASL
000029AE                          2587  *---------------------------------------------------------------------------*         
000029AE  E599                    2588  OP_ASL      ROL.L   #2,D1
000029B0  0281 00000003           2589              ANDI.L  #$3,D1
000029B6  0C01 0000               2590              CMPI.B  #0,D1
000029BA  6700 0016               2591              BEQ     OP_ASL_B
000029BE  0C01 0001               2592              CMPI.B  #$1,D1
000029C2  6700 0032               2593              BEQ     OP_ASL_W
000029C6  0C01 0002               2594              CMPI.B  #$2,D1
000029CA  6700 0018               2595              BEQ     OP_ASL_L
000029CE                          2596              
000029CE  4EF8 14B2               2597              JMP OP_DATA
000029D2                          2598  
000029D2  43F9 00004059           2599  OP_ASL_B    LEA     DISP_ASL_B,A1
000029D8  103C 000E               2600              MOVE.B  #14,D0
000029DC  4E4F                    2601              TRAP    #15
000029DE  183C 0000               2602              MOVE.B  #0,D4
000029E2  4E75                    2603              RTS
000029E4                          2604  
000029E4  43F9 0000407D           2605  OP_ASL_L    LEA     DISP_ASL_L,A1
000029EA  103C 000E               2606              MOVE.B  #14,D0
000029EE  4E4F                    2607              TRAP    #15
000029F0  183C 0002               2608              MOVE.B  #2,D4
000029F4  4E75                    2609              RTS
000029F6                          2610  
000029F6  43F9 0000406B           2611  OP_ASL_W    LEA     DISP_ASL_W,A1
000029FC  103C 000E               2612              MOVE.B  #14,D0
00002A00  4E4F                    2613              TRAP    #15
00002A02  183C 0001               2614              MOVE.B  #1,D4
00002A06  4E75                    2615              RTS
00002A08                          2616   
00002A08                          2617  *---------------------------------------------------------------------------*
00002A08                          2618  * OP_ROR: decode and display ROR
00002A08                          2619  *---------------------------------------------------------------------------*             
00002A08  E599                    2620  OP_ROR      ROL.L   #2,D1
00002A0A  0281 00000003           2621              ANDI.L  #$3,D1
00002A10  0C01 0000               2622              CMPI.B  #0,D1
00002A14  6700 0016               2623              BEQ     OP_ROR_B
00002A18  0C01 0001               2624              CMPI.B  #$1,D1
00002A1C  6700 0032               2625              BEQ     OP_ROR_W
00002A20  0C01 0002               2626              CMPI.B  #$2,D1
00002A24  6700 0018               2627              BEQ     OP_ROR_L
00002A28                          2628              
00002A28  4EF8 14B2               2629              JMP OP_DATA
00002A2C                          2630  
00002A2C  43F9 00004086           2631  OP_ROR_B    LEA     DISP_ROR_B,A1
00002A32  103C 000E               2632              MOVE.B  #14,D0
00002A36  4E4F                    2633              TRAP    #15
00002A38  183C 0000               2634              MOVE.B  #0,D4
00002A3C  4E75                    2635              RTS
00002A3E                          2636  
00002A3E  43F9 000040AA           2637  OP_ROR_L    LEA     DISP_ROR_L,A1
00002A44  103C 000E               2638              MOVE.B  #14,D0
00002A48  4E4F                    2639              TRAP    #15
00002A4A  183C 0002               2640              MOVE.B  #2,D4
00002A4E  4E75                    2641              RTS
00002A50                          2642  
00002A50  43F9 00004098           2643  OP_ROR_W    LEA     DISP_ROR_W,A1
00002A56  103C 000E               2644              MOVE.B  #14,D0
00002A5A  4E4F                    2645              TRAP    #15
00002A5C  183C 0001               2646              MOVE.B  #1,D4
00002A60  4E75                    2647              RTS
00002A62                          2648  
00002A62                          2649  *---------------------------------------------------------------------------*
00002A62                          2650  * OP_ROL: decode and display ROL
00002A62                          2651  *---------------------------------------------------------------------------*             
00002A62  E599                    2652  OP_ROL      ROL.L   #2,D1
00002A64  0281 00000003           2653              ANDI.L  #$3,D1
00002A6A  0C01 0000               2654              CMPI.B  #0,D1
00002A6E  6700 0016               2655              BEQ     OP_ROL_B
00002A72  0C01 0001               2656              CMPI.B  #$1,D1
00002A76  6700 0032               2657              BEQ     OP_ROL_W
00002A7A  0C01 0002               2658              CMPI.B  #$2,D1
00002A7E  6700 0018               2659              BEQ     OP_ROL_L
00002A82                          2660              
00002A82  4EF8 14B2               2661              JMP OP_DATA
00002A86                          2662  
00002A86                          2663  
00002A86  43F9 0000408F           2664  OP_ROL_B    LEA     DISP_ROL_B,A1
00002A8C  103C 000E               2665              MOVE.B  #14,D0
00002A90  4E4F                    2666              TRAP    #15
00002A92  183C 0000               2667              MOVE.B  #0,D4
00002A96  4E75                    2668              RTS
00002A98                          2669  
00002A98  43F9 000040B3           2670  OP_ROL_L    LEA     DISP_ROL_L,A1
00002A9E  103C 000E               2671              MOVE.B  #14,D0
00002AA2  4E4F                    2672              TRAP    #15
00002AA4  183C 0002               2673              MOVE.B  #2,D4
00002AA8  4E75                    2674              RTS
00002AAA                          2675  
00002AAA  43F9 000040A1           2676  OP_ROL_W    LEA     DISP_ROL_W,A1
00002AB0  103C 000E               2677              MOVE.B  #14,D0
00002AB4  4E4F                    2678              TRAP    #15
00002AB6  183C 0001               2679              MOVE.B  #1,D4
00002ABA  4E75                    2680              RTS
00002ABC                          2681              
00002ABC                          2682  *---------------------------------------------------------------------------*
00002ABC                          2683  * OP1111 : Special reserved
00002ABC                          2684  *---------------------------------------------------------------------------*           
00002ABC  4EF8 14B2               2685  OP1111      JMP     OP_DATA
00002AC0                          2686  
00002AC0                          2687  *---------------------------------------------------------------------------*
00002AC0                          2688  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00002AC0                          2689  *---------------------------------------------------------------------------*
00002AC0                          2690  EA_NOSRC    
00002AC0  4EB9 00002B7E           2691              JSR     SRC_MODE
00002AC6  43F9 00003D80           2692              LEA     ENDLINE_M,A1
00002ACC  103C 000E               2693              MOVE.B  #14,D0
00002AD0  4E4F                    2694              TRAP    #15
00002AD2  4E75                    2695              RTS
00002AD4                          2696              
00002AD4                          2697  *---------------------------------------------------------------------------*
00002AD4                          2698  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00002AD4                          2699  *---------------------------------------------------------------------------*
00002AD4                          2700  EA_ARITH
00002AD4  4EB9 00002B7E           2701              JSR     SRC_MODE
00002ADA  43F9 000040FA           2702              LEA     DISP_D,A1
00002AE0  103C 000E               2703              MOVE.B  #14,D0
00002AE4  4E4F                    2704              TRAP    #15
00002AE6  4EB9 00002E0A           2705              JSR     DEST_REGISTER
00002AEC  43F9 00003D80           2706              LEA     ENDLINE_M,A1
00002AF2  103C 000E               2707              MOVE.B  #14,D0
00002AF6  4E4F                    2708              TRAP    #15
00002AF8  4E75                    2709              RTS
00002AFA                          2710              
00002AFA                          2711  *---------------------------------------------------------------------------*
00002AFA                          2712  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00002AFA                          2713  *---------------------------------------------------------------------------*
00002AFA                          2714  EA_MOVEA
00002AFA  4EB9 00002B7E           2715              JSR     SRC_MODE
00002B00  43F9 0000410B           2716              LEA     DISP_AOP,A1
00002B06  103C 000E               2717              MOVE.B  #14,D0
00002B0A  4E4F                    2718              TRAP    #15
00002B0C  4EB9 00002E0A           2719              JSR     DEST_REGISTER
00002B12  43F9 00004109           2720              LEA     DISP_CP,A1
00002B18  103C 000D               2721              MOVE.B  #13,D0
00002B1C  4E4F                    2722              TRAP    #15
00002B1E  4E75                    2723              RTS
00002B20                          2724              
00002B20                          2725  *---------------------------------------------------------------------------*
00002B20                          2726  * EA_GEN: decode and display effective addresses for MOVE
00002B20                          2727  *---------------------------------------------------------------------------*
00002B20                          2728  EA_GEN          
00002B20                          2729              * retrieve/display source mode/register
00002B20  4EB9 00002B7E           2730              JSR     SRC_MODE
00002B26                          2731              
00002B26                          2732              * retrieve/display destination mode/register
00002B26  4EB9 00002B3A           2733              JSR     DEST_MODE
00002B2C                          2734              
00002B2C  43F9 00003D80           2735              LEA     ENDLINE_M,A1
00002B32  103C 000E               2736              MOVE.B  #14,D0
00002B36  4E4F                    2737              TRAP    #15
00002B38                          2738              
00002B38  4E75                    2739              RTS
00002B3A                          2740  
00002B3A                          2741  *---------------------------------------------------------------------------*
00002B3A                          2742  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002B3A                          2743  *---------------------------------------------------------------------------*           
00002B3A                          2744  DEST_MODE   
00002B3A                          2745              * clear registers to store temp data
00002B3A  4280                    2746              CLR.L   D0                      
00002B3C  4281                    2747              CLR.L   D1                      
00002B3E  207C 00000000           2748              MOVEA.L #0, A0                  
00002B44  227C 00000000           2749              MOVEA.L #0, A1                  
00002B4A  2205                    2750              MOVE.L  D5,D1
00002B4C  EC89                    2751              LSR.L   #6,D1
00002B4E  0281 00000007           2752              ANDI.L  #$7,D1
00002B54  0C01 0000               2753              CMPI.B  #0,D1   * Dn
00002B58  6700 0082               2754              BEQ     D_MODE000
00002B5C  0C01 0002               2755              CMPI.B  #2,D1   * (An)
00002B60  6700 00C2               2756              BEQ     D_MODE010
00002B64  0C01 0003               2757              CMPI.B  #3,D1   * (An)+
00002B68  6700 011A               2758              BEQ     D_MODE011
00002B6C  0C01 0004               2759              CMPI.B  #4,D1   * -(An)
00002B70  6700 0132               2760              BEQ     D_MODE100
00002B74  0C01 0007               2761              CMPI.B  #7,D1  * abs
00002B78  6700 017C               2762              BEQ     D_MODE111 
00002B7C  4E75                    2763              RTS
00002B7E                          2764  
00002B7E                          2765  *---------------------------------------------------------------------------*
00002B7E                          2766  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002B7E                          2767  *---------------------------------------------------------------------------*  
00002B7E                          2768  SRC_MODE    
00002B7E                          2769              * clear registers to store temp data
00002B7E  4280                    2770              CLR.L   D0                      
00002B80  4281                    2771              CLR.L   D1                      
00002B82  207C 00000000           2772              MOVEA.L #0, A0                  
00002B88  227C 00000000           2773              MOVEA.L #0, A1                  
00002B8E  2205                    2774              MOVE.L  D5,D1
00002B90  E489                    2775              LSR.L   #2,D1
00002B92  0281 0000000E           2776              ANDI.L  #$E,D1
00002B98                          2777              
00002B98  0C01 0000               2778              CMPI.B  #0,D1   * Dn
00002B9C  6700 002A               2779              BEQ     MODE000
00002BA0  0C01 0002               2780              CMPI.B  #2,D1   * An 
00002BA4  6700 004A               2781              BEQ     MODE001
00002BA8  0C01 0004               2782              CMPI.B  #4,D1   * (An)
00002BAC  6700 0056               2783              BEQ     MODE010
00002BB0  0C01 0006               2784              CMPI.B  #6,D1   * (An)+
00002BB4  6700 008E               2785              BEQ     MODE011
00002BB8  0C01 0008               2786              CMPI.B  #8,D1   * -(An)
00002BBC  6700 00A6               2787              BEQ     MODE100
00002BC0  0C01 000F               2788              CMPI.B  #15,D1  * abs/immediate
00002BC4  6700 00FE               2789              BEQ     MODE111 
00002BC8                          2790        
00002BC8                          2791  *---------------------------------------------------------------------------*
00002BC8                          2792  * MODE000: decode and display source mode Dn
00002BC8                          2793  *---------------------------------------------------------------------------*           
00002BC8                          2794  MODE000     *Dn
00002BC8  43F9 000040FA           2795              LEA     DISP_D,A1
00002BCE  103C 000E               2796              MOVE.B  #14,D0
00002BD2  4E4F                    2797              TRAP    #15
00002BD4  4EB9 00002E66           2798              JSR     SRC_REGISTER
00002BDA  4E75                    2799              RTS
00002BDC                          2800  
00002BDC                          2801  *---------------------------------------------------------------------------*
00002BDC                          2802  * D_MODE000: decode and display dest mode Dn
00002BDC                          2803  *---------------------------------------------------------------------------*
00002BDC                          2804  D_MODE000     *Dn
00002BDC  43F9 000040FA           2805              LEA     DISP_D,A1
00002BE2  103C 000E               2806              MOVE.B  #14,D0
00002BE6  4E4F                    2807              TRAP    #15
00002BE8  4EB9 00002E0A           2808              JSR     DEST_REGISTER
00002BEE  4E75                    2809              RTS
00002BF0                          2810  
00002BF0                          2811  *---------------------------------------------------------------------------*
00002BF0                          2812  * MODE001: decode and display source mode An
00002BF0                          2813  *---------------------------------------------------------------------------* 
00002BF0                          2814  MODE001 *An
00002BF0  43F9 000040FF           2815              LEA     DISP_A,A1
00002BF6  103C 000E               2816              MOVE.B  #14,D0
00002BFA  4E4F                    2817              TRAP    #15
00002BFC  4EB9 00002E66           2818              JSR     SRC_REGISTER
00002C02                          2819          
00002C02  4E75                    2820              RTS
00002C04                          2821  
00002C04                          2822  *---------------------------------------------------------------------------*
00002C04                          2823  * MODE010: decode and display source mode (An)
00002C04                          2824  *---------------------------------------------------------------------------*    
00002C04                          2825  MODE010 *(An)
00002C04  43F9 0000410B           2826              LEA     DISP_AOP,A1  *display (A
00002C0A  103C 000E               2827              MOVE.B  #14,D0
00002C0E  4E4F                    2828              TRAP    #15
00002C10                          2829  
00002C10  4EB9 00002E66           2830              JSR     SRC_REGISTER * display register
00002C16                          2831  
00002C16  43F9 00004109           2832              LEA     DISP_CP,A1   *display )
00002C1C  103C 000E               2833              MOVE.B  #14,D0
00002C20  4E4F                    2834              TRAP    #15
00002C22                          2835              
00002C22  4E75                    2836              RTS
00002C24                          2837  
00002C24                          2838  *---------------------------------------------------------------------------*
00002C24                          2839  * D_MODE010: decode and display dest mode (An)
00002C24                          2840  *---------------------------------------------------------------------------*
00002C24                          2841  D_MODE010 *(An)
00002C24  43F9 0000410B           2842              LEA     DISP_AOP,A1  *display (A
00002C2A  103C 000E               2843              MOVE.B  #14,D0
00002C2E  4E4F                    2844              TRAP    #15
00002C30                          2845     
00002C30  4EB9 00002E0A           2846              JSR     DEST_REGISTER * display register
00002C36                          2847  
00002C36  43F9 00004109           2848              LEA     DISP_CP,A1   *display )
00002C3C  103C 000E               2849              MOVE.B  #14,D0
00002C40  4E4F                    2850              TRAP    #15
00002C42                          2851              
00002C42  4E75                    2852              RTS
00002C44                          2853  
00002C44                          2854  *---------------------------------------------------------------------------*
00002C44                          2855  * MODE011: decode and display source mode (An)+
00002C44                          2856  *---------------------------------------------------------------------------*
00002C44                          2857  MODE011 *(An)+
00002C44  43F9 0000410B           2858              LEA     DISP_AOP,A1      *display (A
00002C4A  103C 000E               2859              MOVE.B  #14,D0
00002C4E  4E4F                    2860              TRAP    #15
00002C50                          2861              
00002C50  4EB9 00002E66           2862              JSR     SRC_REGISTER    * display register
00002C56                          2863  
00002C56  43F9 00004118           2864              LEA     DISP_POST,A1    *display )+
00002C5C  103C 000E               2865              MOVE.B  #14,D0
00002C60  4E4F                    2866              TRAP    #15
00002C62                          2867              
00002C62  4E75                    2868              RTS
00002C64                          2869              
00002C64                          2870  *---------------------------------------------------------------------------*
00002C64                          2871  * MODE100: decode and display source mode -(An)
00002C64                          2872  *---------------------------------------------------------------------------*
00002C64                          2873  MODE100 *-(An)
00002C64  43F9 00004111           2874              LEA     DISP_PRE,A1    *display -(A
00002C6A  103C 000E               2875              MOVE.B  #14,D0
00002C6E  4E4F                    2876              TRAP    #15
00002C70                          2877  
00002C70  4EB9 00002E66           2878              JSR     SRC_REGISTER    *display register
00002C76                          2879  
00002C76  43F9 00004109           2880              LEA     DISP_CP,A1   *display )
00002C7C  103C 000E               2881              MOVE.B  #14,D0
00002C80  4E4F                    2882              TRAP    #15
00002C82                          2883              
00002C82  4E75                    2884              RTS
00002C84                          2885  
00002C84                          2886  *---------------------------------------------------------------------------*
00002C84                          2887  * D_MODE011: decode and display dest mode (An)+
00002C84                          2888  *---------------------------------------------------------------------------*
00002C84                          2889  D_MODE011 *(An)+
00002C84  43F9 0000410B           2890              LEA     DISP_AOP,A1      *display (A
00002C8A  103C 000E               2891              MOVE.B  #14,D0
00002C8E  4E4F                    2892              TRAP    #15
00002C90                          2893  
00002C90  4EB9 00002E0A           2894              JSR     DEST_REGISTER    * display register
00002C96                          2895  
00002C96  43F9 00004118           2896              LEA     DISP_POST,A1    *display )+
00002C9C  103C 000E               2897              MOVE.B  #14,D0
00002CA0  4E4F                    2898              TRAP    #15
00002CA2                          2899              
00002CA2  4E75                    2900              RTS
00002CA4                          2901              
00002CA4                          2902  *---------------------------------------------------------------------------*
00002CA4                          2903  * D_MODE100: decode and display dest mode -(An)
00002CA4                          2904  *---------------------------------------------------------------------------*            
00002CA4                          2905  D_MODE100 *-(An)
00002CA4  43F9 00004111           2906              LEA     DISP_PRE,A1    *display -(A
00002CAA  103C 000E               2907              MOVE.B  #14,D0
00002CAE  4E4F                    2908              TRAP    #15
00002CB0                          2909              
00002CB0  4EB9 00002E0A           2910              JSR     DEST_REGISTER    *display register
00002CB6                          2911  
00002CB6  43F9 00004109           2912              LEA     DISP_CP,A1   *display )
00002CBC  103C 000E               2913              MOVE.B  #14,D0
00002CC0  4E4F                    2914              TRAP    #15
00002CC2                          2915              
00002CC2  4E75                    2916              RTS
00002CC4                          2917  
00002CC4                          2918  *---------------------------------------------------------------------------*
00002CC4                          2919  * MODE111: decode and display source mode absolute/immediate
00002CC4                          2920  *---------------------------------------------------------------------------*
00002CC4                          2921  MODE111     * abs/immediate
00002CC4                          2922              * clear registers to store temp data
00002CC4  4280                    2923              CLR.L   D0                      
00002CC6  4281                    2924              CLR.L   D1                      
00002CC8  207C 00000000           2925              MOVEA.L #0, A0                  
00002CCE  227C 00000000           2926              MOVEA.L #0, A1                  
00002CD4  2205                    2927              MOVE.L  D5,D1
00002CD6                          2928              
00002CD6                          2929              * retrieve source register for MODE 111
00002CD6  E389                    2930              LSL.L   #1,D1   * shift the bits to left by 1
00002CD8  0281 0000000E           2931              ANDI.L  #$E,D1  * mask the first 4 bits 
00002CDE  0C01 0000               2932              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002CE2  6700 003E               2933              BEQ     WORDMODE
00002CE6  0C01 0002               2934              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002CEA  6700 0062               2935              BEQ     LONGMODE
00002CEE  0C01 0008               2936              CMPI.B  #8, D1  * if it's 1000, immediate data
00002CF2  6700 0086               2937              BEQ     IMMEDIATE
00002CF6                          2938       
00002CF6                          2939  *---------------------------------------------------------------------------*
00002CF6                          2940  * D_MODE111: decode and display dest mode absolute/immediate
00002CF6                          2941  *---------------------------------------------------------------------------*           
00002CF6                          2942  D_MODE111   * abs
00002CF6                          2943              * clear registers to store temp data
00002CF6  4280                    2944              CLR.L   D0                      
00002CF8  4281                    2945              CLR.L   D1                      
00002CFA  207C 00000000           2946              MOVEA.L #0, A0                  
00002D00  227C 00000000           2947              MOVEA.L #0, A1                  
00002D06  2205                    2948              MOVE.L  D5,D1
00002D08                          2949              
00002D08                          2950              * retrieve dest register for MODE 111
00002D08  EC89                    2951              LSR.L   #6,D1   * shift the bits to right by 6
00002D0A  E689                    2952              LSR.L   #3,D1   * shift the bits to right by extra 3
00002D0C  0201 0001               2953              ANDI.B  #1,D1   * mask the first 2 bits 
00002D10  0C01 0000               2954              CMPI.B  #0, D1  * if it's 000, absolute word address
00002D14  6700 000C               2955              BEQ     WORDMODE
00002D18  0C01 0001               2956              CMPI.B  #1, D1  * if it's 001, absolute long address
00002D1C  6700 0030               2957              BEQ     LONGMODE
00002D20                          2958              *JSR     OP_DATA *not sure..
00002D20  4E75                    2959              RTS
00002D22                          2960  
00002D22                          2961  
00002D22                          2962  *---------------------------------------------------------------------------*
00002D22                          2963  * WORDMODE: absolute word address
00002D22                          2964  *---------------------------------------------------------------------------*
00002D22  43F9 000040F5           2965  WORDMODE    LEA     DISP_HEX,A1
00002D28  103C 000E               2966              MOVE.B  #14,D0
00002D2C  4E4F                    2967              TRAP    #15
00002D2E                          2968              
00002D2E  4285                    2969              CLR.L   D5
00002D30  3A1D                    2970              MOVE.W  (A5)+,D5
00002D32                          2971              
00002D32  43F9 00003DD3           2972              LEA     TMPOUTPUT,A1
00002D38  2205                    2973              MOVE.L  D5,D1
00002D3A  7404                    2974              MOVE.L  #4,D2       *move word size 4
00002D3C  4EB8 11B2               2975              JSR     HEX2ASCII
00002D40  43F9 00003DD3           2976              LEA     TMPOUTPUT,A1
00002D46  103C 000E               2977              MOVE.B  #14,D0
00002D4A  4E4F                    2978              TRAP    #15
00002D4C                          2979              
00002D4C  4E75                    2980              RTS
00002D4E                          2981  
00002D4E                          2982  *---------------------------------------------------------------------------*
00002D4E                          2983  * LONGMODE: absolute long address
00002D4E                          2984  *---------------------------------------------------------------------------*
00002D4E  43F9 000040F5           2985  LONGMODE    LEA     DISP_HEX,A1
00002D54  103C 000E               2986              MOVE.B  #14,D0
00002D58  4E4F                    2987              TRAP    #15
00002D5A                          2988              
00002D5A  4285                    2989              CLR.L   D5
00002D5C  2A1D                    2990              MOVE.L  (A5)+,D5
00002D5E                          2991              
00002D5E  43F9 00003DD3           2992              LEA     TMPOUTPUT,A1
00002D64  2205                    2993              MOVE.L  D5,D1
00002D66  7408                    2994              MOVE.L  #8,D2           *move longword size 8
00002D68  4EB8 11B2               2995              JSR     HEX2ASCII
00002D6C  43F9 00003DD3           2996              LEA     TMPOUTPUT,A1
00002D72  103C 000E               2997              MOVE.B  #14,D0
00002D76  4E4F                    2998              TRAP    #15
00002D78                          2999              
00002D78  4E75                    3000              RTS
00002D7A                          3001  
00002D7A                          3002  
00002D7A                          3003  *---------------------------------------------------------------------------*
00002D7A                          3004  * IMMEDIATE: immediate address
00002D7A                          3005  *---------------------------------------------------------------------------*
00002D7A  43F9 0000411B           3006  IMMEDIATE   LEA     DISP_LB,A1
00002D80  103C 000E               3007              MOVE.B  #14,D0
00002D84  4E4F                    3008              TRAP    #15
00002D86  43F9 000040F5           3009              LEA     DISP_HEX,A1
00002D8C  103C 000E               3010              MOVE.B  #14,D0
00002D90  4E4F                    3011              TRAP    #15
00002D92                          3012              
00002D92                          3013              * check for size
00002D92  0C04 0000               3014              CMPI.B  #0,D4
00002D96  6700 0012               3015              BEQ     IMMD_B
00002D9A  0C04 0001               3016              CMPI.B  #1,D4
00002D9E  6700 002A               3017              BEQ     IMMD_W
00002DA2  0C04 0002               3018              CMPI.B  #2,D4
00002DA6  6700 0042               3019              BEQ     IMMD_L
00002DAA                          3020  
00002DAA                          3021  IMMD_B
00002DAA  4285                    3022              CLR.L   D5
00002DAC  3A1D                    3023              MOVE.W  (A5)+,D5
00002DAE                          3024              
00002DAE  43F9 00003DD3           3025              LEA     TMPOUTPUT,A1
00002DB4  2205                    3026              MOVE.L  D5,D1
00002DB6  7402                    3027              MOVE.L  #2,D2
00002DB8  4EB8 11B2               3028              JSR     HEX2ASCII
00002DBC  43F9 00003DD3           3029              LEA     TMPOUTPUT,A1
00002DC2  103C 000E               3030              MOVE.B  #14,D0
00002DC6  4E4F                    3031              TRAP    #15
00002DC8  4E75                    3032              RTS
00002DCA                          3033              
00002DCA                          3034  IMMD_W
00002DCA  4285                    3035              CLR.L   D5
00002DCC  3A1D                    3036              MOVE.W  (A5)+,D5
00002DCE                          3037              
00002DCE  43F9 00003DD3           3038              LEA     TMPOUTPUT,A1
00002DD4  2205                    3039              MOVE.L  D5,D1
00002DD6  7404                    3040              MOVE.L  #4,D2
00002DD8  4EB8 11B2               3041              JSR     HEX2ASCII
00002DDC  43F9 00003DD3           3042              LEA     TMPOUTPUT,A1
00002DE2  103C 000E               3043              MOVE.B  #14,D0
00002DE6  4E4F                    3044              TRAP    #15
00002DE8  4E75                    3045              RTS
00002DEA                          3046              
00002DEA                          3047  
00002DEA                          3048  IMMD_L
00002DEA  4285                    3049              CLR.L   D5
00002DEC  3A1D                    3050              MOVE.W  (A5)+,D5
00002DEE                          3051              
00002DEE  43F9 00003DD3           3052              LEA     TMPOUTPUT,A1
00002DF4  2205                    3053              MOVE.L  D5,D1
00002DF6  7408                    3054              MOVE.L  #8,D2
00002DF8  4EB8 11B2               3055              JSR     HEX2ASCII
00002DFC  43F9 00003DD3           3056              LEA     TMPOUTPUT,A1
00002E02  103C 000E               3057              MOVE.B  #14,D0
00002E06  4E4F                    3058              TRAP    #15
00002E08  4E75                    3059              RTS
00002E0A                          3060  
00002E0A                          3061  
00002E0A                          3062  *---------------------------------------------------------------------------*
00002E0A                          3063  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00002E0A                          3064  *---------------------------------------------------------------------------*
00002E0A                          3065  DEST_REGISTER
00002E0A                          3066              * clear registers to store temp data
00002E0A  4280                    3067              CLR.L   D0                      
00002E0C  4281                    3068              CLR.L   D1                      
00002E0E  207C 00000000           3069              MOVEA.L #0, A0                  
00002E14  227C 00000000           3070              MOVEA.L #0, A1 
00002E1A                          3071              
00002E1A  2205                    3072              MOVE.L  D5,D1
00002E1C  EC89                    3073              LSR.L   #6,D1
00002E1E  E689                    3074              LSR.L   #3,D1
00002E20  0281 00000007           3075              ANDI.L  #7,D1
00002E26                          3076              
00002E26  0C01 0000               3077              CMPI.B  #0,D1
00002E2A  6700 0092               3078              BEQ     REG_0
00002E2E  0C01 0001               3079              CMPI.B  #1,D1
00002E32  6700 0098               3080              BEQ     REG_1
00002E36  0C01 0002               3081              CMPI.B  #2,D1
00002E3A  6700 009E               3082              BEQ     REG_2
00002E3E  0C01 0003               3083              CMPI.B  #3,D1
00002E42  6700 00A4               3084              BEQ     REG_3
00002E46  0C01 0004               3085              CMPI.B  #4,D1
00002E4A  6700 00AA               3086              BEQ     REG_4
00002E4E  0C01 0005               3087              CMPI.B  #5,D1
00002E52  6700 00B0               3088              BEQ     REG_5
00002E56  0C01 0006               3089              CMPI.B  #6,D1
00002E5A  6700 00B6               3090              BEQ     REG_6
00002E5E  0C01 0007               3091              CMPI.B  #7,D1
00002E62  6700 00BC               3092              BEQ     REG_7
00002E66                          3093  
00002E66                          3094  *---------------------------------------------------------------------------*
00002E66                          3095  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00002E66                          3096  *---------------------------------------------------------------------------*           
00002E66                          3097  SRC_REGISTER 
00002E66                          3098              * clear registers to store temp data
00002E66  4280                    3099              CLR.L   D0                      
00002E68  4281                    3100              CLR.L   D1                      
00002E6A  207C 00000000           3101              MOVEA.L #0, A0                  
00002E70  227C 00000000           3102              MOVEA.L #0, A1                  
00002E76                          3103              
00002E76  2205                    3104              MOVE.L  D5,D1   * temp store the processing data
00002E78  0281 00000007           3105              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00002E7E                          3106              
00002E7E  0C01 0000               3107              CMPI.B  #0,D1
00002E82  6700 003A               3108              BEQ     REG_0
00002E86  0C01 0001               3109              CMPI.B  #1,D1
00002E8A  6700 0040               3110              BEQ     REG_1
00002E8E  0C01 0002               3111              CMPI.B  #2,D1
00002E92  6700 0046               3112              BEQ     REG_2
00002E96  0C01 0003               3113              CMPI.B  #3,D1
00002E9A  6700 004C               3114              BEQ     REG_3
00002E9E  0C01 0004               3115              CMPI.B  #4,D1
00002EA2  6700 0052               3116              BEQ     REG_4
00002EA6  0C01 0005               3117              CMPI.B  #5,D1
00002EAA  6700 0058               3118              BEQ     REG_5
00002EAE  0C01 0006               3119              CMPI.B  #6,D1
00002EB2  6700 005E               3120              BEQ     REG_6
00002EB6  0C01 0007               3121              CMPI.B  #7,D1
00002EBA  6700 0064               3122              BEQ     REG_7
00002EBE                          3123  
00002EBE                          3124  *---------------------------------------------------------------------------*
00002EBE                          3125  * REG_0 ~ REG_7: display register 0 to 7
00002EBE                          3126  *---------------------------------------------------------------------------*
00002EBE  43F9 00004120           3127  REG_0       LEA     DISP_0,A1
00002EC4  103C 000E               3128              MOVE.B  #14,D0
00002EC8  4E4F                    3129              TRAP    #15
00002ECA  4E75                    3130              RTS
00002ECC                          3131              
00002ECC  43F9 00004122           3132  REG_1       LEA     DISP_1,A1
00002ED2  103C 000E               3133              MOVE.B  #14,D0
00002ED6  4E4F                    3134              TRAP    #15
00002ED8  4E75                    3135              RTS
00002EDA                          3136              
00002EDA                          3137  
00002EDA  43F9 00004124           3138  REG_2       LEA     DISP_2,A1
00002EE0  103C 000E               3139              MOVE.B  #14,D0
00002EE4  4E4F                    3140              TRAP    #15
00002EE6  4E75                    3141              RTS
00002EE8                          3142            
00002EE8  43F9 00004126           3143  REG_3       LEA     DISP_3,A1
00002EEE  103C 000E               3144              MOVE.B  #14,D0
00002EF2  4E4F                    3145              TRAP    #15
00002EF4  4E75                    3146              RTS
00002EF6                          3147              
00002EF6  43F9 00004128           3148  REG_4       LEA     DISP_4,A1
00002EFC  103C 000E               3149              MOVE.B  #14,D0
00002F00  4E4F                    3150              TRAP    #15
00002F02  4E75                    3151              RTS
00002F04                          3152              
00002F04  43F9 0000412A           3153  REG_5       LEA     DISP_5,A1
00002F0A  103C 000E               3154              MOVE.B  #14,D0
00002F0E  4E4F                    3155              TRAP    #15
00002F10  4E75                    3156              RTS
00002F12                          3157              
00002F12  43F9 0000412C           3158  REG_6       LEA     DISP_6,A1
00002F18  103C 000E               3159              MOVE.B  #14,D0
00002F1C  4E4F                    3160              TRAP    #15
00002F1E  4E75                    3161              RTS
00002F20                          3162              
00002F20  43F9 0000412E           3163  REG_7       LEA     DISP_7,A1
00002F26  103C 000E               3164              MOVE.B  #14,D0
00002F2A  4E4F                    3165              TRAP    #15
00002F2C  4E75                    3166              RTS
00002F2E                          3167              
00002F2E                          3168  *---------------------------------------------------------------------------*
00002F2E                          3169  * REPEAT : Ask user whether they wish to run the program again
00002F2E                          3170  *---------------------------------------------------------------------------*           
00002F2E  4246                    3171  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00002F30  43F9 00003BF9           3172              LEA     REPEATMSG,A1
00002F36  103C 000E               3173              MOVE.B  #14,D0
00002F3A  4E4F                    3174              TRAP    #15
00002F3C                          3175              
00002F3C  43F9 00003D83           3176              LEA     TMPINPUT,A1             * allocate space to temp store user input
00002F42  103C 0002               3177              MOVE.B  #2,D0
00002F46  4E4F                    3178              TRAP    #15
00002F48                          3179  
00002F48  0C01 0001               3180              CMPI.B  #1,D1                   * check for length of user input
00002F4C  66E0                    3181              BNE     REPEAT                  * return to the beginning of the function if unequal
00002F4E                          3182              
00002F4E  0C11 0059               3183              CMPI.B  #$59,(A1)               * compare the input with Y    
00002F52  6700 E0B6               3184              BEQ     PROGLP                  * repeat the program
00002F56                          3185              
00002F56  0C11 0079               3186              CMPI.B  #$79,(A1)               * compare the input with y    
00002F5A  6700 E0AE               3187              BEQ     PROGLP                  * repeat the program
00002F5E                          3188              
00002F5E  0C11 004E               3189              CMPI.B  #$4E,(A1)               * compare the input with N    
00002F62  6700 0928               3190              BEQ     TERMINATE               * finish program
00002F66                          3191              
00002F66  0C11 006E               3192              CMPI.B  #$6E,(A1)               * compare the input with n    
00002F6A  6700 0920               3193              BEQ     TERMINATE               * finish program
00002F6E                          3194              
00002F6E  60BE                    3195              BRA     REPEAT                  * invalid input/repeat the function
00002F70                          3196  
00002F70                          3197  *---------------------------------------------------------------------------*
00002F70                          3198  * EA DECODING INTERFACE
00002F70                          3199  * [A0] - RESERVED FOR USE
00002F70                          3200  * [D2] - RESERVED FOR USE
00002F70                          3201  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00002F70                          3202  *---------------------------------------------------------------------------*
00002F70                          3203  GET_EA_EA_SRC
00002F70                          3204      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00002F70                          3205      
00002F70                          3206      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00002F70  2405                    3207      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00002F72  E68A                    3208      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00002F74  23C2 00004146           3209      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00002F7A  7407                    3210      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00002F7C  C5B9 00004146           3211      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00002F82                          3212                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00002F82                          3213      
00002F82                          3214      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00002F82                          3215      *DESTINATION REGISTER FORMAT STANDARD         *
00002F82                          3216      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00002F82                          3217      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00002F82                          3218      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00002F82                          3219      *0 - Dn                                       *
00002F82                          3220      *1 - An                                       *
00002F82                          3221      *2 - (An)                                     *
00002F82                          3222      *3 - (An)+                                    *
00002F82                          3223      *4 - -(An)                                    *
00002F82                          3224      *5 - (XXX).W                                  *
00002F82                          3225      *6 - (XXX).L                                  *
00002F82                          3226      *7 - #<data>                                  *
00002F82                          3227      ***********************************************
00002F82                          3228      
00002F82                          3229      *** Check if source ...  <ea> = Dn
00002F82                          3230  CHECK0    
00002F82  41F9 00004136           3231            LEA     TEMP_REGISTER_FORMAT,A0
00002F88  1439 00004135           3232            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002F8E  1082                    3233            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002F90  0239 0001 00004136      3234            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00002F98  0C39 0001 00004136      3235            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00002FA0  6700 006A               3236            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002FA4  0CB9 00000000 00004146  3237            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00002FAE  6600 005C               3238            BNE     CHECK1
00002FB2                          3239            
00002FB2                          3240            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002FB2  163C 0020               3241            MOVE.B    #' ',D3
00002FB6  6100 0856               3242            BSR       PUSH_STACK
00002FBA  163C 0044               3243            MOVE.B    #'D',D3
00002FBE  6100 084E               3244            BSR       PUSH_STACK
00002FC2                          3245  
00002FC2                          3246            *FIND REGISTER NUMBER END LOCATION*  
00002FC2  13F9 00004138 0000413E  3247            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002FCC  0239 000F 0000413E      3248            AND.B   #$0F,VAR_BYTE_END
00002FD4                          3249            
00002FD4                          3250            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002FD4  23C5 00004142           3251            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002FDA  1439 0000413E           3252            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002FE0                          3253            
00002FE0                          3254            *INTITIALIZE FOR BIT SHIFTING
00002FE0  41F9 00004142           3255            LEA     VAR_TEMP_CLEANCOPY,A0
00002FE6  2639 00004142           3256            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002FEC                          3257  LOOP_SHIFTING
00002FEC  0C02 0000               3258            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002FF0  6700 0008               3259            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002FF4  E24B                    3260            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002FF6  5302                    3261            SUB.B   #1,D2                     *DECREMENT COUNTER
00002FF8  60F2                    3262            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00002FFA                          3263  MASKING_NEXT
00002FFA  C6BC 00000007           3264            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003000  0603 0030               3265            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003004  6100 0808               3266            BSR     PUSH_STACK                *PUSH TO STACK
00003008                          3267            
00003008  6000 0394               3268            BRA     GET_SRC_SUCCESS           *RETURN          
0000300C                          3269            
0000300C                          3270            
0000300C                          3271            *** Check if source ...  <ea> = An
0000300C  41F9 00004136           3272  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00003012  1439 00004135           3273            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003018  1082                    3274            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000301A  0239 0002 00004136      3275            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003022  0C39 0002 00004136      3276            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
0000302A  6700 006A               3277            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000302E  0CB9 00000001 00004146  3278            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003038  6600 005C               3279            BNE     CHECK2
0000303C                          3280            
0000303C                          3281            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000303C  163C 0020               3282            MOVE.B    #' ',D3
00003040  6100 07CC               3283            BSR       PUSH_STACK
00003044  163C 0041               3284            MOVE.B    #'A',D3
00003048  6100 07C4               3285            BSR       PUSH_STACK
0000304C                          3286  
0000304C                          3287            
0000304C                          3288            *FIND REGISTER NUMBER END LOCATION*  
0000304C  13F9 00004138 0000413E  3289            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003056  0239 000F 0000413E      3290            AND.B   #$0F,VAR_BYTE_END
0000305E                          3291            
0000305E                          3292            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000305E  23C5 00004142           3293            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003064  1439 0000413E           3294            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000306A                          3295            
0000306A                          3296            *INTITIALIZE FOR BIT SHIFTING
0000306A  41F9 00004142           3297            LEA     VAR_TEMP_CLEANCOPY,A0
00003070  2639 00004142           3298            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003076                          3299  LOOP_SHIFTING1
00003076  0C02 0000               3300            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000307A  6700 0008               3301            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000307E  E24B                    3302            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003080  5302                    3303            SUB.B   #1,D2                     *DECREMENT COUNTER
00003082  60F2                    3304            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003084                          3305  MASKING_NEXT1
00003084  C6BC 00000007           3306            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000308A  0603 0030               3307            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000308E  6100 077E               3308            BSR     PUSH_STACK                *PUSH TO STACK
00003092                          3309            
00003092  6000 030A               3310            BRA     GET_SRC_SUCCESS                   *RETURN 
00003096                          3311            
00003096                          3312            
00003096                          3313            
00003096                          3314            
00003096                          3315            *** Check if source ...  <ea> = (An)       
00003096  41F9 00004136           3316  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
0000309C  1439 00004135           3317            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000030A2  1082                    3318            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000030A4  0239 0004 00004136      3319            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000030AC  0C39 0004 00004136      3320            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000030B4  6700 007A               3321            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000030B8  0CB9 00000002 00004146  3322            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000030C2  6600 006C               3323            BNE     CHECK3
000030C6                          3324            
000030C6                          3325            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000030C6  163C 0020               3326            MOVE.B    #' ',D3
000030CA  6100 0742               3327            BSR       PUSH_STACK
000030CE  163C 0028               3328            MOVE.B    #'(',D3
000030D2  6100 073A               3329            BSR       PUSH_STACK
000030D6  163C 0041               3330            MOVE.B    #'A',D3
000030DA  6100 0732               3331            BSR       PUSH_STACK
000030DE                          3332  
000030DE                          3333            
000030DE                          3334            *FIND REGISTER NUMBER END LOCATION*  
000030DE  13F9 00004138 0000413E  3335            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000030E8  0239 000F 0000413E      3336            AND.B   #$0F,VAR_BYTE_END
000030F0                          3337            
000030F0                          3338            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000030F0  23C5 00004142           3339            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000030F6  1439 0000413E           3340            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000030FC                          3341            
000030FC                          3342            *INTITIALIZE FOR BIT SHIFTING
000030FC  41F9 00004142           3343            LEA     VAR_TEMP_CLEANCOPY,A0
00003102  2639 00004142           3344            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003108                          3345  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003108  0C02 0000               3346            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000310C  6700 0008               3347            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003110  E24B                    3348            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003112  5302                    3349            SUB.B   #1,D2                     *DECREMENT COUNTER
00003114  60F2                    3350            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003116                          3351  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003116  0283 00000007           3352            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000311C  0603 0030               3353            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003120  6100 06EC               3354            BSR     PUSH_STACK                *PUSH TO STACK
00003124                          3355            
00003124  163C 0029               3356            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003128  6100 06E4               3357            BSR       PUSH_STACK
0000312C                          3358            
0000312C  6000 0270               3359            BRA     GET_SRC_SUCCESS                   *RETURN 
00003130                          3360  
00003130                          3361            
00003130                          3362            
00003130                          3363                      
00003130                          3364  *** Check if source ...  <ea> = (An)+       
00003130  41F9 00004136           3365  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003136  1439 00004135           3366            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000313C  1082                    3367            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000313E  0239 0008 00004136      3368            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003146  0C39 0008 00004136      3369            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
0000314E  6700 0082               3370            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003152  0CB9 00000003 00004146  3371            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000315C  6600 0074               3372            BNE     CHECK4
00003160                          3373            
00003160                          3374            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003160  163C 0020               3375            MOVE.B    #' ',D3
00003164  6100 06A8               3376            BSR       PUSH_STACK
00003168  163C 0028               3377            MOVE.B    #'(',D3
0000316C  6100 06A0               3378            BSR       PUSH_STACK
00003170  163C 0041               3379            MOVE.B    #'A',D3
00003174  6100 0698               3380            BSR       PUSH_STACK
00003178                          3381  
00003178                          3382            
00003178                          3383            *FIND REGISTER NUMBER END LOCATION*  
00003178  13F9 00004138 0000413E  3384            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003182  0239 000F 0000413E      3385            ANDI.B   #$0F,VAR_BYTE_END
0000318A                          3386            
0000318A                          3387            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000318A  23C5 00004142           3388            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003190  1439 0000413E           3389            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003196                          3390            
00003196                          3391            *INTITIALIZE FOR BIT SHIFTING
00003196  41F9 00004142           3392            LEA     VAR_TEMP_CLEANCOPY,A0
0000319C  2639 00004142           3393            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000031A2                          3394            
000031A2                          3395  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
000031A2  0C02 0000               3396            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000031A6  6700 0008               3397            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000031AA  E24B                    3398            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000031AC  5302                    3399            SUBI.B   #1,D2                     *DECREMENT COUNTER
000031AE  60F2                    3400            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
000031B0                          3401                                               *change: NAME OF LABEL*
000031B0                          3402  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000031B0  0283 00000007           3403            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000031B6  0603 0030               3404            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000031BA  6100 0652               3405            BSR     PUSH_STACK                *PUSH TO STACK
000031BE                          3406            
000031BE  163C 0029               3407            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000031C2  6100 064A               3408            BSR       PUSH_STACK
000031C6  163C 002B               3409            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000031CA  6100 0642               3410            BSR       PUSH_STACK
000031CE                          3411            
000031CE  6000 01CE               3412            BRA       GET_SRC_SUCCESS                   *RETURN 
000031D2                          3413  
000031D2                          3414            
000031D2                          3415            
000031D2                          3416                      
000031D2                          3417            *** Check if source ...  <ea> = -(An)       
000031D2  41F9 00004136           3418  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
000031D8  1439 00004135           3419            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000031DE  1082                    3420            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000031E0  0239 0010 00004136      3421            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000031E8  0C39 0010 00004136      3422            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000031F0  6700 0082               3423            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000031F4  0CB9 00000004 00004146  3424            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000031FE  6600 0074               3425            BNE     CHECK7
00003202                          3426            
00003202                          3427            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003202  163C 0020               3428            MOVE.B    #' ',D3
00003206  6100 0606               3429            BSR       PUSH_STACK
0000320A  163C 002D               3430            MOVE.B    #'-',D3
0000320E  6100 05FE               3431            BSR       PUSH_STACK
00003212  163C 0028               3432            MOVE.B    #'(',D3
00003216  6100 05F6               3433            BSR       PUSH_STACK
0000321A  163C 0041               3434            MOVE.B    #'A',D3
0000321E  6100 05EE               3435            BSR       PUSH_STACK
00003222                          3436  
00003222                          3437            
00003222                          3438            *FIND REGISTER NUMBER END LOCATION*  
00003222  13F9 00004138 0000413E  3439            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000322C  0239 000F 0000413E      3440            AND.B   #$0F,VAR_BYTE_END
00003234                          3441            
00003234                          3442            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003234  23C5 00004142           3443            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000323A  1439 0000413E           3444            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003240                          3445            
00003240                          3446            *INTITIALIZE FOR BIT SHIFTING
00003240  41F9 00004142           3447            LEA     VAR_TEMP_CLEANCOPY,A0
00003246  2639 00004142           3448            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000324C                          3449            
0000324C                          3450  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
0000324C  0C02 0000               3451            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003250  6700 0008               3452            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003254  E24B                    3453            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003256  5302                    3454            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003258  60F2                    3455            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
0000325A                          3456                                               *change: NAME OF LABEL*
0000325A                          3457  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
0000325A  0283 00000007           3458            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003260  0603 0030               3459            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003264  6100 05A8               3460            BSR     PUSH_STACK                *PUSH TO STACK
00003268                          3461            
00003268  163C 0029               3462            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000326C  6100 05A0               3463            BSR       PUSH_STACK
00003270                          3464            
00003270  6000 012C               3465            BRA     GET_SRC_SUCCESS                   *RETURN
00003274                          3466            
00003274                          3467                      
00003274                          3468            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003274  0CB9 00000007 00004146  3469  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
0000327E  6600 011A               3470            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003282                          3471                   
00003282                          3472            *NEXT: (MODE == 111) 
00003282                          3473            *NOW: CHECK FOR SRC REGISTER 
00003282                          3474                  *(000 = (xxx).W)
00003282                          3475                  *(001 = (xxx).L)
00003282                          3476                  *(010 = #<data>)
00003282                          3477                  
00003282                          3478            *FIND REGISTER NUMBER END LOCATION*  
00003282  13F9 00004138 0000413E  3479            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000328C  0239 000F 0000413E      3480            AND.B   #$0F,VAR_BYTE_END
00003294                          3481            
00003294                          3482            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003294  23C5 00004142           3483            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000329A  1439 0000413E           3484            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000032A0                          3485            
000032A0                          3486            *INTITIALIZE FOR BIT SHIFTING
000032A0  41F9 00004142           3487            LEA     VAR_TEMP_CLEANCOPY,A0
000032A6  2C39 00004142           3488            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000032AC                          3489  SRC_LOOP_SHIFTING
000032AC  0C02 0000               3490            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000032B0  6700 0008               3491            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000032B4  E24E                    3492            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000032B6  5302                    3493            SUB.B   #1,D2                     *DECREMENT COUNTER
000032B8  60F2                    3494            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
000032BA                          3495  SRC_MASKING_NEXT
000032BA  CCBC 00000007           3496            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000032C0                          3497           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000032C0                          3498           
000032C0                          3499  CHECK_WORD  
000032C0  41F9 00004136           3500            LEA     TEMP_REGISTER_FORMAT,A0
000032C6  1439 00004135           3501            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000032CC  1082                    3502            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000032CE  0239 0020 00004136      3503            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000032D6  0C39 0020 00004136      3504            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000032DE  6700 0026               3505            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000032E2  0C06 0000               3506            CMPI.B  #0,D6                          
000032E6  6600 001E               3507            BNE     CHECK_LONG 
000032EA                          3508            
000032EA                          3509            *IT IS A WORD AT THIS POINT*
000032EA                          3510            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000032EA  163C 0020               3511            MOVE.B    #' ',D3
000032EE  6100 051E               3512            BSR       PUSH_STACK
000032F2  163C 0024               3513            MOVE.B    #'$',D3
000032F6  6100 0516               3514            BSR       PUSH_STACK
000032FA  321D                    3515            MOVE.W    (A5)+,D1
000032FC  7404                    3516            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000032FE  6100 DEF4               3517            BSR       HEX2ASCII2STACK
00003302  6000 009A               3518            BRA     GET_SRC_SUCCESS
00003306                          3519  
00003306                          3520  CHECK_LONG
00003306  41F9 00004136           3521            LEA     TEMP_REGISTER_FORMAT,A0
0000330C  1439 00004135           3522            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003312  1082                    3523            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003314  0239 0040 00004136      3524            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000331C  0C39 0040 00004136      3525            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003324  6700 002E               3526            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003328  0C06 0001               3527            CMPI.B  #1,D6                          
0000332C  6600 0026               3528            BNE     CHECK_IMMEDIATE  
00003330                          3529  
00003330                          3530            *IT IS A WORD AT THIS POINT*
00003330                          3531            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003330  163C 0020               3532            MOVE.B    #' ',D3
00003334  6100 04D8               3533            BSR       PUSH_STACK
00003338  163C 0024               3534            MOVE.B    #'$',D3
0000333C  6100 04D0               3535            BSR       PUSH_STACK
00003340  321D                    3536            MOVE.W    (A5)+,D1
00003342  7404                    3537            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003344  6100 DEAE               3538            BSR       HEX2ASCII2STACK
00003348  321D                    3539            MOVE.W    (A5)+,D1
0000334A  7404                    3540            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000334C  6100 DEA6               3541            BSR       HEX2ASCII2STACK
00003350  6000 004C               3542            BRA     GET_SRC_SUCCESS
00003354                          3543            
00003354                          3544  CHECK_IMMEDIATE
00003354  41F9 00004136           3545            LEA     TEMP_REGISTER_FORMAT,A0
0000335A  1439 00004135           3546            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003360  1082                    3547            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003362  0239 0080 00004136      3548            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000336A  0C39 0080 00004136      3549            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003372  6700 0026               3550            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003376  0C06 0004               3551            CMPI.B  #4,D6                          
0000337A  6600 001E               3552            BNE     GET_SRC_FAILED 
0000337E                          3553  
0000337E                          3554            *IT IS A WORD AT THIS POINT*
0000337E                          3555            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000337E  163C 0020               3556            MOVE.B    #' ',D3
00003382  6100 048A               3557            BSR       PUSH_STACK
00003386  163C 0023               3558            MOVE.B    #'#',D3
0000338A  6100 0482               3559            BSR       PUSH_STACK
0000338E  321D                    3560            MOVE.W    (A5)+,D1
00003390  7404                    3561            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003392  6100 DE60               3562            BSR       HEX2ASCII2STACK
00003396  6000 0006               3563            BRA     GET_SRC_SUCCESS
0000339A                          3564            
0000339A                          3565  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
0000339A  7801                    3566            MOVE.L #1,D4
0000339C  4E75                    3567            RTS
0000339E                          3568  GET_SRC_SUCCESS 
0000339E  4E75                    3569            RTS
000033A0                          3570                                 
000033A0                          3571      
000033A0                          3572  
000033A0                          3573  
000033A0                          3574  
000033A0                          3575  
000033A0                          3576  
000033A0                          3577  
000033A0                          3578  GET_EA_EA_DEST
000033A0                          3579  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000033A0                          3580      
000033A0                          3581      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000033A0  2405                    3582      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000033A2  EC8A                    3583      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
000033A4  23C2 00004146           3584      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000033AA  7407                    3585      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000033AC  C5B9 00004146           3586      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000033B2                          3587                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000033B2                          3588      
000033B2                          3589      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000033B2                          3590      *DESTINATION REGISTER FORMAT STANDARD         *
000033B2                          3591      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000033B2                          3592      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000033B2                          3593      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000033B2                          3594      *0 - Dn                                       *
000033B2                          3595      *1 - An                                       *
000033B2                          3596      *2 - (An)                                     *
000033B2                          3597      *3 - (An)+                                    *
000033B2                          3598      *4 - -(An)                                    *
000033B2                          3599      *5 - (XXX).W                                  *
000033B2                          3600      *6 - (XXX).L                                  *
000033B2                          3601      *7 - #<data>                                  *
000033B2                          3602      ***********************************************
000033B2                          3603      
000033B2                          3604      *** Check if source ...  <ea> = Dn
000033B2                          3605  DEST_CHECK0    
000033B2  41F9 00004136           3606            LEA     TEMP_REGISTER_FORMAT,A0
000033B8  1439 00004134           3607            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000033BE  1082                    3608            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000033C0  0239 0001 00004136      3609            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000033C8  0C39 0001 00004136      3610            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
000033D0  6700 006A               3611            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000033D4  0CB9 00000000 00004146  3612            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000033DE  6600 005C               3613            BNE     DEST_CHECK1
000033E2                          3614            
000033E2                          3615            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000033E2  163C 0020               3616            MOVE.B    #' ',D3
000033E6  6100 0426               3617            BSR       PUSH_STACK
000033EA  163C 0044               3618            MOVE.B    #'D',D3
000033EE  6100 041E               3619            BSR       PUSH_STACK
000033F2                          3620  
000033F2                          3621            *FIND REGISTER NUMBER END LOCATION*  
000033F2  13F9 00004137 0000413E  3622            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000033FC  0239 000F 0000413E      3623            AND.B   #$0F,VAR_BYTE_END
00003404                          3624            
00003404                          3625            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003404  23C5 00004142           3626            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000340A  1439 0000413E           3627            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003410                          3628            
00003410                          3629            *INTITIALIZE FOR BIT SHIFTING
00003410  41F9 00004142           3630            LEA     VAR_TEMP_CLEANCOPY,A0
00003416  2639 00004142           3631            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000341C                          3632  DEST_LOOP_SHIFTING
0000341C  0C02 0000               3633            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003420  6700 0008               3634            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003424  E24B                    3635            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003426  5302                    3636            SUB.B   #1,D2                     *DECREMENT COUNTER
00003428  60F2                    3637            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
0000342A                          3638  DEST_MASKING_NEXT
0000342A  C6BC 00000007           3639            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003430  0603 0030               3640            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003434  6100 03D8               3641            BSR     PUSH_STACK                *PUSH TO STACK
00003438                          3642            
00003438  6000 0394               3643            BRA     GET_DST_SUCCESS           *RETURN          
0000343C                          3644            
0000343C                          3645            
0000343C                          3646            *** Check if source ...  <ea> = An
0000343C                          3647  DEST_CHECK1    
0000343C  41F9 00004136           3648            LEA     TEMP_REGISTER_FORMAT,A0
00003442  1439 00004134           3649            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003448  1082                    3650            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000344A  0239 0002 00004136      3651            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003452  0C39 0002 00004136      3652            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
0000345A  6700 006A               3653            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000345E  0CB9 00000001 00004146  3654            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003468  6600 005C               3655            BNE     DEST_CHECK2
0000346C                          3656            
0000346C                          3657            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000346C  163C 0020               3658            MOVE.B    #' ',D3
00003470  6100 039C               3659            BSR       PUSH_STACK
00003474  163C 0041               3660            MOVE.B    #'A',D3
00003478  6100 0394               3661            BSR       PUSH_STACK
0000347C                          3662  
0000347C                          3663            
0000347C                          3664            *FIND REGISTER NUMBER END LOCATION*  
0000347C  13F9 00004137 0000413E  3665            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003486  0239 000F 0000413E      3666            AND.B   #$0F,VAR_BYTE_END
0000348E                          3667            
0000348E                          3668            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000348E  23C5 00004142           3669            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003494  1439 0000413E           3670            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000349A                          3671            
0000349A                          3672            *INTITIALIZE FOR BIT SHIFTING
0000349A  41F9 00004142           3673            LEA     VAR_TEMP_CLEANCOPY,A0
000034A0  2639 00004142           3674            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000034A6                          3675  DEST_LOOP_SHIFTING1
000034A6  0C02 0000               3676            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000034AA  6700 0008               3677            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000034AE  E24B                    3678            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000034B0  5302                    3679            SUB.B   #1,D2                     *DECREMENT COUNTER
000034B2  60F2                    3680            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
000034B4                          3681  DEST_MASKING_NEXT1
000034B4  C6BC 00000007           3682            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000034BA  0603 0030               3683            ADD.B   #$30,D3                   *CONVERT TO CHAR
000034BE  6100 034E               3684            BSR     PUSH_STACK                *PUSH TO STACK
000034C2                          3685            
000034C2  6000 030A               3686            BRA     GET_DST_SUCCESS                   *RETURN 
000034C6                          3687            
000034C6                          3688            
000034C6                          3689            
000034C6                          3690            
000034C6                          3691            *** Check if source ...  <ea> = (An)       
000034C6                          3692  DEST_CHECK2    
000034C6  41F9 00004136           3693            LEA     TEMP_REGISTER_FORMAT,A0
000034CC  1439 00004134           3694            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000034D2  1082                    3695            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000034D4  0239 0004 00004136      3696            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000034DC  0C39 0004 00004136      3697            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000034E4  6700 007A               3698            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000034E8  0CB9 00000002 00004146  3699            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000034F2  6600 006C               3700            BNE     DEST_CHECK3
000034F6                          3701            
000034F6                          3702            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000034F6  163C 0020               3703            MOVE.B    #' ',D3
000034FA  6100 0312               3704            BSR       PUSH_STACK
000034FE  163C 0028               3705            MOVE.B    #'(',D3
00003502  6100 030A               3706            BSR       PUSH_STACK
00003506  163C 0041               3707            MOVE.B    #'A',D3
0000350A  6100 0302               3708            BSR       PUSH_STACK
0000350E                          3709  
0000350E                          3710            
0000350E                          3711            *FIND REGISTER NUMBER END LOCATION*  
0000350E  13F9 00004137 0000413E  3712            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003518  0239 000F 0000413E      3713            AND.B   #$0F,VAR_BYTE_END
00003520                          3714            
00003520                          3715            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003520  23C5 00004142           3716            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003526  1439 0000413E           3717            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000352C                          3718            
0000352C                          3719            *INTITIALIZE FOR BIT SHIFTING
0000352C  41F9 00004142           3720            LEA     VAR_TEMP_CLEANCOPY,A0
00003532  2639 00004142           3721            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003538                          3722  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003538  0C02 0000               3723            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000353C  6700 0008               3724            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003540  E24B                    3725            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003542  5302                    3726            SUB.B   #1,D2                     *DECREMENT COUNTER
00003544  60F2                    3727            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003546                          3728  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003546  0283 00000007           3729            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000354C  0603 0030               3730            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003550  6100 02BC               3731            BSR     PUSH_STACK                *PUSH TO STACK
00003554                          3732            
00003554  163C 0029               3733            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003558  6100 02B4               3734            BSR       PUSH_STACK
0000355C                          3735            
0000355C  6000 0270               3736            BRA     GET_DST_SUCCESS                   *RETURN 
00003560                          3737  
00003560                          3738            
00003560                          3739            
00003560                          3740                      
00003560                          3741  *** Check if source ...  <ea> = (An)+       
00003560  41F9 00004136           3742  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003566  1439 00004134           3743            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000356C  1082                    3744            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000356E  0239 0008 00004136      3745            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003576  0C39 0008 00004136      3746            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
0000357E  6700 0082               3747            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003582  0CB9 00000003 00004146  3748            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000358C  6600 0074               3749            BNE     DEST_CHECK4
00003590                          3750            
00003590                          3751            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003590  163C 0020               3752            MOVE.B    #' ',D3
00003594  6100 0278               3753            BSR       PUSH_STACK
00003598  163C 0028               3754            MOVE.B    #'(',D3
0000359C  6100 0270               3755            BSR       PUSH_STACK
000035A0  163C 0041               3756            MOVE.B    #'A',D3
000035A4  6100 0268               3757            BSR       PUSH_STACK
000035A8                          3758  
000035A8                          3759            
000035A8                          3760            *FIND REGISTER NUMBER END LOCATION*  
000035A8  13F9 00004137 0000413E  3761            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000035B2  0239 000F 0000413E      3762            ANDI.B   #$0F,VAR_BYTE_END
000035BA                          3763            
000035BA                          3764            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000035BA  23C5 00004142           3765            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000035C0  1439 0000413E           3766            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000035C6                          3767            
000035C6                          3768            *INTITIALIZE FOR BIT SHIFTING
000035C6  41F9 00004142           3769            LEA     VAR_TEMP_CLEANCOPY,A0
000035CC  2639 00004142           3770            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000035D2                          3771            
000035D2                          3772  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
000035D2  0C02 0000               3773            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000035D6  6700 0008               3774            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000035DA  E24B                    3775            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000035DC  5302                    3776            SUBI.B   #1,D2                     *DECREMENT COUNTER
000035DE  60F2                    3777            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
000035E0                          3778                                               *change: NAME OF LABEL*
000035E0                          3779  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000035E0  0283 00000007           3780            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000035E6  0603 0030               3781            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000035EA  6100 0222               3782            BSR     PUSH_STACK                *PUSH TO STACK
000035EE                          3783            
000035EE  163C 0029               3784            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000035F2  6100 021A               3785            BSR       PUSH_STACK
000035F6  163C 002B               3786            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000035FA  6100 0212               3787            BSR       PUSH_STACK
000035FE                          3788            
000035FE  6000 01CE               3789            BRA       GET_DST_SUCCESS                   *RETURN 
00003602                          3790  
00003602                          3791            
00003602                          3792            
00003602                          3793                      
00003602                          3794            *** Check if source ...  <ea> = -(An)       
00003602                          3795  DEST_CHECK4    
00003602  41F9 00004136           3796            LEA     TEMP_REGISTER_FORMAT,A0
00003608  1439 00004134           3797            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000360E  1082                    3798            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003610  0239 0010 00004136      3799            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003618  0C39 0010 00004136      3800            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003620  6700 0082               3801            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003624  0CB9 00000004 00004146  3802            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000362E  6600 0074               3803            BNE     DEST_CHECK7
00003632                          3804            
00003632                          3805            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003632  163C 0020               3806            MOVE.B    #' ',D3
00003636  6100 01D6               3807            BSR       PUSH_STACK
0000363A  163C 002D               3808            MOVE.B    #'-',D3
0000363E  6100 01CE               3809            BSR       PUSH_STACK
00003642  163C 0028               3810            MOVE.B    #'(',D3
00003646  6100 01C6               3811            BSR       PUSH_STACK
0000364A  163C 0041               3812            MOVE.B    #'A',D3
0000364E  6100 01BE               3813            BSR       PUSH_STACK
00003652                          3814  
00003652                          3815            
00003652                          3816            *FIND REGISTER NUMBER END LOCATION*  
00003652  13F9 00004137 0000413E  3817            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000365C  0239 000F 0000413E      3818            AND.B   #$0F,VAR_BYTE_END
00003664                          3819            
00003664                          3820            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003664  23C5 00004142           3821            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000366A  1439 0000413E           3822            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003670                          3823            
00003670                          3824            *INTITIALIZE FOR BIT SHIFTING
00003670  41F9 00004142           3825            LEA     VAR_TEMP_CLEANCOPY,A0
00003676  2639 00004142           3826            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000367C                          3827            
0000367C                          3828  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
0000367C  0C02 0000               3829            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003680  6700 0008               3830            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003684  E24B                    3831            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003686  5302                    3832            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003688  60F2                    3833            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
0000368A                          3834                                               *change: NAME OF LABEL*
0000368A                          3835  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
0000368A  0283 00000007           3836            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003690  0603 0030               3837            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003694  6100 0178               3838            BSR     PUSH_STACK                *PUSH TO STACK
00003698                          3839            
00003698  163C 0029               3840            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000369C  6100 0170               3841            BSR       PUSH_STACK
000036A0                          3842            
000036A0  6000 012C               3843            BRA     GET_DST_SUCCESS                   *RETURN
000036A4                          3844            
000036A4                          3845                      
000036A4                          3846            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000036A4                          3847  DEST_CHECK7    
000036A4  0CB9 00000007 00004146  3848            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000036AE  6600 011A               3849            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000036B2                          3850                   
000036B2                          3851            *NEXT: (MODE == 111) 
000036B2                          3852            *NOW: CHECK FOR SRC REGISTER 
000036B2                          3853                  *(000 = (xxx).W)
000036B2                          3854                  *(001 = (xxx).L)
000036B2                          3855                  *(010 = #<data>)
000036B2                          3856                  
000036B2                          3857            *FIND REGISTER NUMBER END LOCATION*  
000036B2  13F9 00004137 0000413E  3858            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000036BC  0239 000F 0000413E      3859            AND.B   #$0F,VAR_BYTE_END
000036C4                          3860            
000036C4                          3861            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036C4  23C5 00004142           3862            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000036CA  1439 0000413E           3863            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000036D0                          3864            
000036D0                          3865            *INTITIALIZE FOR BIT SHIFTING
000036D0  41F9 00004142           3866            LEA     VAR_TEMP_CLEANCOPY,A0
000036D6  2C39 00004142           3867            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000036DC                          3868  DEST_LOOP_SHIFTING7
000036DC  0C02 0000               3869            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000036E0  6700 0008               3870            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000036E4  E24E                    3871            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000036E6  5302                    3872            SUB.B   #1,D2                     *DECREMENT COUNTER
000036E8  60F2                    3873            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
000036EA                          3874  DEST_MASKING_NEXT7
000036EA  CCBC 00000007           3875            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000036F0                          3876           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000036F0                          3877            
000036F0                          3878  DEST_CHECK_WORD  
000036F0  41F9 00004136           3879            LEA     TEMP_REGISTER_FORMAT,A0
000036F6  1439 00004134           3880            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036FC  1082                    3881            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036FE  0239 0020 00004136      3882            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003706  0C39 0020 00004136      3883            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000370E  6700 0026               3884            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003712  0C06 0000               3885            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003716  6600 001E               3886            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
0000371A                          3887            *IT IS A WORD AT THIS POINT*
0000371A                          3888            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000371A  163C 0020               3889            MOVE.B    #' ',D3
0000371E  6100 00EE               3890            BSR       PUSH_STACK
00003722  163C 0024               3891            MOVE.B    #'$',D3
00003726  6100 00E6               3892            BSR       PUSH_STACK
0000372A  321D                    3893            MOVE.W    (A5)+,D1
0000372C  7404                    3894            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000372E  6100 DAC4               3895            BSR       HEX2ASCII2STACK
00003732  6000 009A               3896            BRA       GET_DST_SUCCESS
00003736                          3897  
00003736                          3898  DEST_CHECK_LONG
00003736  41F9 00004136           3899            LEA     TEMP_REGISTER_FORMAT,A0
0000373C  1439 00004134           3900            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003742  1082                    3901            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003744  0239 0040 00004136      3902            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000374C  0C39 0040 00004136      3903            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003754  6700 002E               3904            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003758  0C06 0001               3905            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
0000375C  6600 0026               3906            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003760                          3907            *IT IS A WORD AT THIS POINT*
00003760                          3908            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003760  163C 0020               3909            MOVE.B    #' ',D3
00003764  6100 00A8               3910            BSR       PUSH_STACK
00003768  163C 0024               3911            MOVE.B    #'$',D3
0000376C  6100 00A0               3912            BSR       PUSH_STACK
00003770  321D                    3913            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003772  7404                    3914            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003774  6100 DA7E               3915            BSR       HEX2ASCII2STACK
00003778  321D                    3916            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
0000377A  7404                    3917            MOVE.L    #4,D2          
0000377C  6100 DA76               3918            BSR       HEX2ASCII2STACK
00003780  6000 004C               3919            BRA     GET_DST_SUCCESS
00003784                          3920            
00003784                          3921  DEST_CHECK_IMMEDIATE
00003784  41F9 00004136           3922            LEA     TEMP_REGISTER_FORMAT,A0
0000378A  1439 00004134           3923            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003790  1082                    3924            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003792  0239 0080 00004136      3925            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000379A  0C39 0080 00004136      3926            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000037A2  6700 0026               3927            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000037A6  0C06 0004               3928            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
000037AA  6600 001E               3929            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
000037AE                          3930            
000037AE                          3931            *IT IS A WORD AT THIS POINT*
000037AE                          3932            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000037AE  163C 0020               3933            MOVE.B    #' ',D3
000037B2  6100 005A               3934            BSR       PUSH_STACK
000037B6  163C 0023               3935            MOVE.B    #'#',D3
000037BA  6100 0052               3936            BSR       PUSH_STACK
000037BE  321D                    3937            MOVE.W    (A5)+,D1
000037C0  7404                    3938            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000037C2  6100 DA30               3939            BSR       HEX2ASCII2STACK
000037C6  6000 0006               3940            BRA       GET_DST_SUCCESS
000037CA                          3941            
000037CA                          3942  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
000037CA  7801                    3943            MOVE.L #1,D4
000037CC  4E75                    3944            RTS
000037CE                          3945  GET_DST_SUCCESS 
000037CE  4E75                    3946            RTS
000037D0                          3947  
000037D0                          3948  
000037D0                          3949  *---------------------------------------------------------------------------*
000037D0                          3950  * STACK/QUEUE INTERFACE
000037D0                          3951  *---------------------------------------------------------------------------*
000037D0                          3952  PRINT_STACK
000037D0  0C39 0000 00004130      3953            CMP.B     #0,COUNTER
000037D8  6700 000E               3954            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
000037DC                          3955            
000037DC                          3956  PRINT_STACK_HELPER
000037DC  6100 0038               3957            BSR      POP_STACK          *PRINTS ADDRESS
000037E0  103C 0006               3958            MOVE.B   #6,D0              *Display single character in D1.B. 
000037E4  4E4F                    3959            TRAP     #15             *ACTIVATES PRINT
000037E6                          3960  
000037E6  60E8                    3961            BRA       PRINT_STACK
000037E8                          3962  PRINT_STACK_RETURN
000037E8  4E75                    3963            RTS
000037EA                          3964            
000037EA                          3965            
000037EA                          3966  PRINT_QUEUE
000037EA  0C39 0000 00004130      3967            CMP.B     #0,COUNTER
000037F2  6700 0018               3968            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
000037F6                          3969            
000037F6                          3970  PRINT_QUEUE_HELPER
000037F6  33F9 00004130 00004132  3971            MOVE.W   COUNTER,QUEUE_COUNTER
00003800  6100 0022               3972            BSR      POP_FRONT          *PRINTS ADDRESS
00003804  103C 0006               3973            MOVE.B   #6,D0              *Display single character in D1.B. 
00003808  4E4F                    3974            TRAP     #15             *ACTIVATES PRINT
0000380A                          3975  
0000380A  60DE                    3976            BRA       PRINT_QUEUE
0000380C                          3977  PRINT_QUEUE_RETURN
0000380C  4E75                    3978            RTS
0000380E                          3979            
0000380E                          3980  *PUSHES.W CONTENTS OF [D3] INTO STACK          
0000380E                          3981  PUSH_STACK
0000380E  1503                    3982              MOVE.B  D3,-(A2)
00003810  6100 0058               3983              BSR     INCREMENT
00003814  4E75                    3984              RTS
00003816                          3985  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003816                          3986  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003816                          3987  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003816                          3988  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003816                          3989  *         TRAP        #15             *ACTIVATES PRINT
00003816                          3990  POP_STACK
00003816  BECA                    3991              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003818  6700 0008               3992              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
0000381C  121A                    3993              MOVE.B  (A2)+,D1 
0000381E  6100 0052               3994              BSR     DECREMENT
00003822                          3995  POP_RETURN
00003822  4E75                    3996              RTS 
00003824                          3997        
00003824                          3998  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003824  0C39 0000 00004132      3999  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000382C  6700 0030               4000              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003830                          4001              
00003830                          4002              
00003830                          4003              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003830  347C 7000               4004              MOVEA.W #STACK,A2   *START A2 AT STACK
00003834  0622 0000               4005              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003838  384A                    4006              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
0000383A  0624 0000               4007              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
0000383E  1212                    4008              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003840                          4009  POP_SHIFT_LOOP
00003840  0C39 0000 00004132      4010              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003848  6700 0014               4011              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000384C  1494                    4012              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
0000384E  0624 0000               4013              ADD.B   #0,-(A4)
00003852  0622 0000               4014              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003856  5339 00004132           4015              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
0000385C                          4016              
0000385C  60E2                    4017              BRA     POP_SHIFT_LOOP
0000385E                          4018                          
0000385E                          4019  POP_FRONT_RETURN 
0000385E                          4020              *RESET A2 BACK TO SP
0000385E  347C 7000               4021              MOVEA.W #STACK,A2    
00003862  5339 00004130           4022              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003868  4E75                    4023              RTS   
0000386A                          4024  
0000386A                          4025  INCREMENT
0000386A  5239 00004130           4026              ADD.B   #1, COUNTER
00003870  4E75                    4027              RTS           
00003872                          4028  DECREMENT
00003872  5339 00004130           4029              SUB.B   #1, COUNTER
00003878  4E75                    4030              RTS           
0000387A                          4031  CLEAR_STACK
0000387A  0C39 0000 00004130      4032              CMP.B     #0,COUNTER
00003882  6700 0006               4033              BEQ       CLEAR_RETURN
00003886  618E                    4034              BSR       POP_STACK
00003888  60F0                    4035              BRA       CLEAR_STACK
0000388A                          4036   
0000388A                          4037  CLEAR_RETURN
0000388A  4E75                    4038              RTS    
0000388C                          4039  *---------------------------------------------------------------------------*
0000388C                          4040  * TERMINATE
0000388C                          4041  *---------------------------------------------------------------------------*
0000388C                          4042  TERMINATE   
0000388C  43F9 00003C3C           4043              LEA     FINMSG,A1
00003892  103C 000E               4044              MOVE.B  #14,D0
00003896  4E4F                    4045              TRAP    #15
00003898                          4046  
00003898  103C 0009               4047              MOVE.B  #9,D0
0000389C  4E4F                    4048              TRAP    #15
0000389E                          4049  
0000389E                          4050  *---------------------------------------------------------------------------*
0000389E                          4051  * Data storage                                                 
0000389E                          4052  *---------------------------------------------------------------------------*  
0000389E                          4053  WELCOME
0000389E= 20 20 20 20 20 20 ...   4054              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
000038EE= 3D 3D 3D 3D 3D 20 ...   4055              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
0000393E= 3D 3D 3D 3D 3D 20 ...   4056              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
0000398E                          4057      
0000398E= 20 20 20 20 20 20 ...   4058              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
000039DE= 20 20 20 20 20 20 ...   4059              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00003A2E= 20 20 20 20 20 20 ...   4060              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003A7E                          4061      
00003A7E= 20 20 20 20 20 20 ...   4062              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00003ACE= 3D 3D 3D 3D 3D 20 ...   4063              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00003B1E= 3D 3D 3D 3D 3D 20 ...   4064              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003B73                          4065  
00003B73                          4066  PROMPT_START
00003B73= 50 6C 65 61 73 65 ...   4067              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00003BA2                          4068      
00003BA2                          4069  PROMPT_END
00003BA2= 50 6C 65 61 73 65 ...   4070              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00003BCF= 0D 0A 48 69 74 20 ...   4071  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00003BF9= 57 6F 75 6C 64 20 ...   4072  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003C3C= 54 68 61 6E 6B 20 ...   4073  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003C67= 45 72 72 6F 72 3A ...   4074  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003C86= 45 72 72 6F 72 3A ...   4075  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003CAB= 45 72 72 6F 72 3A ...   4076  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003CD8                          4077  
00003CD8                          4078  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003D28                          4079  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003D78                          4080  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003D7C                          4081  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003D80= 0D 0A 00                4082  ENDLINE_M   DC.B    CR,LF,0
00003D83                          4083  TMPINPUT    DS.B    80                      * temp store user input
00003DD3                          4084  TMPOUTPUT   DS.B    80                      * temp store prog output
00003E23= 20 20 20 4F 52 49 ...   4085  DISP_ORI_B  DC.B    '   ORI.B',0
00003E2C= 20 20 20 4F 52 49 ...   4086  DISP_ORI_W  DC.B    '   ORI.W',0
00003E35= 20 20 20 4F 52 49 ...   4087  DISP_ORI_L  DC.B    '   ORI.L',0
00003E3E= 20 20 20 45 4F 52 ...   4088  DISP_EORI_B  DC.B    '   EORI.B',0
00003E48= 20 20 20 45 4F 52 ...   4089  DISP_EORI_W  DC.B    '   EORI.W',0
00003E52= 20 20 20 45 4F 52 ...   4090  DISP_EORI_L  DC.B    '   EORI.L',0
00003E5C= 20 20 20 42 54 53 ...   4091  DISP_BTST   DC.B    '   BTST',0
00003E64= 20 20 20 43 4D 50 ...   4092  DISP_CMPI_B  DC.B    '   CMPI.B',0
00003E6E= 20 20 20 43 4D 50 ...   4093  DISP_CMPI_W  DC.B    '   CMPI.W',0
00003E78= 20 20 20 43 4D 50 ...   4094  DISP_CMPI_L  DC.B    '   CMPI.L',0
00003E82= 20 20 20 44 41 54 ...   4095  DISP_DATA   DC.B    '   DATA',0
00003E8A= 20 20 20 4D 4F 56 ...   4096  DISP_MOVE_B DC.B    '   MOVE.B',0
00003E94= 20 20 20 4D 4F 56 ...   4097  DISP_MOVE_W DC.B    '   MOVE.W',0
00003E9E= 20 20 20 4D 4F 56 ...   4098  DISP_MOVE_L DC.B    '   MOVE.L',0
00003EA8= 20 20 20 52 54 53 00    4099  DISP_RTS    DC.B    '   RTS',0
00003EAF= 20 20 20 4A 53 52 00    4100  DISP_JSR    DC.B    '   JSR',0
00003EB6= 20 20 20 4E 45 47 ...   4101  DISP_NEG_B    DC.B    '   NEG.B',0
00003EBF= 20 20 20 4E 45 47 ...   4102  DISP_NEG_W    DC.B    '   NEG.W',0
00003EC8= 20 20 20 4E 45 47 ...   4103  DISP_NEG_L    DC.B    '   NEG.L',0
00003ED1= 20 20 20 4E 4F 54 ...   4104  DISP_NOT_B  DC.B    '   NOT.B',0
00003EDA= 20 20 20 4E 4F 54 ...   4105  DISP_NOT_W  DC.B    '   NOT.W',0
00003EE3= 20 20 20 4E 4F 54 ...   4106  DISP_NOT_L  DC.B    '   NOT.L',0
00003EEC= 20 20 20 4C 45 41 00    4107  DISP_LEA    DC.B    '   LEA',0
00003EF3= 20 20 20 4D 4F 56 ...   4108  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00003EFE= 20 20 20 4D 4F 56 ...   4109  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00003F09= 20 20 20 41 44 44 ...   4110  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00003F13= 20 20 20 41 44 44 ...   4111  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00003F1D= 20 20 20 41 44 44 ...   4112  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00003F27= 20 20 20 44 49 56 ...   4113  DISP_DIVS   DC.B    '   DIVS',0
00003F2F= 20 20 20 53 55 42 ...   4114  DISP_SUB_B  DC.B    '   SUB.B',0
00003F38= 20 20 20 53 55 42 ...   4115  DISP_SUB_W  DC.B    '   SUB.W',0
00003F41= 20 20 20 53 55 42 ...   4116  DISP_SUB_L  DC.B    '   SUB.L',0
00003F4A= 20 20 20 53 55 42 ...   4117  DISP_SUBI_B  DC.B    '   SUBI.B',0
00003F54= 20 20 20 53 55 42 ...   4118  DISP_SUBI_W  DC.B    '   SUBI.W',0
00003F5E= 20 20 20 53 55 42 ...   4119  DISP_SUBI_L  DC.B    '   SUBI.L',0
00003F68= 20 20 20 53 55 42 ...   4120  DISP_SUBA_W  DC.B    '   SUBA.W',0
00003F72= 20 20 20 53 55 42 ...   4121  DISP_SUBA_L  DC.B    '   SUBA.L',0
00003F7C= 20 20 20 45 4F 52 ...   4122  DISP_EOR_B  DC.B    '   EOR.B',0
00003F85= 20 20 20 45 4F 52 ...   4123  DISP_EOR_W  DC.B    '   EOR.W',0
00003F8E= 20 20 20 45 4F 52 ...   4124  DISP_EOR_L  DC.B    '   EOR.L',0
00003F97= 20 20 20 43 4D 50 ...   4125  DISP_CMP_B  DC.B    '   CMP.B',0
00003FA0= 20 20 20 43 4D 50 ...   4126  DISP_CMP_W  DC.B    '   CMP.W',0
00003FA9= 20 20 20 43 4D 50 ...   4127  DISP_CMP_L  DC.B    '   CMP.L',0
00003FB2= 20 20 20 43 4D 50 ...   4128  DISP_CMPA_W  DC.B    '   CMPA.W',0
00003FBC= 20 20 20 43 4D 50 ...   4129  DISP_CMPA_L  DC.B    '   CMPA.L',0
00003FC6= 20 20 20 4D 55 4C ...   4130  DISP_MULS_W DC.B    '   MULS.W',0
00003FD0= 20 20 20 41 4E 44 ...   4131  DISP_AND_B  DC.B    '   AND.B',0
00003FD9= 20 20 20 41 4E 44 ...   4132  DISP_AND_W  DC.B    '   AND.W',0
00003FE2= 20 20 20 41 4E 44 ...   4133  DISP_AND_L  DC.B    '   AND.L',0
00003FEB= 20 20 20 41 44 44 ...   4134  DISP_ADD_B  DC.B    '   ADD.B',0
00003FF4= 20 20 20 41 44 44 ...   4135  DISP_ADD_W  DC.B    '   ADD.W',0
00003FFD= 20 20 20 41 44 44 ...   4136  DISP_ADD_L  DC.B    '   ADD.L',0
00004006= 20 20 20 41 44 44 ...   4137  DISP_ADDA_W DC.B    '   ADDA.W',0
00004010= 20 20 20 41 44 44 ...   4138  DISP_ADDA_L DC.B    '   ADDA.L',0
0000401A= 20 20 20 4C 53 52 ...   4139  DISP_LSR_B  DC.B    '   LSR.B',0
00004023= 20 20 20 4C 53 4C ...   4140  DISP_LSL_B  DC.B    '   LSL.B',0
0000402C= 20 20 20 4C 53 52 ...   4141  DISP_LSR_W  DC.B    '   LSR.W',0
00004035= 20 20 20 4C 53 4C ...   4142  DISP_LSL_W  DC.B    '   LSL.W',0
0000403E= 20 20 20 4C 53 52 ...   4143  DISP_LSR_L  DC.B    '   LSR.L',0
00004047= 20 20 20 4C 53 4C ...   4144  DISP_LSL_L  DC.B    '   LSL.L',0
00004050= 20 20 20 41 53 52 ...   4145  DISP_ASR_B  DC.B    '   ASR.B',0
00004059= 20 20 20 41 53 4C ...   4146  DISP_ASL_B  DC.B    '   ASL.B',0
00004062= 20 20 20 41 53 52 ...   4147  DISP_ASR_W  DC.B    '   ASR.W',0
0000406B= 20 20 20 41 53 4C ...   4148  DISP_ASL_W  DC.B    '   ASL.W',0
00004074= 20 20 20 41 53 52 ...   4149  DISP_ASR_L  DC.B    '   ASR.L',0
0000407D= 20 20 20 41 53 4C ...   4150  DISP_ASL_L  DC.B    '   ASL.L',0
00004086= 20 20 20 52 4F 52 ...   4151  DISP_ROR_B  DC.B    '   ROR.B',0
0000408F= 20 20 20 52 4F 4C ...   4152  DISP_ROL_B  DC.B    '   ROL.B',0
00004098= 20 20 20 52 4F 52 ...   4153  DISP_ROR_W  DC.B    '   ROR.W',0
000040A1= 20 20 20 52 4F 4C ...   4154  DISP_ROL_W  DC.B    '   ROL.W',0
000040AA= 20 20 20 52 4F 52 ...   4155  DISP_ROR_L  DC.B    '   ROR.L',0
000040B3= 20 20 20 52 4F 4C ...   4156  DISP_ROL_L  DC.B    '   ROL.L',0
000040BC= 20 20 20 42 52 41 00    4157  DISP_BRA    DC.B    '   BRA',0
000040C3= 20 20 20 42 4C 54 00    4158  DISP_BLT    DC.B    '   BLT',0
000040CA= 20 20 20 42 45 51 00    4159  DISP_BEQ    DC.B    '   BEQ',0
000040D1= 20 20 20 42 4E 45 00    4160  DISP_BNE    DC.B    '   BNE',0
000040D8= 20 20 20 42 48 49 00    4161  DISP_BHI    DC.B    '   BHI',0
000040DF= 20 20 20 4D 4F 56 ...   4162  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
000040EA= 20 20 20 4D 4F 56 ...   4163  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
000040F5                          4164  
000040F5= 20 20 20 24 00          4165  DISP_HEX     DC.B    '   $',0
000040FA= 20 20 20 44 00          4166  DISP_D  DC.B    '   D',0
000040FF= 20 20 20 41 00          4167  DISP_A  DC.B    '   A',0
00004104= 20 20 20 28 00          4168  DISP_OP  DC.B    '   (',0
00004109= 29 00                   4169  DISP_CP  DC.B   ')',0
0000410B= 20 20 20 28 41 00       4170  DISP_AOP  DC.B    '   (A',0
00004111                          4171  
00004111= 20 20 20 2D 28 41 00    4172  DISP_PRE    DC.B    '   -(A',0
00004118= 29 2B 00                4173  DISP_POST   DC.B    ')+',0
0000411B= 20 20 20 23 00          4174  DISP_LB DC.B    '   #',0
00004120= 30 00                   4175  DISP_0  DC.B    '0',0
00004122= 31 00                   4176  DISP_1  DC.B    '1',0
00004124= 32 00                   4177  DISP_2  DC.B    '2',0
00004126= 33 00                   4178  DISP_3  DC.B    '3',0
00004128= 34 00                   4179  DISP_4  DC.B    '4',0
0000412A= 35 00                   4180  DISP_5  DC.B    '5',0
0000412C= 36 00                   4181  DISP_6  DC.B    '6',0
0000412E= 37 00                   4182  DISP_7  DC.B    '7',0
00004130                          4183  
00004130                          4184  *STACK INTERFACE VARIABLES*
00004130                          4185  COUNTER         DS.W    1
00004132                          4186  QUEUE_COUNTER   DS.W    1
00004134                          4187  
00004134                          4188  *EA DECODING INTERFACE VARIABLES* 
00004134                          4189  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004135                          4190  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004136                          4191  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004137                          4192  
00004137                          4193  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004137                          4194  * WORD + WORD = LONG
00004137                          4195  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004137                          4196  * A              + F            = AF         <= EXAMPLE
00004137                          4197  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004137                          4198  GET_DST_START_END    DS.B    1
00004138                          4199  GET_SRC_START_END    DS.B    1
00004139                          4200  
00004139                          4201  *STORES THE START + END BITS HERE (FROM ABOVE)
0000413A                          4202  VAR_BYTE_START      DS.L    1
0000413E                          4203  VAR_BYTE_END        DS.L    1
00004142                          4204  VAR_TEMP_CLEANCOPY  DS.L    1
00004146                          4205  
00004146                          4206  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
0000414A                          4207  
0000414A                          4208  *MORE FOR STACK USAGE*
0000414A= 2C 00                   4209  DISP_COMMA  DC.B    ',',0
0000414C= 20 20 20 00             4210  DISP_INDENT  DC.B    '   ',0
00004150                          4211  
00004150                          4212  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004150                          4213  POINTER_WORD    DS.W       1
00004152                          4214  
00004152                          4215  
00004152                          4216  
00004152                          4217  *---------------------------------------------------------------------------*
00004152                          4218  * Ends program
00004152                          4219  *---------------------------------------------------------------------------*
00004152                          4220              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1150
ASCII2HEX           114A
ASC_ERR             11AC
ASC_LOW             118E
ASC_NUM             119E
ASC_SFT             11A6
ASC_UPP             1196
CHECK0              2F82
CHECK1              300C
CHECK2              3096
CHECK3              3130
CHECK4              31D2
CHECK7              3274
CHECK_IMMEDIATE     3354
CHECK_LONG          3306
CHECK_WORD          32C0
CLEAR_RETURN        388A
CLEAR_STACK         387A
COUNTER             4130
CR                  D
DECREMENT           3872
DEST_CHECK0         33B2
DEST_CHECK1         343C
DEST_CHECK2         34C6
DEST_CHECK3         3560
DEST_CHECK4         3602
DEST_CHECK7         36A4
DEST_CHECK_IMMEDIATE  3784
DEST_CHECK_LONG     3736
DEST_CHECK_WORD     36F0
DEST_LOOP_SHIFTING  341C
DEST_LOOP_SHIFTING1  34A6
DEST_LOOP_SHIFTING2  3538
DEST_LOOP_SHIFTING3  35D2
DEST_LOOP_SHIFTING4  367C
DEST_LOOP_SHIFTING7  36DC
DEST_MASKING_NEXT   342A
DEST_MASKING_NEXT1  34B4
DEST_MASKING_NEXT2  3546
DEST_MASKING_NEXT3  35E0
DEST_MASKING_NEXT4  368A
DEST_MASKING_NEXT7  36EA
DEST_MODE           2B3A
DEST_REGISTER       2E0A
DEST_REGISTER_FORMAT  4134
DISPLAY_30_LINES    12F8
DISP_0              4120
DISP_1              4122
DISP_2              4124
DISP_3              4126
DISP_4              4128
DISP_5              412A
DISP_6              412C
DISP_7              412E
DISP_A              40FF
DISP_ADDA_L         4010
DISP_ADDA_W         4006
DISP_ADDQ_B         3F09
DISP_ADDQ_L         3F1D
DISP_ADDQ_W         3F13
DISP_ADD_B          3FEB
DISP_ADD_L          3FFD
DISP_ADD_W          3FF4
DISP_AND_B          3FD0
DISP_AND_L          3FE2
DISP_AND_W          3FD9
DISP_AOP            410B
DISP_ASL_B          4059
DISP_ASL_L          407D
DISP_ASL_W          406B
DISP_ASR_B          4050
DISP_ASR_L          4074
DISP_ASR_W          4062
DISP_BEQ            40CA
DISP_BHI            40D8
DISP_BLT            40C3
DISP_BNE            40D1
DISP_BRA            40BC
DISP_BTST           3E5C
DISP_CMPA_L         3FBC
DISP_CMPA_W         3FB2
DISP_CMPI_B         3E64
DISP_CMPI_L         3E78
DISP_CMPI_W         3E6E
DISP_CMP_B          3F97
DISP_CMP_L          3FA9
DISP_CMP_W          3FA0
DISP_COMMA          414A
DISP_CP             4109
DISP_D              40FA
DISP_DATA           3E82
DISP_DIVS           3F27
DISP_EORI_B         3E3E
DISP_EORI_L         3E52
DISP_EORI_W         3E48
DISP_EOR_B          3F7C
DISP_EOR_L          3F8E
DISP_EOR_W          3F85
DISP_HEX            40F5
DISP_INDENT         414C
DISP_JSR            3EAF
DISP_LB             411B
DISP_LEA            3EEC
DISP_LSL_B          4023
DISP_LSL_L          4047
DISP_LSL_W          4035
DISP_LSR_B          401A
DISP_LSR_L          403E
DISP_LSR_W          402C
DISP_MOVEA_L        40EA
DISP_MOVEA_W        40DF
DISP_MOVEM_L        3EFE
DISP_MOVEM_W        3EF3
DISP_MOVE_B         3E8A
DISP_MOVE_L         3E9E
DISP_MOVE_W         3E94
DISP_MULS_W         3FC6
DISP_NEG_B          3EB6
DISP_NEG_L          3EC8
DISP_NEG_W          3EBF
DISP_NEXT           3BCF
DISP_NOT_B          3ED1
DISP_NOT_L          3EE3
DISP_NOT_W          3EDA
DISP_OP             4104
DISP_ORI_B          3E23
DISP_ORI_L          3E35
DISP_ORI_W          3E2C
DISP_POST           4118
DISP_PRE            4111
DISP_ROL_B          408F
DISP_ROL_L          40B3
DISP_ROL_W          40A1
DISP_ROR_B          4086
DISP_ROR_L          40AA
DISP_ROR_W          4098
DISP_RTS            3EA8
DISP_SUBA_L         3F72
DISP_SUBA_W         3F68
DISP_SUBI_B         3F4A
DISP_SUBI_L         3F5E
DISP_SUBI_W         3F54
DISP_SUB_B          3F2F
DISP_SUB_L          3F41
DISP_SUB_W          3F38
D_MODE000           2BDC
D_MODE010           2C24
D_MODE011           2C84
D_MODE100           2CA4
D_MODE111           2CF6
EA_ARITH            2AD4
EA_DATA             14D6
EA_GEN              2B20
EA_MOVEA            2AFA
EA_NOSRC            2AC0
ENDLINE_M           3D80
END_ADDR            1096
ERRMSG_1            3C67
ERRMSG_3            3C86
ERRMSG_5            3CAB
ERROR_1             10FA
ERROR_2             110A
ERROR_3             111A
ERROR_4             112A
ERROR_5             113A
E_ADDR_HX           3D7C
FINMSG              3C3C
GET_DST_FAILED      37CA
GET_DST_START_END   4137
GET_DST_SUCCESS     37CE
GET_EA_EA_DEST      33A0
GET_EA_EA_SRC       2F70
GET_SRC_FAILED      339A
GET_SRC_START_END   4138
GET_SRC_SUCCESS     339E
HEX2ASCII           11B2
HEX2ASCII2STACK     11F4
HEX_CHAR            11E0
HEX_CONT            11E4
HEX_LOOP            11C6
IMMD_B              2DAA
IMMD_L              2DEA
IMMD_W              2DCA
IMMEDIATE           2D7A
INCREMENT           386A
INTRO               1028
IS_ODD              1238
IS_ODD_ERR          124E
JMPTABLE            1324
LF                  A
LONGMODE            2D4E
LOOP_SHIFTING       2FEC
LOOP_SHIFTING1      3076
LOOP_SHIFTING2      3108
LOOP_SHIFTING3      31A2
LOOP_SHIFTING4      324C
MAIN                1254
MASKING_NEXT        2FFA
MASKING_NEXT1       3084
MASKING_NEXT2       3116
MASKING_NEXT3       31B0
MASKING_NEXT4       325A
MODE000             2BC8
MODE001             2BF0
MODE010             2C04
MODE011             2C44
MODE100             2C64
MODE111             2CC4
NEXTLINES           1306
OP0000              1384
OP0001              15AA
OP0010              1618
OP0011              1716
OP0100              1812
OP0101              1A0E
OP0110              1A8A
OP0111              1B18
OP1000              1B1C
OP1000_DIVS_DN_EA_OR_EA_DN  1B2A
OP1000_DIVS_RETURN  1C0E
OP1000_EA_DN_DIVS   1B58
OP1000_PRINT_L_DIVS  1BC6
OP1000_PRINT_W_DIVS  1B7E
OP1001              1C24
OP1001_ADD_RETURN   1F72
OP1001_DETERMINE_DN_EA_OR_EA_DN  1D3A
OP1001_DN_EA        1D72
OP1001_EA_DN        1E72
OP1001_PRINT_B      1E9A
OP1001_PRINT_B2     1D9A
OP1001_PRINT_L      1F2A
OP1001_PRINT_L2     1E2A
OP1001_PRINT_W      1EE2
OP1001_PRINT_W2     1DE2
OP1001_SUBA_L       1C56
OP1001_SUBA_W       1CC8
OP1010              1FE0
OP1011              1FE4
OP1100              20E0
OP1100_AND_RETURN   2430
OP1100_DETERMINE_DN_EA_OR_EA_DN  21F6
OP1100_DN_EA        2230
OP1100_EA_DN        2330
OP1100_EA_DN_MULS   213E
OP1100_MULS_DN_EA_OR_EA_DN  2110
OP1100_MULS_RETURN  21F4
OP1100_PRINT_B      2358
OP1100_PRINT_B2     2258
OP1100_PRINT_L      23E8
OP1100_PRINT_L2     22E8
OP1100_PRINT_L_MULS  21AC
OP1100_PRINT_W      23A0
OP1100_PRINT_W2     22A0
OP1100_PRINT_W_MULS  2164
OP1101              2432
OP1101_ADDA_L       2464
OP1101_ADDA_W       24D6
OP1101_ADD_RETURN   2780
OP1101_DETERMINE_DN_EA_OR_EA_DN  2548
OP1101_DN_EA        2580
OP1101_EA_DN        2680
OP1101_PRINT_B      26A8
OP1101_PRINT_B2     25A8
OP1101_PRINT_L      2738
OP1101_PRINT_L2     2638
OP1101_PRINT_W      26F0
OP1101_PRINT_W2     25F0
OP1110              280E
OP1111              2ABC
OP_ADDA_L           27F6
OP_ADDA_W           27DE
OP_ADDQ             1A2E
OP_ADDQ_B           1A54
OP_ADDQ_L           1A78
OP_ADDQ_W           1A66
OP_ADD_B            2796
OP_ADD_L            27C6
OP_ADD_W            27AE
OP_ASL              29AE
OP_ASL_B            29D2
OP_ASL_L            29E4
OP_ASL_W            29F6
OP_ASR              2954
OP_ASR_B            2978
OP_ASR_L            298A
OP_ASR_W            299C
OP_ASX              2870
OP_BEQ              1AEE
OP_BHI              1AD2
OP_BLT              1B0A
OP_BNE              1AE0
OP_BRA              1AFC
OP_BTST             13F8
OP_CMPA_L           2050
OP_CMPA_W           203E
OP_CMPI             14FE
OP_CMPI_B           151E
OP_CMPI_L           1542
OP_CMPI_W           1530
OP_CMP_B            2062
OP_CMP_L            2092
OP_CMP_W            207A
OP_DATA             14B2
OP_DIVS             1C10
OP_EORI             1406
OP_EORI_B           1426
OP_EORI_L           144A
OP_EORI_W           1438
OP_EOR_B            20AA
OP_EOR_L            20CE
OP_EOR_W            20BC
OP_JSR              19EC
OP_LEA              18C0
OP_LEA_DN_EA_OR_EA_DN  18CE
OP_LEA_RETURN       192C
OP_LSL              28FA
OP_LSL_B            291E
OP_LSL_L            2930
OP_LSL_W            2942
OP_LSR              28A0
OP_LSR_B            28C4
OP_LSR_L            28D6
OP_LSR_W            28E8
OP_LSX              2858
OP_MOVEA_L          16A6
OP_MOVEA_W          17A2
OP_MOVEM_L          18AE
OP_MOVEM_W          189C
OP_MOVE_B           15B0
OP_MOVE_L           163E
OP_MOVE_W           173A
OP_MULS             2102
OP_NEG              192E
OP_NEG_B            194E
OP_NEG_L            197E
OP_NEG_W            1966
OP_NOT              1996
OP_NOT_B            19B6
OP_NOT_L            19DA
OP_NOT_W            19C8
OP_ORI              1554
OP_ORI_B            1574
OP_ORI_L            1598
OP_ORI_W            1586
OP_PRINT_L_LEA      18EC
OP_ROL              2A62
OP_ROL_B            2A86
OP_ROL_L            2A98
OP_ROL_W            2AAA
OP_ROR              2A08
OP_ROR_B            2A2C
OP_ROR_L            2A3E
OP_ROR_W            2A50
OP_ROX              2888
OP_RTS              1A00
OP_SUBA_L           1FCE
OP_SUBA_W           1FBC
OP_SUBI             145C
OP_SUBI_B           147C
OP_SUBI_L           14A0
OP_SUBI_W           148E
OP_SUB_B            1F74
OP_SUB_L            1FA4
OP_SUB_W            1F8C
OUTPUT_PROCESSED_DATA  12D8
POINTER_WORD        4150
POP_FRONT           3824
POP_FRONT_RETURN    385E
POP_RETURN          3822
POP_SHIFT_LOOP      3840
POP_STACK           3816
PRINT_QUEUE         37EA
PRINT_QUEUE_HELPER  37F6
PRINT_QUEUE_RETURN  380C
PRINT_STACK         37D0
PRINT_STACK_HELPER  37DC
PRINT_STACK_RETURN  37E8
PROGLP              100A
PROMPT_END          3BA2
PROMPT_START        3B73
PUSH_STACK          380E
QUEUE_COUNTER       4132
REG_0               2EBE
REG_1               2ECC
REG_2               2EDA
REG_3               2EE8
REG_4               2EF6
REG_5               2F04
REG_6               2F12
REG_7               2F20
REPEAT              2F2E
REPEATMSG           3BF9
RETURN              11B0
SRC_LOOP_SHIFTING   32AC
SRC_MASKING_NEXT    32BA
SRC_MODE            2B7E
SRC_REGISTER        2E66
SRC_REGISTER_FORMAT  4135
STACK               7000
STACK_HEX_CHAR      1222
STACK_HEX_CONT      1226
STACK_HEX_LOOP      1208
START               1004
START_ADDR          1044
S_ADDR_HX           3D78
TEMP_REGISTER_FORMAT  4136
TERMINATE           388C
TESTING             1036
TMPINPUT            3D83
TMPOUTPUT           3DD3
VAR_BYTE_END        413E
VAR_BYTE_START      413A
VAR_LONG_ADDRESS_MODE_CHECK  4146
VAR_TEMP_CLEANCOPY  4142
VR_E_ADDR           3D28
VR_S_ADDR           3CD8
WELCOME             389E
WORDMODE            2D22
