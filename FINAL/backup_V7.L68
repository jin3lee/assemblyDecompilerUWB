00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 2:45:43 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001048             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109A             38              JSR     END_ADDR
00001016  43F9 00003FBC             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 00001258             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003ADA             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036                            53              
00001036  B793                      54              EOR.L  D3,(A3)
00001038  B99C                      55              EOR.L  D4,(A4)+
0000103A  BBA5                      56              EOR.L  D5,-(A5)
0000103C  BDB8 3331                 57              EOR.L  D6,$3331
00001040  BFB9 44444441             58              EOR.L  D7,$44444441
00001046                            59  
00001046                            60  
00001046                            61  
00001046  4E75                      62              RTS
00001048                            63  *---------------------------------------------------------------------------*
00001048                            64  * START_ADDR: Compute the starting address
00001048                            65  *---------------------------------------------------------------------------*
00001048                            66  START_ADDR
00001048                            67              * Output
00001048  43F9 00003DAF             68              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000104E  103C 000E                 69              MOVE.B  #14,D0                  * Display PROMPT_START
00001052  4E4F                      70              TRAP    #15
00001054                            71      
00001054                            72              * Input
00001054  43F9 00003F14             73              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105A  103C 0002                 74              MOVE.B  #2,D0                   * Ask user for input
0000105E  4E4F                      75              TRAP    #15
00001060                            76              
00001060                            77              * Error Checking (length)
00001060  0C01 0000                 78              CMPI.B  #0, D1                  * Check if input length <= 0
00001064  6F00 0098                 79              BLE     ERROR_1
00001068  0C01 0008                 80              CMPI.B  #8, D1                  * Check if input length > 8
0000106C  6E00 0090                 81              BGT     ERROR_1
00001070                            82              
00001070                            83              * Conversion & Storage
00001070  4EB9 0000114E             84              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001076  0C07 0001                 85              CMPI.B  #1, D7                  * Check for error
0000107A  6700 0082                 86              BEQ     ERROR_1                 
0000107E  23C1 00003FB4             87              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001084                            88              
00001084                            89              * Error Checking (Odd)
00001084  43F9 00003FB4             90              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108A  4EB9 0000123C             91              JSR     IS_ODD                  * Check if the input address is odd
00001090  0C07 0001                 92              CMPI.B  #1, D7                  * Check for error
00001094  6700 0088                 93              BEQ     ERROR_3
00001098                            94              
00001098                            95              * Return
00001098  4E75                      96              RTS     
0000109A                            97  *---------------------------------------------------------------------------*
0000109A                            98  * END_ADDR: Compute the ending address
0000109A                            99  *---------------------------------------------------------------------------*
0000109A                           100  END_ADDR
0000109A                           101              * Output
0000109A  43F9 00003DDE            102              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A0  103C 000E                103              MOVE.B  #14,D0                  * Display PROMPT_END
000010A4  4E4F                     104              TRAP    #15
000010A6                           105  
000010A6                           106              * Input
000010A6  43F9 00003F64            107              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AC  103C 0002                108              MOVE.B  #2,D0                   * Ask user for input
000010B0  4E4F                     109              TRAP    #15
000010B2                           110              
000010B2                           111              * Error Checking (length)
000010B2  0C01 0000                112              CMPI.B  #0, D1                  * Check if input length <= 0
000010B6  6F00 0056                113              BLE     ERROR_2
000010BA  0C01 0008                114              CMPI.B  #8, D1                  * Check if input length > 8
000010BE  6E00 004E                115              BGT     ERROR_2
000010C2                           116              
000010C2                           117              * Conversion & Storage
000010C2  4EB9 0000114E            118              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010C8  0C07 0001                119              CMPI.B  #1, D7                  * Check for error
000010CC  6700 0040                120              BEQ     ERROR_2
000010D0  23C1 00003FB8            121              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D6                           122              
000010D6                           123              * Error Checking (start > end case)
000010D6  2439 00003FB4            124              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DC  B282                     125              CMP.L   D2, D1                  * Compare starting and ending address
000010DE  6300 005E                126              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E2                           127              
000010E2                           128              * Error Checking (Odd case)
000010E2  43F9 00003FB8            129              LEA     E_ADDR_HX, A1           * Move the ending address
000010E8  4EB9 0000123C            130              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010EE  0C07 0001                131              CMPI.B  #1, D7                  * Check for an error flag
000010F2  6700 003A                132              BEQ     ERROR_4
000010F6                           133              
000010F6                           134              * Inputs are valid
000010F6  2A79 00003FB4            135              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FC                           136              
000010FC  4E75                     137              RTS
000010FE                           138              
000010FE                           139  *---------------------------------------------------------------------------*
000010FE                           140  * ERROR_1: Address error (Invalid starting address)
000010FE                           141  *---------------------------------------------------------------------------*
000010FE                           142  ERROR_1
000010FE  43F9 00003EA3            143              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001104  103C 000E                144              MOVE.B  #14, D0                 * Display ERRMSG_1
00001108  4E4F                     145              TRAP    #15
0000110A  4EF8 1048                146              JMP     START_ADDR              * Jump to START_ADDR
0000110E                           147      
0000110E                           148  *---------------------------------------------------------------------------*
0000110E                           149  * ERROR_2: Address error (Invalid ending address)
0000110E                           150  *---------------------------------------------------------------------------*
0000110E                           151  ERROR_2
0000110E  43F9 00003EA3            152              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001114  103C 000E                153              MOVE.B  #14, D0                 * Display ERRMSG_1
00001118  4E4F                     154              TRAP    #15
0000111A  4EF8 109A                155              JMP     END_ADDR                * Jump to END_ADDR
0000111E                           156  
0000111E                           157  *---------------------------------------------------------------------------*
0000111E                           158  * ERROR_3: Address error (Odd starting address)
0000111E                           159  *---------------------------------------------------------------------------*
0000111E                           160  ERROR_3
0000111E  43F9 00003EC2            161              LEA     ERRMSG_3, A1
00001124  103C 000E                162              MOVE.B  #14, D0
00001128  4E4F                     163              TRAP    #15
0000112A  4EF8 1048                164              JMP     START_ADDR
0000112E                           165     
0000112E                           166  *---------------------------------------------------------------------------*
0000112E                           167  * ERROR_4: Address error (Odd ending address)
0000112E                           168  *---------------------------------------------------------------------------*         
0000112E                           169  ERROR_4
0000112E  43F9 00003EC2            170              LEA     ERRMSG_3, A1
00001134  103C 000E                171              MOVE.B  #14, D0
00001138  4E4F                     172              TRAP    #15
0000113A  4EF8 109A                173              JMP     END_ADDR
0000113E                           174            
0000113E                           175  *---------------------------------------------------------------------------*
0000113E                           176  * ERROR_3: Address error (Ending address is less than starting address)
0000113E                           177  *---------------------------------------------------------------------------*
0000113E                           178  ERROR_5
0000113E  43F9 00003EE7            179              LEA     ERRMSG_5, A1
00001144  103C 000E                180              MOVE.B  #14, D0
00001148  4E4F                     181              TRAP    #15
0000114A  4EF8 109A                182              JMP     END_ADDR
0000114E                           183    
0000114E                           184  *---------------------------------------------------------------------------*
0000114E                           185  * ASCII2HEX: Convert ASCii to Hexadecimal
0000114E                           186  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000114E                           187  *---------------------------------------------------------------------------*
0000114E  4281                     188  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001150  4287                     189              CLR.L   D7                      * Set the error flag to 0
00001152  4282                     190              CLR.L   D2                      * Clear D2 for temp storage
00001154                           191              
00001154  1419                     192  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001156  0C02 0000                193              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115A  6700 0058                194              BEQ     RETURN                  * If it's NULL, go to return
0000115E  0C02 0066                195              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001162  6E00 004C                196              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001166  0C02 0061                197              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116A  6C00 0026                198              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000116E  0C02 0046                199              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001172  6E00 003C                200              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001176  0C02 0041                201              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117A  6C00 001E                202              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000117E  0C02 0039                203              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001182  6E00 002C                204              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001186  0C02 0030                205              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118A  6C00 0016                206              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000118E  6000 0020                207              BRA     ASC_ERR                 * Invalid input
00001192                           208  
00001192  0442 0057                209  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001196  6000 0012                210              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119A                           211              
0000119A  0442 0037                212  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000119E  6000 000A                213              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A2                           214              
000011A2  0442 0030                215  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A6  6000 0002                216              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AA                           217              
000011AA  E981                     218  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AC  D202                     219              ADD.B   D2, D1                  * Add the converted input to D1
000011AE  60A4                     220              BRA     ASC2HXLP                * Loop
000011B0                           221  
000011B0  1E3C 0001                222  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B4  4E75                     223  RETURN      RTS     
000011B6                           224  
000011B6                           225  *---------------------------------------------------------------------------*
000011B6                           226  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011B6                           227  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011B6                           228  *---------------------------------------------------------------------------*
000011B6  0C02 0008                229  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011BA  6700 000E                230              BEQ     HEX_LOOP
000011BE  4841                     231              SWAP    D1
000011C0  0C02 0002                232              CMPI.B  #2,D2
000011C4  6600 0004                233              BNE     HEX_LOOP
000011C8  E189                     234              LSL.L   #8,D1
000011CA                           235             
000011CA  E999                     236  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011CC  2601                     237              MOVE.L  D1, D3                  * Move D1 to D3
000011CE  0283 0000000F            238              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011D4  0C03 0009                239              CMPI.B  #9, D3                  * Compare te digit
000011D8  6E00 000A                240              BGT     HEX_CHAR              
000011DC  0603 0030                241              ADDI.B  #48,D3                  * Add 48 for numerical output
000011E0  6000 0006                242              BRA     HEX_CONT
000011E4                           243              
000011E4  0603 0037                244  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011E8                           245  
000011E8  12C3                     246  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011EA  5342                     247              SUBI    #1, D2                  * Decrement the size
000011EC  0C02 0000                248              CMPI.B  #0, D2                  * Check if D2 is 0
000011F0  66D8                     249              BNE     HEX_LOOP                * Loop
000011F2  12BC 0000                250              MOVE.B  #$0,(A1)                * Null terminator
000011F6  4E75                     251              RTS
000011F8                           252  *---------------------------------------------------------------------------*
000011F8                           253  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
000011F8                           254  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011F8                           255  *---------------------------------------------------------------------------*
000011F8                           256  HEX2ASCII2STACK
000011F8  0C02 0008                257              CMPI.B  #8, D2                  * Check to see if the size is long
000011FC  6700 000E                258              BEQ     STACK_HEX_LOOP
00001200  4841                     259              SWAP    D1
00001202  0C02 0002                260              CMPI.B  #2,D2
00001206  6600 0004                261              BNE     STACK_HEX_LOOP
0000120A  E189                     262              LSL.L   #8,D1
0000120C                           263             
0000120C                           264  STACK_HEX_LOOP    
0000120C  E999                     265              ROL.L   #4, D1                  * Roll D1 to left
0000120E  2601                     266              MOVE.L  D1, D3                  * Move D1 to D3
00001210  0283 0000000F            267              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001216  0C03 0009                268              CMPI.B  #9, D3                  * Compare te digit
0000121A  6E00 000A                269              BGT     STACK_HEX_CHAR              
0000121E  0603 0030                270              ADDI.B  #48,D3                  * Add 48 for numerical output
00001222  6000 0006                271              BRA     STACK_HEX_CONT
00001226                           272              
00001226                           273  STACK_HEX_CHAR    
00001226  0603 0037                274              ADDI.B  #55,D3                  * Add 55 for character output
0000122A                           275  
0000122A                           276  STACK_HEX_CONT    
0000122A  6100 281E                277              BSR     PUSH_STACK              *PLACE INTO STACK
0000122E  5342                     278              SUBI    #1, D2                  * Decrement the size
00001230  0C02 0000                279              CMPI.B  #0, D2                  * Check if D2 is 0
00001234  66D6                     280              BNE     STACK_HEX_LOOP                * Loop
00001236  12BC 0000                281              MOVE.B  #$0,(A1)                * Null terminator
0000123A  4E75                     282              RTS
0000123C                           283  
0000123C                           284  
0000123C                           285  *---------------------------------------------------------------------------*
0000123C                           286  * IS_ODD: Check whether the source address is odd
0000123C                           287  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000123C                           288  *---------------------------------------------------------------------------*
0000123C  4281                     289  IS_ODD      CLR.L   D1                      * Clear the result
0000123E  4287                     290              CLR.L   D7                      * Set the error flag to 0
00001240  2211                     291              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001242  82FC 0002                292              DIVU    #2, D1                  * Divide the result by 2
00001246  4841                     293              SWAP    D1                      * Swap remainder with quotient
00001248  0C01 0001                294              CMPI.B  #1, D1                  * Check for error
0000124C  6700 0004                295              BEQ     IS_ODD_ERR
00001250  4E75                     296              RTS
00001252                           297              
00001252  1E3C 0001                298  IS_ODD_ERR  MOVE.B  #1, D7
00001256  4E75                     299              RTS
00001258                           300  
00001258                           301  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
00001258                           302  * MAIN                    
00001258                           303  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
00001258                           304  * A5: Processing address
00001258                           305  *
00001258                           306  * D3: USED FOR PUSHING INTO STACK
00001258                           307  *     To push into stack => MOVE.W #DATA,D3 
00001258                           308  *                           BSR    PUSH_STACK
00001258                           309  *     To print stack     => BSR    PRINT_STACK 
00001258                           310  *     To clear stack     => BSR    CLEAR_STACK
00001258                           311  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
00001258                           312  MAIN        
00001258                           313              *initialize stack pointer
00001258  33FC 0000 0000436C       314              MOVE.W  #0,COUNTER
00001260  347C 7000                315              MOVEA.W #STACK,A2
00001264  163C 0020                316              MOVE.B  #' ',D3
00001268  6100 27E0                317              BSR     PUSH_STACK
0000126C  6100 27DC                318              BSR     PUSH_STACK
00001270  6100 27D8                319              BSR     PUSH_STACK
00001274                           320              
00001274                           321              * clear registers for temp storage
00001274  4280                     322              CLR.L   D0                   
00001276  4281                     323              CLR.L   D1                   
00001278  227C 00000000            324              MOVEA.L #0, A1                
0000127E                           325              
0000127E  220D                     326              MOVE.L  A5,D1                   * check to see if the address is fully read
00001280  23CD 00003FB4            327              MOVE.L  A5,S_ADDR_HX
00001286  B2B9 00003FB8            328              CMP.L   E_ADDR_HX,D1
0000128C  6C00 1EDC                329              BGE     REPEAT                  * go to repeat for user action
00001290                           330  
00001290  43F9 0000400F            331              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001296  143C 0008                332              MOVE.B  #8,D2                   * set the output size
0000129A  4EB8 11B6                333              JSR     HEX2ASCII               
0000129E  43F9 0000400F            334              LEA     TMPOUTPUT,A1
000012A4  103C 000E                335              MOVE.B  #14,D0
000012A8  4E4F                     336              TRAP    #15
000012AA                           337              
000012AA  4285                     338              CLR.L    D5                      * clear the processing data
000012AC  3A1D                     339              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012AE                           340                                               * advance the current instruction pointer to the next
000012AE                           341                                               * instruction in memory
000012AE                           342  *----------------------------------------*
000012AE                           343  * Registers          
000012AE                           344  * [D1] - COPY OF D5
000012AE                           345  * [D5] - DATA TO BE PROCESSED
000012AE                           346  * [D6] - COUNTER FOR LINES PROCESSED
000012AE                           347  *
000012AE                           348  * [D4]      - ERROR FLAG BEFORE PRINTING
000012AE                           349  * [STACK]   - PRINTS PROCESS DATA
000012AE                           350  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012AE                           351  *
000012AE                           352  * [A1] - USED FOR JUMPING/PRINTING
000012AE                           353  *
000012AE                           354  *----------------------------------------*
000012AE                           355  
000012AE                           356              
000012AE                           357              *Processing the first 4 most significant bits 
000012AE  2205                     358              MOVE.L  D5,D1                    * copy the current processing data to D1
000012B0  143C 000C                359              MOVE.B  #12,D2                   * shift to right by 12 bits
000012B4  E469                     360              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012B6  C2FC 0006                361              MULU    #6,D1                    * form offset
000012BA  43F9 00001328            362              LEA     JMPTABLE,A1              * index into table
000012C0  4EB1 1000                363              JSR     0(A1,D1)                 * jump indirect with index
000012C4                           364              
000012C4                           365              *SECURED EA*
000012C4  B83C 0001                366              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012C8  6600 0012                367              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012CC  6100 01E8                368              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012D0  6100 27E4                369              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012D4  183C 0000                370              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012D8  6000 0022                371              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012DC                           372             
000012DC                           373  OUTPUT_PROCESSED_DATA       
000012DC  163C 000D                374              MOVE.B  #$D,D3                  *carriage return
000012E0  6100 2768                375              BSR     PUSH_STACK
000012E4  163C 000A                376              MOVE.B  #$A,D3                  *new line feed
000012E8  6100 2760                377              BSR     PUSH_STACK
000012EC  163C 0000                378              MOVE.B  #$0,D3                  *null
000012F0  6100 2758                379              BSR     PUSH_STACK
000012F4                           380       
000012F4  6100 2730                381              BSR     PRINT_QUEUE
000012F8  183C 0000                382              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012FC                           383  DISPLAY_30_LINES
000012FC                           384              * display 30 lines per page
000012FC  5206                     385              ADDI.B  #1,D6
000012FE  0C06 001E                386              CMPI.B  #30,D6
00001302  6C00 0006                387              BGE     NEXTLINES
00001306  6000 FF50                388              BRA     MAIN
0000130A                           389            
0000130A                           390  *---------------------------------------------------------------------------*
0000130A                           391  * NEXTLINES: receive input from user to print the next 30 lines
0000130A                           392  *---------------------------------------------------------------------------*  
0000130A  4206                     393  NEXTLINES   CLR.B   D6
0000130C  43F9 00003E0B            394              LEA     DISP_NEXT,A1
00001312  103C 000E                395              MOVE.B  #14,D0
00001316  4E4F                     396              TRAP    #15
00001318  43F9 00003FBF            397              LEA     TMPINPUT,A1
0000131E  103C 0002                398              MOVE.B  #2,D0
00001322  4E4F                     399              TRAP    #15
00001324  4EF8 1258                400              JMP     MAIN
00001328                           401    
00001328                           402  *---------------------------------------------------------------------------*
00001328                           403  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001328                           404  *---------------------------------------------------------------------------*  
00001328  4EF9 00001388            405  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
0000132E  4EF9 000015AE            406              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001334  4EF9 0000161C            407              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000133A  4EF9 0000171A            408              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
00001340  4EF9 00001816            409              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
00001346  4EF9 00001A6C            410              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
0000134C  4EF9 00001C10            411              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *NOT FINISHED - LYN
00001352  4EF9 00001C9E            412              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
00001358  4EF9 00001CA2            413              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
0000135E  4EF9 00001DAA            414              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001364  4EF9 00002166            415              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
0000136A  4EF9 0000216A            416              JMP     OP1011  * CMP/EOR/CMPA
00001370  4EF9 0000231C            417              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
00001376  4EF9 0000266E            418              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000137C  4EF9 00002A4A            419              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001382  4EF9 00002CF8            420              JMP     OP1111  * Special/Reserved
00001388                           421              
00001388                           422  *---------------------------------------------------------------------------*
00001388                           423  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
00001388                           424  *---------------------------------------------------------------------------*           
00001388                           425  OP0000                                                                                  
00001388  4281                     426              CLR.L   D1          * to temporarily store the address to process
0000138A  4280                     427              CLR.L   D0  
0000138C  4284                     428              CLR.L   D4                 
0000138E  227C 00000000            429              MOVEA.L #0, A1                
00001394                           430              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001394                           431              * Check if bit 11,10,9,8 are 0000)
00001394  2205                     432              MOVE.L  D5,D1
00001396  0281 00000F00            433              ANDI.L  #$0F00,D1
0000139C  0C81 00000000            434              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013A2  6700 01B4                435              BEQ     OP_ORI
000013A6                           436  
000013A6                           437              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013A6                           438              * check if bit 11,10,9,8 are 1100
000013A6  4281                     439              CLR.L   D1
000013A8  2205                     440              MOVE.L  D5,D1
000013AA  0281 00000F00            441              ANDI.L  #$0F00,D1
000013B0  0C81 00000C00            442              CMPI.L  #$0C00,D1
000013B6  6700 014A                443              BEQ     OP_CMPI
000013BA                           444              
000013BA                           445              * check for SUBI
000013BA  4281                     446              CLR.L   D1
000013BC  2205                     447              MOVE.L  D5,D1
000013BE  0281 00000F00            448              ANDI.L  #$0F00,D1
000013C4  0C81 00000400            449              CMPI.L  #$0400,D1
000013CA  6700 0094                450              BEQ     OP_SUBI
000013CE                           451              
000013CE                           452              * check for EORI
000013CE  4281                     453              CLR.L   D1
000013D0  2205                     454              MOVE.L  D5,D1
000013D2  0281 00000F00            455              ANDI.L  #$0F00,D1
000013D8  0C81 00000A00            456              CMPI.L  #$0A00,D1
000013DE  6700 002A                457              BEQ     OP_EORI
000013E2                           458              
000013E2                           459              * check for BTST
000013E2  4281                     460              CLR.L   D1
000013E4  2205                     461              MOVE.L  D5,D1
000013E6  EA99                     462              ROR.L   #5,D1
000013E8  0281 00000008            463              ANDI.L  #$8,D1
000013EE  0C01 0008                464              CMPI.B  #8,D1
000013F2  6700 0008                465              BEQ     OP_BTST
000013F6                           466  
000013F6                           467              * OP0000 series other than ORI/CMPI/BTST/EORI
000013F6  4EF9 000014B6            468              JMP     OP_DATA
000013FC                           469              
000013FC                           470  *---------------------------------------------------------------------------*
000013FC                           471  * OP_BTST: display BTST
000013FC                           472  *---------------------------------------------------------------------------* 
000013FC  43F9 00004098            473  OP_BTST     LEA     DISP_BTST,A1
00001402  103C 000E                474              MOVE.B  #14,D0
00001406  4E4F                     475              TRAP    #15
00001408  4E75                     476              RTS
0000140A                           477  
0000140A                           478  *---------------------------------------------------------------------------*
0000140A                           479  * OP_EORI: decode and display EORI
0000140A                           480  *---------------------------------------------------------------------------* 
0000140A                           481  OP_EORI
0000140A  4281                     482              CLR.L   D1
0000140C  4284                     483              CLR.L   D4
0000140E  2205                     484              MOVE.L  D5,D1
00001410  EC99                     485              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001412  0C01 0000                486              CMPI.B  #0,D1
00001416  6700 0012                487              BEQ     OP_EORI_B    * size is byte
0000141A  0C01 0001                488              CMPI.B  #1,D1
0000141E  6700 001C                489              BEQ     OP_EORI_W    * size is word
00001422  0C01 0002                490              CMPI.B  #2,D1
00001426  6700 0026                491              BEQ     OP_EORI_L    * size is long
0000142A                           492  
0000142A                           493  OP_EORI_B    * size is byte    
0000142A  183C 0000                494              MOVE.B  #0,D4
0000142E  43F9 0000407A            495              LEA     DISP_EORI_B,A1
00001434  103C 000E                496              MOVE.B  #14,D0
00001438  4E4F                     497              TRAP    #15
0000143A  4E75                     498              RTS
0000143C                           499              
0000143C                           500  OP_EORI_W    * size is word
0000143C  183C 0001                501              MOVE.B  #1,D4
00001440  43F9 00004084            502              LEA     DISP_EORI_W,A1
00001446  103C 000E                503              MOVE.B  #14,D0
0000144A  4E4F                     504              TRAP    #15
0000144C  4E75                     505              RTS
0000144E                           506              
0000144E                           507  OP_EORI_L    * size is long
0000144E  183C 0002                508              MOVE.B  #2,D4
00001452  43F9 0000408E            509              LEA     DISP_EORI_L,A1
00001458  103C 000E                510              MOVE.B  #14,D0
0000145C  4E4F                     511              TRAP    #15
0000145E  4E75                     512              RTS
00001460                           513              
00001460                           514  *---------------------------------------------------------------------------*
00001460                           515  * OP_SUBI: decode SUBI.B/.W/.L
00001460                           516  *---------------------------------------------------------------------------* 
00001460                           517  OP_SUBI
00001460  4281                     518              CLR.L   D1
00001462  4284                     519              CLR.L   D4
00001464  2205                     520              MOVE.L  D5,D1
00001466  EC99                     521              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001468  0C01 0000                522              CMPI.B  #0,D1
0000146C  6700 0012                523              BEQ     OP_SUBI_B    * size is byte
00001470  0C01 0001                524              CMPI.B  #1,D1
00001474  6700 001C                525              BEQ     OP_SUBI_W    * size is word
00001478  0C01 0002                526              CMPI.B  #2,D1
0000147C  6700 0026                527              BEQ     OP_SUBI_L    * size is long
00001480                           528  
00001480                           529  OP_SUBI_B    * size is byte    
00001480  183C 0000                530              MOVE.B  #0,D4
00001484  43F9 00004186            531              LEA     DISP_SUBI_B,A1
0000148A  103C 000E                532              MOVE.B  #14,D0
0000148E  4E4F                     533              TRAP    #15
00001490  4E75                     534              RTS
00001492                           535              
00001492                           536  OP_SUBI_W    * size is word
00001492  183C 0001                537              MOVE.B  #1,D4
00001496  43F9 00004190            538              LEA     DISP_SUBI_W,A1
0000149C  103C 000E                539              MOVE.B  #14,D0
000014A0  4E4F                     540              TRAP    #15
000014A2  4E75                     541              RTS
000014A4                           542              
000014A4                           543  OP_SUBI_L    * size is long
000014A4  183C 0002                544              MOVE.B  #2,D4
000014A8  43F9 0000419A            545              LEA     DISP_SUBI_L,A1
000014AE  103C 000E                546              MOVE.B  #14,D0
000014B2  4E4F                     547              TRAP    #15
000014B4  4E75                     548              RTS
000014B6                           549              
000014B6                           550  *---------------------------------------------------------------------------*
000014B6                           551  * OP_DATA : unidentified opcode
000014B6                           552  *---------------------------------------------------------------------------* 
000014B6                           553  OP_DATA
000014B6  4280                     554              CLR.L   D0                   
000014B8  4281                     555              CLR.L   D1     
000014BA  4284                     556              CLR.L   D4                    
000014BC  227C 00000000            557              MOVEA.L #0, A1             
000014C2  4287                     558              CLR.L   D7
000014C4  1E3C 0001                559              MOVE.B  #1,D7                   * error flag is true
000014C8                           560              
000014C8  43F9 000040BE            561              LEA     DISP_DATA,A1
000014CE  103C 000E                562              MOVE.B  #14,D0
000014D2  4E4F                     563              TRAP    #15
000014D4                           564              
000014D4  4EF9 000014DA            565              JMP     EA_DATA
000014DA                           566             
000014DA                           567             
000014DA                           568  *---------------------------------------------------------------------------*
000014DA                           569  * EA_DATA
000014DA                           570  *---------------------------------------------------------------------------*       
000014DA  43F9 0000400F            571  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014E0  2205                     572              MOVE.L  D5,D1           * transfer the processing data to D1
000014E2  7404                     573              MOVE.L  #4,D2           * set to word size
000014E4  4EB8 11B6                574              JSR     HEX2ASCII       * prepare output in ascii
000014E8  43F9 00004331            575              LEA     DISP_HEX,A1     * display $ symbol
000014EE  103C 000E                576              MOVE.B  #14,D0      
000014F2  4E4F                     577              TRAP    #15
000014F4  43F9 0000400F            578              LEA     TMPOUTPUT,A1    * display with a new line
000014FA  103C 000D                579              MOVE.B  #13,D0
000014FE  4E4F                     580              TRAP    #15
00001500                           581  
00001500  4E75                     582              RTS
00001502                           583              
00001502                           584  *---------------------------------------------------------------------------*
00001502                           585  * OP_CMPI : decode CMPI and its size
00001502                           586  *---------------------------------------------------------------------------*          
00001502                           587  OP_CMPI
00001502  4281                     588              CLR.L   D1
00001504  4284                     589              CLR.L   D4
00001506  2205                     590              MOVE.L  D5,D1
00001508  EC99                     591              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000150A  0C01 0000                592              CMPI.B  #0,D1
0000150E  6700 0012                593              BEQ     OP_CMPI_B    * size is byte
00001512  0C01 0001                594              CMPI.B  #1,D1
00001516  6700 001C                595              BEQ     OP_CMPI_W    * size is word
0000151A  0C01 0002                596              CMPI.B  #2,D1
0000151E  6700 0026                597              BEQ     OP_CMPI_L    * size is long
00001522                           598  
00001522                           599  OP_CMPI_B    * size is byte    
00001522  183C 0000                600              MOVE.B  #0,D4
00001526  43F9 000040A0            601              LEA     DISP_CMPI_B,A1
0000152C  103C 000E                602              MOVE.B  #14,D0
00001530  4E4F                     603              TRAP    #15
00001532  4E75                     604              RTS
00001534                           605              
00001534                           606  OP_CMPI_W    * size is word
00001534  183C 0001                607              MOVE.B  #1,D4
00001538  43F9 000040AA            608              LEA     DISP_CMPI_W,A1
0000153E  103C 000E                609              MOVE.B  #14,D0
00001542  4E4F                     610              TRAP    #15
00001544  4E75                     611              RTS
00001546                           612              
00001546                           613  OP_CMPI_L    * size is long
00001546  183C 0002                614              MOVE.B  #2,D4
0000154A  43F9 000040B4            615              LEA     DISP_CMPI_L,A1
00001550  103C 000E                616              MOVE.B  #14,D0
00001554  4E4F                     617              TRAP    #15
00001556  4E75                     618              RTS
00001558                           619   
00001558                           620  *---------------------------------------------------------------------------*
00001558                           621  * OP_ORI : decode ORI and its size
00001558                           622  *---------------------------------------------------------------------------* 
00001558                           623  OP_ORI      
00001558  4281                     624              CLR.L   D1
0000155A  4284                     625              CLR.L   D4
0000155C  2205                     626              MOVE.L  D5,D1
0000155E  EC99                     627              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001560  0C01 0000                628              CMPI.B  #0,D1
00001564  6700 0012                629              BEQ     OP_ORI_B    * size is byte
00001568  0C01 0001                630              CMPI.B  #1,D1
0000156C  6700 001C                631              BEQ     OP_ORI_W    * size is word
00001570  0C01 0002                632              CMPI.B  #2,D1
00001574  6700 0026                633              BEQ     OP_ORI_L    * size is long
00001578                           634  
00001578                           635  OP_ORI_B    * size is byte    
00001578  183C 0000                636              MOVE.B  #0,D4
0000157C  43F9 0000405F            637              LEA     DISP_ORI_B,A1
00001582  103C 000E                638              MOVE.B  #14,D0
00001586  4E4F                     639              TRAP    #15
00001588  4E75                     640              RTS
0000158A                           641              
0000158A                           642  OP_ORI_W    * size is word
0000158A  183C 0001                643              MOVE.B  #1,D4
0000158E  43F9 00004068            644              LEA     DISP_ORI_W,A1
00001594  103C 000E                645              MOVE.B  #14,D0
00001598  4E4F                     646              TRAP    #15
0000159A  4E75                     647              RTS
0000159C                           648              
0000159C                           649  OP_ORI_L    * size is long
0000159C  183C 0002                650              MOVE.B  #2,D4
000015A0  43F9 00004071            651              LEA     DISP_ORI_L,A1
000015A6  103C 000E                652              MOVE.B  #14,D0
000015AA  4E4F                     653              TRAP    #15
000015AC  4E75                     654              RTS
000015AE                           655          
000015AE                           656  *---------------------------------------------------------------------------*
000015AE                           657  * OP0001: MOVE.B
000015AE                           658  *---------------------------------------------------------------------------*
000015AE                           659  OP0001      
000015AE  4EF9 000015B4            660              JMP     OP_MOVE_B   * display MOVE.B
000015B4                           661              
000015B4                           662  *---------------------------------------------------------------------------*
000015B4                           663  * OP_MOVE_B: display MOVE_B and proceed to EA
000015B4                           664  *---------------------------------------------------------------------------*
000015B4                           665  OP_MOVE_B                                                                       
000015B4                           666             
000015B4                           667             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015B4  13FC 0082 00004370       668             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015BC  13FC 0000 00004371       669             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015C4                           670             
000015C4                           671             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015C4  13FC 00B9 00004373       672             MOVE.B   #$B9,GET_DST_START_END
000015CC  13FC 0020 00004374       673             MOVE.B   #$20,GET_SRC_START_END
000015D4                           674             
000015D4                           675              *CLEAR D3
000015D4  4283                     676              CLR.L   D3
000015D6                           677              *LOAD STACK WITH THIS OPMODE
000015D6  6100 2472                678              BSR     PUSH_STACK
000015DA  163C 004D                679              MOVE.B  #'M',D3
000015DE  6100 246A                680              BSR     PUSH_STACK
000015E2  163C 004F                681              MOVE.B  #'O',D3
000015E6  6100 2462                682              BSR     PUSH_STACK
000015EA  163C 0056                683              MOVE.B  #'V',D3
000015EE  6100 245A                684              BSR     PUSH_STACK
000015F2  163C 0045                685              MOVE.B  #'E',D3
000015F6  6100 2452                686              BSR     PUSH_STACK
000015FA  163C 002E                687              MOVE.B  #'.',D3
000015FE  6100 244A                688              BSR     PUSH_STACK
00001602  163C 0042                689              MOVE.B  #'B',D3
00001606  6100 2442                690              BSR     PUSH_STACK
0000160A                           691              
0000160A  6100 1BA0                692              BSR     GET_EA_EA_SRC
0000160E  163C 002C                693              MOVE.B  #',',D3
00001612  6100 2436                694              BSR     PUSH_STACK
00001616  6100 1FC4                695              BSR     GET_EA_EA_DEST
0000161A                           696              
0000161A  4E75                     697              RTS
0000161C                           698              
0000161C                           699             
0000161C                           700  *---------------------------------------------------------------------------*
0000161C                           701  * OP0010: decode MOVE.L/MOVEA.L
0000161C                           702  *---------------------------------------------------------------------------*
0000161C                           703  OP0010      
0000161C  183C 0002                704              MOVE.B  #2,D4
00001620  4280                     705              CLR.L   D0                     
00001622  4281                     706              CLR.L   D1                      
00001624  227C 00000000            707              MOVEA.L #0, A1                 
0000162A                           708              
0000162A  2205                     709              MOVE.L  D5,D1
0000162C  EA99                     710              ROR.L   #5,D1
0000162E  0281 0000000E            711              ANDI.L  #$E,D1
00001634  0C01 0002                712              CMPI.B  #2,D1
00001638  6700 0070                713              BEQ     OP_MOVEA_L
0000163C                           714  
0000163C  4EF9 00001642            715              JMP     OP_MOVE_L
00001642                           716             
00001642                           717  
00001642                           718  *---------------------------------------------------------------------------*
00001642                           719  * OP_MOVE_L: display MOVE_L and proceed to EA
00001642                           720  *---------------------------------------------------------------------------*
00001642                           721  OP_MOVE_L   
00001642                           722             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001642  13FC 0082 00004370       723             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000164A  13FC 0000 00004371       724             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001652                           725             
00001652                           726             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001652  13FC 00B9 00004373       727             MOVE.B   #$B9,GET_DST_START_END
0000165A  13FC 0020 00004374       728             MOVE.B   #$20,GET_SRC_START_END
00001662                           729             
00001662                           730              *CLEAR D3
00001662  4283                     731              CLR.L   D3
00001664                           732              *LOAD STACK WITH THIS OPMODE
00001664  6100 23E4                733              BSR     PUSH_STACK
00001668  163C 004D                734              MOVE.B  #'M',D3
0000166C  6100 23DC                735              BSR     PUSH_STACK
00001670  163C 004F                736              MOVE.B  #'O',D3
00001674  6100 23D4                737              BSR     PUSH_STACK
00001678  163C 0056                738              MOVE.B  #'V',D3
0000167C  6100 23CC                739              BSR     PUSH_STACK
00001680  163C 0045                740              MOVE.B  #'E',D3
00001684  6100 23C4                741              BSR     PUSH_STACK
00001688  163C 002E                742              MOVE.B  #'.',D3
0000168C  6100 23BC                743              BSR     PUSH_STACK
00001690  163C 004C                744              MOVE.B  #'L',D3
00001694  6100 23B4                745              BSR     PUSH_STACK
00001698                           746              
00001698  6100 1B12                747              BSR     GET_EA_EA_SRC
0000169C  163C 002C                748              MOVE.B  #',',D3
000016A0  6100 23A8                749              BSR     PUSH_STACK
000016A4  6100 1F36                750              BSR     GET_EA_EA_DEST
000016A8                           751              
000016A8  4E75                     752              RTS
000016AA                           753  
000016AA                           754  
000016AA                           755  *---------------------------------------------------------------------------*
000016AA                           756  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000016AA                           757  *---------------------------------------------------------------------------*
000016AA                           758  OP_MOVEA_L 
000016AA                           759             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016AA  13FC 00FD 00004370       760             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016B2  13FC 0000 00004371       761             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016BA                           762             
000016BA                           763             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016BA  13FC 00B9 00004373       764             MOVE.B   #$B9,GET_DST_START_END
000016C2  13FC 0020 00004374       765             MOVE.B   #$20,GET_SRC_START_END
000016CA                           766             
000016CA                           767              *CLEAR D3
000016CA  4283                     768              CLR.L   D3
000016CC                           769              *LOAD STACK WITH THIS OPMODE
000016CC  6100 237C                770              BSR     PUSH_STACK
000016D0  163C 004D                771              MOVE.B  #'M',D3
000016D4  6100 2374                772              BSR     PUSH_STACK
000016D8  163C 004F                773              MOVE.B  #'O',D3
000016DC  6100 236C                774              BSR     PUSH_STACK
000016E0  163C 0056                775              MOVE.B  #'V',D3
000016E4  6100 2364                776              BSR     PUSH_STACK
000016E8  163C 0045                777              MOVE.B  #'E',D3
000016EC  6100 235C                778              BSR     PUSH_STACK           
000016F0  163C 0041                779              MOVE.B  #'A',D3
000016F4  6100 2354                780              BSR     PUSH_STACK
000016F8  163C 002E                781              MOVE.B  #'.',D3
000016FC  6100 234C                782              BSR     PUSH_STACK
00001700  163C 004C                783              MOVE.B  #'L',D3
00001704  6100 2344                784              BSR     PUSH_STACK
00001708                           785              
00001708  6100 1AA2                786              BSR     GET_EA_EA_SRC
0000170C  163C 002C                787              MOVE.B  #',',D3
00001710  6100 2338                788              BSR     PUSH_STACK
00001714  6100 1EC6                789              BSR     GET_EA_EA_DEST
00001718                           790              
00001718  4E75                     791              RTS
0000171A                           792  
0000171A                           793              
0000171A                           794  *---------------------------------------------------------------------------*
0000171A                           795  * OP0011: decode MOVE.W/MOVEA.W
0000171A                           796  *---------------------------------------------------------------------------*
0000171A                           797  OP0011      
0000171A  4280                     798              CLR.L   D0                      
0000171C  4281                     799              CLR.L   D1  
0000171E  4284                     800              CLR.L   D4                   
00001720  227C 00000000            801              MOVEA.L #0, A1 
00001726                           802                
00001726  2205                     803              MOVE.L  D5,D1
00001728  EC99                     804              ROR.L   #6,D1
0000172A  0281 00000007            805              ANDI.L  #$07,D1
00001730  0C01 0001                806              CMPI.B  #1,D1
00001734  6700 0070                807              BEQ     OP_MOVEA_W
00001738                           808              
00001738  4EF9 0000173E            809              JMP     OP_MOVE_W
0000173E                           810            
0000173E                           811  *---------------------------------------------------------------------------*
0000173E                           812  * OP_MOVE_W: display MOVE_W and proceed to EA
0000173E                           813  *---------------------------------------------------------------------------*
0000173E                           814  OP_MOVE_W   
0000173E                           815             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000173E  13FC 0082 00004370       816             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001746  13FC 0000 00004371       817             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000174E                           818             
0000174E                           819             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000174E  13FC 00B9 00004373       820             MOVE.B   #$B9,GET_DST_START_END
00001756  13FC 0020 00004374       821             MOVE.B   #$20,GET_SRC_START_END
0000175E                           822             
0000175E                           823              *CLEAR D3
0000175E  4283                     824              CLR.L   D3
00001760                           825              *LOAD STACK WITH THIS OPMODE
00001760  6100 22E8                826              BSR     PUSH_STACK
00001764  163C 004D                827              MOVE.B  #'M',D3
00001768  6100 22E0                828              BSR     PUSH_STACK
0000176C  163C 004F                829              MOVE.B  #'O',D3
00001770  6100 22D8                830              BSR     PUSH_STACK
00001774  163C 0056                831              MOVE.B  #'V',D3
00001778  6100 22D0                832              BSR     PUSH_STACK
0000177C  163C 0045                833              MOVE.B  #'E',D3
00001780  6100 22C8                834              BSR     PUSH_STACK
00001784  163C 002E                835              MOVE.B  #'.',D3
00001788  6100 22C0                836              BSR     PUSH_STACK
0000178C  163C 0057                837              MOVE.B  #'W',D3
00001790  6100 22B8                838              BSR     PUSH_STACK
00001794                           839              
00001794  6100 1A16                840              BSR     GET_EA_EA_SRC
00001798  163C 002C                841              MOVE.B  #',',D3
0000179C  6100 22AC                842              BSR     PUSH_STACK
000017A0  6100 1E3A                843              BSR     GET_EA_EA_DEST
000017A4                           844              
000017A4  4E75                     845              RTS
000017A6                           846  
000017A6                           847  *---------------------------------------------------------------------------*
000017A6                           848  * OP_MOVEA_W: display MOVEA and proceed to EA
000017A6                           849  *---------------------------------------------------------------------------*
000017A6                           850  OP_MOVEA_W 
000017A6                           851             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017A6  13FC 00FD 00004370       852             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000017AE  13FC 0000 00004371       853             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017B6                           854             
000017B6                           855             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017B6  13FC 00B9 00004373       856             MOVE.B   #$B9,GET_DST_START_END
000017BE  13FC 0020 00004374       857             MOVE.B   #$20,GET_SRC_START_END
000017C6                           858             
000017C6                           859              *CLEAR D3
000017C6  4283                     860              CLR.L   D3
000017C8                           861              *LOAD STACK WITH THIS OPMODE
000017C8  6100 2280                862              BSR     PUSH_STACK
000017CC  163C 004D                863              MOVE.B  #'M',D3
000017D0  6100 2278                864              BSR     PUSH_STACK
000017D4  163C 004F                865              MOVE.B  #'O',D3
000017D8  6100 2270                866              BSR     PUSH_STACK
000017DC  163C 0056                867              MOVE.B  #'V',D3
000017E0  6100 2268                868              BSR     PUSH_STACK
000017E4  163C 0045                869              MOVE.B  #'E',D3
000017E8  6100 2260                870              BSR     PUSH_STACK           
000017EC  163C 0041                871              MOVE.B  #'A',D3
000017F0  6100 2258                872              BSR     PUSH_STACK
000017F4  163C 002E                873              MOVE.B  #'.',D3
000017F8  6100 2250                874              BSR     PUSH_STACK
000017FC  163C 0057                875              MOVE.B  #'W',D3
00001800  6100 2248                876              BSR     PUSH_STACK
00001804                           877              
00001804  6100 19A6                878              BSR     GET_EA_EA_SRC
00001808  163C 002C                879              MOVE.B  #',',D3
0000180C  6100 223C                880              BSR     PUSH_STACK
00001810  6100 1DCA                881              BSR     GET_EA_EA_DEST
00001814                           882            
00001814  4E75                     883              RTS
00001816                           884  *---------------------------------------------------------------------------*
00001816                           885  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001816                           886  *---------------------------------------------------------------------------*
00001816                           887  OP0100
00001816  4280                     888              CLR.L   D0                      
00001818  4281                     889              CLR.L   D1  
0000181A  4284                     890              CLR.L   D4                      
0000181C  227C 00000000            891              MOVEA.L #0, A1                  
00001822  2205                     892              MOVE.L  D5,D1  
00001824                           893              
00001824                           894              * check for RTS
00001824  0C41 4E75                895              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001828  6700 0228                896              BEQ     OP_RTS
0000182C                           897              
0000182C                           898              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
0000182C  4281                     899              CLR.L   D1 
0000182E  2205                     900              MOVE.L  D5,D1  
00001830  0241 0F00                901              ANDI.W  #$0F00,D1
00001834  0C41 0E00                902              CMPI.W  #$0E00,D1
00001838  6700 0204                903              BEQ     OP_JSR
0000183C                           904  
0000183C                           905              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000183C  4281                     906              CLR.L   D1 
0000183E  2205                     907              MOVE.L  D5,D1  
00001840  0241 0F00                908              ANDI.W  #$0F00,D1
00001844  0C41 0400                909              CMPI.W  #$0400,D1
00001848  6700 00E8                910              BEQ     OP_NEG
0000184C                           911              
0000184C                           912              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
0000184C  4281                     913              CLR.L   D1 
0000184E  2205                     914              MOVE.L  D5,D1  
00001850  0241 0F00                915              ANDI.W  #$0F00,D1
00001854  0C41 0600                916              CMPI.W  #$0600,D1
00001858  6700 015E                917              BEQ     OP_NOT
0000185C                           918              
0000185C                           919              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
0000185C  4281                     920              CLR.L   D1 
0000185E  2205                     921              MOVE.L  D5,D1  
00001860  EC99                     922              ROR.L   #6,D1
00001862  0281 00000007            923              ANDI.L  #7,D1
00001868  0C81 00000007            924              CMPI.L  #7,D1
0000186E  6700 0054                925              BEQ     OP_LEA
00001872                           926              
00001872                           927              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001872  4281                     928              CLR.L   D1 
00001874  2205                     929              MOVE.L  D5,D1  
00001876  EB59                     930              ROL.W   #5,D1
00001878  0C01 0001                931              CMPI.B  #1,D1
0000187C  6600 FC38                932              BNE     OP_DATA
00001880  E959                     933              ROL.W   #4,D1
00001882  0C01 0001                934              CMPI.B  #1,D1
00001886  6600 FC2E                935              BNE     OP_DATA
0000188A  E359                     936              ROL.W   #1,D1
0000188C  0C01 0000                937              CMPI.B  #0,D1
00001890  6700 000E                938              BEQ     OP_MOVEM_W
00001894  0C01 0001                939              CMPI.B  #1,D1
00001898  6700 0018                940              BEQ     OP_MOVEM_L
0000189C  4EF8 14B6                941              JMP     OP_DATA
000018A0                           942  
000018A0                           943  *---------------------------------------------------------------------------*
000018A0                           944  * OP_MOVEM_W: display MOVEM_W
000018A0                           945  *---------------------------------------------------------------------------*    
000018A0                           946  OP_MOVEM_W  
000018A0  183C 0001                947              MOVE.B  #1,D4
000018A4  43F9 0000412F            948              LEA     DISP_MOVEM_W,A1
000018AA  103C 000E                949              MOVE.B  #14,D0
000018AE  4E4F                     950              TRAP    #15
000018B0  4E75                     951              RTS
000018B2                           952  
000018B2                           953  *---------------------------------------------------------------------------*
000018B2                           954  * OP_MOVEM_L: display MOVEM_L
000018B2                           955  *---------------------------------------------------------------------------*
000018B2                           956  OP_MOVEM_L  
000018B2  183C 0002                957              MOVE.B  #2,D4
000018B6  43F9 0000413A            958              LEA     DISP_MOVEM_L,A1
000018BC  103C 000E                959              MOVE.B  #14,D0
000018C0  4E4F                     960              TRAP    #15
000018C2  4E75                     961              RTS
000018C4                           962     
000018C4                           963  *---------------------------------------------------------------------------*
000018C4                           964  * OP_LEA: decode and display LEA
000018C4                           965  *---------------------------------------------------------------------------*
000018C4                           966  OP_LEA      
000018C4  4281                     967               CLR.L   D1       
000018C6  4284                     968              CLR.L   D4                   
000018C8  227C 00000000            969              MOVEA.L #0, A1              
000018CE  2205                     970              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000018D0                           971              *CLEAR D3
000018D0  4283                     972              CLR.L   D3
000018D2                           973  
000018D2                           974  OP_LEA_DN_EA_OR_EA_DN 
000018D2                           975              *LOAD STACK WITH THIS OPMODE
000018D2  6100 2176                976              BSR     PUSH_STACK
000018D6  163C 004C                977              MOVE.B  #'L',D3
000018DA  6100 216E                978              BSR     PUSH_STACK
000018DE  163C 0045                979              MOVE.B  #'E',D3
000018E2  6100 2166                980              BSR     PUSH_STACK
000018E6  163C 0041                981              MOVE.B  #'A',D3
000018EA  6100 215E                982              BSR     PUSH_STACK
000018EE  2205                     983              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000018F0                           984          
000018F0                           985  
000018F0                           986  OP_PRINT_L_LEA
000018F0                           987                          
000018F0                           988              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018F0  13FC 0000 00004370       989              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000018F8  13FC 009B 00004371       990              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001900                           991             
00001900                           992              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001900  13FC 00B9 00004373       993              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001908  13FC 0020 00004374       994              MOVE.B   #$20,GET_SRC_START_END
00001910                           995  
00001910                           996              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001910  0285 0000FE3F            997              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001916  0685 00000040            998              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000191C                           999  
0000191C  6100 188E               1000              BSR     GET_EA_EA_SRC      *GETS <ea>
00001920  163C 002C               1001              MOVE.B  #',',D3
00001924  6100 2124               1002              BSR     PUSH_STACK           
00001928  6100 1CB2               1003              BSR     GET_EA_EA_DEST       *GETS Dn    
0000192C                          1004  
0000192C                          1005              
0000192C  6000 0002               1006              BRA     OP_LEA_RETURN
00001930                          1007              
00001930                          1008  OP_LEA_RETURN
00001930  4E75                    1009              RTS
00001932                          1010              
00001932                          1011  
00001932                          1012  
00001932                          1013  *---------------------------------------------------------------------------*
00001932                          1014  * OP_NEG: decode and display NEG 
00001932                          1015  *---------------------------------------------------------------------------*
00001932                          1016  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001932  4281                    1017              CLR.L   D1
00001934  4284                    1018              CLR.L   D4
00001936  2205                    1019              MOVE.L  D5,D1
00001938                          1020              
00001938                          1021              *CLEAR D3
00001938  4283                    1022              CLR.L   D3
0000193A                          1023              *LOAD STACK WITH THIS OPMODE
0000193A  6100 210E               1024              BSR     PUSH_STACK
0000193E  163C 004E               1025              MOVE.B  #'N',D3
00001942  6100 2106               1026              BSR     PUSH_STACK
00001946  163C 0045               1027              MOVE.B  #'E',D3
0000194A  6100 20FE               1028              BSR     PUSH_STACK
0000194E  163C 0047               1029              MOVE.B  #'G',D3
00001952  6100 20F6               1030              BSR     PUSH_STACK
00001956  163C 002E               1031              MOVE.B  #'.',D3
0000195A  6100 20EE               1032              BSR     PUSH_STACK
0000195E                          1033              
0000195E                          1034              
0000195E  EC99                    1035              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001960  0281 00000007           1036              ANDI.L  #$07,D1
00001966                          1037              
00001966  0C01 0000               1038              CMPI.B  #0,D1
0000196A  6700 0012               1039              BEQ     OP_NEG_B    * size is byte
0000196E  0C01 0001               1040              CMPI.B  #1,D1
00001972  6700 0016               1041              BEQ     OP_NEG_W    * size is word
00001976  0C01 0002               1042              CMPI.B  #2,D1
0000197A  6700 001A               1043              BEQ     OP_NEG_L    * size is long
0000197E                          1044                         
0000197E                          1045  
0000197E                          1046  OP_NEG_B    * size is byte   
0000197E  163C 0042               1047              MOVE.B  #'B',D3
00001982  6100 20C6               1048              BSR     PUSH_STACK
00001986  6000 001A               1049              BRA     OP_NEG_PRINT_EA
0000198A                          1050  
0000198A                          1051              
0000198A                          1052  OP_NEG_W    * size is word
0000198A  163C 0057               1053              MOVE.B  #'W',D3
0000198E  6100 20BA               1054              BSR     PUSH_STACK
00001992  6000 000E               1055              BRA     OP_NEG_PRINT_EA
00001996                          1056  
00001996                          1057              
00001996                          1058  OP_NEG_L    * size is long
00001996  163C 004C               1059              MOVE.B  #'L',D3
0000199A  6100 20AE               1060              BSR     PUSH_STACK
0000199E  6000 0002               1061              BRA     OP_NEG_PRINT_EA
000019A2                          1062  
000019A2                          1063  
000019A2                          1064  OP_NEG_PRINT_EA
000019A2                          1065   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019A2  13FC 0082 00004371      1066             MOVE.B   #$82,SRC_REGISTER_FORMAT
000019AA                          1067             
000019AA                          1068             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000019AA  13FC 0020 00004374      1069             MOVE.B   #$20,GET_SRC_START_END
000019B2                          1070                         
000019B2                          1071  
000019B2  6100 17F8               1072              BSR     GET_EA_EA_SRC
000019B6                          1073              
000019B6  4E75                    1074              RTS
000019B8                          1075  
000019B8                          1076  *---------------------------------------------------------------------------*
000019B8                          1077  * OP_NOT: decode and display NOT 
000019B8                          1078  *---------------------------------------------------------------------------*
000019B8                          1079  OP_NOT
000019B8  4281                    1080              CLR.L   D1
000019BA  4284                    1081              CLR.L   D4
000019BC  2205                    1082              MOVE.L  D5,D1
000019BE                          1083              
000019BE                          1084              *CLEAR D3
000019BE  4283                    1085              CLR.L   D3
000019C0                          1086              *LOAD STACK WITH THIS OPMODE
000019C0  6100 2088               1087              BSR     PUSH_STACK
000019C4  163C 004E               1088              MOVE.B  #'N',D3
000019C8  6100 2080               1089              BSR     PUSH_STACK
000019CC  163C 004F               1090              MOVE.B  #'O',D3
000019D0  6100 2078               1091              BSR     PUSH_STACK
000019D4  163C 0054               1092              MOVE.B  #'T',D3
000019D8  6100 2070               1093              BSR     PUSH_STACK
000019DC  163C 002E               1094              MOVE.B  #'.',D3
000019E0  6100 2068               1095              BSR     PUSH_STACK
000019E4                          1096              
000019E4                          1097              
000019E4  EC99                    1098              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000019E6  0281 00000007           1099              ANDI.L  #$07,D1
000019EC                          1100              
000019EC  0C01 0000               1101              CMPI.B  #0,D1
000019F0  6700 0012               1102              BEQ     OP_NOT_B    * size is byte
000019F4  0C01 0001               1103              CMPI.B  #1,D1
000019F8  6700 0016               1104              BEQ     OP_NOT_W    * size is word
000019FC  0C01 0002               1105              CMPI.B  #2,D1
00001A00  6700 001A               1106              BEQ     OP_NOT_L    * size is long
00001A04                          1107                         
00001A04                          1108  
00001A04                          1109  OP_NOT_B    * size is byte   
00001A04  163C 0042               1110              MOVE.B  #'B',D3
00001A08  6100 2040               1111              BSR     PUSH_STACK
00001A0C  6000 001A               1112              BRA     OP_NOT_PRINT_EA
00001A10                          1113  
00001A10                          1114              
00001A10                          1115  OP_NOT_W    * size is word
00001A10  163C 0057               1116              MOVE.B  #'W',D3
00001A14  6100 2034               1117              BSR     PUSH_STACK
00001A18  6000 000E               1118              BRA     OP_NOT_PRINT_EA
00001A1C                          1119  
00001A1C                          1120              
00001A1C                          1121  OP_NOT_L    * size is long
00001A1C  163C 004C               1122              MOVE.B  #'L',D3
00001A20  6100 2028               1123              BSR     PUSH_STACK
00001A24  6000 0002               1124              BRA     OP_NOT_PRINT_EA
00001A28                          1125  
00001A28                          1126  
00001A28                          1127  OP_NOT_PRINT_EA
00001A28                          1128   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A28  13FC 0082 00004371      1129             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001A30                          1130             
00001A30                          1131             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A30  13FC 0020 00004374      1132             MOVE.B   #$20,GET_SRC_START_END
00001A38  6100 1772               1133              BSR     GET_EA_EA_SRC
00001A3C                          1134              
00001A3C  4E75                    1135              RTS
00001A3E                          1136  
00001A3E                          1137  
00001A3E                          1138  *---------------------------------------------------------------------------*
00001A3E                          1139  * OP_JSR: display JSR     
00001A3E                          1140  *---------------------------------------------------------------------------*
00001A3E  43F9 000040EB           1141  OP_JSR      LEA     DISP_JSR,A1
00001A44  103C 000E               1142              MOVE.B  #14,D0
00001A48  4E4F                    1143              TRAP    #15
00001A4A  4EB9 00002CFC           1144              JSR     EA_NOSRC
00001A50                          1145  
00001A50  4E75                    1146              RTS
00001A52                          1147  
00001A52                          1148  *---------------------------------------------------------------------------*
00001A52                          1149  * OP_RTS: display RTS     
00001A52                          1150  *---------------------------------------------------------------------------* 
00001A52                          1151  OP_RTS      
00001A52  163C 0052               1152              MOVE.B #'R',D3
00001A56  6100 1FF2               1153              BSR     PUSH_STACK
00001A5A  163C 0054               1154              MOVE.B #'T',D3
00001A5E  6100 1FEA               1155              BSR     PUSH_STACK
00001A62  163C 0053               1156              MOVE.B #'S',D3
00001A66  6100 1FE2               1157              BSR     PUSH_STACK
00001A6A  4E75                    1158              RTS
00001A6C                          1159  
00001A6C                          1160  *---------------------------------------------------------------------------*
00001A6C                          1161  * OP0101: decode ADDQ
00001A6C                          1162  *---------------------------------------------------------------------------* 
00001A6C                          1163  OP0101      
00001A6C                          1164             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A6C  13FC 0082 00004370      1165             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A74  13FC 0080 00004371      1166             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001A7C                          1167             
00001A7C                          1168             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A7C  13FC 00B9 00004373      1169             MOVE.B   #$B9,GET_DST_START_END
00001A84  13FC 0020 00004374      1170             MOVE.B   #$20,GET_SRC_START_END
00001A8C                          1171             
00001A8C                          1172              *CLEAR D3
00001A8C  4283                    1173              CLR.L   D3
00001A8E                          1174              *LOAD STACK WITH THIS OPMODE
00001A8E  6100 1FBA               1175              BSR     PUSH_STACK
00001A92  163C 0041               1176              MOVE.B  #'A',D3
00001A96  6100 1FB2               1177              BSR     PUSH_STACK
00001A9A  163C 0044               1178              MOVE.B  #'D',D3
00001A9E  6100 1FAA               1179              BSR     PUSH_STACK
00001AA2  163C 0044               1180              MOVE.B  #'D',D3
00001AA6  6100 1FA2               1181              BSR     PUSH_STACK
00001AAA  163C 0051               1182              MOVE.B  #'Q',D3
00001AAE  6100 1F9A               1183              BSR     PUSH_STACK
00001AB2  163C 002E               1184              MOVE.B  #'.',D3
00001AB6  6100 1F92               1185              BSR     PUSH_STACK
00001ABA                          1186              
00001ABA                          1187              *FIGURE OUT SIZE*
00001ABA                          1188              *00 = BYTE
00001ABA                          1189              *01 = WORD
00001ABA                          1190              *10 = LONG
00001ABA                          1191              * BITS 7&6
00001ABA                          1192              
00001ABA                          1193              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001ABA  2205                    1194              MOVE.L  D5,D1
00001ABC  EC99                    1195              ROR.L   #6,D1
00001ABE  0281 00000003           1196              ANDI.L  #$03,D1
00001AC4  0C01 0000               1197              CMPI.B  #%00,D1
00001AC8  6700 001E               1198              BEQ     OP0101_ADDQ_B
00001ACC  0281 00000003           1199              ANDI.L  #$03,D1
00001AD2  0C01 0001               1200              CMPI.B  #%01,D1
00001AD6  6700 001C               1201              BEQ     OP0101_ADDQ_W
00001ADA  0281 00000003           1202              ANDI.L  #$03,D1
00001AE0  0C01 0002               1203              CMPI.B  #%10,D1
00001AE4  6700 001A               1204              BEQ     OP0101_ADDQ_L
00001AE8                          1205            
00001AE8                          1206  OP0101_ADDQ_B
00001AE8                          1207              
00001AE8  163C 0042               1208              MOVE.B  #'B',D3
00001AEC  6100 1F5C               1209              BSR     PUSH_STACK
00001AF0  6000 0016               1210              BRA     OP0101_RETURN
00001AF4                          1211  OP0101_ADDQ_W
00001AF4                          1212              
00001AF4  163C 0057               1213              MOVE.B  #'W',D3
00001AF8  6100 1F50               1214              BSR     PUSH_STACK
00001AFC  6000 000A               1215              BRA     OP0101_RETURN
00001B00                          1216  OP0101_ADDQ_L
00001B00                          1217              
00001B00  163C 004C               1218              MOVE.B  #'L',D3
00001B04  6100 1F44               1219              BSR     PUSH_STACK
00001B08                          1220  OP0101_RETURN            
00001B08                          1221  
00001B08                          1222              
00001B08                          1223  *GET DATA FROM ADDQ AND PRINT #0-8
00001B08  163C 0020               1224              MOVE.B  #' ',D3
00001B0C  6100 1F3C               1225              BSR     PUSH_STACK
00001B10  163C 0023               1226              MOVE.B  #'#',D3
00001B14  6100 1F34               1227              BSR     PUSH_STACK 
00001B18                          1228  
00001B18                          1229                       
00001B18                          1230              *GET DATA #   
00001B18  2205                    1231              MOVE.L  D5,D1
00001B1A  EC99                    1232              ROR.L   #6,D1            
00001B1C  E699                    1233              ROR.L   #3,D1
00001B1E  0281 00000007           1234              ANDI.L  #$07,D1
00001B24                          1235              
00001B24  0C01 0000               1236              CMPI.B  #%000,D1
00001B28  6700 009A               1237              BEQ     OP0101_ADDQ_B_8
00001B2C  0C01 0001               1238              CMPI.B  #%001,D1
00001B30  6700 003E               1239              BEQ     OP0101_ADDQ_B_1
00001B34  0C01 0002               1240              CMPI.B  #%010,D1
00001B38  6700 0042               1241              BEQ     OP0101_ADDQ_B_2
00001B3C  0C01 0003               1242              CMPI.B  #%011,D1
00001B40  6700 0046               1243              BEQ     OP0101_ADDQ_B_3
00001B44  0C01 0004               1244              CMPI.B  #%100,D1
00001B48  6700 004A               1245              BEQ     OP0101_ADDQ_B_4
00001B4C  0C01 0005               1246              CMPI.B  #%101,D1
00001B50  6700 004E               1247              BEQ     OP0101_ADDQ_B_5
00001B54  0C01 0006               1248              CMPI.B  #%110,D1
00001B58  6700 0052               1249              BEQ     OP0101_ADDQ_B_6
00001B5C  0C01 0007               1250              CMPI.B  #%111,D1
00001B60  6700 0056               1251              BEQ     OP0101_ADDQ_B_7
00001B64                          1252              
00001B64                          1253  OP0101_ADDQ_B_0
00001B64  163C 0030               1254              MOVE.B  #'0',D3
00001B68  6100 1EE0               1255              BSR     PUSH_STACK
00001B6C  6000 005E               1256              BRA     OP0101_RETURN2            
00001B70                          1257  OP0101_ADDQ_B_1
00001B70  163C 0031               1258              MOVE.B  #'1',D3
00001B74  6100 1ED4               1259              BSR     PUSH_STACK
00001B78  6000 0052               1260              BRA     OP0101_RETURN2            
00001B7C                          1261  OP0101_ADDQ_B_2
00001B7C  163C 0032               1262              MOVE.B  #'2',D3
00001B80  6100 1EC8               1263              BSR     PUSH_STACK
00001B84  6000 0046               1264              BRA     OP0101_RETURN2            
00001B88                          1265  OP0101_ADDQ_B_3
00001B88  163C 0033               1266              MOVE.B  #'3',D3
00001B8C  6100 1EBC               1267              BSR     PUSH_STACK
00001B90  6000 003A               1268              BRA     OP0101_RETURN2            
00001B94                          1269  OP0101_ADDQ_B_4
00001B94  163C 0034               1270              MOVE.B  #'4',D3
00001B98  6100 1EB0               1271              BSR     PUSH_STACK
00001B9C  6000 002E               1272              BRA     OP0101_RETURN2            
00001BA0                          1273  OP0101_ADDQ_B_5
00001BA0  163C 0035               1274              MOVE.B  #'5',D3
00001BA4  6100 1EA4               1275              BSR     PUSH_STACK
00001BA8  6000 0022               1276              BRA     OP0101_RETURN2
00001BAC                          1277  OP0101_ADDQ_B_6
00001BAC  163C 0036               1278              MOVE.B  #'6',D3
00001BB0  6100 1E98               1279              BSR     PUSH_STACK
00001BB4  6000 0016               1280              BRA     OP0101_RETURN2
00001BB8                          1281  OP0101_ADDQ_B_7
00001BB8  163C 0037               1282              MOVE.B  #'7',D3
00001BBC  6100 1E8C               1283              BSR     PUSH_STACK
00001BC0  6000 000A               1284              BRA     OP0101_RETURN2
00001BC4                          1285  
00001BC4                          1286  OP0101_ADDQ_B_8
00001BC4  163C 0038               1287              MOVE.B  #'8',D3
00001BC8  6100 1E80               1288              BSR     PUSH_STACK
00001BCC                          1289              
00001BCC                          1290  OP0101_RETURN2            
00001BCC  163C 002C               1291              MOVE.B  #',',D3
00001BD0  6100 1E78               1292              BSR     PUSH_STACK
00001BD4  6100 15D6               1293              BSR     GET_EA_EA_SRC
00001BD8                          1294              
00001BD8  4E75                    1295              RTS
00001BDA                          1296  
00001BDA                          1297  
00001BDA                          1298              
00001BDA                          1299  *---------------------------------------------------------------------------*
00001BDA                          1300  * OP_ADDQ: display ADDQ
00001BDA                          1301  *---------------------------------------------------------------------------*              
00001BDA                          1302  OP_ADDQ_B    * size is byte   
00001BDA  183C 0000               1303              MOVE.B  #0,D4 
00001BDE  43F9 00004145           1304              LEA     DISP_ADDQ_B,A1
00001BE4  103C 000E               1305              MOVE.B  #14,D0
00001BE8  4E4F                    1306              TRAP    #15
00001BEA  4E75                    1307              RTS
00001BEC                          1308              
00001BEC                          1309  OP_ADDQ_W    * size is word
00001BEC  183C 0001               1310              MOVE.B  #1,D4
00001BF0  43F9 0000414F           1311              LEA     DISP_ADDQ_W,A1
00001BF6  103C 000E               1312              MOVE.B  #14,D0
00001BFA  4E4F                    1313              TRAP    #15
00001BFC  4E75                    1314              RTS
00001BFE                          1315              
00001BFE                          1316  OP_ADDQ_L    * size is long
00001BFE  183C 0002               1317              MOVE.B  #2,D4
00001C02  43F9 00004159           1318              LEA     DISP_ADDQ_L,A1
00001C08  103C 000E               1319              MOVE.B  #14,D0
00001C0C  4E4F                    1320              TRAP    #15
00001C0E  4E75                    1321              RTS
00001C10                          1322  
00001C10                          1323  *---------------------------------------------------------------------------*
00001C10                          1324  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001C10                          1325  *---------------------------------------------------------------------------*              
00001C10  4280                    1326  OP0110      CLR.L   D0                  
00001C12  4281                    1327              CLR.L   D1   
00001C14  4284                    1328              CLR.L   D4                 
00001C16  227C 00000000           1329              MOVEA.L #0,A1
00001C1C  2205                    1330              MOVE.L  D5, D1                
00001C1E  0281 000000FF           1331              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001C24  2205                    1332              MOVE.L  D5,D1                  
00001C26  0281 00000F00           1333              ANDI.L  #$0F00,D1
00001C2C                          1334                 
00001C2C  0C41 0000               1335              CMPI.W  #$0000,D1               * Check for BRA
00001C30  6700 0050               1336              BEQ     OP_BRA                  
00001C34                          1337                          
00001C34  0C41 0D00               1338              CMPI.W  #$0D00,D1               * Check for BLT
00001C38  6700 0056               1339              BEQ     OP_BLT      
00001C3C                          1340  
00001C3C  0C41 0700               1341              CMPI.W  #$0700,D1               * Check for BEQ
00001C40  6700 0032               1342              BEQ     OP_BEQ      
00001C44                          1343  
00001C44  0C41 0600               1344              CMPI.W  #$0600,D1               * Check for BNE
00001C48  6700 001C               1345              BEQ     OP_BNE  
00001C4C                          1346              
00001C4C  0C41 0200               1347              CMPI.W  #$0200,D1               * Check for BHI
00001C50  6700 0006               1348              BEQ     OP_BHI
00001C54                          1349  
00001C54  4EF8 14B6               1350              JMP     OP_DATA
00001C58                          1351              
00001C58  43F9 00004314           1352  OP_BHI      LEA     DISP_BHI,A1             
00001C5E  103C 000E               1353              MOVE.B  #14,D0
00001C62  4E4F                    1354              TRAP    #15
00001C64  4E75                    1355              RTS
00001C66                          1356  
00001C66  43F9 0000430D           1357  OP_BNE      LEA     DISP_BNE,A1             
00001C6C  103C 000E               1358              MOVE.B  #14,D0
00001C70  4E4F                    1359              TRAP    #15
00001C72  4E75                    1360              RTS
00001C74                          1361  
00001C74  43F9 00004306           1362  OP_BEQ      LEA     DISP_BEQ,A1             
00001C7A  103C 000E               1363              MOVE.B  #14,D0
00001C7E  4E4F                    1364              TRAP    #15
00001C80  4E75                    1365              RTS          
00001C82                          1366                          
00001C82  43F9 000042F8           1367  OP_BRA      LEA     DISP_BRA,A1             
00001C88  103C 000E               1368              MOVE.B  #14,D0
00001C8C  4E4F                    1369              TRAP    #15
00001C8E  4E75                    1370              RTS
00001C90                          1371              
00001C90  43F9 000042FF           1372  OP_BLT      LEA     DISP_BLT,A1          
00001C96  103C 000E               1373              MOVE.B  #14,D0
00001C9A  4E4F                    1374              TRAP    #15
00001C9C  4E75                    1375              RTS
00001C9E                          1376     
00001C9E                          1377  *---------------------------------------------------------------------------*
00001C9E                          1378  * OP0111 : MOVEQ not required
00001C9E                          1379  *---------------------------------------------------------------------------*           
00001C9E  4EF8 14B6               1380  OP0111      JMP     OP_DATA
00001CA2                          1381             
00001CA2                          1382  *---------------------------------------------------------------------------*
00001CA2                          1383  * OP1000 : decode DIVS
00001CA2                          1384  *---------------------------------------------------------------------------*           
00001CA2                          1385  OP1000                           
00001CA2  4281                    1386              CLR.L   D1       
00001CA4  4284                    1387              CLR.L   D4                   
00001CA6  227C 00000000           1388              MOVEA.L #0, A1              
00001CAC  2205                    1389              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001CAE                          1390              *CLEAR D3
00001CAE  4283                    1391              CLR.L   D3
00001CB0                          1392  
00001CB0                          1393  OP1000_DIVS_DN_EA_OR_EA_DN 
00001CB0                          1394              *LOAD STACK WITH THIS OPMODE
00001CB0  6100 1D98               1395              BSR     PUSH_STACK
00001CB4  163C 0044               1396              MOVE.B  #'D',D3
00001CB8  6100 1D90               1397              BSR     PUSH_STACK
00001CBC  163C 0049               1398              MOVE.B  #'I',D3
00001CC0  6100 1D88               1399              BSR     PUSH_STACK
00001CC4  163C 0056               1400              MOVE.B  #'V',D3
00001CC8  6100 1D80               1401              BSR     PUSH_STACK
00001CCC  163C 0053               1402              MOVE.B  #'S',D3
00001CD0  6100 1D78               1403              BSR     PUSH_STACK
00001CD4  163C 002E               1404              MOVE.B  #'.',D3
00001CD8  6100 1D70               1405              BSR     PUSH_STACK
00001CDC                          1406              
00001CDC  2205                    1407              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CDE                          1408              
00001CDE                          1409  OP1000_EA_DN_DIVS
00001CDE                          1410              *BITS (7 TO 6) 
00001CDE                          1411              *00 = .B
00001CDE                          1412              *01 = .W
00001CDE                          1413              *10 = .L 
00001CDE  2205                    1414              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001CE0  EC99                    1415              ROR.L   #6,D1
00001CE2  0281 00000003           1416              ANDI.L  #$03,D1
00001CE8  0C81 00000003           1417              CMPI.L  #%11,D1 *EQUALS .W
00001CEE  6700 0014               1418              BEQ     OP1000_PRINT_W_DIVS
00001CF2  0C81 00000000           1419              CMPI.L  #%00,D1 *EQUALS .L
00001CF8  6700 0052               1420              BEQ     OP1000_PRINT_L_DIVS
00001CFC                          1421              
00001CFC  183C 0001               1422              MOVE.B  #1,D4               *ERROR READ
00001D00  6000 0092               1423              BRA     OP1000_DIVS_RETURN
00001D04                          1424  OP1000_PRINT_W_DIVS
00001D04  163C 0057               1425              MOVE.B  #'W',D3
00001D08  6100 1D40               1426              BSR     PUSH_STACK
00001D0C                          1427  
00001D0C                          1428              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D0C  13FC 0000 00004370      1429              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D14  13FC 0000 00004371      1430              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D1C                          1431             
00001D1C                          1432              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D1C  13FC 00B9 00004373      1433              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D24  13FC 0020 00004374      1434              MOVE.B   #$20,GET_SRC_START_END
00001D2C                          1435  
00001D2C                          1436             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D2C  0285 0000FE3F           1437              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D32  0685 00000000           1438              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001D38                          1439  
00001D38                          1440              
00001D38  6100 1472               1441              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D3C  163C 002C               1442              MOVE.B  #',',D3
00001D40  6100 1D08               1443              BSR     PUSH_STACK
00001D44  6100 1896               1444              BSR     GET_EA_EA_DEST       *GETS Dn    
00001D48                          1445              
00001D48  6000 004A               1446              BRA     OP1000_DIVS_RETURN
00001D4C                          1447  OP1000_PRINT_L_DIVS
00001D4C  163C 004C               1448              MOVE.B  #'L',D3
00001D50  6100 1CF8               1449              BSR     PUSH_STACK
00001D54                          1450              
00001D54                          1451              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D54  13FC 0000 00004370      1452              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D5C  13FC 0000 00004371      1453              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D64                          1454             
00001D64                          1455              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D64  13FC 00B9 00004373      1456              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D6C  13FC 0020 00004374      1457              MOVE.B   #$20,GET_SRC_START_END
00001D74                          1458  
00001D74                          1459              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D74  0285 0000FE3F           1460              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D7A  0685 00000000           1461              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001D80                          1462  
00001D80                          1463                     
00001D80  6100 142A               1464              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D84  163C 002C               1465              MOVE.B  #',',D3
00001D88  6100 1CC0               1466              BSR     PUSH_STACK                  
00001D8C  6100 184E               1467              BSR     GET_EA_EA_DEST       *GETS Dn    
00001D90                          1468  
00001D90                          1469              
00001D90  6000 0002               1470              BRA     OP1000_DIVS_RETURN
00001D94                          1471              
00001D94                          1472  OP1000_DIVS_RETURN
00001D94  4E75                    1473              RTS
00001D96                          1474              
00001D96                          1475  
00001D96                          1476  
00001D96                          1477  *---------------------------------------------------------------------------*
00001D96                          1478  * OP_DIVS: display DIVS and proceed to EA
00001D96                          1479  *---------------------------------------------------------------------------*  
00001D96  43F9 00004163           1480  OP_DIVS     LEA     DISP_DIVS,A1
00001D9C  103C 000E               1481              MOVE.B  #14,D0
00001DA0  4E4F                    1482              TRAP    #15
00001DA2  4EF9 00002D10           1483              JMP     EA_ARITH
00001DA8                          1484  
00001DA8  4E75                    1485              RTS
00001DAA                          1486              
00001DAA                          1487  *---------------------------------------------------------------------------*
00001DAA                          1488  * OP1001: decode SUB/SUBA
00001DAA                          1489  *---------------------------------------------------------------------------*      
00001DAA                          1490  OP1001      
00001DAA  4280                    1491              CLR.L   D0                  
00001DAC  4281                    1492              CLR.L   D1       
00001DAE  4284                    1493              CLR.L   D4                   
00001DB0  227C 00000000           1494              MOVEA.L #0, A1              
00001DB6  2205                    1495              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001DB8                          1496              
00001DB8                          1497              *CLEAR D3
00001DB8  4283                    1498              CLR.L   D3
00001DBA                          1499              
00001DBA                          1500              
00001DBA                          1501              
00001DBA                          1502              **INTEGRATING SUB.W/.L INTO THIS CODE**
00001DBA  2205                    1503              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001DBC                          1504              *BITS (INDEX 8) 
00001DBC                          1505              *0 = ADD.B/W/L <EA>,Dn
00001DBC                          1506              *1 = ADD.B/W/L Dn,<EA> 
00001DBC  EC99                    1507              ROR.L   #6,D1
00001DBE  0281 00000007           1508              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001DC4  0C81 00000007           1509              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001DCA  6700 0010               1510              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001DCE  0C81 00000003           1511              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001DD4  6700 0078               1512              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001DD8  6000 00E6               1513              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001DDC                          1514              
00001DDC                          1515  OP1001_SUBA_L
00001DDC                          1516              *LOAD STACK WITH THIS OPMODE
00001DDC  6100 1C6C               1517              BSR     PUSH_STACK
00001DE0  163C 0053               1518              MOVE.B  #'S',D3
00001DE4  6100 1C64               1519              BSR     PUSH_STACK
00001DE8  163C 0055               1520              MOVE.B  #'U',D3
00001DEC  6100 1C5C               1521              BSR     PUSH_STACK
00001DF0  163C 0042               1522              MOVE.B  #'B',D3
00001DF4  6100 1C54               1523              BSR     PUSH_STACK
00001DF8  163C 0041               1524              MOVE.B  #'A',D3
00001DFC  6100 1C4C               1525              BSR     PUSH_STACK
00001E00  163C 002E               1526              MOVE.B  #'.',D3
00001E04  6100 1C44               1527              BSR     PUSH_STACK
00001E08  163C 004C               1528              MOVE.B  #'L',D3
00001E0C  6100 1C3C               1529              BSR     PUSH_STACK
00001E10                          1530              
00001E10                          1531             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E10  13FC 0000 00004370      1532             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E18  13FC 0000 00004371      1533             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E20                          1534             
00001E20                          1535             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E20  13FC 00B9 00004373      1536             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E28  13FC 0020 00004374      1537             MOVE.B   #$20,GET_SRC_START_END
00001E30                          1538  
00001E30                          1539              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E30  0285 0000FE3F           1540              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E36  0685 00000040           1541              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E3C                          1542       
00001E3C                          1543              *PRINT <EA>,AN
00001E3C  6100 136E               1544              BSR     GET_EA_EA_SRC       *GETS <ea>
00001E40  163C 002C               1545              MOVE.B  #',',D3
00001E44  6100 1C04               1546              BSR     PUSH_STACK                     
00001E48  6100 1792               1547              BSR     GET_EA_EA_DEST      *GETS Dn
00001E4C                          1548  
00001E4C                          1549              
00001E4C                          1550              
00001E4C  4E75                    1551              RTS
00001E4E                          1552  OP1001_SUBA_W
00001E4E                          1553              *LOAD STACK WITH THIS OPMODE
00001E4E  6100 1BFA               1554              BSR     PUSH_STACK
00001E52  163C 0053               1555              MOVE.B  #'S',D3
00001E56  6100 1BF2               1556              BSR     PUSH_STACK
00001E5A  163C 0055               1557              MOVE.B  #'U',D3
00001E5E  6100 1BEA               1558              BSR     PUSH_STACK
00001E62  163C 0042               1559              MOVE.B  #'B',D3
00001E66  6100 1BE2               1560              BSR     PUSH_STACK
00001E6A  163C 0041               1561              MOVE.B  #'A',D3
00001E6E  6100 1BDA               1562              BSR     PUSH_STACK
00001E72  163C 002E               1563              MOVE.B  #'.',D3
00001E76  6100 1BD2               1564              BSR     PUSH_STACK
00001E7A  163C 0057               1565              MOVE.B  #'W',D3
00001E7E  6100 1BCA               1566              BSR     PUSH_STACK
00001E82                          1567              
00001E82                          1568             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E82  13FC 0000 00004370      1569             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E8A  13FC 0000 00004371      1570             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E92                          1571             
00001E92                          1572             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E92  13FC 00B9 00004373      1573             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E9A  13FC 0020 00004374      1574             MOVE.B   #$20,GET_SRC_START_END
00001EA2                          1575  
00001EA2                          1576              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001EA2  0285 0000FE3F           1577              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001EA8  0685 00000040           1578              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001EAE                          1579       
00001EAE                          1580              *PRINT <EA>,AN
00001EAE  6100 12FC               1581              BSR     GET_EA_EA_SRC       *GETS <ea>
00001EB2  163C 002C               1582              MOVE.B  #',',D3
00001EB6  6100 1B92               1583              BSR     PUSH_STACK                     
00001EBA  6100 1720               1584              BSR     GET_EA_EA_DEST      *GETS Dn
00001EBE                          1585  
00001EBE  4E75                    1586              RTS
00001EC0                          1587  
00001EC0                          1588  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001EC0                          1589              *LOAD STACK WITH THIS OPMODE
00001EC0  6100 1B88               1590              BSR     PUSH_STACK
00001EC4  163C 0053               1591              MOVE.B  #'S',D3
00001EC8  6100 1B80               1592              BSR     PUSH_STACK
00001ECC  163C 0055               1593              MOVE.B  #'U',D3
00001ED0  6100 1B78               1594              BSR     PUSH_STACK
00001ED4  163C 0042               1595              MOVE.B  #'B',D3
00001ED8  6100 1B70               1596              BSR     PUSH_STACK
00001EDC  163C 002E               1597              MOVE.B  #'.',D3
00001EE0  6100 1B68               1598              BSR     PUSH_STACK
00001EE4                          1599              
00001EE4  2205                    1600              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001EE6                          1601              
00001EE6                          1602              *BITS (INDEX 8) 
00001EE6                          1603              *0 = ADD.B/W/L <EA>,Dn
00001EE6                          1604              *1 = ADD.B/W/L Dn,<EA> 
00001EE6  E099                    1605              ROR.L   #8,D1
00001EE8  0281 00000001           1606              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001EEE  0C81 00000000           1607              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001EF4  6700 0102               1608              BEQ     OP1001_EA_DN
00001EF8                          1609              *else procede to Dn_EA
00001EF8                          1610              
00001EF8                          1611  OP1001_DN_EA
00001EF8                          1612              *BITS (7 TO 6) 
00001EF8                          1613              *00 = .B
00001EF8                          1614              *01 = .W
00001EF8                          1615              *10 = .L 
00001EF8  2205                    1616              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001EFA  EC99                    1617              ROR.L   #6,D1
00001EFC  0281 00000003           1618              ANDI.L  #$03,D1
00001F02  0C81 00000000           1619              CMPI.L  #$00,D1 *EQUALS .B
00001F08  6700 0016               1620              BEQ     OP1001_PRINT_B2
00001F0C  0C81 00000001           1621              CMPI.L  #$01,D1 *EQUALS .W
00001F12  6700 0054               1622              BEQ     OP1001_PRINT_W2
00001F16  0C81 00000002           1623              CMPI.L  #$02,D1 *EQUALS .L
00001F1C  6700 0092               1624              BEQ     OP1001_PRINT_L2
00001F20                          1625  OP1001_PRINT_B2
00001F20                          1626              *PUSH 'B'
00001F20  163C 0042               1627              MOVE.B  #'B',D3
00001F24  6100 1B24               1628              BSR     PUSH_STACK
00001F28                          1629             
00001F28                          1630              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F28  13FC 0000 00004370      1631             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F30  13FC 0083 00004371      1632             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F38                          1633             
00001F38                          1634             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F38  13FC 00B9 00004373      1635             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F40  13FC 0020 00004374      1636             MOVE.B   #$20,GET_SRC_START_END
00001F48                          1637  
00001F48                          1638              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F48  0285 0000FE3F           1639              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F4E  0685 00000040           1640              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001F54                          1641       
00001F54  6100 1686               1642              BSR     GET_EA_EA_DEST      *GETS Dn
00001F58  163C 002C               1643              MOVE.B  #',',D3
00001F5C  6100 1AEC               1644              BSR     PUSH_STACK                     
00001F60  6100 124A               1645              BSR     GET_EA_EA_SRC       *GETS <ea>
00001F64                          1646  
00001F64                          1647              
00001F64  6000 0A56               1648              BRA     OP1101_ADD_RETURN
00001F68                          1649  OP1001_PRINT_W2
00001F68  163C 0057               1650              MOVE.B  #'W',D3
00001F6C  6100 1ADC               1651              BSR     PUSH_STACK
00001F70                          1652  
00001F70                          1653              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F70  13FC 0000 00004370      1654              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F78  13FC 0083 00004371      1655              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F80                          1656             
00001F80                          1657              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F80  13FC 00B9 00004373      1658              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F88  13FC 0020 00004374      1659              MOVE.B   #$20,GET_SRC_START_END
00001F90                          1660  
00001F90                          1661              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F90  0285 0000FE3F           1662              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F96  0685 00000040           1663              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001F9C                          1664  
00001F9C                          1665        
00001F9C  6100 163E               1666              BSR     GET_EA_EA_DEST      *GETS Dn
00001FA0  163C 002C               1667              MOVE.B  #',',D3
00001FA4  6100 1AA4               1668              BSR     PUSH_STACK               
00001FA8  6100 1202               1669              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001FAC                          1670  
00001FAC                          1671  
00001FAC                          1672  
00001FAC  6000 0A0E               1673              BRA     OP1101_ADD_RETURN
00001FB0                          1674  OP1001_PRINT_L2 
00001FB0  163C 004C               1675              MOVE.B  #'L',D3
00001FB4  6100 1A94               1676              BSR     PUSH_STACK
00001FB8                          1677              
00001FB8                          1678              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001FB8  13FC 0000 00004370      1679              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001FC0  13FC 0083 00004371      1680              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001FC8                          1681             
00001FC8                          1682              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001FC8  13FC 00B9 00004373      1683              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001FD0  13FC 0020 00004374      1684              MOVE.B   #$20,GET_SRC_START_END
00001FD8                          1685  
00001FD8                          1686             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001FD8  0285 0000FE3F           1687              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001FDE  0685 00000040           1688              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001FE4                          1689  
00001FE4                          1690               
00001FE4  6100 15F6               1691              BSR     GET_EA_EA_DEST       *GETS Dn
00001FE8  163C 002C               1692              MOVE.B  #',',D3
00001FEC  6100 1A5C               1693              BSR     PUSH_STACK          
00001FF0  6100 11BA               1694              BSR     GET_EA_EA_SRC        *GETS <ea>
00001FF4                          1695  
00001FF4  6000 09C6               1696              BRA     OP1101_ADD_RETURN
00001FF8                          1697              
00001FF8                          1698  OP1001_EA_DN           
00001FF8                          1699              *BITS (7 TO 6) 
00001FF8                          1700              *00 = .B
00001FF8                          1701              *01 = .W
00001FF8                          1702              *10 = .L 
00001FF8  2205                    1703              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001FFA  EC99                    1704              ROR.L   #6,D1
00001FFC  0281 00000003           1705              ANDI.L  #$03,D1
00002002  0C81 00000000           1706              CMPI.L  #$00,D1 *EQUALS .B
00002008  6700 0016               1707              BEQ     OP1001_PRINT_B
0000200C  0C81 00000001           1708              CMPI.L  #$01,D1 *EQUALS .W
00002012  6700 0054               1709              BEQ     OP1001_PRINT_W
00002016  0C81 00000002           1710              CMPI.L  #$02,D1 *EQUALS .L
0000201C  6700 0092               1711              BEQ     OP1001_PRINT_L
00002020                          1712  OP1001_PRINT_B
00002020  163C 0042               1713              MOVE.B  #'B',D3
00002024  6100 1A24               1714              BSR     PUSH_STACK
00002028                          1715                
00002028                          1716              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002028  13FC 0000 00004370      1717              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002030  13FC 0002 00004371      1718              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002038                          1719             
00002038                          1720              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002038  13FC 00B9 00004373      1721              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002040  13FC 0020 00004374      1722              MOVE.B   #$20,GET_SRC_START_END
00002048                          1723  
00002048                          1724             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002048  0285 0000FE3F           1725              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000204E  0685 00000040           1726              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002054                          1727  
00002054                          1728              
00002054  6100 1156               1729              BSR     GET_EA_EA_SRC      *GETS <ea>
00002058  163C 002C               1730              MOVE.B  #',',D3
0000205C  6100 19EC               1731              BSR     PUSH_STACK          
00002060  6100 157A               1732              BSR     GET_EA_EA_DEST       *GETS Dn
00002064                          1733              
00002064  6000 0956               1734              BRA     OP1101_ADD_RETURN
00002068                          1735  OP1001_PRINT_W
00002068  163C 0057               1736              MOVE.B  #'W',D3
0000206C  6100 19DC               1737              BSR     PUSH_STACK
00002070                          1738  
00002070                          1739              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002070  13FC 0000 00004370      1740              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002078  13FC 0000 00004371      1741              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002080                          1742             
00002080                          1743              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002080  13FC 00B9 00004373      1744              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002088  13FC 0020 00004374      1745              MOVE.B   #$20,GET_SRC_START_END
00002090                          1746  
00002090                          1747             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002090  0285 0000FE3F           1748              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002096  0685 00000040           1749              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000209C                          1750  
0000209C                          1751              
0000209C  6100 110E               1752              BSR     GET_EA_EA_SRC      *GETS <ea>
000020A0  163C 002C               1753              MOVE.B  #',',D3
000020A4  6100 19A4               1754              BSR     PUSH_STACK
000020A8  6100 1532               1755              BSR     GET_EA_EA_DEST       *GETS Dn    
000020AC                          1756              
000020AC  6000 004A               1757              BRA     OP1001_ADD_RETURN
000020B0                          1758  OP1001_PRINT_L 
000020B0  163C 004C               1759              MOVE.B  #'L',D3
000020B4  6100 1994               1760              BSR     PUSH_STACK
000020B8                          1761              
000020B8                          1762              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020B8  13FC 0000 00004370      1763              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020C0  13FC 0000 00004371      1764              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020C8                          1765             
000020C8                          1766              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020C8  13FC 00B9 00004373      1767              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020D0  13FC 0020 00004374      1768              MOVE.B   #$20,GET_SRC_START_END
000020D8                          1769  
000020D8                          1770              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000020D8  0285 0000FE3F           1771              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020DE  0685 00000040           1772              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000020E4                          1773  
000020E4                          1774                     
000020E4  6100 10C6               1775              BSR     GET_EA_EA_SRC      *GETS <ea>
000020E8  163C 002C               1776              MOVE.B  #',',D3
000020EC  6100 195C               1777              BSR     PUSH_STACK                  
000020F0  6100 14EA               1778              BSR     GET_EA_EA_DEST       *GETS Dn    
000020F4                          1779  
000020F4                          1780              
000020F4  6000 0002               1781              BRA     OP1001_ADD_RETURN
000020F8                          1782              
000020F8                          1783  OP1001_ADD_RETURN
000020F8  4E75                    1784              RTS
000020FA                          1785  
000020FA                          1786    
000020FA                          1787  *---------------------------------------------------------------------------*
000020FA                          1788  * OP_SUB: display SUB and proceed to EA
000020FA                          1789  *---------------------------------------------------------------------------*            
000020FA  43F9 0000416B           1790  OP_SUB_B    LEA     DISP_SUB_B,A1
00002100  103C 000E               1791              MOVE.B  #14,D0
00002104  4E4F                    1792              TRAP    #15
00002106  183C 0000               1793              MOVE.B  #0,D4
0000210A  4EF9 00002D5C           1794              JMP     EA_GEN
00002110                          1795  
00002110  4E75                    1796              RTS
00002112                          1797  
00002112  43F9 00004174           1798  OP_SUB_W    LEA     DISP_SUB_W,A1
00002118  103C 000E               1799              MOVE.B  #14,D0
0000211C  4E4F                    1800              TRAP    #15
0000211E  183C 0001               1801              MOVE.B  #1,D4
00002122  4EF9 00002D5C           1802              JMP     EA_GEN
00002128                          1803  
00002128  4E75                    1804              RTS
0000212A                          1805  
0000212A  43F9 0000417D           1806  OP_SUB_L    LEA     DISP_SUB_L,A1
00002130  103C 000E               1807              MOVE.B  #14,D0
00002134  4E4F                    1808              TRAP    #15
00002136  183C 0002               1809              MOVE.B  #2,D4
0000213A  4EF9 00002D5C           1810              JMP     EA_GEN
00002140                          1811  
00002140  4E75                    1812              RTS
00002142                          1813  
00002142                          1814  *---------------------------------------------------------------------------*
00002142                          1815  * OP_SUBA: display SUBA
00002142                          1816  *---------------------------------------------------------------------------*  
00002142  43F9 000041A4           1817  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00002148  103C 000E               1818              MOVE.B  #14,D0
0000214C  4E4F                    1819              TRAP    #15
0000214E  183C 0001               1820              MOVE.B  #1,D4
00002152  4E75                    1821              RTS
00002154                          1822  
00002154  43F9 000041AE           1823  OP_SUBA_L   LEA     DISP_SUBA_L,A1
0000215A  103C 000E               1824              MOVE.B  #14,D0
0000215E  4E4F                    1825              TRAP    #15
00002160  183C 0002               1826              MOVE.B  #2,D4
00002164  4E75                    1827              RTS         
00002166                          1828  *---------------------------------------------------------------------------*
00002166                          1829  * OP1010 : unassigned
00002166                          1830  *---------------------------------------------------------------------------*           
00002166  4EF8 14B6               1831  OP1010      JMP     OP_DATA
0000216A                          1832              
0000216A                          1833  *---------------------------------------------------------------------------*
0000216A                          1834  * OP1011 : decode CMP/EOR/CMPA
0000216A                          1835  *---------------------------------------------------------------------------*           
0000216A  4280                    1836  OP1011      CLR.L   D0                
0000216C  4281                    1837              CLR.L   D1            
0000216E  4284                    1838              CLR.L   D4                   
00002170  227C 00000000           1839              MOVEA.L #0, A1               
00002176  2205                    1840              MOVE.L  D5,D1
00002178  EA99                    1841              ROR.L   #5,D1
0000217A  0281 0000000E           1842              ANDI.L  #$E,D1
00002180  0C01 0000               1843              CMPI.B  #$0,D1
00002184  6700 003E               1844              BEQ     OP1011_CMP
00002188  0C01 0002               1845              CMPI.B  #$2,D1
0000218C  6700 0036               1846              BEQ     OP1011_CMP
00002190  0C01 0004               1847              CMPI.B  #$4,D1
00002194  6700 002E               1848              BEQ     OP1011_CMP
00002198  0C01 0008               1849              CMPI.B  #$8,D1
0000219C  6700 002A               1850              BEQ     OP1011_EOR
000021A0  0C01 000A               1851              CMPI.B  #$A,D1
000021A4  6700 0022               1852              BEQ     OP1011_EOR
000021A8  0C01 000C               1853              CMPI.B  #$C,D1
000021AC  6700 001A               1854              BEQ     OP1011_EOR  
000021B0  0C01 0006               1855              CMPI.B  #$6,D1
000021B4  6700 0010               1856              BEQ     OP1011_CMPA
000021B8  0C01 000E               1857              CMPI.B  #$E,D1
000021BC  6700 0008               1858              BEQ     OP1011_CMPA 
000021C0                          1859  
000021C0  4EF8 14B6               1860              JMP     OP_DATA          
000021C4                          1861  
000021C4                          1862  
000021C4                          1863  
000021C4                          1864  
000021C4                          1865  OP1011_CMP
000021C4  4E75                    1866              RTS
000021C6                          1867  
000021C6                          1868  OP1011_CMPA
000021C6  4E75                    1869              RTS
000021C8                          1870  OP1011_EOR
000021C8                          1871  
000021C8                          1872   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021C8  13FC 0082 00004370      1873             MOVE.B   #$82,DEST_REGISTER_FORMAT
000021D0  13FC 0080 00004371      1874             MOVE.B   #$80,SRC_REGISTER_FORMAT
000021D8                          1875             
000021D8                          1876             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021D8  13FC 00B9 00004373      1877             MOVE.B   #$B9,GET_DST_START_END
000021E0  13FC 0020 00004374      1878             MOVE.B   #$20,GET_SRC_START_END
000021E8                          1879             
000021E8                          1880              *CLEAR D3
000021E8  4283                    1881              CLR.L   D3
000021EA                          1882              *LOAD STACK WITH THIS OPMODE
000021EA  6100 185E               1883              BSR     PUSH_STACK
000021EE  163C 0045               1884              MOVE.B  #'E',D3
000021F2  6100 1856               1885              BSR     PUSH_STACK
000021F6  163C 004F               1886              MOVE.B  #'O',D3
000021FA  6100 184E               1887              BSR     PUSH_STACK
000021FE  163C 0052               1888              MOVE.B  #'R',D3
00002202  6100 1846               1889              BSR     PUSH_STACK
00002206  163C 002E               1890              MOVE.B  #'.',D3
0000220A  6100 183E               1891              BSR     PUSH_STACK
0000220E                          1892              
0000220E                          1893              *FIGURE OUT SIZE*
0000220E                          1894              *00 = BYTE
0000220E                          1895              *01 = WORD
0000220E                          1896              *10 = LONG
0000220E                          1897              * BITS 7&6
0000220E                          1898              
0000220E                          1899              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000220E  2205                    1900              MOVE.L  D5,D1
00002210  EC99                    1901              ROR.L   #6,D1
00002212  0281 00000003           1902              ANDI.L  #$03,D1
00002218  0C01 0000               1903              CMPI.B  #%00,D1
0000221C  6700 001E               1904              BEQ     OP1011_EOR_B
00002220  0281 00000003           1905              ANDI.L  #$03,D1
00002226  0C01 0001               1906              CMPI.B  #%01,D1
0000222A  6700 001C               1907              BEQ     OP1011_EOR_W
0000222E  0281 00000003           1908              ANDI.L  #$03,D1
00002234  0C01 0002               1909              CMPI.B  #%10,D1
00002238  6700 001A               1910              BEQ     OP1011_EOR_L
0000223C                          1911            
0000223C                          1912  OP1011_EOR_B
0000223C                          1913              
0000223C  163C 0042               1914              MOVE.B  #'B',D3
00002240  6100 1808               1915              BSR     PUSH_STACK
00002244  6000 0016               1916              BRA     OP1011_RETURN
00002248                          1917  OP1011_EOR_W
00002248                          1918              
00002248  163C 0057               1919              MOVE.B  #'W',D3
0000224C  6100 17FC               1920              BSR     PUSH_STACK
00002250  6000 000A               1921              BRA     OP1011_RETURN
00002254                          1922  OP1011_EOR_L
00002254                          1923              
00002254  163C 004C               1924              MOVE.B  #'L',D3
00002258  6100 17F0               1925              BSR     PUSH_STACK
0000225C                          1926  OP1011_RETURN            
0000225C                          1927  
0000225C                          1928              
0000225C                          1929  *GET DATA FROM ADDQ AND PRINT #0-8
0000225C                          1930       
0000225C                          1931              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000225C  0285 0000FE3F           1932              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002262  0685 00000000           1933              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002268                          1934  
00002268  6100 1372               1935              BSR     GET_EA_EA_DEST
0000226C  163C 002C               1936              MOVE.B  #',',D3
00002270  6100 17D8               1937              BSR     PUSH_STACK
00002274  6100 0F36               1938              BSR     GET_EA_EA_SRC
00002278                          1939              
00002278  4E75                    1940              RTS
0000227A                          1941              
0000227A                          1942              
0000227A                          1943              
0000227A                          1944              
0000227A                          1945  
0000227A                          1946  *---------------------------------------------------------------------------*
0000227A                          1947  * OP_CMPA: display CMPA 
0000227A                          1948  *---------------------------------------------------------------------------
0000227A  43F9 000041EE           1949  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00002280  103C 000E               1950              MOVE.B  #14,D0
00002284  4E4F                    1951              TRAP    #15
00002286  183C 0001               1952              MOVE.B  #1,D4
0000228A  4E75                    1953              RTS
0000228C                          1954  
0000228C  43F9 000041F8           1955  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002292  103C 000E               1956              MOVE.B  #14,D0
00002296  4E4F                    1957              TRAP    #15
00002298  183C 0002               1958              MOVE.B  #2,D4
0000229C  4E75                    1959              RTS
0000229E                          1960  
0000229E                          1961  *---------------------------------------------------------------------------*
0000229E                          1962  * OP_CMP: display CMP and proceed to EA
0000229E                          1963  *---------------------------------------------------------------------------*  
0000229E  43F9 000041D3           1964  OP_CMP_B    LEA     DISP_CMP_B,A1
000022A4  103C 000E               1965              MOVE.B  #14,D0
000022A8  4E4F                    1966              TRAP    #15
000022AA  183C 0000               1967              MOVE.B  #0,D4
000022AE  4EF9 00002D5C           1968              JMP     EA_GEN
000022B4                          1969  
000022B4  4E75                    1970              RTS
000022B6                          1971              
000022B6  43F9 000041DC           1972  OP_CMP_W    LEA     DISP_CMP_W,A1
000022BC  103C 000E               1973              MOVE.B  #14,D0
000022C0  4E4F                    1974              TRAP    #15
000022C2  183C 0001               1975              MOVE.B  #1,D4
000022C6  4EF9 00002D5C           1976              JMP     EA_GEN
000022CC                          1977  
000022CC  4E75                    1978              RTS
000022CE                          1979              
000022CE  43F9 000041E5           1980  OP_CMP_L    LEA     DISP_CMP_L,A1
000022D4  103C 000E               1981              MOVE.B  #14,D0
000022D8  4E4F                    1982              TRAP    #15
000022DA  183C 0002               1983              MOVE.B  #2,D4
000022DE  4EF9 00002D5C           1984              JMP     EA_GEN
000022E4                          1985  
000022E4  4E75                    1986              RTS
000022E6                          1987              
000022E6                          1988  *---------------------------------------------------------------------------*
000022E6                          1989  * OP_EOR: display EOR
000022E6                          1990  *---------------------------------------------------------------------------*  
000022E6  43F9 000041B8           1991  OP_EOR_B    LEA     DISP_EOR_B,A1
000022EC  103C 000E               1992              MOVE.B  #14,D0
000022F0  4E4F                    1993              TRAP    #15
000022F2  183C 0000               1994              MOVE.B  #0,D4
000022F6  4E75                    1995              RTS
000022F8                          1996              
000022F8  43F9 000041C1           1997  OP_EOR_W    LEA     DISP_EOR_W,A1
000022FE  103C 000E               1998              MOVE.B  #14,D0
00002302  4E4F                    1999              TRAP    #15
00002304  183C 0001               2000              MOVE.B  #1,D4
00002308  4E75                    2001              RTS
0000230A                          2002              
0000230A  43F9 000041CA           2003  OP_EOR_L    LEA     DISP_EOR_L,A1
00002310  103C 000E               2004              MOVE.B  #14,D0
00002314  4E4F                    2005              TRAP    #15
00002316  183C 0002               2006              MOVE.B  #2,D4
0000231A  4E75                    2007              RTS    
0000231C                          2008  
0000231C                          2009  *---------------------------------------------------------------------------*
0000231C                          2010  * OP1100: Decode and display MULS/AND and proceed to EA
0000231C                          2011  *---------------------------------------------------------------------------* 
0000231C  4280                    2012  OP1100      CLR.L   D0                 
0000231E  4281                    2013              CLR.L   D1    
00002320  4284                    2014              CLR.L   D4                
00002322  227C 00000000           2015              MOVEA.L #0, A1        
00002328  2205                    2016              MOVE.L  D5,D1
0000232A  EA89                    2017              LSR.L   #5,D1
0000232C  0281 0000000E           2018              ANDI.L  #$E,D1
00002332  0C41 000E               2019              CMPI.W  #$E,D1
00002336  6700 0006               2020              BEQ     OP_MULS
0000233A  6000 00F6               2021              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000233E                          2022  
0000233E                          2023  OP_MULS                      
0000233E  4281                    2024              CLR.L   D1       
00002340  4284                    2025              CLR.L   D4                   
00002342  227C 00000000           2026              MOVEA.L #0, A1              
00002348  2205                    2027              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000234A                          2028              *CLEAR D3
0000234A  4283                    2029              CLR.L   D3
0000234C                          2030  
0000234C                          2031  OP1100_MULS_DN_EA_OR_EA_DN 
0000234C                          2032              *LOAD STACK WITH THIS OPMODE
0000234C  6100 16FC               2033              BSR     PUSH_STACK
00002350  163C 004D               2034              MOVE.B  #'M',D3
00002354  6100 16F4               2035              BSR     PUSH_STACK
00002358  163C 0055               2036              MOVE.B  #'U',D3
0000235C  6100 16EC               2037              BSR     PUSH_STACK
00002360  163C 004C               2038              MOVE.B  #'L',D3
00002364  6100 16E4               2039              BSR     PUSH_STACK
00002368  163C 0053               2040              MOVE.B  #'S',D3
0000236C  6100 16DC               2041              BSR     PUSH_STACK
00002370  163C 002E               2042              MOVE.B  #'.',D3
00002374  6100 16D4               2043              BSR     PUSH_STACK
00002378                          2044              
00002378  2205                    2045              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000237A                          2046              
0000237A                          2047  OP1100_EA_DN_MULS           
0000237A                          2048              *BITS (7 TO 6) 
0000237A                          2049              *00 = .B
0000237A                          2050              *01 = .W
0000237A                          2051              *10 = .L 
0000237A  2205                    2052              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000237C  EC99                    2053              ROR.L   #6,D1
0000237E  0281 00000003           2054              ANDI.L  #$03,D1
00002384  0C81 00000003           2055              CMPI.L  #%11,D1 *EQUALS .W
0000238A  6700 0014               2056              BEQ     OP1100_PRINT_W_MULS
0000238E  0C81 00000000           2057              CMPI.L  #%00,D1 *EQUALS .L
00002394  6700 0052               2058              BEQ     OP1100_PRINT_L_MULS
00002398                          2059              
00002398  183C 0001               2060              MOVE.B  #1,D4               *ERROR READ
0000239C  6000 0092               2061              BRA     OP1100_MULS_RETURN
000023A0                          2062  OP1100_PRINT_W_MULS
000023A0  163C 0057               2063              MOVE.B  #'W',D3
000023A4  6100 16A4               2064              BSR     PUSH_STACK
000023A8                          2065  
000023A8                          2066              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023A8  13FC 0000 00004370      2067              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023B0  13FC 0000 00004371      2068              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023B8                          2069             
000023B8                          2070              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023B8  13FC 00B9 00004373      2071              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023C0  13FC 0020 00004374      2072              MOVE.B   #$20,GET_SRC_START_END
000023C8                          2073  
000023C8                          2074             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023C8  0285 0000FE3F           2075              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023CE  0685 00000000           2076              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000023D4                          2077  
000023D4                          2078              
000023D4  6100 0DD6               2079              BSR     GET_EA_EA_SRC      *GETS <ea>
000023D8  163C 002C               2080              MOVE.B  #',',D3
000023DC  6100 166C               2081              BSR     PUSH_STACK
000023E0  6100 11FA               2082              BSR     GET_EA_EA_DEST       *GETS Dn    
000023E4                          2083              
000023E4  6000 004A               2084              BRA     OP1100_MULS_RETURN
000023E8                          2085  OP1100_PRINT_L_MULS 
000023E8  163C 004C               2086              MOVE.B  #'L',D3
000023EC  6100 165C               2087              BSR     PUSH_STACK
000023F0                          2088              
000023F0                          2089              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023F0  13FC 0000 00004370      2090              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023F8  13FC 0000 00004371      2091              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002400                          2092             
00002400                          2093              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002400  13FC 00B9 00004373      2094              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002408  13FC 0020 00004374      2095              MOVE.B   #$20,GET_SRC_START_END
00002410                          2096  
00002410                          2097              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002410  0285 0000FE3F           2098              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002416  0685 00000000           2099              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000241C                          2100  
0000241C                          2101                     
0000241C  6100 0D8E               2102              BSR     GET_EA_EA_SRC      *GETS <ea>
00002420  163C 002C               2103              MOVE.B  #',',D3
00002424  6100 1624               2104              BSR     PUSH_STACK                  
00002428  6100 11B2               2105              BSR     GET_EA_EA_DEST       *GETS Dn    
0000242C                          2106  
0000242C                          2107              
0000242C  6000 0002               2108              BRA     OP1100_MULS_RETURN
00002430                          2109              
00002430                          2110  OP1100_MULS_RETURN
00002430  4E75                    2111              RTS
00002432                          2112              
00002432                          2113  
00002432                          2114  
00002432                          2115  
00002432                          2116  
00002432                          2117  
00002432                          2118  
00002432                          2119  
00002432                          2120  
00002432                          2121  
00002432                          2122  
00002432                          2123  
00002432                          2124  
00002432                          2125  OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002432                          2126              *LOAD STACK WITH THIS OPMODE
00002432  4283                    2127              CLR.L   D3
00002434  6100 1614               2128              BSR     PUSH_STACK
00002438  163C 0041               2129              MOVE.B  #'A',D3
0000243C  6100 160C               2130              BSR     PUSH_STACK
00002440  163C 004E               2131              MOVE.B  #'N',D3
00002444  6100 1604               2132              BSR     PUSH_STACK
00002448  163C 0044               2133              MOVE.B  #'D',D3
0000244C  6100 15FC               2134              BSR     PUSH_STACK
00002450  163C 002E               2135              MOVE.B  #'.',D3
00002454  6100 15F4               2136              BSR     PUSH_STACK
00002458                          2137              
00002458  2205                    2138              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000245A                          2139              
0000245A                          2140              *BITS (INDEX 8) 
0000245A                          2141              *0 = ADD.B/W/L <EA>,Dn
0000245A                          2142              *1 = ADD.B/W/L Dn,<EA> 
0000245A  E099                    2143              ROR.L   #8,D1
0000245C  0281 00000001           2144              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002462  0C81 00000000           2145              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002468  6700 0102               2146              BEQ     OP1100_EA_DN
0000246C                          2147              *else procede to Dn_EA
0000246C                          2148              
0000246C                          2149  OP1100_DN_EA
0000246C                          2150              *BITS (7 TO 6) 
0000246C                          2151              *00 = .B
0000246C                          2152              *01 = .W
0000246C                          2153              *10 = .L 
0000246C  2205                    2154              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000246E  EC99                    2155              ROR.L   #6,D1
00002470  0281 00000003           2156              ANDI.L  #$03,D1
00002476  0C81 00000000           2157              CMPI.L  #$00,D1 *EQUALS .B
0000247C  6700 0016               2158              BEQ     OP1100_PRINT_B2
00002480  0C81 00000001           2159              CMPI.L  #$01,D1 *EQUALS .W
00002486  6700 0054               2160              BEQ     OP1100_PRINT_W2
0000248A  0C81 00000002           2161              CMPI.L  #$02,D1 *EQUALS .L
00002490  6700 0092               2162              BEQ     OP1100_PRINT_L2
00002494                          2163  OP1100_PRINT_B2
00002494                          2164              *PUSH 'B'
00002494  163C 0042               2165              MOVE.B  #'B',D3
00002498  6100 15B0               2166              BSR     PUSH_STACK
0000249C                          2167             
0000249C                          2168              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000249C  13FC 0000 00004370      2169             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024A4  13FC 0083 00004371      2170             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024AC                          2171             
000024AC                          2172             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024AC  13FC 00B9 00004373      2173             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024B4  13FC 0020 00004374      2174             MOVE.B   #$20,GET_SRC_START_END
000024BC                          2175  
000024BC                          2176              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024BC  0285 0000FE3F           2177              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024C2  0685 00000000           2178              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024C8                          2179       
000024C8  6100 1112               2180              BSR     GET_EA_EA_DEST      *GETS Dn
000024CC  163C 002C               2181              MOVE.B  #',',D3
000024D0  6100 1578               2182              BSR     PUSH_STACK                     
000024D4  6100 0CD6               2183              BSR     GET_EA_EA_SRC       *GETS <ea>
000024D8                          2184  
000024D8                          2185              
000024D8  6000 0192               2186              BRA     OP1100_AND_RETURN
000024DC                          2187  OP1100_PRINT_W2
000024DC  163C 0057               2188              MOVE.B  #'W',D3
000024E0  6100 1568               2189              BSR     PUSH_STACK
000024E4                          2190  
000024E4                          2191              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024E4  13FC 0000 00004370      2192              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024EC  13FC 0083 00004371      2193              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024F4                          2194             
000024F4                          2195              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024F4  13FC 00B9 00004373      2196              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024FC  13FC 0020 00004374      2197              MOVE.B   #$20,GET_SRC_START_END
00002504                          2198  
00002504                          2199              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002504  0285 0000FE3F           2200              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000250A  0685 00000000           2201              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002510                          2202  
00002510                          2203        
00002510  6100 10CA               2204              BSR     GET_EA_EA_DEST      *GETS Dn
00002514  163C 002C               2205              MOVE.B  #',',D3
00002518  6100 1530               2206              BSR     PUSH_STACK               
0000251C  6100 0C8E               2207              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002520                          2208  
00002520                          2209  
00002520                          2210  
00002520  6000 049A               2211              BRA     OP1101_ADD_RETURN
00002524                          2212  OP1100_PRINT_L2 
00002524  163C 004C               2213              MOVE.B  #'L',D3
00002528  6100 1520               2214              BSR     PUSH_STACK
0000252C                          2215              
0000252C                          2216              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000252C  13FC 0000 00004370      2217              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002534  13FC 0083 00004371      2218              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000253C                          2219             
0000253C                          2220              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000253C  13FC 00B9 00004373      2221              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002544  13FC 0020 00004374      2222              MOVE.B   #$20,GET_SRC_START_END
0000254C                          2223  
0000254C                          2224             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000254C  0285 0000FE3F           2225              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002552  0685 00000000           2226              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002558                          2227  
00002558                          2228               
00002558  6100 1082               2229              BSR     GET_EA_EA_DEST       *GETS Dn
0000255C  163C 002C               2230              MOVE.B  #',',D3
00002560  6100 14E8               2231              BSR     PUSH_STACK          
00002564  6100 0C46               2232              BSR     GET_EA_EA_SRC        *GETS <ea>
00002568                          2233  
00002568  6000 0102               2234              BRA     OP1100_AND_RETURN
0000256C                          2235              
0000256C                          2236  OP1100_EA_DN           
0000256C                          2237              *BITS (7 TO 6) 
0000256C                          2238              *00 = .B
0000256C                          2239              *01 = .W
0000256C                          2240              *10 = .L 
0000256C  2205                    2241              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000256E  EC99                    2242              ROR.L   #6,D1
00002570  0281 00000003           2243              ANDI.L  #$03,D1
00002576  0C81 00000000           2244              CMPI.L  #$00,D1 *EQUALS .B
0000257C  6700 0016               2245              BEQ     OP1100_PRINT_B
00002580  0C81 00000001           2246              CMPI.L  #$01,D1 *EQUALS .W
00002586  6700 0054               2247              BEQ     OP1100_PRINT_W
0000258A  0C81 00000002           2248              CMPI.L  #$02,D1 *EQUALS .L
00002590  6700 0092               2249              BEQ     OP1100_PRINT_L
00002594                          2250  OP1100_PRINT_B
00002594  163C 0042               2251              MOVE.B  #'B',D3
00002598  6100 14B0               2252              BSR     PUSH_STACK
0000259C                          2253                
0000259C                          2254              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000259C  13FC 0000 00004370      2255              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025A4  13FC 0002 00004371      2256              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025AC                          2257             
000025AC                          2258              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025AC  13FC 00B9 00004373      2259              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025B4  13FC 0020 00004374      2260              MOVE.B   #$20,GET_SRC_START_END
000025BC                          2261  
000025BC                          2262             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025BC  0285 0000FE3F           2263              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000025C2  0685 00000000           2264              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
000025C8                          2265  
000025C8                          2266              
000025C8  6100 0BE2               2267              BSR     GET_EA_EA_SRC      *GETS <ea>
000025CC  163C 002C               2268              MOVE.B  #',',D3
000025D0  6100 1478               2269              BSR     PUSH_STACK          
000025D4  6100 1006               2270              BSR     GET_EA_EA_DEST       *GETS Dn
000025D8                          2271              
000025D8  6000 03E2               2272              BRA     OP1101_ADD_RETURN
000025DC                          2273  OP1100_PRINT_W
000025DC  163C 0057               2274              MOVE.B  #'W',D3
000025E0  6100 1468               2275              BSR     PUSH_STACK
000025E4                          2276  
000025E4                          2277              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025E4  13FC 0000 00004370      2278              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025EC  13FC 0002 00004371      2279              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025F4                          2280             
000025F4                          2281              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025F4  13FC 00B9 00004373      2282              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025FC  13FC 0020 00004374      2283              MOVE.B   #$20,GET_SRC_START_END
00002604                          2284  
00002604                          2285             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002604  0285 0000FE3F           2286              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000260A  0685 00000000           2287              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002610                          2288  
00002610                          2289              
00002610  6100 0B9A               2290              BSR     GET_EA_EA_SRC      *GETS <ea>
00002614  163C 002C               2291              MOVE.B  #',',D3
00002618  6100 1430               2292              BSR     PUSH_STACK
0000261C  6100 0FBE               2293              BSR     GET_EA_EA_DEST       *GETS Dn    
00002620                          2294              
00002620  6000 FAD6               2295              BRA     OP1001_ADD_RETURN
00002624                          2296  OP1100_PRINT_L 
00002624  163C 004C               2297              MOVE.B  #'L',D3
00002628  6100 1420               2298              BSR     PUSH_STACK
0000262C                          2299              
0000262C                          2300              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000262C  13FC 0000 00004370      2301              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002634  13FC 0002 00004371      2302              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000263C                          2303             
0000263C                          2304              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000263C  13FC 00B9 00004373      2305              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002644  13FC 0020 00004374      2306              MOVE.B   #$20,GET_SRC_START_END
0000264C                          2307  
0000264C                          2308              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000264C  0285 0000FE3F           2309              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002652  0685 00000000           2310              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002658                          2311  
00002658                          2312                     
00002658  6100 0B52               2313              BSR     GET_EA_EA_SRC      *GETS <ea>
0000265C  163C 002C               2314              MOVE.B  #',',D3
00002660  6100 13E8               2315              BSR     PUSH_STACK                  
00002664  6100 0F76               2316              BSR     GET_EA_EA_DEST       *GETS Dn    
00002668                          2317  
00002668                          2318              
00002668  6000 0002               2319              BRA     OP1100_AND_RETURN
0000266C                          2320              
0000266C                          2321  OP1100_AND_RETURN
0000266C  4E75                    2322              RTS
0000266E                          2323  
0000266E                          2324  
0000266E                          2325  *---------------------------------------------------------------------------*
0000266E                          2326  * OP1101: Decode ADD/ADDA
0000266E                          2327  *---------------------------------------------------------------------------* 
0000266E  4280                    2328  OP1101      CLR.L   D0                  
00002670  4281                    2329              CLR.L   D1       
00002672  4284                    2330              CLR.L   D4                   
00002674  227C 00000000           2331              MOVEA.L #0, A1              
0000267A  2205                    2332              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000267C                          2333              
0000267C                          2334              *CLEAR D3
0000267C  4283                    2335              CLR.L   D3
0000267E                          2336              
0000267E                          2337              
0000267E                          2338              
0000267E                          2339              **INTEGRATING ADDA.W/.L INTO THIS CODE**
0000267E  2205                    2340              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002680                          2341              *BITS (INDEX 8) 
00002680                          2342              *0 = ADD.B/W/L <EA>,Dn
00002680                          2343              *1 = ADD.B/W/L Dn,<EA> 
00002680  EC99                    2344              ROR.L   #6,D1
00002682  0281 00000007           2345              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002688  0C81 00000007           2346              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
0000268E  6700 0010               2347              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002692  0C81 00000003           2348              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002698  6700 0078               2349              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
0000269C  6000 00E6               2350              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
000026A0                          2351              
000026A0                          2352  OP1101_ADDA_L
000026A0                          2353              *LOAD STACK WITH THIS OPMODE
000026A0  6100 13A8               2354              BSR     PUSH_STACK
000026A4  163C 0041               2355              MOVE.B  #'A',D3
000026A8  6100 13A0               2356              BSR     PUSH_STACK
000026AC  163C 0044               2357              MOVE.B  #'D',D3
000026B0  6100 1398               2358              BSR     PUSH_STACK
000026B4  163C 0044               2359              MOVE.B  #'D',D3
000026B8  6100 1390               2360              BSR     PUSH_STACK
000026BC  163C 0041               2361              MOVE.B  #'A',D3
000026C0  6100 1388               2362              BSR     PUSH_STACK
000026C4  163C 002E               2363              MOVE.B  #'.',D3
000026C8  6100 1380               2364              BSR     PUSH_STACK
000026CC  163C 004C               2365              MOVE.B  #'L',D3
000026D0  6100 1378               2366              BSR     PUSH_STACK
000026D4                          2367              
000026D4                          2368             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026D4  13FC 0000 00004370      2369             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000026DC  13FC 0000 00004371      2370             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000026E4                          2371             
000026E4                          2372             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026E4  13FC 00B9 00004373      2373             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000026EC  13FC 0020 00004374      2374             MOVE.B   #$20,GET_SRC_START_END
000026F4                          2375  
000026F4                          2376              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026F4  0285 0000FE3F           2377              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026FA  0685 00000040           2378              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002700                          2379       
00002700                          2380              *PRINT <EA>,AN
00002700  6100 0AAA               2381              BSR     GET_EA_EA_SRC       *GETS <ea>
00002704  163C 002C               2382              MOVE.B  #',',D3
00002708  6100 1340               2383              BSR     PUSH_STACK                     
0000270C  6100 0ECE               2384              BSR     GET_EA_EA_DEST      *GETS Dn
00002710                          2385  
00002710                          2386              
00002710                          2387              
00002710  4E75                    2388              RTS
00002712                          2389  OP1101_ADDA_W
00002712                          2390              *LOAD STACK WITH THIS OPMODE
00002712  6100 1336               2391              BSR     PUSH_STACK
00002716  163C 0041               2392              MOVE.B  #'A',D3
0000271A  6100 132E               2393              BSR     PUSH_STACK
0000271E  163C 0044               2394              MOVE.B  #'D',D3
00002722  6100 1326               2395              BSR     PUSH_STACK
00002726  163C 0044               2396              MOVE.B  #'D',D3
0000272A  6100 131E               2397              BSR     PUSH_STACK
0000272E  163C 0041               2398              MOVE.B  #'A',D3
00002732  6100 1316               2399              BSR     PUSH_STACK
00002736  163C 002E               2400              MOVE.B  #'.',D3
0000273A  6100 130E               2401              BSR     PUSH_STACK
0000273E  163C 0057               2402              MOVE.B  #'W',D3
00002742  6100 1306               2403              BSR     PUSH_STACK
00002746                          2404              
00002746                          2405             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002746  13FC 0000 00004370      2406             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000274E  13FC 0000 00004371      2407             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002756                          2408             
00002756                          2409             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002756  13FC 00B9 00004373      2410             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000275E  13FC 0020 00004374      2411             MOVE.B   #$20,GET_SRC_START_END
00002766                          2412  
00002766                          2413              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002766  0285 0000FE3F           2414              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000276C  0685 00000040           2415              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002772                          2416       
00002772                          2417              *PRINT <EA>,AN
00002772  6100 0A38               2418              BSR     GET_EA_EA_SRC       *GETS <ea>
00002776  163C 002C               2419              MOVE.B  #',',D3
0000277A  6100 12CE               2420              BSR     PUSH_STACK                     
0000277E  6100 0E5C               2421              BSR     GET_EA_EA_DEST      *GETS Dn
00002782                          2422  
00002782  4E75                    2423              RTS
00002784                          2424  
00002784                          2425  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002784                          2426              *LOAD STACK WITH THIS OPMODE
00002784  6100 12C4               2427              BSR     PUSH_STACK
00002788  163C 0041               2428              MOVE.B  #'A',D3
0000278C  6100 12BC               2429              BSR     PUSH_STACK
00002790  163C 0044               2430              MOVE.B  #'D',D3
00002794  6100 12B4               2431              BSR     PUSH_STACK
00002798  163C 0044               2432              MOVE.B  #'D',D3
0000279C  6100 12AC               2433              BSR     PUSH_STACK
000027A0  163C 002E               2434              MOVE.B  #'.',D3
000027A4  6100 12A4               2435              BSR     PUSH_STACK
000027A8                          2436              
000027A8  2205                    2437              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000027AA                          2438              
000027AA                          2439              *BITS (INDEX 8) 
000027AA                          2440              *0 = ADD.B/W/L <EA>,Dn
000027AA                          2441              *1 = ADD.B/W/L Dn,<EA> 
000027AA  E099                    2442              ROR.L   #8,D1
000027AC  0281 00000001           2443              ANDI.L  #$01,D1     *MASKS WITH 00000001
000027B2  0C81 00000000           2444              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000027B8  6700 0102               2445              BEQ     OP1101_EA_DN
000027BC                          2446              *else procede to Dn_EA
000027BC                          2447              
000027BC                          2448  OP1101_DN_EA
000027BC                          2449              *BITS (7 TO 6) 
000027BC                          2450              *00 = .B
000027BC                          2451              *01 = .W
000027BC                          2452              *10 = .L 
000027BC  2205                    2453              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000027BE  EC99                    2454              ROR.L   #6,D1
000027C0  0281 00000003           2455              ANDI.L  #$03,D1
000027C6  0C81 00000000           2456              CMPI.L  #$00,D1 *EQUALS .B
000027CC  6700 0016               2457              BEQ     OP1101_PRINT_B2
000027D0  0C81 00000001           2458              CMPI.L  #$01,D1 *EQUALS .W
000027D6  6700 0054               2459              BEQ     OP1101_PRINT_W2
000027DA  0C81 00000002           2460              CMPI.L  #$02,D1 *EQUALS .L
000027E0  6700 0092               2461              BEQ     OP1101_PRINT_L2
000027E4                          2462  OP1101_PRINT_B2
000027E4                          2463              *PUSH 'B'
000027E4  163C 0042               2464              MOVE.B  #'B',D3
000027E8  6100 1260               2465              BSR     PUSH_STACK
000027EC                          2466             
000027EC                          2467              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000027EC  13FC 0002 00004370      2468             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000027F4  13FC 0083 00004371      2469             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000027FC                          2470             
000027FC                          2471             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000027FC  13FC 00B9 00004373      2472             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002804  13FC 0020 00004374      2473             MOVE.B   #$20,GET_SRC_START_END
0000280C                          2474  
0000280C                          2475              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000280C  0285 0000FE3F           2476              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002812  0685 00000000           2477              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002818                          2478       
00002818  6100 0DC2               2479              BSR     GET_EA_EA_DEST      *GETS Dn
0000281C  163C 002C               2480              MOVE.B  #',',D3
00002820  6100 1228               2481              BSR     PUSH_STACK                     
00002824  6100 0986               2482              BSR     GET_EA_EA_SRC       *GETS <ea>
00002828                          2483  
00002828                          2484              
00002828  6000 0192               2485              BRA     OP1101_ADD_RETURN
0000282C                          2486  OP1101_PRINT_W2
0000282C  163C 0057               2487              MOVE.B  #'W',D3
00002830  6100 1218               2488              BSR     PUSH_STACK
00002834                          2489  
00002834                          2490              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002834  13FC 0000 00004370      2491              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000283C  13FC 0083 00004371      2492              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002844                          2493             
00002844                          2494              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002844  13FC 00B9 00004373      2495              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000284C  13FC 0020 00004374      2496              MOVE.B   #$20,GET_SRC_START_END
00002854                          2497  
00002854                          2498              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002854  0285 0000FE3F           2499              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000285A  0685 00000000           2500              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002860                          2501  
00002860                          2502        
00002860  6100 0D7A               2503              BSR     GET_EA_EA_DEST      *GETS Dn
00002864  163C 002C               2504              MOVE.B  #',',D3
00002868  6100 11E0               2505              BSR     PUSH_STACK               
0000286C  6100 093E               2506              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002870                          2507  
00002870                          2508  
00002870                          2509  
00002870  6000 014A               2510              BRA     OP1101_ADD_RETURN
00002874                          2511  OP1101_PRINT_L2 
00002874  163C 004C               2512              MOVE.B  #'L',D3
00002878  6100 11D0               2513              BSR     PUSH_STACK
0000287C                          2514              
0000287C                          2515              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000287C  13FC 0000 00004370      2516              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002884  13FC 0083 00004371      2517              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000288C                          2518             
0000288C                          2519              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000288C  13FC 00B9 00004373      2520              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002894  13FC 0020 00004374      2521              MOVE.B   #$20,GET_SRC_START_END
0000289C                          2522  
0000289C                          2523             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000289C  0285 0000FE3F           2524              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028A2  0685 00000000           2525              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028A8                          2526  
000028A8                          2527               
000028A8  6100 0D32               2528              BSR     GET_EA_EA_DEST       *GETS Dn
000028AC  163C 002C               2529              MOVE.B  #',',D3
000028B0  6100 1198               2530              BSR     PUSH_STACK          
000028B4  6100 08F6               2531              BSR     GET_EA_EA_SRC        *GETS <ea>
000028B8                          2532  
000028B8  6000 0102               2533              BRA     OP1101_ADD_RETURN
000028BC                          2534              
000028BC                          2535  OP1101_EA_DN           
000028BC                          2536              *BITS (7 TO 6) 
000028BC                          2537              *00 = .B
000028BC                          2538              *01 = .W
000028BC                          2539              *10 = .L 
000028BC  2205                    2540              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000028BE  EC99                    2541              ROR.L   #6,D1
000028C0  0281 00000003           2542              ANDI.L  #$03,D1
000028C6  0C81 00000000           2543              CMPI.L  #$00,D1 *EQUALS .B
000028CC  6700 0016               2544              BEQ     OP1101_PRINT_B
000028D0  0C81 00000001           2545              CMPI.L  #$01,D1 *EQUALS .W
000028D6  6700 0054               2546              BEQ     OP1101_PRINT_W
000028DA  0C81 00000002           2547              CMPI.L  #$02,D1 *EQUALS .L
000028E0  6700 0092               2548              BEQ     OP1101_PRINT_L
000028E4                          2549  OP1101_PRINT_B
000028E4  163C 0042               2550              MOVE.B  #'B',D3
000028E8  6100 1160               2551              BSR     PUSH_STACK
000028EC                          2552                
000028EC                          2553              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028EC  13FC 0002 00004370      2554              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028F4  13FC 0002 00004371      2555              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028FC                          2556             
000028FC                          2557              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028FC  13FC 00B9 00004373      2558              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002904  13FC 0020 00004374      2559              MOVE.B   #$20,GET_SRC_START_END
0000290C                          2560  
0000290C                          2561             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000290C  0285 0000FE3F           2562              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002912  0685 00000000           2563              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002918                          2564  
00002918                          2565              
00002918  6100 0892               2566              BSR     GET_EA_EA_SRC      *GETS <ea>
0000291C  163C 002C               2567              MOVE.B  #',',D3
00002920  6100 1128               2568              BSR     PUSH_STACK          
00002924  6100 0CB6               2569              BSR     GET_EA_EA_DEST       *GETS Dn
00002928                          2570              
00002928  6000 0092               2571              BRA     OP1101_ADD_RETURN
0000292C                          2572  OP1101_PRINT_W
0000292C  163C 0057               2573              MOVE.B  #'W',D3
00002930  6100 1118               2574              BSR     PUSH_STACK
00002934                          2575  
00002934                          2576              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002934  13FC 0000 00004370      2577              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000293C  13FC 0000 00004371      2578              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002944                          2579             
00002944                          2580              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002944  13FC 00B9 00004373      2581              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000294C  13FC 0020 00004374      2582              MOVE.B   #$20,GET_SRC_START_END
00002954                          2583  
00002954                          2584             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002954  0285 0000FE3F           2585              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000295A  0685 00000000           2586              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002960                          2587  
00002960                          2588              
00002960  6100 084A               2589              BSR     GET_EA_EA_SRC      *GETS <ea>
00002964  163C 002C               2590              MOVE.B  #',',D3
00002968  6100 10E0               2591              BSR     PUSH_STACK
0000296C  6100 0C6E               2592              BSR     GET_EA_EA_DEST       *GETS Dn    
00002970                          2593              
00002970  6000 004A               2594              BRA     OP1101_ADD_RETURN
00002974                          2595  OP1101_PRINT_L 
00002974  163C 004C               2596              MOVE.B  #'L',D3
00002978  6100 10D0               2597              BSR     PUSH_STACK
0000297C                          2598              
0000297C                          2599              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000297C  13FC 0000 00004370      2600              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002984  13FC 0000 00004371      2601              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000298C                          2602             
0000298C                          2603              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000298C  13FC 00B9 00004373      2604              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002994  13FC 0020 00004374      2605              MOVE.B   #$20,GET_SRC_START_END
0000299C                          2606  
0000299C                          2607              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000299C  0285 0000FE3F           2608              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029A2  0685 00000000           2609              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000029A8                          2610  
000029A8                          2611                     
000029A8  6100 0802               2612              BSR     GET_EA_EA_SRC      *GETS <ea>
000029AC  163C 002C               2613              MOVE.B  #',',D3
000029B0  6100 1098               2614              BSR     PUSH_STACK                  
000029B4  6100 0C26               2615              BSR     GET_EA_EA_DEST       *GETS Dn    
000029B8                          2616  
000029B8                          2617              
000029B8  6000 0002               2618              BRA     OP1101_ADD_RETURN
000029BC                          2619              
000029BC                          2620  OP1101_ADD_RETURN
000029BC  4E75                    2621              RTS
000029BE                          2622              
000029BE                          2623              *ADDW
000029BE  0C01 0006               2624              CMPI.B  #$6,D1
000029C2  6700 0056               2625              BEQ     OP_ADDA_W
000029C6  0C01 000E               2626              CMPI.B  #$E,D1
000029CA  6700 0066               2627              BEQ     OP_ADDA_L 
000029CE                          2628  
000029CE  4EF8 14B6               2629              JMP     OP_DATA  
000029D2                          2630            
000029D2                          2631  *---------------------------------------------------------------------------*
000029D2                          2632  * OP_ADD: display ADD and proceed to EA
000029D2                          2633  *---------------------------------------------------------------------------*  
000029D2  43F9 00004227           2634  OP_ADD_B    LEA     DISP_ADD_B,A1
000029D8  103C 000E               2635              MOVE.B  #14,D0
000029DC  4E4F                    2636              TRAP    #15
000029DE  183C 0000               2637              MOVE.B  #0,D4
000029E2  4EF9 00002D5C           2638              JMP     EA_GEN
000029E8                          2639  
000029E8  4E75                    2640              RTS
000029EA                          2641  
000029EA  43F9 00004230           2642  OP_ADD_W    LEA     DISP_ADD_W,A1
000029F0  103C 000E               2643              MOVE.B  #14,D0
000029F4  4E4F                    2644              TRAP    #15
000029F6  183C 0001               2645              MOVE.B  #1,D4
000029FA  4EF9 00002D5C           2646              JMP     EA_GEN
00002A00                          2647  
00002A00  4E75                    2648              RTS
00002A02                          2649  
00002A02  43F9 00004239           2650  OP_ADD_L    LEA     DISP_ADD_L,A1
00002A08  103C 000E               2651              MOVE.B  #14,D0
00002A0C  4E4F                    2652              TRAP    #15
00002A0E  183C 0002               2653              MOVE.B  #2,D4
00002A12  4EF9 00002D5C           2654              JMP     EA_GEN
00002A18                          2655  
00002A18  4E75                    2656              RTS
00002A1A                          2657  
00002A1A                          2658  *---------------------------------------------------------------------------*
00002A1A                          2659  * OP_ADDA: display ADDA and proceed to EA
00002A1A                          2660  *---------------------------------------------------------------------------*  
00002A1A  43F9 00004242           2661  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002A20  103C 000E               2662              MOVE.B  #14,D0
00002A24  4E4F                    2663              TRAP    #15
00002A26  183C 0001               2664              MOVE.B  #1,D4
00002A2A  4EF9 00002D5C           2665              JMP     EA_GEN
00002A30                          2666  
00002A30  4E75                    2667              RTS
00002A32                          2668  
00002A32  43F9 0000424C           2669  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002A38  103C 000E               2670              MOVE.B  #14,D0
00002A3C  4E4F                    2671              TRAP    #15
00002A3E  183C 0002               2672              MOVE.B  #2,D4
00002A42  4EF9 00002D5C           2673              JMP     EA_GEN
00002A48                          2674  
00002A48  4E75                    2675              RTS
00002A4A                          2676              
00002A4A                          2677  *---------------------------------------------------------------------------*
00002A4A                          2678  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002A4A                          2679  *---------------------------------------------------------------------------* 
00002A4A  4280                    2680  OP1110      CLR.L   D0                  
00002A4C  4281                    2681              CLR.L   D1   
00002A4E  4284                    2682              CLR.L   D4                   
00002A50  227C 00000000           2683              MOVEA.L #0, A1                 
00002A56  2205                    2684              MOVE.L  D5,D1
00002A58                          2685              
00002A58                          2686              * check for LSX
00002A58  E699                    2687              ROR.L   #3,D1
00002A5A  0281 00000001           2688              ANDI.L  #$1,D1
00002A60  0C01 0001               2689              CMPI.B  #1,D1
00002A64  6700 002E               2690              BEQ     OP_LSX
00002A68                          2691              
00002A68                          2692              * reset D1 and check for ASX
00002A68  4281                    2693              CLR.L   D1
00002A6A  2205                    2694              MOVE.L  D5,D1
00002A6C  E699                    2695              ROR.L   #3,D1
00002A6E  0281 00000001           2696              ANDI.L  #$1,D1
00002A74  0C01 0000               2697              CMPI.B  #0,D1
00002A78  6700 0032               2698              BEQ     OP_ASX
00002A7C                          2699  
00002A7C                          2700              * reset D1 and check for ROX
00002A7C  4281                    2701              CLR.L   D1
00002A7E  2205                    2702              MOVE.L  D5,D1
00002A80  E699                    2703              ROR.L   #3,D1
00002A82  0281 00000001           2704              ANDI.L  #$1,D1
00002A88  0C01 0003               2705              CMPI.B  #3,D1
00002A8C  6700 0036               2706              BEQ     OP_ROX
00002A90                          2707              
00002A90  4EF8 14B6               2708              JMP     OP_DATA
00002A94                          2709  
00002A94                          2710  *---------------------------------------------------------------------------*
00002A94                          2711  * OP_LSX: process LSR/LSL
00002A94                          2712  *---------------------------------------------------------------------------*            
00002A94  EA99                    2713  OP_LSX      ROR.L   #5,D1
00002A96  0281 00000001           2714              ANDI.L  #$1,D1
00002A9C  0C01 0000               2715              CMPI.B  #0,D1
00002AA0  6700 003A               2716              BEQ     OP_LSR
00002AA4  0C01 0001               2717              CMPI.B  #1,D1
00002AA8  6700 008C               2718              BEQ     OP_LSL
00002AAC                          2719              
00002AAC                          2720  *---------------------------------------------------------------------------*
00002AAC                          2721  * OP_ASX: process ASR/ASL
00002AAC                          2722  *---------------------------------------------------------------------------*  
00002AAC  EA99                    2723  OP_ASX      ROR.L   #5,D1
00002AAE  0281 00000001           2724              ANDI.L  #$1,D1
00002AB4  0C01 0000               2725              CMPI.B  #0,D1
00002AB8  6700 00D6               2726              BEQ     OP_ASR
00002ABC  0C01 0001               2727              CMPI.B  #1,D1
00002AC0  6700 0128               2728              BEQ     OP_ASL
00002AC4                          2729              
00002AC4                          2730  *---------------------------------------------------------------------------*
00002AC4                          2731  * OP_ROX: process ROR/ROL
00002AC4                          2732  *---------------------------------------------------------------------------*  
00002AC4  EA99                    2733  OP_ROX      ROR.L   #5,D1
00002AC6  0281 00000001           2734              ANDI.L  #$1,D1
00002ACC  0C01 0000               2735              CMPI.B  #0,D1
00002AD0  6700 0172               2736              BEQ     OP_ROR
00002AD4  0C01 0001               2737              CMPI.B  #1,D1
00002AD8  6700 01C4               2738              BEQ     OP_ROL
00002ADC                          2739  
00002ADC                          2740  *---------------------------------------------------------------------------*
00002ADC                          2741  * OP_LSR: decode and display LSR
00002ADC                          2742  *---------------------------------------------------------------------------*        
00002ADC  E599                    2743  OP_LSR      ROL.L   #2,D1
00002ADE  0281 00000003           2744              ANDI.L  #$3,D1
00002AE4  0C01 0000               2745              CMPI.B  #0,D1
00002AE8  6700 0016               2746              BEQ     OP_LSR_B
00002AEC  0C01 0001               2747              CMPI.B  #$1,D1
00002AF0  6700 0032               2748              BEQ     OP_LSR_W
00002AF4  0C01 0002               2749              CMPI.B  #$2,D1
00002AF8  6700 0018               2750              BEQ     OP_LSR_L
00002AFC                          2751              
00002AFC  4EF8 14B6               2752              JMP     OP_DATA
00002B00                          2753  
00002B00  43F9 00004256           2754  OP_LSR_B    LEA     DISP_LSR_B,A1
00002B06  103C 000E               2755              MOVE.B  #14,D0
00002B0A  4E4F                    2756              TRAP    #15
00002B0C  183C 0000               2757              MOVE.B  #0,D4
00002B10  4E75                    2758              RTS
00002B12                          2759  
00002B12  43F9 0000427A           2760  OP_LSR_L    LEA     DISP_LSR_L,A1
00002B18  103C 000E               2761              MOVE.B  #14,D0
00002B1C  4E4F                    2762              TRAP    #15
00002B1E  183C 0002               2763              MOVE.B  #2,D4
00002B22  4E75                    2764              RTS
00002B24                          2765  
00002B24  43F9 00004268           2766  OP_LSR_W    LEA     DISP_LSR_W,A1
00002B2A  103C 000E               2767              MOVE.B  #14,D0
00002B2E  4E4F                    2768              TRAP    #15
00002B30  183C 0001               2769              MOVE.B  #1,D4
00002B34  4E75                    2770              RTS
00002B36                          2771   
00002B36                          2772  *---------------------------------------------------------------------------*
00002B36                          2773  * OP_LSL: decode and display LSL
00002B36                          2774  *---------------------------------------------------------------------------*             
00002B36  E599                    2775  OP_LSL      ROL.L   #2,D1
00002B38  0281 00000003           2776              ANDI.L  #$3,D1
00002B3E  0C01 0000               2777              CMPI.B  #0,D1
00002B42  6700 0016               2778              BEQ     OP_LSL_B
00002B46  0C01 0001               2779              CMPI.B  #$1,D1
00002B4A  6700 0032               2780              BEQ     OP_LSL_W
00002B4E  0C01 0002               2781              CMPI.B  #$2,D1
00002B52  6700 0018               2782              BEQ     OP_LSL_L
00002B56                          2783              
00002B56  4EF8 14B6               2784              JMP OP_DATA
00002B5A                          2785  
00002B5A  43F9 0000425F           2786  OP_LSL_B    LEA     DISP_LSL_B,A1
00002B60  103C 000E               2787              MOVE.B  #14,D0
00002B64  4E4F                    2788              TRAP    #15
00002B66  183C 0000               2789              MOVE.B  #0,D4
00002B6A  4E75                    2790              RTS
00002B6C                          2791  
00002B6C  43F9 00004283           2792  OP_LSL_L    LEA     DISP_LSL_L,A1
00002B72  103C 000E               2793              MOVE.B  #14,D0
00002B76  4E4F                    2794              TRAP    #15
00002B78  183C 0002               2795              MOVE.B  #2,D4
00002B7C  4E75                    2796              RTS
00002B7E                          2797  
00002B7E  43F9 00004271           2798  OP_LSL_W    LEA     DISP_LSL_W,A1
00002B84  103C 000E               2799              MOVE.B  #14,D0
00002B88  4E4F                    2800              TRAP    #15
00002B8A  183C 0001               2801              MOVE.B  #1,D4
00002B8E  4E75                    2802              RTS
00002B90                          2803   
00002B90                          2804  *---------------------------------------------------------------------------*
00002B90                          2805  * OP_ASR: decode and display ASR
00002B90                          2806  *---------------------------------------------------------------------------*             
00002B90  E599                    2807  OP_ASR      ROL.L   #2,D1
00002B92  0281 00000003           2808              ANDI.L  #$3,D1
00002B98  0C01 0000               2809              CMPI.B  #0,D1
00002B9C  6700 0016               2810              BEQ     OP_ASR_B
00002BA0  0C01 0001               2811              CMPI.B  #$1,D1
00002BA4  6700 0032               2812              BEQ     OP_ASR_W
00002BA8  0C01 0002               2813              CMPI.B  #$2,D1
00002BAC  6700 0018               2814              BEQ     OP_ASR_L
00002BB0                          2815              
00002BB0  4EF8 14B6               2816              JMP OP_DATA
00002BB4                          2817  
00002BB4  43F9 0000428C           2818  OP_ASR_B    LEA     DISP_ASR_B,A1
00002BBA  103C 000E               2819              MOVE.B  #14,D0
00002BBE  4E4F                    2820              TRAP    #15
00002BC0  183C 0000               2821              MOVE.B  #0,D4
00002BC4  4E75                    2822              RTS
00002BC6                          2823  
00002BC6  43F9 000042B0           2824  OP_ASR_L    LEA     DISP_ASR_L,A1
00002BCC  103C 000E               2825              MOVE.B  #14,D0
00002BD0  4E4F                    2826              TRAP    #15
00002BD2  183C 0002               2827              MOVE.B  #2,D4
00002BD6  4E75                    2828              RTS
00002BD8                          2829  
00002BD8  43F9 0000429E           2830  OP_ASR_W    LEA     DISP_ASR_W,A1
00002BDE  103C 000E               2831              MOVE.B  #14,D0
00002BE2  4E4F                    2832              TRAP    #15
00002BE4  183C 0001               2833              MOVE.B  #1,D4
00002BE8  4E75                    2834              RTS
00002BEA                          2835       
00002BEA                          2836  *---------------------------------------------------------------------------*
00002BEA                          2837  * OP_ASL: decode and display ASL
00002BEA                          2838  *---------------------------------------------------------------------------*         
00002BEA  E599                    2839  OP_ASL      ROL.L   #2,D1
00002BEC  0281 00000003           2840              ANDI.L  #$3,D1
00002BF2  0C01 0000               2841              CMPI.B  #0,D1
00002BF6  6700 0016               2842              BEQ     OP_ASL_B
00002BFA  0C01 0001               2843              CMPI.B  #$1,D1
00002BFE  6700 0032               2844              BEQ     OP_ASL_W
00002C02  0C01 0002               2845              CMPI.B  #$2,D1
00002C06  6700 0018               2846              BEQ     OP_ASL_L
00002C0A                          2847              
00002C0A  4EF8 14B6               2848              JMP OP_DATA
00002C0E                          2849  
00002C0E  43F9 00004295           2850  OP_ASL_B    LEA     DISP_ASL_B,A1
00002C14  103C 000E               2851              MOVE.B  #14,D0
00002C18  4E4F                    2852              TRAP    #15
00002C1A  183C 0000               2853              MOVE.B  #0,D4
00002C1E  4E75                    2854              RTS
00002C20                          2855  
00002C20  43F9 000042B9           2856  OP_ASL_L    LEA     DISP_ASL_L,A1
00002C26  103C 000E               2857              MOVE.B  #14,D0
00002C2A  4E4F                    2858              TRAP    #15
00002C2C  183C 0002               2859              MOVE.B  #2,D4
00002C30  4E75                    2860              RTS
00002C32                          2861  
00002C32  43F9 000042A7           2862  OP_ASL_W    LEA     DISP_ASL_W,A1
00002C38  103C 000E               2863              MOVE.B  #14,D0
00002C3C  4E4F                    2864              TRAP    #15
00002C3E  183C 0001               2865              MOVE.B  #1,D4
00002C42  4E75                    2866              RTS
00002C44                          2867   
00002C44                          2868  *---------------------------------------------------------------------------*
00002C44                          2869  * OP_ROR: decode and display ROR
00002C44                          2870  *---------------------------------------------------------------------------*             
00002C44  E599                    2871  OP_ROR      ROL.L   #2,D1
00002C46  0281 00000003           2872              ANDI.L  #$3,D1
00002C4C  0C01 0000               2873              CMPI.B  #0,D1
00002C50  6700 0016               2874              BEQ     OP_ROR_B
00002C54  0C01 0001               2875              CMPI.B  #$1,D1
00002C58  6700 0032               2876              BEQ     OP_ROR_W
00002C5C  0C01 0002               2877              CMPI.B  #$2,D1
00002C60  6700 0018               2878              BEQ     OP_ROR_L
00002C64                          2879              
00002C64  4EF8 14B6               2880              JMP OP_DATA
00002C68                          2881  
00002C68  43F9 000042C2           2882  OP_ROR_B    LEA     DISP_ROR_B,A1
00002C6E  103C 000E               2883              MOVE.B  #14,D0
00002C72  4E4F                    2884              TRAP    #15
00002C74  183C 0000               2885              MOVE.B  #0,D4
00002C78  4E75                    2886              RTS
00002C7A                          2887  
00002C7A  43F9 000042E6           2888  OP_ROR_L    LEA     DISP_ROR_L,A1
00002C80  103C 000E               2889              MOVE.B  #14,D0
00002C84  4E4F                    2890              TRAP    #15
00002C86  183C 0002               2891              MOVE.B  #2,D4
00002C8A  4E75                    2892              RTS
00002C8C                          2893  
00002C8C  43F9 000042D4           2894  OP_ROR_W    LEA     DISP_ROR_W,A1
00002C92  103C 000E               2895              MOVE.B  #14,D0
00002C96  4E4F                    2896              TRAP    #15
00002C98  183C 0001               2897              MOVE.B  #1,D4
00002C9C  4E75                    2898              RTS
00002C9E                          2899  
00002C9E                          2900  *---------------------------------------------------------------------------*
00002C9E                          2901  * OP_ROL: decode and display ROL
00002C9E                          2902  *---------------------------------------------------------------------------*             
00002C9E  E599                    2903  OP_ROL      ROL.L   #2,D1
00002CA0  0281 00000003           2904              ANDI.L  #$3,D1
00002CA6  0C01 0000               2905              CMPI.B  #0,D1
00002CAA  6700 0016               2906              BEQ     OP_ROL_B
00002CAE  0C01 0001               2907              CMPI.B  #$1,D1
00002CB2  6700 0032               2908              BEQ     OP_ROL_W
00002CB6  0C01 0002               2909              CMPI.B  #$2,D1
00002CBA  6700 0018               2910              BEQ     OP_ROL_L
00002CBE                          2911              
00002CBE  4EF8 14B6               2912              JMP OP_DATA
00002CC2                          2913  
00002CC2                          2914  
00002CC2  43F9 000042CB           2915  OP_ROL_B    LEA     DISP_ROL_B,A1
00002CC8  103C 000E               2916              MOVE.B  #14,D0
00002CCC  4E4F                    2917              TRAP    #15
00002CCE  183C 0000               2918              MOVE.B  #0,D4
00002CD2  4E75                    2919              RTS
00002CD4                          2920  
00002CD4  43F9 000042EF           2921  OP_ROL_L    LEA     DISP_ROL_L,A1
00002CDA  103C 000E               2922              MOVE.B  #14,D0
00002CDE  4E4F                    2923              TRAP    #15
00002CE0  183C 0002               2924              MOVE.B  #2,D4
00002CE4  4E75                    2925              RTS
00002CE6                          2926  
00002CE6  43F9 000042DD           2927  OP_ROL_W    LEA     DISP_ROL_W,A1
00002CEC  103C 000E               2928              MOVE.B  #14,D0
00002CF0  4E4F                    2929              TRAP    #15
00002CF2  183C 0001               2930              MOVE.B  #1,D4
00002CF6  4E75                    2931              RTS
00002CF8                          2932              
00002CF8                          2933  *---------------------------------------------------------------------------*
00002CF8                          2934  * OP1111 : Special reserved
00002CF8                          2935  *---------------------------------------------------------------------------*           
00002CF8  4EF8 14B6               2936  OP1111      JMP     OP_DATA
00002CFC                          2937  
00002CFC                          2938  *---------------------------------------------------------------------------*
00002CFC                          2939  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00002CFC                          2940  *---------------------------------------------------------------------------*
00002CFC                          2941  EA_NOSRC    
00002CFC  4EB9 00002DBA           2942              JSR     SRC_MODE
00002D02  43F9 00003FBC           2943              LEA     ENDLINE_M,A1
00002D08  103C 000E               2944              MOVE.B  #14,D0
00002D0C  4E4F                    2945              TRAP    #15
00002D0E  4E75                    2946              RTS
00002D10                          2947              
00002D10                          2948  *---------------------------------------------------------------------------*
00002D10                          2949  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00002D10                          2950  *---------------------------------------------------------------------------*
00002D10                          2951  EA_ARITH
00002D10  4EB9 00002DBA           2952              JSR     SRC_MODE
00002D16  43F9 00004336           2953              LEA     DISP_D,A1
00002D1C  103C 000E               2954              MOVE.B  #14,D0
00002D20  4E4F                    2955              TRAP    #15
00002D22  4EB9 00003046           2956              JSR     DEST_REGISTER
00002D28  43F9 00003FBC           2957              LEA     ENDLINE_M,A1
00002D2E  103C 000E               2958              MOVE.B  #14,D0
00002D32  4E4F                    2959              TRAP    #15
00002D34  4E75                    2960              RTS
00002D36                          2961              
00002D36                          2962  *---------------------------------------------------------------------------*
00002D36                          2963  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00002D36                          2964  *---------------------------------------------------------------------------*
00002D36                          2965  EA_MOVEA
00002D36  4EB9 00002DBA           2966              JSR     SRC_MODE
00002D3C  43F9 00004347           2967              LEA     DISP_AOP,A1
00002D42  103C 000E               2968              MOVE.B  #14,D0
00002D46  4E4F                    2969              TRAP    #15
00002D48  4EB9 00003046           2970              JSR     DEST_REGISTER
00002D4E  43F9 00004345           2971              LEA     DISP_CP,A1
00002D54  103C 000D               2972              MOVE.B  #13,D0
00002D58  4E4F                    2973              TRAP    #15
00002D5A  4E75                    2974              RTS
00002D5C                          2975              
00002D5C                          2976  *---------------------------------------------------------------------------*
00002D5C                          2977  * EA_GEN: decode and display effective addresses for MOVE
00002D5C                          2978  *---------------------------------------------------------------------------*
00002D5C                          2979  EA_GEN          
00002D5C                          2980              * retrieve/display source mode/register
00002D5C  4EB9 00002DBA           2981              JSR     SRC_MODE
00002D62                          2982              
00002D62                          2983              * retrieve/display destination mode/register
00002D62  4EB9 00002D76           2984              JSR     DEST_MODE
00002D68                          2985              
00002D68  43F9 00003FBC           2986              LEA     ENDLINE_M,A1
00002D6E  103C 000E               2987              MOVE.B  #14,D0
00002D72  4E4F                    2988              TRAP    #15
00002D74                          2989              
00002D74  4E75                    2990              RTS
00002D76                          2991  
00002D76                          2992  *---------------------------------------------------------------------------*
00002D76                          2993  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002D76                          2994  *---------------------------------------------------------------------------*           
00002D76                          2995  DEST_MODE   
00002D76                          2996              * clear registers to store temp data
00002D76  4280                    2997              CLR.L   D0                      
00002D78  4281                    2998              CLR.L   D1                      
00002D7A  207C 00000000           2999              MOVEA.L #0, A0                  
00002D80  227C 00000000           3000              MOVEA.L #0, A1                  
00002D86  2205                    3001              MOVE.L  D5,D1
00002D88  EC89                    3002              LSR.L   #6,D1
00002D8A  0281 00000007           3003              ANDI.L  #$7,D1
00002D90  0C01 0000               3004              CMPI.B  #0,D1   * Dn
00002D94  6700 0082               3005              BEQ     D_MODE000
00002D98  0C01 0002               3006              CMPI.B  #2,D1   * (An)
00002D9C  6700 00C2               3007              BEQ     D_MODE010
00002DA0  0C01 0003               3008              CMPI.B  #3,D1   * (An)+
00002DA4  6700 011A               3009              BEQ     D_MODE011
00002DA8  0C01 0004               3010              CMPI.B  #4,D1   * -(An)
00002DAC  6700 0132               3011              BEQ     D_MODE100
00002DB0  0C01 0007               3012              CMPI.B  #7,D1  * abs
00002DB4  6700 017C               3013              BEQ     D_MODE111 
00002DB8  4E75                    3014              RTS
00002DBA                          3015  
00002DBA                          3016  *---------------------------------------------------------------------------*
00002DBA                          3017  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002DBA                          3018  *---------------------------------------------------------------------------*  
00002DBA                          3019  SRC_MODE    
00002DBA                          3020              * clear registers to store temp data
00002DBA  4280                    3021              CLR.L   D0                      
00002DBC  4281                    3022              CLR.L   D1                      
00002DBE  207C 00000000           3023              MOVEA.L #0, A0                  
00002DC4  227C 00000000           3024              MOVEA.L #0, A1                  
00002DCA  2205                    3025              MOVE.L  D5,D1
00002DCC  E489                    3026              LSR.L   #2,D1
00002DCE  0281 0000000E           3027              ANDI.L  #$E,D1
00002DD4                          3028              
00002DD4  0C01 0000               3029              CMPI.B  #0,D1   * Dn
00002DD8  6700 002A               3030              BEQ     MODE000
00002DDC  0C01 0002               3031              CMPI.B  #2,D1   * An 
00002DE0  6700 004A               3032              BEQ     MODE001
00002DE4  0C01 0004               3033              CMPI.B  #4,D1   * (An)
00002DE8  6700 0056               3034              BEQ     MODE010
00002DEC  0C01 0006               3035              CMPI.B  #6,D1   * (An)+
00002DF0  6700 008E               3036              BEQ     MODE011
00002DF4  0C01 0008               3037              CMPI.B  #8,D1   * -(An)
00002DF8  6700 00A6               3038              BEQ     MODE100
00002DFC  0C01 000F               3039              CMPI.B  #15,D1  * abs/immediate
00002E00  6700 00FE               3040              BEQ     MODE111 
00002E04                          3041        
00002E04                          3042  *---------------------------------------------------------------------------*
00002E04                          3043  * MODE000: decode and display source mode Dn
00002E04                          3044  *---------------------------------------------------------------------------*           
00002E04                          3045  MODE000     *Dn
00002E04  43F9 00004336           3046              LEA     DISP_D,A1
00002E0A  103C 000E               3047              MOVE.B  #14,D0
00002E0E  4E4F                    3048              TRAP    #15
00002E10  4EB9 000030A2           3049              JSR     SRC_REGISTER
00002E16  4E75                    3050              RTS
00002E18                          3051  
00002E18                          3052  *---------------------------------------------------------------------------*
00002E18                          3053  * D_MODE000: decode and display dest mode Dn
00002E18                          3054  *---------------------------------------------------------------------------*
00002E18                          3055  D_MODE000     *Dn
00002E18  43F9 00004336           3056              LEA     DISP_D,A1
00002E1E  103C 000E               3057              MOVE.B  #14,D0
00002E22  4E4F                    3058              TRAP    #15
00002E24  4EB9 00003046           3059              JSR     DEST_REGISTER
00002E2A  4E75                    3060              RTS
00002E2C                          3061  
00002E2C                          3062  *---------------------------------------------------------------------------*
00002E2C                          3063  * MODE001: decode and display source mode An
00002E2C                          3064  *---------------------------------------------------------------------------* 
00002E2C                          3065  MODE001 *An
00002E2C  43F9 0000433B           3066              LEA     DISP_A,A1
00002E32  103C 000E               3067              MOVE.B  #14,D0
00002E36  4E4F                    3068              TRAP    #15
00002E38  4EB9 000030A2           3069              JSR     SRC_REGISTER
00002E3E                          3070          
00002E3E  4E75                    3071              RTS
00002E40                          3072  
00002E40                          3073  *---------------------------------------------------------------------------*
00002E40                          3074  * MODE010: decode and display source mode (An)
00002E40                          3075  *---------------------------------------------------------------------------*    
00002E40                          3076  MODE010 *(An)
00002E40  43F9 00004347           3077              LEA     DISP_AOP,A1  *display (A
00002E46  103C 000E               3078              MOVE.B  #14,D0
00002E4A  4E4F                    3079              TRAP    #15
00002E4C                          3080  
00002E4C  4EB9 000030A2           3081              JSR     SRC_REGISTER * display register
00002E52                          3082  
00002E52  43F9 00004345           3083              LEA     DISP_CP,A1   *display )
00002E58  103C 000E               3084              MOVE.B  #14,D0
00002E5C  4E4F                    3085              TRAP    #15
00002E5E                          3086              
00002E5E  4E75                    3087              RTS
00002E60                          3088  
00002E60                          3089  *---------------------------------------------------------------------------*
00002E60                          3090  * D_MODE010: decode and display dest mode (An)
00002E60                          3091  *---------------------------------------------------------------------------*
00002E60                          3092  D_MODE010 *(An)
00002E60  43F9 00004347           3093              LEA     DISP_AOP,A1  *display (A
00002E66  103C 000E               3094              MOVE.B  #14,D0
00002E6A  4E4F                    3095              TRAP    #15
00002E6C                          3096     
00002E6C  4EB9 00003046           3097              JSR     DEST_REGISTER * display register
00002E72                          3098  
00002E72  43F9 00004345           3099              LEA     DISP_CP,A1   *display )
00002E78  103C 000E               3100              MOVE.B  #14,D0
00002E7C  4E4F                    3101              TRAP    #15
00002E7E                          3102              
00002E7E  4E75                    3103              RTS
00002E80                          3104  
00002E80                          3105  *---------------------------------------------------------------------------*
00002E80                          3106  * MODE011: decode and display source mode (An)+
00002E80                          3107  *---------------------------------------------------------------------------*
00002E80                          3108  MODE011 *(An)+
00002E80  43F9 00004347           3109              LEA     DISP_AOP,A1      *display (A
00002E86  103C 000E               3110              MOVE.B  #14,D0
00002E8A  4E4F                    3111              TRAP    #15
00002E8C                          3112              
00002E8C  4EB9 000030A2           3113              JSR     SRC_REGISTER    * display register
00002E92                          3114  
00002E92  43F9 00004354           3115              LEA     DISP_POST,A1    *display )+
00002E98  103C 000E               3116              MOVE.B  #14,D0
00002E9C  4E4F                    3117              TRAP    #15
00002E9E                          3118              
00002E9E  4E75                    3119              RTS
00002EA0                          3120              
00002EA0                          3121  *---------------------------------------------------------------------------*
00002EA0                          3122  * MODE100: decode and display source mode -(An)
00002EA0                          3123  *---------------------------------------------------------------------------*
00002EA0                          3124  MODE100 *-(An)
00002EA0  43F9 0000434D           3125              LEA     DISP_PRE,A1    *display -(A
00002EA6  103C 000E               3126              MOVE.B  #14,D0
00002EAA  4E4F                    3127              TRAP    #15
00002EAC                          3128  
00002EAC  4EB9 000030A2           3129              JSR     SRC_REGISTER    *display register
00002EB2                          3130  
00002EB2  43F9 00004345           3131              LEA     DISP_CP,A1   *display )
00002EB8  103C 000E               3132              MOVE.B  #14,D0
00002EBC  4E4F                    3133              TRAP    #15
00002EBE                          3134              
00002EBE  4E75                    3135              RTS
00002EC0                          3136  
00002EC0                          3137  *---------------------------------------------------------------------------*
00002EC0                          3138  * D_MODE011: decode and display dest mode (An)+
00002EC0                          3139  *---------------------------------------------------------------------------*
00002EC0                          3140  D_MODE011 *(An)+
00002EC0  43F9 00004347           3141              LEA     DISP_AOP,A1      *display (A
00002EC6  103C 000E               3142              MOVE.B  #14,D0
00002ECA  4E4F                    3143              TRAP    #15
00002ECC                          3144  
00002ECC  4EB9 00003046           3145              JSR     DEST_REGISTER    * display register
00002ED2                          3146  
00002ED2  43F9 00004354           3147              LEA     DISP_POST,A1    *display )+
00002ED8  103C 000E               3148              MOVE.B  #14,D0
00002EDC  4E4F                    3149              TRAP    #15
00002EDE                          3150              
00002EDE  4E75                    3151              RTS
00002EE0                          3152              
00002EE0                          3153  *---------------------------------------------------------------------------*
00002EE0                          3154  * D_MODE100: decode and display dest mode -(An)
00002EE0                          3155  *---------------------------------------------------------------------------*            
00002EE0                          3156  D_MODE100 *-(An)
00002EE0  43F9 0000434D           3157              LEA     DISP_PRE,A1    *display -(A
00002EE6  103C 000E               3158              MOVE.B  #14,D0
00002EEA  4E4F                    3159              TRAP    #15
00002EEC                          3160              
00002EEC  4EB9 00003046           3161              JSR     DEST_REGISTER    *display register
00002EF2                          3162  
00002EF2  43F9 00004345           3163              LEA     DISP_CP,A1   *display )
00002EF8  103C 000E               3164              MOVE.B  #14,D0
00002EFC  4E4F                    3165              TRAP    #15
00002EFE                          3166              
00002EFE  4E75                    3167              RTS
00002F00                          3168  
00002F00                          3169  *---------------------------------------------------------------------------*
00002F00                          3170  * MODE111: decode and display source mode absolute/immediate
00002F00                          3171  *---------------------------------------------------------------------------*
00002F00                          3172  MODE111     * abs/immediate
00002F00                          3173              * clear registers to store temp data
00002F00  4280                    3174              CLR.L   D0                      
00002F02  4281                    3175              CLR.L   D1                      
00002F04  207C 00000000           3176              MOVEA.L #0, A0                  
00002F0A  227C 00000000           3177              MOVEA.L #0, A1                  
00002F10  2205                    3178              MOVE.L  D5,D1
00002F12                          3179              
00002F12                          3180              * retrieve source register for MODE 111
00002F12  E389                    3181              LSL.L   #1,D1   * shift the bits to left by 1
00002F14  0281 0000000E           3182              ANDI.L  #$E,D1  * mask the first 4 bits 
00002F1A  0C01 0000               3183              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002F1E  6700 003E               3184              BEQ     WORDMODE
00002F22  0C01 0002               3185              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002F26  6700 0062               3186              BEQ     LONGMODE
00002F2A  0C01 0008               3187              CMPI.B  #8, D1  * if it's 1000, immediate data
00002F2E  6700 0086               3188              BEQ     IMMEDIATE
00002F32                          3189       
00002F32                          3190  *---------------------------------------------------------------------------*
00002F32                          3191  * D_MODE111: decode and display dest mode absolute/immediate
00002F32                          3192  *---------------------------------------------------------------------------*           
00002F32                          3193  D_MODE111   * abs
00002F32                          3194              * clear registers to store temp data
00002F32  4280                    3195              CLR.L   D0                      
00002F34  4281                    3196              CLR.L   D1                      
00002F36  207C 00000000           3197              MOVEA.L #0, A0                  
00002F3C  227C 00000000           3198              MOVEA.L #0, A1                  
00002F42  2205                    3199              MOVE.L  D5,D1
00002F44                          3200              
00002F44                          3201              * retrieve dest register for MODE 111
00002F44  EC89                    3202              LSR.L   #6,D1   * shift the bits to right by 6
00002F46  E689                    3203              LSR.L   #3,D1   * shift the bits to right by extra 3
00002F48  0201 0001               3204              ANDI.B  #1,D1   * mask the first 2 bits 
00002F4C  0C01 0000               3205              CMPI.B  #0, D1  * if it's 000, absolute word address
00002F50  6700 000C               3206              BEQ     WORDMODE
00002F54  0C01 0001               3207              CMPI.B  #1, D1  * if it's 001, absolute long address
00002F58  6700 0030               3208              BEQ     LONGMODE
00002F5C                          3209              *JSR     OP_DATA *not sure..
00002F5C  4E75                    3210              RTS
00002F5E                          3211  
00002F5E                          3212  
00002F5E                          3213  *---------------------------------------------------------------------------*
00002F5E                          3214  * WORDMODE: absolute word address
00002F5E                          3215  *---------------------------------------------------------------------------*
00002F5E  43F9 00004331           3216  WORDMODE    LEA     DISP_HEX,A1
00002F64  103C 000E               3217              MOVE.B  #14,D0
00002F68  4E4F                    3218              TRAP    #15
00002F6A                          3219              
00002F6A  4285                    3220              CLR.L   D5
00002F6C  3A1D                    3221              MOVE.W  (A5)+,D5
00002F6E                          3222              
00002F6E  43F9 0000400F           3223              LEA     TMPOUTPUT,A1
00002F74  2205                    3224              MOVE.L  D5,D1
00002F76  7404                    3225              MOVE.L  #4,D2       *move word size 4
00002F78  4EB8 11B6               3226              JSR     HEX2ASCII
00002F7C  43F9 0000400F           3227              LEA     TMPOUTPUT,A1
00002F82  103C 000E               3228              MOVE.B  #14,D0
00002F86  4E4F                    3229              TRAP    #15
00002F88                          3230              
00002F88  4E75                    3231              RTS
00002F8A                          3232  
00002F8A                          3233  *---------------------------------------------------------------------------*
00002F8A                          3234  * LONGMODE: absolute long address
00002F8A                          3235  *---------------------------------------------------------------------------*
00002F8A  43F9 00004331           3236  LONGMODE    LEA     DISP_HEX,A1
00002F90  103C 000E               3237              MOVE.B  #14,D0
00002F94  4E4F                    3238              TRAP    #15
00002F96                          3239              
00002F96  4285                    3240              CLR.L   D5
00002F98  2A1D                    3241              MOVE.L  (A5)+,D5
00002F9A                          3242              
00002F9A  43F9 0000400F           3243              LEA     TMPOUTPUT,A1
00002FA0  2205                    3244              MOVE.L  D5,D1
00002FA2  7408                    3245              MOVE.L  #8,D2           *move longword size 8
00002FA4  4EB8 11B6               3246              JSR     HEX2ASCII
00002FA8  43F9 0000400F           3247              LEA     TMPOUTPUT,A1
00002FAE  103C 000E               3248              MOVE.B  #14,D0
00002FB2  4E4F                    3249              TRAP    #15
00002FB4                          3250              
00002FB4  4E75                    3251              RTS
00002FB6                          3252  
00002FB6                          3253  
00002FB6                          3254  *---------------------------------------------------------------------------*
00002FB6                          3255  * IMMEDIATE: immediate address
00002FB6                          3256  *---------------------------------------------------------------------------*
00002FB6  43F9 00004357           3257  IMMEDIATE   LEA     DISP_LB,A1
00002FBC  103C 000E               3258              MOVE.B  #14,D0
00002FC0  4E4F                    3259              TRAP    #15
00002FC2  43F9 00004331           3260              LEA     DISP_HEX,A1
00002FC8  103C 000E               3261              MOVE.B  #14,D0
00002FCC  4E4F                    3262              TRAP    #15
00002FCE                          3263              
00002FCE                          3264              * check for size
00002FCE  0C04 0000               3265              CMPI.B  #0,D4
00002FD2  6700 0012               3266              BEQ     IMMD_B
00002FD6  0C04 0001               3267              CMPI.B  #1,D4
00002FDA  6700 002A               3268              BEQ     IMMD_W
00002FDE  0C04 0002               3269              CMPI.B  #2,D4
00002FE2  6700 0042               3270              BEQ     IMMD_L
00002FE6                          3271  
00002FE6                          3272  IMMD_B
00002FE6  4285                    3273              CLR.L   D5
00002FE8  3A1D                    3274              MOVE.W  (A5)+,D5
00002FEA                          3275              
00002FEA  43F9 0000400F           3276              LEA     TMPOUTPUT,A1
00002FF0  2205                    3277              MOVE.L  D5,D1
00002FF2  7402                    3278              MOVE.L  #2,D2
00002FF4  4EB8 11B6               3279              JSR     HEX2ASCII
00002FF8  43F9 0000400F           3280              LEA     TMPOUTPUT,A1
00002FFE  103C 000E               3281              MOVE.B  #14,D0
00003002  4E4F                    3282              TRAP    #15
00003004  4E75                    3283              RTS
00003006                          3284              
00003006                          3285  IMMD_W
00003006  4285                    3286              CLR.L   D5
00003008  3A1D                    3287              MOVE.W  (A5)+,D5
0000300A                          3288              
0000300A  43F9 0000400F           3289              LEA     TMPOUTPUT,A1
00003010  2205                    3290              MOVE.L  D5,D1
00003012  7404                    3291              MOVE.L  #4,D2
00003014  4EB8 11B6               3292              JSR     HEX2ASCII
00003018  43F9 0000400F           3293              LEA     TMPOUTPUT,A1
0000301E  103C 000E               3294              MOVE.B  #14,D0
00003022  4E4F                    3295              TRAP    #15
00003024  4E75                    3296              RTS
00003026                          3297              
00003026                          3298  
00003026                          3299  IMMD_L
00003026  4285                    3300              CLR.L   D5
00003028  3A1D                    3301              MOVE.W  (A5)+,D5
0000302A                          3302              
0000302A  43F9 0000400F           3303              LEA     TMPOUTPUT,A1
00003030  2205                    3304              MOVE.L  D5,D1
00003032  7408                    3305              MOVE.L  #8,D2
00003034  4EB8 11B6               3306              JSR     HEX2ASCII
00003038  43F9 0000400F           3307              LEA     TMPOUTPUT,A1
0000303E  103C 000E               3308              MOVE.B  #14,D0
00003042  4E4F                    3309              TRAP    #15
00003044  4E75                    3310              RTS
00003046                          3311  
00003046                          3312  
00003046                          3313  *---------------------------------------------------------------------------*
00003046                          3314  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00003046                          3315  *---------------------------------------------------------------------------*
00003046                          3316  DEST_REGISTER
00003046                          3317              * clear registers to store temp data
00003046  4280                    3318              CLR.L   D0                      
00003048  4281                    3319              CLR.L   D1                      
0000304A  207C 00000000           3320              MOVEA.L #0, A0                  
00003050  227C 00000000           3321              MOVEA.L #0, A1 
00003056                          3322              
00003056  2205                    3323              MOVE.L  D5,D1
00003058  EC89                    3324              LSR.L   #6,D1
0000305A  E689                    3325              LSR.L   #3,D1
0000305C  0281 00000007           3326              ANDI.L  #7,D1
00003062                          3327              
00003062  0C01 0000               3328              CMPI.B  #0,D1
00003066  6700 0092               3329              BEQ     REG_0
0000306A  0C01 0001               3330              CMPI.B  #1,D1
0000306E  6700 0098               3331              BEQ     REG_1
00003072  0C01 0002               3332              CMPI.B  #2,D1
00003076  6700 009E               3333              BEQ     REG_2
0000307A  0C01 0003               3334              CMPI.B  #3,D1
0000307E  6700 00A4               3335              BEQ     REG_3
00003082  0C01 0004               3336              CMPI.B  #4,D1
00003086  6700 00AA               3337              BEQ     REG_4
0000308A  0C01 0005               3338              CMPI.B  #5,D1
0000308E  6700 00B0               3339              BEQ     REG_5
00003092  0C01 0006               3340              CMPI.B  #6,D1
00003096  6700 00B6               3341              BEQ     REG_6
0000309A  0C01 0007               3342              CMPI.B  #7,D1
0000309E  6700 00BC               3343              BEQ     REG_7
000030A2                          3344  
000030A2                          3345  *---------------------------------------------------------------------------*
000030A2                          3346  * SRC_REGISTER: decode and display source register (bit 2 - 0)
000030A2                          3347  *---------------------------------------------------------------------------*           
000030A2                          3348  SRC_REGISTER 
000030A2                          3349              * clear registers to store temp data
000030A2  4280                    3350              CLR.L   D0                      
000030A4  4281                    3351              CLR.L   D1                      
000030A6  207C 00000000           3352              MOVEA.L #0, A0                  
000030AC  227C 00000000           3353              MOVEA.L #0, A1                  
000030B2                          3354              
000030B2  2205                    3355              MOVE.L  D5,D1   * temp store the processing data
000030B4  0281 00000007           3356              ANDI.L  #7,D1   * mask the first 4 bits with 0111
000030BA                          3357              
000030BA  0C01 0000               3358              CMPI.B  #0,D1
000030BE  6700 003A               3359              BEQ     REG_0
000030C2  0C01 0001               3360              CMPI.B  #1,D1
000030C6  6700 0040               3361              BEQ     REG_1
000030CA  0C01 0002               3362              CMPI.B  #2,D1
000030CE  6700 0046               3363              BEQ     REG_2
000030D2  0C01 0003               3364              CMPI.B  #3,D1
000030D6  6700 004C               3365              BEQ     REG_3
000030DA  0C01 0004               3366              CMPI.B  #4,D1
000030DE  6700 0052               3367              BEQ     REG_4
000030E2  0C01 0005               3368              CMPI.B  #5,D1
000030E6  6700 0058               3369              BEQ     REG_5
000030EA  0C01 0006               3370              CMPI.B  #6,D1
000030EE  6700 005E               3371              BEQ     REG_6
000030F2  0C01 0007               3372              CMPI.B  #7,D1
000030F6  6700 0064               3373              BEQ     REG_7
000030FA                          3374  
000030FA                          3375  *---------------------------------------------------------------------------*
000030FA                          3376  * REG_0 ~ REG_7: display register 0 to 7
000030FA                          3377  *---------------------------------------------------------------------------*
000030FA  43F9 0000435C           3378  REG_0       LEA     DISP_0,A1
00003100  103C 000E               3379              MOVE.B  #14,D0
00003104  4E4F                    3380              TRAP    #15
00003106  4E75                    3381              RTS
00003108                          3382              
00003108  43F9 0000435E           3383  REG_1       LEA     DISP_1,A1
0000310E  103C 000E               3384              MOVE.B  #14,D0
00003112  4E4F                    3385              TRAP    #15
00003114  4E75                    3386              RTS
00003116                          3387              
00003116                          3388  
00003116  43F9 00004360           3389  REG_2       LEA     DISP_2,A1
0000311C  103C 000E               3390              MOVE.B  #14,D0
00003120  4E4F                    3391              TRAP    #15
00003122  4E75                    3392              RTS
00003124                          3393            
00003124  43F9 00004362           3394  REG_3       LEA     DISP_3,A1
0000312A  103C 000E               3395              MOVE.B  #14,D0
0000312E  4E4F                    3396              TRAP    #15
00003130  4E75                    3397              RTS
00003132                          3398              
00003132  43F9 00004364           3399  REG_4       LEA     DISP_4,A1
00003138  103C 000E               3400              MOVE.B  #14,D0
0000313C  4E4F                    3401              TRAP    #15
0000313E  4E75                    3402              RTS
00003140                          3403              
00003140  43F9 00004366           3404  REG_5       LEA     DISP_5,A1
00003146  103C 000E               3405              MOVE.B  #14,D0
0000314A  4E4F                    3406              TRAP    #15
0000314C  4E75                    3407              RTS
0000314E                          3408              
0000314E  43F9 00004368           3409  REG_6       LEA     DISP_6,A1
00003154  103C 000E               3410              MOVE.B  #14,D0
00003158  4E4F                    3411              TRAP    #15
0000315A  4E75                    3412              RTS
0000315C                          3413              
0000315C  43F9 0000436A           3414  REG_7       LEA     DISP_7,A1
00003162  103C 000E               3415              MOVE.B  #14,D0
00003166  4E4F                    3416              TRAP    #15
00003168  4E75                    3417              RTS
0000316A                          3418              
0000316A                          3419  *---------------------------------------------------------------------------*
0000316A                          3420  * REPEAT : Ask user whether they wish to run the program again
0000316A                          3421  *---------------------------------------------------------------------------*           
0000316A  4246                    3422  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
0000316C  43F9 00003E35           3423              LEA     REPEATMSG,A1
00003172  103C 000E               3424              MOVE.B  #14,D0
00003176  4E4F                    3425              TRAP    #15
00003178                          3426              
00003178  43F9 00003FBF           3427              LEA     TMPINPUT,A1             * allocate space to temp store user input
0000317E  103C 0002               3428              MOVE.B  #2,D0
00003182  4E4F                    3429              TRAP    #15
00003184                          3430  
00003184  0C01 0001               3431              CMPI.B  #1,D1                   * check for length of user input
00003188  66E0                    3432              BNE     REPEAT                  * return to the beginning of the function if unequal
0000318A                          3433              
0000318A  0C11 0059               3434              CMPI.B  #$59,(A1)               * compare the input with Y    
0000318E  6700 DE7A               3435              BEQ     PROGLP                  * repeat the program
00003192                          3436              
00003192  0C11 0079               3437              CMPI.B  #$79,(A1)               * compare the input with y    
00003196  6700 DE72               3438              BEQ     PROGLP                  * repeat the program
0000319A                          3439              
0000319A  0C11 004E               3440              CMPI.B  #$4E,(A1)               * compare the input with N    
0000319E  6700 0928               3441              BEQ     TERMINATE               * finish program
000031A2                          3442              
000031A2  0C11 006E               3443              CMPI.B  #$6E,(A1)               * compare the input with n    
000031A6  6700 0920               3444              BEQ     TERMINATE               * finish program
000031AA                          3445              
000031AA  60BE                    3446              BRA     REPEAT                  * invalid input/repeat the function
000031AC                          3447  
000031AC                          3448  *---------------------------------------------------------------------------*
000031AC                          3449  * EA DECODING INTERFACE
000031AC                          3450  * [A0] - RESERVED FOR USE
000031AC                          3451  * [D2] - RESERVED FOR USE
000031AC                          3452  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
000031AC                          3453  *---------------------------------------------------------------------------*
000031AC                          3454  GET_EA_EA_SRC
000031AC                          3455      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000031AC                          3456      
000031AC                          3457      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000031AC  2405                    3458      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000031AE  E68A                    3459      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
000031B0  23C2 00004382           3460      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000031B6  7407                    3461      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000031B8  C5B9 00004382           3462      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000031BE                          3463                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000031BE                          3464      
000031BE                          3465      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000031BE                          3466      *DESTINATION REGISTER FORMAT STANDARD         *
000031BE                          3467      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000031BE                          3468      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000031BE                          3469      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000031BE                          3470      *0 - Dn                                       *
000031BE                          3471      *1 - An                                       *
000031BE                          3472      *2 - (An)                                     *
000031BE                          3473      *3 - (An)+                                    *
000031BE                          3474      *4 - -(An)                                    *
000031BE                          3475      *5 - (XXX).W                                  *
000031BE                          3476      *6 - (XXX).L                                  *
000031BE                          3477      *7 - #<data>                                  *
000031BE                          3478      ***********************************************
000031BE                          3479      
000031BE                          3480      *** Check if source ...  <ea> = Dn
000031BE                          3481  CHECK0    
000031BE  41F9 00004372           3482            LEA     TEMP_REGISTER_FORMAT,A0
000031C4  1439 00004371           3483            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000031CA  1082                    3484            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000031CC  0239 0001 00004372      3485            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000031D4  0C39 0001 00004372      3486            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
000031DC  6700 006A               3487            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000031E0  0CB9 00000000 00004382  3488            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000031EA  6600 005C               3489            BNE     CHECK1
000031EE                          3490            
000031EE                          3491            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000031EE  163C 0020               3492            MOVE.B    #' ',D3
000031F2  6100 0856               3493            BSR       PUSH_STACK
000031F6  163C 0044               3494            MOVE.B    #'D',D3
000031FA  6100 084E               3495            BSR       PUSH_STACK
000031FE                          3496  
000031FE                          3497            *FIND REGISTER NUMBER END LOCATION*  
000031FE  13F9 00004374 0000437A  3498            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003208  0239 000F 0000437A      3499            AND.B   #$0F,VAR_BYTE_END
00003210                          3500            
00003210                          3501            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003210  23C5 0000437E           3502            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003216  1439 0000437A           3503            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000321C                          3504            
0000321C                          3505            *INTITIALIZE FOR BIT SHIFTING
0000321C  41F9 0000437E           3506            LEA     VAR_TEMP_CLEANCOPY,A0
00003222  2639 0000437E           3507            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003228                          3508  LOOP_SHIFTING
00003228  0C02 0000               3509            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000322C  6700 0008               3510            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003230  E24B                    3511            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003232  5302                    3512            SUB.B   #1,D2                     *DECREMENT COUNTER
00003234  60F2                    3513            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00003236                          3514  MASKING_NEXT
00003236  C6BC 00000007           3515            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000323C  0603 0030               3516            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003240  6100 0808               3517            BSR     PUSH_STACK                *PUSH TO STACK
00003244                          3518            
00003244  6000 0394               3519            BRA     GET_SRC_SUCCESS           *RETURN          
00003248                          3520            
00003248                          3521            
00003248                          3522            *** Check if source ...  <ea> = An
00003248  41F9 00004372           3523  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
0000324E  1439 00004371           3524            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003254  1082                    3525            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003256  0239 0002 00004372      3526            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
0000325E  0C39 0002 00004372      3527            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003266  6700 006A               3528            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000326A  0CB9 00000001 00004382  3529            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003274  6600 005C               3530            BNE     CHECK2
00003278                          3531            
00003278                          3532            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003278  163C 0020               3533            MOVE.B    #' ',D3
0000327C  6100 07CC               3534            BSR       PUSH_STACK
00003280  163C 0041               3535            MOVE.B    #'A',D3
00003284  6100 07C4               3536            BSR       PUSH_STACK
00003288                          3537  
00003288                          3538            
00003288                          3539            *FIND REGISTER NUMBER END LOCATION*  
00003288  13F9 00004374 0000437A  3540            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003292  0239 000F 0000437A      3541            AND.B   #$0F,VAR_BYTE_END
0000329A                          3542            
0000329A                          3543            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000329A  23C5 0000437E           3544            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000032A0  1439 0000437A           3545            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
000032A6                          3546            
000032A6                          3547            *INTITIALIZE FOR BIT SHIFTING
000032A6  41F9 0000437E           3548            LEA     VAR_TEMP_CLEANCOPY,A0
000032AC  2639 0000437E           3549            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000032B2                          3550  LOOP_SHIFTING1
000032B2  0C02 0000               3551            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000032B6  6700 0008               3552            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000032BA  E24B                    3553            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000032BC  5302                    3554            SUB.B   #1,D2                     *DECREMENT COUNTER
000032BE  60F2                    3555            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
000032C0                          3556  MASKING_NEXT1
000032C0  C6BC 00000007           3557            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000032C6  0603 0030               3558            ADD.B   #$30,D3                   *CONVERT TO CHAR
000032CA  6100 077E               3559            BSR     PUSH_STACK                *PUSH TO STACK
000032CE                          3560            
000032CE  6000 030A               3561            BRA     GET_SRC_SUCCESS                   *RETURN 
000032D2                          3562            
000032D2                          3563            
000032D2                          3564            
000032D2                          3565            
000032D2                          3566            *** Check if source ...  <ea> = (An)       
000032D2  41F9 00004372           3567  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
000032D8  1439 00004371           3568            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000032DE  1082                    3569            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000032E0  0239 0004 00004372      3570            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000032E8  0C39 0004 00004372      3571            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000032F0  6700 007A               3572            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000032F4  0CB9 00000002 00004382  3573            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000032FE  6600 006C               3574            BNE     CHECK3
00003302                          3575            
00003302                          3576            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003302  163C 0020               3577            MOVE.B    #' ',D3
00003306  6100 0742               3578            BSR       PUSH_STACK
0000330A  163C 0028               3579            MOVE.B    #'(',D3
0000330E  6100 073A               3580            BSR       PUSH_STACK
00003312  163C 0041               3581            MOVE.B    #'A',D3
00003316  6100 0732               3582            BSR       PUSH_STACK
0000331A                          3583  
0000331A                          3584            
0000331A                          3585            *FIND REGISTER NUMBER END LOCATION*  
0000331A  13F9 00004374 0000437A  3586            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003324  0239 000F 0000437A      3587            AND.B   #$0F,VAR_BYTE_END
0000332C                          3588            
0000332C                          3589            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000332C  23C5 0000437E           3590            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003332  1439 0000437A           3591            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003338                          3592            
00003338                          3593            *INTITIALIZE FOR BIT SHIFTING
00003338  41F9 0000437E           3594            LEA     VAR_TEMP_CLEANCOPY,A0
0000333E  2639 0000437E           3595            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003344                          3596  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003344  0C02 0000               3597            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003348  6700 0008               3598            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000334C  E24B                    3599            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000334E  5302                    3600            SUB.B   #1,D2                     *DECREMENT COUNTER
00003350  60F2                    3601            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003352                          3602  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003352  0283 00000007           3603            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003358  0603 0030               3604            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000335C  6100 06EC               3605            BSR     PUSH_STACK                *PUSH TO STACK
00003360                          3606            
00003360  163C 0029               3607            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003364  6100 06E4               3608            BSR       PUSH_STACK
00003368                          3609            
00003368  6000 0270               3610            BRA     GET_SRC_SUCCESS                   *RETURN 
0000336C                          3611  
0000336C                          3612            
0000336C                          3613            
0000336C                          3614                      
0000336C                          3615  *** Check if source ...  <ea> = (An)+       
0000336C  41F9 00004372           3616  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003372  1439 00004371           3617            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003378  1082                    3618            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000337A  0239 0008 00004372      3619            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003382  0C39 0008 00004372      3620            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
0000338A  6700 0082               3621            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000338E  0CB9 00000003 00004382  3622            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003398  6600 0074               3623            BNE     CHECK4
0000339C                          3624            
0000339C                          3625            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000339C  163C 0020               3626            MOVE.B    #' ',D3
000033A0  6100 06A8               3627            BSR       PUSH_STACK
000033A4  163C 0028               3628            MOVE.B    #'(',D3
000033A8  6100 06A0               3629            BSR       PUSH_STACK
000033AC  163C 0041               3630            MOVE.B    #'A',D3
000033B0  6100 0698               3631            BSR       PUSH_STACK
000033B4                          3632  
000033B4                          3633            
000033B4                          3634            *FIND REGISTER NUMBER END LOCATION*  
000033B4  13F9 00004374 0000437A  3635            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000033BE  0239 000F 0000437A      3636            ANDI.B   #$0F,VAR_BYTE_END
000033C6                          3637            
000033C6                          3638            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000033C6  23C5 0000437E           3639            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000033CC  1439 0000437A           3640            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000033D2                          3641            
000033D2                          3642            *INTITIALIZE FOR BIT SHIFTING
000033D2  41F9 0000437E           3643            LEA     VAR_TEMP_CLEANCOPY,A0
000033D8  2639 0000437E           3644            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000033DE                          3645            
000033DE                          3646  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
000033DE  0C02 0000               3647            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000033E2  6700 0008               3648            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000033E6  E24B                    3649            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000033E8  5302                    3650            SUBI.B   #1,D2                     *DECREMENT COUNTER
000033EA  60F2                    3651            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
000033EC                          3652                                               *change: NAME OF LABEL*
000033EC                          3653  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000033EC  0283 00000007           3654            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000033F2  0603 0030               3655            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000033F6  6100 0652               3656            BSR     PUSH_STACK                *PUSH TO STACK
000033FA                          3657            
000033FA  163C 0029               3658            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000033FE  6100 064A               3659            BSR       PUSH_STACK
00003402  163C 002B               3660            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003406  6100 0642               3661            BSR       PUSH_STACK
0000340A                          3662            
0000340A  6000 01CE               3663            BRA       GET_SRC_SUCCESS                   *RETURN 
0000340E                          3664  
0000340E                          3665            
0000340E                          3666            
0000340E                          3667                      
0000340E                          3668            *** Check if source ...  <ea> = -(An)       
0000340E  41F9 00004372           3669  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003414  1439 00004371           3670            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000341A  1082                    3671            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000341C  0239 0010 00004372      3672            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003424  0C39 0010 00004372      3673            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000342C  6700 0082               3674            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003430  0CB9 00000004 00004382  3675            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000343A  6600 0074               3676            BNE     CHECK7
0000343E                          3677            
0000343E                          3678            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000343E  163C 0020               3679            MOVE.B    #' ',D3
00003442  6100 0606               3680            BSR       PUSH_STACK
00003446  163C 002D               3681            MOVE.B    #'-',D3
0000344A  6100 05FE               3682            BSR       PUSH_STACK
0000344E  163C 0028               3683            MOVE.B    #'(',D3
00003452  6100 05F6               3684            BSR       PUSH_STACK
00003456  163C 0041               3685            MOVE.B    #'A',D3
0000345A  6100 05EE               3686            BSR       PUSH_STACK
0000345E                          3687  
0000345E                          3688            
0000345E                          3689            *FIND REGISTER NUMBER END LOCATION*  
0000345E  13F9 00004374 0000437A  3690            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003468  0239 000F 0000437A      3691            AND.B   #$0F,VAR_BYTE_END
00003470                          3692            
00003470                          3693            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003470  23C5 0000437E           3694            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003476  1439 0000437A           3695            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000347C                          3696            
0000347C                          3697            *INTITIALIZE FOR BIT SHIFTING
0000347C  41F9 0000437E           3698            LEA     VAR_TEMP_CLEANCOPY,A0
00003482  2639 0000437E           3699            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003488                          3700            
00003488                          3701  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003488  0C02 0000               3702            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000348C  6700 0008               3703            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003490  E24B                    3704            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003492  5302                    3705            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003494  60F2                    3706            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003496                          3707                                               *change: NAME OF LABEL*
00003496                          3708  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003496  0283 00000007           3709            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000349C  0603 0030               3710            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000034A0  6100 05A8               3711            BSR     PUSH_STACK                *PUSH TO STACK
000034A4                          3712            
000034A4  163C 0029               3713            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000034A8  6100 05A0               3714            BSR       PUSH_STACK
000034AC                          3715            
000034AC  6000 012C               3716            BRA     GET_SRC_SUCCESS                   *RETURN
000034B0                          3717            
000034B0                          3718                      
000034B0                          3719            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000034B0  0CB9 00000007 00004382  3720  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000034BA  6600 011A               3721            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000034BE                          3722                   
000034BE                          3723            *NEXT: (MODE == 111) 
000034BE                          3724            *NOW: CHECK FOR SRC REGISTER 
000034BE                          3725                  *(000 = (xxx).W)
000034BE                          3726                  *(001 = (xxx).L)
000034BE                          3727                  *(010 = #<data>)
000034BE                          3728                  
000034BE                          3729            *FIND REGISTER NUMBER END LOCATION*  
000034BE  13F9 00004374 0000437A  3730            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000034C8  0239 000F 0000437A      3731            AND.B   #$0F,VAR_BYTE_END
000034D0                          3732            
000034D0                          3733            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000034D0  23C5 0000437E           3734            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000034D6  1439 0000437A           3735            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000034DC                          3736            
000034DC                          3737            *INTITIALIZE FOR BIT SHIFTING
000034DC  41F9 0000437E           3738            LEA     VAR_TEMP_CLEANCOPY,A0
000034E2  2C39 0000437E           3739            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000034E8                          3740  SRC_LOOP_SHIFTING
000034E8  0C02 0000               3741            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000034EC  6700 0008               3742            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000034F0  E24E                    3743            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000034F2  5302                    3744            SUB.B   #1,D2                     *DECREMENT COUNTER
000034F4  60F2                    3745            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
000034F6                          3746  SRC_MASKING_NEXT
000034F6  CCBC 00000007           3747            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000034FC                          3748           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000034FC                          3749           
000034FC                          3750  CHECK_WORD  
000034FC  41F9 00004372           3751            LEA     TEMP_REGISTER_FORMAT,A0
00003502  1439 00004371           3752            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003508  1082                    3753            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000350A  0239 0020 00004372      3754            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003512  0C39 0020 00004372      3755            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000351A  6700 0026               3756            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000351E  0C06 0000               3757            CMPI.B  #0,D6                          
00003522  6600 001E               3758            BNE     CHECK_LONG 
00003526                          3759            
00003526                          3760            *IT IS A WORD AT THIS POINT*
00003526                          3761            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003526  163C 0020               3762            MOVE.B    #' ',D3
0000352A  6100 051E               3763            BSR       PUSH_STACK
0000352E  163C 0024               3764            MOVE.B    #'$',D3
00003532  6100 0516               3765            BSR       PUSH_STACK
00003536  321D                    3766            MOVE.W    (A5)+,D1
00003538  7404                    3767            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000353A  6100 DCBC               3768            BSR       HEX2ASCII2STACK
0000353E  6000 009A               3769            BRA     GET_SRC_SUCCESS
00003542                          3770  
00003542                          3771  CHECK_LONG
00003542  41F9 00004372           3772            LEA     TEMP_REGISTER_FORMAT,A0
00003548  1439 00004371           3773            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000354E  1082                    3774            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003550  0239 0040 00004372      3775            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003558  0C39 0040 00004372      3776            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003560  6700 002E               3777            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003564  0C06 0001               3778            CMPI.B  #1,D6                          
00003568  6600 0026               3779            BNE     CHECK_IMMEDIATE  
0000356C                          3780  
0000356C                          3781            *IT IS A WORD AT THIS POINT*
0000356C                          3782            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000356C  163C 0020               3783            MOVE.B    #' ',D3
00003570  6100 04D8               3784            BSR       PUSH_STACK
00003574  163C 0024               3785            MOVE.B    #'$',D3
00003578  6100 04D0               3786            BSR       PUSH_STACK
0000357C  321D                    3787            MOVE.W    (A5)+,D1
0000357E  7404                    3788            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003580  6100 DC76               3789            BSR       HEX2ASCII2STACK
00003584  321D                    3790            MOVE.W    (A5)+,D1
00003586  7404                    3791            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003588  6100 DC6E               3792            BSR       HEX2ASCII2STACK
0000358C  6000 004C               3793            BRA     GET_SRC_SUCCESS
00003590                          3794            
00003590                          3795  CHECK_IMMEDIATE
00003590  41F9 00004372           3796            LEA     TEMP_REGISTER_FORMAT,A0
00003596  1439 00004371           3797            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000359C  1082                    3798            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000359E  0239 0080 00004372      3799            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000035A6  0C39 0080 00004372      3800            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000035AE  6700 0026               3801            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000035B2  0C06 0004               3802            CMPI.B  #4,D6                          
000035B6  6600 001E               3803            BNE     GET_SRC_FAILED 
000035BA                          3804  
000035BA                          3805            *IT IS A WORD AT THIS POINT*
000035BA                          3806            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000035BA  163C 0020               3807            MOVE.B    #' ',D3
000035BE  6100 048A               3808            BSR       PUSH_STACK
000035C2  163C 0023               3809            MOVE.B    #'#',D3
000035C6  6100 0482               3810            BSR       PUSH_STACK
000035CA  321D                    3811            MOVE.W    (A5)+,D1
000035CC  7404                    3812            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000035CE  6100 DC28               3813            BSR       HEX2ASCII2STACK
000035D2  6000 0006               3814            BRA     GET_SRC_SUCCESS
000035D6                          3815            
000035D6                          3816  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
000035D6  7801                    3817            MOVE.L #1,D4
000035D8  4E75                    3818            RTS
000035DA                          3819  GET_SRC_SUCCESS 
000035DA  4E75                    3820            RTS
000035DC                          3821                                 
000035DC                          3822      
000035DC                          3823  
000035DC                          3824  
000035DC                          3825  
000035DC                          3826  
000035DC                          3827  
000035DC                          3828  
000035DC                          3829  GET_EA_EA_DEST
000035DC                          3830  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000035DC                          3831      
000035DC                          3832      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000035DC  2405                    3833      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000035DE  EC8A                    3834      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
000035E0  23C2 00004382           3835      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000035E6  7407                    3836      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000035E8  C5B9 00004382           3837      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000035EE                          3838                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000035EE                          3839      
000035EE                          3840      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000035EE                          3841      *DESTINATION REGISTER FORMAT STANDARD         *
000035EE                          3842      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000035EE                          3843      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000035EE                          3844      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000035EE                          3845      *0 - Dn                                       *
000035EE                          3846      *1 - An                                       *
000035EE                          3847      *2 - (An)                                     *
000035EE                          3848      *3 - (An)+                                    *
000035EE                          3849      *4 - -(An)                                    *
000035EE                          3850      *5 - (XXX).W                                  *
000035EE                          3851      *6 - (XXX).L                                  *
000035EE                          3852      *7 - #<data>                                  *
000035EE                          3853      ***********************************************
000035EE                          3854      
000035EE                          3855      *** Check if source ...  <ea> = Dn
000035EE                          3856  DEST_CHECK0    
000035EE  41F9 00004372           3857            LEA     TEMP_REGISTER_FORMAT,A0
000035F4  1439 00004370           3858            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000035FA  1082                    3859            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000035FC  0239 0001 00004372      3860            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003604  0C39 0001 00004372      3861            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
0000360C  6700 006A               3862            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003610  0CB9 00000000 00004382  3863            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
0000361A  6600 005C               3864            BNE     DEST_CHECK1
0000361E                          3865            
0000361E                          3866            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000361E  163C 0020               3867            MOVE.B    #' ',D3
00003622  6100 0426               3868            BSR       PUSH_STACK
00003626  163C 0044               3869            MOVE.B    #'D',D3
0000362A  6100 041E               3870            BSR       PUSH_STACK
0000362E                          3871  
0000362E                          3872            *FIND REGISTER NUMBER END LOCATION*  
0000362E  13F9 00004373 0000437A  3873            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003638  0239 000F 0000437A      3874            AND.B   #$0F,VAR_BYTE_END
00003640                          3875            
00003640                          3876            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003640  23C5 0000437E           3877            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003646  1439 0000437A           3878            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000364C                          3879            
0000364C                          3880            *INTITIALIZE FOR BIT SHIFTING
0000364C  41F9 0000437E           3881            LEA     VAR_TEMP_CLEANCOPY,A0
00003652  2639 0000437E           3882            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003658                          3883  DEST_LOOP_SHIFTING
00003658  0C02 0000               3884            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000365C  6700 0008               3885            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003660  E24B                    3886            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003662  5302                    3887            SUB.B   #1,D2                     *DECREMENT COUNTER
00003664  60F2                    3888            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003666                          3889  DEST_MASKING_NEXT
00003666  C6BC 00000007           3890            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000366C  0603 0030               3891            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003670  6100 03D8               3892            BSR     PUSH_STACK                *PUSH TO STACK
00003674                          3893            
00003674  6000 0394               3894            BRA     GET_DST_SUCCESS           *RETURN          
00003678                          3895            
00003678                          3896            
00003678                          3897            *** Check if source ...  <ea> = An
00003678                          3898  DEST_CHECK1    
00003678  41F9 00004372           3899            LEA     TEMP_REGISTER_FORMAT,A0
0000367E  1439 00004370           3900            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003684  1082                    3901            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003686  0239 0002 00004372      3902            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
0000368E  0C39 0002 00004372      3903            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003696  6700 006A               3904            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000369A  0CB9 00000001 00004382  3905            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
000036A4  6600 005C               3906            BNE     DEST_CHECK2
000036A8                          3907            
000036A8                          3908            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000036A8  163C 0020               3909            MOVE.B    #' ',D3
000036AC  6100 039C               3910            BSR       PUSH_STACK
000036B0  163C 0041               3911            MOVE.B    #'A',D3
000036B4  6100 0394               3912            BSR       PUSH_STACK
000036B8                          3913  
000036B8                          3914            
000036B8                          3915            *FIND REGISTER NUMBER END LOCATION*  
000036B8  13F9 00004373 0000437A  3916            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000036C2  0239 000F 0000437A      3917            AND.B   #$0F,VAR_BYTE_END
000036CA                          3918            
000036CA                          3919            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036CA  23C5 0000437E           3920            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000036D0  1439 0000437A           3921            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
000036D6                          3922            
000036D6                          3923            *INTITIALIZE FOR BIT SHIFTING
000036D6  41F9 0000437E           3924            LEA     VAR_TEMP_CLEANCOPY,A0
000036DC  2639 0000437E           3925            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000036E2                          3926  DEST_LOOP_SHIFTING1
000036E2  0C02 0000               3927            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000036E6  6700 0008               3928            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000036EA  E24B                    3929            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000036EC  5302                    3930            SUB.B   #1,D2                     *DECREMENT COUNTER
000036EE  60F2                    3931            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
000036F0                          3932  DEST_MASKING_NEXT1
000036F0  C6BC 00000007           3933            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000036F6  0603 0030               3934            ADD.B   #$30,D3                   *CONVERT TO CHAR
000036FA  6100 034E               3935            BSR     PUSH_STACK                *PUSH TO STACK
000036FE                          3936            
000036FE  6000 030A               3937            BRA     GET_DST_SUCCESS                   *RETURN 
00003702                          3938            
00003702                          3939            
00003702                          3940            
00003702                          3941            
00003702                          3942            *** Check if source ...  <ea> = (An)       
00003702                          3943  DEST_CHECK2    
00003702  41F9 00004372           3944            LEA     TEMP_REGISTER_FORMAT,A0
00003708  1439 00004370           3945            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000370E  1082                    3946            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003710  0239 0004 00004372      3947            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003718  0C39 0004 00004372      3948            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003720  6700 007A               3949            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003724  0CB9 00000002 00004382  3950            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000372E  6600 006C               3951            BNE     DEST_CHECK3
00003732                          3952            
00003732                          3953            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003732  163C 0020               3954            MOVE.B    #' ',D3
00003736  6100 0312               3955            BSR       PUSH_STACK
0000373A  163C 0028               3956            MOVE.B    #'(',D3
0000373E  6100 030A               3957            BSR       PUSH_STACK
00003742  163C 0041               3958            MOVE.B    #'A',D3
00003746  6100 0302               3959            BSR       PUSH_STACK
0000374A                          3960  
0000374A                          3961            
0000374A                          3962            *FIND REGISTER NUMBER END LOCATION*  
0000374A  13F9 00004373 0000437A  3963            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003754  0239 000F 0000437A      3964            AND.B   #$0F,VAR_BYTE_END
0000375C                          3965            
0000375C                          3966            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000375C  23C5 0000437E           3967            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003762  1439 0000437A           3968            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003768                          3969            
00003768                          3970            *INTITIALIZE FOR BIT SHIFTING
00003768  41F9 0000437E           3971            LEA     VAR_TEMP_CLEANCOPY,A0
0000376E  2639 0000437E           3972            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003774                          3973  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003774  0C02 0000               3974            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003778  6700 0008               3975            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000377C  E24B                    3976            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000377E  5302                    3977            SUB.B   #1,D2                     *DECREMENT COUNTER
00003780  60F2                    3978            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003782                          3979  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003782  0283 00000007           3980            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003788  0603 0030               3981            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000378C  6100 02BC               3982            BSR     PUSH_STACK                *PUSH TO STACK
00003790                          3983            
00003790  163C 0029               3984            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003794  6100 02B4               3985            BSR       PUSH_STACK
00003798                          3986            
00003798  6000 0270               3987            BRA     GET_DST_SUCCESS                   *RETURN 
0000379C                          3988  
0000379C                          3989            
0000379C                          3990            
0000379C                          3991                      
0000379C                          3992  *** Check if source ...  <ea> = (An)+       
0000379C  41F9 00004372           3993  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000037A2  1439 00004370           3994            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037A8  1082                    3995            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037AA  0239 0008 00004372      3996            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000037B2  0C39 0008 00004372      3997            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
000037BA  6700 0082               3998            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000037BE  0CB9 00000003 00004382  3999            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000037C8  6600 0074               4000            BNE     DEST_CHECK4
000037CC                          4001            
000037CC                          4002            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000037CC  163C 0020               4003            MOVE.B    #' ',D3
000037D0  6100 0278               4004            BSR       PUSH_STACK
000037D4  163C 0028               4005            MOVE.B    #'(',D3
000037D8  6100 0270               4006            BSR       PUSH_STACK
000037DC  163C 0041               4007            MOVE.B    #'A',D3
000037E0  6100 0268               4008            BSR       PUSH_STACK
000037E4                          4009  
000037E4                          4010            
000037E4                          4011            *FIND REGISTER NUMBER END LOCATION*  
000037E4  13F9 00004373 0000437A  4012            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000037EE  0239 000F 0000437A      4013            ANDI.B   #$0F,VAR_BYTE_END
000037F6                          4014            
000037F6                          4015            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037F6  23C5 0000437E           4016            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037FC  1439 0000437A           4017            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003802                          4018            
00003802                          4019            *INTITIALIZE FOR BIT SHIFTING
00003802  41F9 0000437E           4020            LEA     VAR_TEMP_CLEANCOPY,A0
00003808  2639 0000437E           4021            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000380E                          4022            
0000380E                          4023  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000380E  0C02 0000               4024            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003812  6700 0008               4025            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003816  E24B                    4026            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003818  5302                    4027            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000381A  60F2                    4028            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
0000381C                          4029                                               *change: NAME OF LABEL*
0000381C                          4030  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
0000381C  0283 00000007           4031            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003822  0603 0030               4032            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003826  6100 0222               4033            BSR     PUSH_STACK                *PUSH TO STACK
0000382A                          4034            
0000382A  163C 0029               4035            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000382E  6100 021A               4036            BSR       PUSH_STACK
00003832  163C 002B               4037            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003836  6100 0212               4038            BSR       PUSH_STACK
0000383A                          4039            
0000383A  6000 01CE               4040            BRA       GET_DST_SUCCESS                   *RETURN 
0000383E                          4041  
0000383E                          4042            
0000383E                          4043            
0000383E                          4044                      
0000383E                          4045            *** Check if source ...  <ea> = -(An)       
0000383E                          4046  DEST_CHECK4    
0000383E  41F9 00004372           4047            LEA     TEMP_REGISTER_FORMAT,A0
00003844  1439 00004370           4048            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000384A  1082                    4049            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000384C  0239 0010 00004372      4050            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003854  0C39 0010 00004372      4051            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000385C  6700 0082               4052            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003860  0CB9 00000004 00004382  4053            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000386A  6600 0074               4054            BNE     DEST_CHECK7
0000386E                          4055            
0000386E                          4056            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000386E  163C 0020               4057            MOVE.B    #' ',D3
00003872  6100 01D6               4058            BSR       PUSH_STACK
00003876  163C 002D               4059            MOVE.B    #'-',D3
0000387A  6100 01CE               4060            BSR       PUSH_STACK
0000387E  163C 0028               4061            MOVE.B    #'(',D3
00003882  6100 01C6               4062            BSR       PUSH_STACK
00003886  163C 0041               4063            MOVE.B    #'A',D3
0000388A  6100 01BE               4064            BSR       PUSH_STACK
0000388E                          4065  
0000388E                          4066            
0000388E                          4067            *FIND REGISTER NUMBER END LOCATION*  
0000388E  13F9 00004373 0000437A  4068            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003898  0239 000F 0000437A      4069            AND.B   #$0F,VAR_BYTE_END
000038A0                          4070            
000038A0                          4071            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038A0  23C5 0000437E           4072            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038A6  1439 0000437A           4073            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038AC                          4074            
000038AC                          4075            *INTITIALIZE FOR BIT SHIFTING
000038AC  41F9 0000437E           4076            LEA     VAR_TEMP_CLEANCOPY,A0
000038B2  2639 0000437E           4077            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038B8                          4078            
000038B8                          4079  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
000038B8  0C02 0000               4080            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038BC  6700 0008               4081            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000038C0  E24B                    4082            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000038C2  5302                    4083            SUBI.B   #1,D2                     *DECREMENT COUNTER
000038C4  60F2                    4084            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
000038C6                          4085                                               *change: NAME OF LABEL*
000038C6                          4086  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
000038C6  0283 00000007           4087            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000038CC  0603 0030               4088            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000038D0  6100 0178               4089            BSR     PUSH_STACK                *PUSH TO STACK
000038D4                          4090            
000038D4  163C 0029               4091            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000038D8  6100 0170               4092            BSR       PUSH_STACK
000038DC                          4093            
000038DC  6000 012C               4094            BRA     GET_DST_SUCCESS                   *RETURN
000038E0                          4095            
000038E0                          4096                      
000038E0                          4097            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000038E0                          4098  DEST_CHECK7    
000038E0  0CB9 00000007 00004382  4099            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000038EA  6600 011A               4100            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000038EE                          4101                   
000038EE                          4102            *NEXT: (MODE == 111) 
000038EE                          4103            *NOW: CHECK FOR SRC REGISTER 
000038EE                          4104                  *(000 = (xxx).W)
000038EE                          4105                  *(001 = (xxx).L)
000038EE                          4106                  *(010 = #<data>)
000038EE                          4107                  
000038EE                          4108            *FIND REGISTER NUMBER END LOCATION*  
000038EE  13F9 00004373 0000437A  4109            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000038F8  0239 000F 0000437A      4110            AND.B   #$0F,VAR_BYTE_END
00003900                          4111            
00003900                          4112            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003900  23C5 0000437E           4113            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003906  1439 0000437A           4114            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000390C                          4115            
0000390C                          4116            *INTITIALIZE FOR BIT SHIFTING
0000390C  41F9 0000437E           4117            LEA     VAR_TEMP_CLEANCOPY,A0
00003912  2C39 0000437E           4118            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003918                          4119  DEST_LOOP_SHIFTING7
00003918  0C02 0000               4120            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000391C  6700 0008               4121            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003920  E24E                    4122            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003922  5302                    4123            SUB.B   #1,D2                     *DECREMENT COUNTER
00003924  60F2                    4124            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003926                          4125  DEST_MASKING_NEXT7
00003926  CCBC 00000007           4126            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
0000392C                          4127           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
0000392C                          4128            
0000392C                          4129  DEST_CHECK_WORD  
0000392C  41F9 00004372           4130            LEA     TEMP_REGISTER_FORMAT,A0
00003932  1439 00004370           4131            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003938  1082                    4132            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000393A  0239 0020 00004372      4133            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003942  0C39 0020 00004372      4134            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000394A  6700 0026               4135            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000394E  0C06 0000               4136            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003952  6600 001E               4137            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003956                          4138            *IT IS A WORD AT THIS POINT*
00003956                          4139            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003956  163C 0020               4140            MOVE.B    #' ',D3
0000395A  6100 00EE               4141            BSR       PUSH_STACK
0000395E  163C 0024               4142            MOVE.B    #'$',D3
00003962  6100 00E6               4143            BSR       PUSH_STACK
00003966  321D                    4144            MOVE.W    (A5)+,D1
00003968  7404                    4145            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000396A  6100 D88C               4146            BSR       HEX2ASCII2STACK
0000396E  6000 009A               4147            BRA       GET_DST_SUCCESS
00003972                          4148  
00003972                          4149  DEST_CHECK_LONG
00003972  41F9 00004372           4150            LEA     TEMP_REGISTER_FORMAT,A0
00003978  1439 00004370           4151            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000397E  1082                    4152            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003980  0239 0040 00004372      4153            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003988  0C39 0040 00004372      4154            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003990  6700 002E               4155            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003994  0C06 0001               4156            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003998  6600 0026               4157            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
0000399C                          4158            *IT IS A WORD AT THIS POINT*
0000399C                          4159            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000399C  163C 0020               4160            MOVE.B    #' ',D3
000039A0  6100 00A8               4161            BSR       PUSH_STACK
000039A4  163C 0024               4162            MOVE.B    #'$',D3
000039A8  6100 00A0               4163            BSR       PUSH_STACK
000039AC  321D                    4164            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
000039AE  7404                    4165            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
000039B0  6100 D846               4166            BSR       HEX2ASCII2STACK
000039B4  321D                    4167            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
000039B6  7404                    4168            MOVE.L    #4,D2          
000039B8  6100 D83E               4169            BSR       HEX2ASCII2STACK
000039BC  6000 004C               4170            BRA     GET_DST_SUCCESS
000039C0                          4171            
000039C0                          4172  DEST_CHECK_IMMEDIATE
000039C0  41F9 00004372           4173            LEA     TEMP_REGISTER_FORMAT,A0
000039C6  1439 00004370           4174            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039CC  1082                    4175            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039CE  0239 0080 00004372      4176            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000039D6  0C39 0080 00004372      4177            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039DE  6700 0026               4178            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000039E2  0C06 0004               4179            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
000039E6  6600 001E               4180            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
000039EA                          4181            
000039EA                          4182            *IT IS A WORD AT THIS POINT*
000039EA                          4183            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000039EA  163C 0020               4184            MOVE.B    #' ',D3
000039EE  6100 005A               4185            BSR       PUSH_STACK
000039F2  163C 0023               4186            MOVE.B    #'#',D3
000039F6  6100 0052               4187            BSR       PUSH_STACK
000039FA  321D                    4188            MOVE.W    (A5)+,D1
000039FC  7404                    4189            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000039FE  6100 D7F8               4190            BSR       HEX2ASCII2STACK
00003A02  6000 0006               4191            BRA       GET_DST_SUCCESS
00003A06                          4192            
00003A06                          4193  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003A06  7801                    4194            MOVE.L #1,D4
00003A08  4E75                    4195            RTS
00003A0A                          4196  GET_DST_SUCCESS 
00003A0A  4E75                    4197            RTS
00003A0C                          4198  
00003A0C                          4199  
00003A0C                          4200  *---------------------------------------------------------------------------*
00003A0C                          4201  * STACK/QUEUE INTERFACE
00003A0C                          4202  *---------------------------------------------------------------------------*
00003A0C                          4203  PRINT_STACK
00003A0C  0C39 0000 0000436C      4204            CMP.B     #0,COUNTER
00003A14  6700 000E               4205            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003A18                          4206            
00003A18                          4207  PRINT_STACK_HELPER
00003A18  6100 0038               4208            BSR      POP_STACK          *PRINTS ADDRESS
00003A1C  103C 0006               4209            MOVE.B   #6,D0              *Display single character in D1.B. 
00003A20  4E4F                    4210            TRAP     #15             *ACTIVATES PRINT
00003A22                          4211  
00003A22  60E8                    4212            BRA       PRINT_STACK
00003A24                          4213  PRINT_STACK_RETURN
00003A24  4E75                    4214            RTS
00003A26                          4215            
00003A26                          4216            
00003A26                          4217  PRINT_QUEUE
00003A26  0C39 0000 0000436C      4218            CMP.B     #0,COUNTER
00003A2E  6700 0018               4219            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003A32                          4220            
00003A32                          4221  PRINT_QUEUE_HELPER
00003A32  33F9 0000436C 0000436E  4222            MOVE.W   COUNTER,QUEUE_COUNTER
00003A3C  6100 0022               4223            BSR      POP_FRONT          *PRINTS ADDRESS
00003A40  103C 0006               4224            MOVE.B   #6,D0              *Display single character in D1.B. 
00003A44  4E4F                    4225            TRAP     #15             *ACTIVATES PRINT
00003A46                          4226  
00003A46  60DE                    4227            BRA       PRINT_QUEUE
00003A48                          4228  PRINT_QUEUE_RETURN
00003A48  4E75                    4229            RTS
00003A4A                          4230            
00003A4A                          4231  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003A4A                          4232  PUSH_STACK
00003A4A  1503                    4233              MOVE.B  D3,-(A2)
00003A4C  6100 0058               4234              BSR     INCREMENT
00003A50  4E75                    4235              RTS
00003A52                          4236  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003A52                          4237  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003A52                          4238  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003A52                          4239  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003A52                          4240  *         TRAP        #15             *ACTIVATES PRINT
00003A52                          4241  POP_STACK
00003A52  BECA                    4242              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003A54  6700 0008               4243              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003A58  121A                    4244              MOVE.B  (A2)+,D1 
00003A5A  6100 0052               4245              BSR     DECREMENT
00003A5E                          4246  POP_RETURN
00003A5E  4E75                    4247              RTS 
00003A60                          4248        
00003A60                          4249  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003A60  0C39 0000 0000436E      4250  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003A68  6700 0030               4251              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003A6C                          4252              
00003A6C                          4253              
00003A6C                          4254              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003A6C  347C 7000               4255              MOVEA.W #STACK,A2   *START A2 AT STACK
00003A70  0622 0000               4256              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003A74  384A                    4257              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003A76  0624 0000               4258              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003A7A  1212                    4259              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003A7C                          4260  POP_SHIFT_LOOP
00003A7C  0C39 0000 0000436E      4261              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003A84  6700 0014               4262              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003A88  1494                    4263              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003A8A  0624 0000               4264              ADD.B   #0,-(A4)
00003A8E  0622 0000               4265              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003A92  5339 0000436E           4266              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003A98                          4267              
00003A98  60E2                    4268              BRA     POP_SHIFT_LOOP
00003A9A                          4269                          
00003A9A                          4270  POP_FRONT_RETURN 
00003A9A                          4271              *RESET A2 BACK TO SP
00003A9A  347C 7000               4272              MOVEA.W #STACK,A2    
00003A9E  5339 0000436C           4273              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003AA4  4E75                    4274              RTS   
00003AA6                          4275  
00003AA6                          4276  INCREMENT
00003AA6  5239 0000436C           4277              ADD.B   #1, COUNTER
00003AAC  4E75                    4278              RTS           
00003AAE                          4279  DECREMENT
00003AAE  5339 0000436C           4280              SUB.B   #1, COUNTER
00003AB4  4E75                    4281              RTS           
00003AB6                          4282  CLEAR_STACK
00003AB6  0C39 0000 0000436C      4283              CMP.B     #0,COUNTER
00003ABE  6700 0006               4284              BEQ       CLEAR_RETURN
00003AC2  618E                    4285              BSR       POP_STACK
00003AC4  60F0                    4286              BRA       CLEAR_STACK
00003AC6                          4287   
00003AC6                          4288  CLEAR_RETURN
00003AC6  4E75                    4289              RTS    
00003AC8                          4290  *---------------------------------------------------------------------------*
00003AC8                          4291  * TERMINATE
00003AC8                          4292  *---------------------------------------------------------------------------*
00003AC8                          4293  TERMINATE   
00003AC8  43F9 00003E78           4294              LEA     FINMSG,A1
00003ACE  103C 000E               4295              MOVE.B  #14,D0
00003AD2  4E4F                    4296              TRAP    #15
00003AD4                          4297  
00003AD4  103C 0009               4298              MOVE.B  #9,D0
00003AD8  4E4F                    4299              TRAP    #15
00003ADA                          4300  
00003ADA                          4301  *---------------------------------------------------------------------------*
00003ADA                          4302  * Data storage                                                 
00003ADA                          4303  *---------------------------------------------------------------------------*  
00003ADA                          4304  WELCOME
00003ADA= 20 20 20 20 20 20 ...   4305              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00003B2A= 3D 3D 3D 3D 3D 20 ...   4306              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003B7A= 3D 3D 3D 3D 3D 20 ...   4307              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003BCA                          4308      
00003BCA= 20 20 20 20 20 20 ...   4309              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00003C1A= 20 20 20 20 20 20 ...   4310              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00003C6A= 20 20 20 20 20 20 ...   4311              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003CBA                          4312      
00003CBA= 20 20 20 20 20 20 ...   4313              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00003D0A= 3D 3D 3D 3D 3D 20 ...   4314              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00003D5A= 3D 3D 3D 3D 3D 20 ...   4315              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003DAF                          4316  
00003DAF                          4317  PROMPT_START
00003DAF= 50 6C 65 61 73 65 ...   4318              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00003DDE                          4319      
00003DDE                          4320  PROMPT_END
00003DDE= 50 6C 65 61 73 65 ...   4321              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00003E0B= 0D 0A 48 69 74 20 ...   4322  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00003E35= 57 6F 75 6C 64 20 ...   4323  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003E78= 54 68 61 6E 6B 20 ...   4324  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003EA3= 45 72 72 6F 72 3A ...   4325  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003EC2= 45 72 72 6F 72 3A ...   4326  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003EE7= 45 72 72 6F 72 3A ...   4327  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003F14                          4328  
00003F14                          4329  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003F64                          4330  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003FB4                          4331  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003FB8                          4332  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003FBC= 0D 0A 00                4333  ENDLINE_M   DC.B    CR,LF,0
00003FBF                          4334  TMPINPUT    DS.B    80                      * temp store user input
0000400F                          4335  TMPOUTPUT   DS.B    80                      * temp store prog output
0000405F= 20 20 20 4F 52 49 ...   4336  DISP_ORI_B  DC.B    '   ORI.B',0
00004068= 20 20 20 4F 52 49 ...   4337  DISP_ORI_W  DC.B    '   ORI.W',0
00004071= 20 20 20 4F 52 49 ...   4338  DISP_ORI_L  DC.B    '   ORI.L',0
0000407A= 20 20 20 45 4F 52 ...   4339  DISP_EORI_B  DC.B    '   EORI.B',0
00004084= 20 20 20 45 4F 52 ...   4340  DISP_EORI_W  DC.B    '   EORI.W',0
0000408E= 20 20 20 45 4F 52 ...   4341  DISP_EORI_L  DC.B    '   EORI.L',0
00004098= 20 20 20 42 54 53 ...   4342  DISP_BTST   DC.B    '   BTST',0
000040A0= 20 20 20 43 4D 50 ...   4343  DISP_CMPI_B  DC.B    '   CMPI.B',0
000040AA= 20 20 20 43 4D 50 ...   4344  DISP_CMPI_W  DC.B    '   CMPI.W',0
000040B4= 20 20 20 43 4D 50 ...   4345  DISP_CMPI_L  DC.B    '   CMPI.L',0
000040BE= 20 20 20 44 41 54 ...   4346  DISP_DATA   DC.B    '   DATA',0
000040C6= 20 20 20 4D 4F 56 ...   4347  DISP_MOVE_B DC.B    '   MOVE.B',0
000040D0= 20 20 20 4D 4F 56 ...   4348  DISP_MOVE_W DC.B    '   MOVE.W',0
000040DA= 20 20 20 4D 4F 56 ...   4349  DISP_MOVE_L DC.B    '   MOVE.L',0
000040E4= 20 20 20 52 54 53 00    4350  DISP_RTS    DC.B    '   RTS',0
000040EB= 20 20 20 4A 53 52 00    4351  DISP_JSR    DC.B    '   JSR',0
000040F2= 20 20 20 4E 45 47 ...   4352  DISP_NEG_B    DC.B    '   NEG.B',0
000040FB= 20 20 20 4E 45 47 ...   4353  DISP_NEG_W    DC.B    '   NEG.W',0
00004104= 20 20 20 4E 45 47 ...   4354  DISP_NEG_L    DC.B    '   NEG.L',0
0000410D= 20 20 20 4E 4F 54 ...   4355  DISP_NOT_B  DC.B    '   NOT.B',0
00004116= 20 20 20 4E 4F 54 ...   4356  DISP_NOT_W  DC.B    '   NOT.W',0
0000411F= 20 20 20 4E 4F 54 ...   4357  DISP_NOT_L  DC.B    '   NOT.L',0
00004128= 20 20 20 4C 45 41 00    4358  DISP_LEA    DC.B    '   LEA',0
0000412F= 20 20 20 4D 4F 56 ...   4359  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
0000413A= 20 20 20 4D 4F 56 ...   4360  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00004145= 20 20 20 41 44 44 ...   4361  DISP_ADDQ_B DC.B    '   ADDQ.B',0
0000414F= 20 20 20 41 44 44 ...   4362  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00004159= 20 20 20 41 44 44 ...   4363  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00004163= 20 20 20 44 49 56 ...   4364  DISP_DIVS   DC.B    '   DIVS',0
0000416B= 20 20 20 53 55 42 ...   4365  DISP_SUB_B  DC.B    '   SUB.B',0
00004174= 20 20 20 53 55 42 ...   4366  DISP_SUB_W  DC.B    '   SUB.W',0
0000417D= 20 20 20 53 55 42 ...   4367  DISP_SUB_L  DC.B    '   SUB.L',0
00004186= 20 20 20 53 55 42 ...   4368  DISP_SUBI_B  DC.B    '   SUBI.B',0
00004190= 20 20 20 53 55 42 ...   4369  DISP_SUBI_W  DC.B    '   SUBI.W',0
0000419A= 20 20 20 53 55 42 ...   4370  DISP_SUBI_L  DC.B    '   SUBI.L',0
000041A4= 20 20 20 53 55 42 ...   4371  DISP_SUBA_W  DC.B    '   SUBA.W',0
000041AE= 20 20 20 53 55 42 ...   4372  DISP_SUBA_L  DC.B    '   SUBA.L',0
000041B8= 20 20 20 45 4F 52 ...   4373  DISP_EOR_B  DC.B    '   EOR.B',0
000041C1= 20 20 20 45 4F 52 ...   4374  DISP_EOR_W  DC.B    '   EOR.W',0
000041CA= 20 20 20 45 4F 52 ...   4375  DISP_EOR_L  DC.B    '   EOR.L',0
000041D3= 20 20 20 43 4D 50 ...   4376  DISP_CMP_B  DC.B    '   CMP.B',0
000041DC= 20 20 20 43 4D 50 ...   4377  DISP_CMP_W  DC.B    '   CMP.W',0
000041E5= 20 20 20 43 4D 50 ...   4378  DISP_CMP_L  DC.B    '   CMP.L',0
000041EE= 20 20 20 43 4D 50 ...   4379  DISP_CMPA_W  DC.B    '   CMPA.W',0
000041F8= 20 20 20 43 4D 50 ...   4380  DISP_CMPA_L  DC.B    '   CMPA.L',0
00004202= 20 20 20 4D 55 4C ...   4381  DISP_MULS_W DC.B    '   MULS.W',0
0000420C= 20 20 20 41 4E 44 ...   4382  DISP_AND_B  DC.B    '   AND.B',0
00004215= 20 20 20 41 4E 44 ...   4383  DISP_AND_W  DC.B    '   AND.W',0
0000421E= 20 20 20 41 4E 44 ...   4384  DISP_AND_L  DC.B    '   AND.L',0
00004227= 20 20 20 41 44 44 ...   4385  DISP_ADD_B  DC.B    '   ADD.B',0
00004230= 20 20 20 41 44 44 ...   4386  DISP_ADD_W  DC.B    '   ADD.W',0
00004239= 20 20 20 41 44 44 ...   4387  DISP_ADD_L  DC.B    '   ADD.L',0
00004242= 20 20 20 41 44 44 ...   4388  DISP_ADDA_W DC.B    '   ADDA.W',0
0000424C= 20 20 20 41 44 44 ...   4389  DISP_ADDA_L DC.B    '   ADDA.L',0
00004256= 20 20 20 4C 53 52 ...   4390  DISP_LSR_B  DC.B    '   LSR.B',0
0000425F= 20 20 20 4C 53 4C ...   4391  DISP_LSL_B  DC.B    '   LSL.B',0
00004268= 20 20 20 4C 53 52 ...   4392  DISP_LSR_W  DC.B    '   LSR.W',0
00004271= 20 20 20 4C 53 4C ...   4393  DISP_LSL_W  DC.B    '   LSL.W',0
0000427A= 20 20 20 4C 53 52 ...   4394  DISP_LSR_L  DC.B    '   LSR.L',0
00004283= 20 20 20 4C 53 4C ...   4395  DISP_LSL_L  DC.B    '   LSL.L',0
0000428C= 20 20 20 41 53 52 ...   4396  DISP_ASR_B  DC.B    '   ASR.B',0
00004295= 20 20 20 41 53 4C ...   4397  DISP_ASL_B  DC.B    '   ASL.B',0
0000429E= 20 20 20 41 53 52 ...   4398  DISP_ASR_W  DC.B    '   ASR.W',0
000042A7= 20 20 20 41 53 4C ...   4399  DISP_ASL_W  DC.B    '   ASL.W',0
000042B0= 20 20 20 41 53 52 ...   4400  DISP_ASR_L  DC.B    '   ASR.L',0
000042B9= 20 20 20 41 53 4C ...   4401  DISP_ASL_L  DC.B    '   ASL.L',0
000042C2= 20 20 20 52 4F 52 ...   4402  DISP_ROR_B  DC.B    '   ROR.B',0
000042CB= 20 20 20 52 4F 4C ...   4403  DISP_ROL_B  DC.B    '   ROL.B',0
000042D4= 20 20 20 52 4F 52 ...   4404  DISP_ROR_W  DC.B    '   ROR.W',0
000042DD= 20 20 20 52 4F 4C ...   4405  DISP_ROL_W  DC.B    '   ROL.W',0
000042E6= 20 20 20 52 4F 52 ...   4406  DISP_ROR_L  DC.B    '   ROR.L',0
000042EF= 20 20 20 52 4F 4C ...   4407  DISP_ROL_L  DC.B    '   ROL.L',0
000042F8= 20 20 20 42 52 41 00    4408  DISP_BRA    DC.B    '   BRA',0
000042FF= 20 20 20 42 4C 54 00    4409  DISP_BLT    DC.B    '   BLT',0
00004306= 20 20 20 42 45 51 00    4410  DISP_BEQ    DC.B    '   BEQ',0
0000430D= 20 20 20 42 4E 45 00    4411  DISP_BNE    DC.B    '   BNE',0
00004314= 20 20 20 42 48 49 00    4412  DISP_BHI    DC.B    '   BHI',0
0000431B= 20 20 20 4D 4F 56 ...   4413  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004326= 20 20 20 4D 4F 56 ...   4414  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004331                          4415  
00004331= 20 20 20 24 00          4416  DISP_HEX     DC.B    '   $',0
00004336= 20 20 20 44 00          4417  DISP_D  DC.B    '   D',0
0000433B= 20 20 20 41 00          4418  DISP_A  DC.B    '   A',0
00004340= 20 20 20 28 00          4419  DISP_OP  DC.B    '   (',0
00004345= 29 00                   4420  DISP_CP  DC.B   ')',0
00004347= 20 20 20 28 41 00       4421  DISP_AOP  DC.B    '   (A',0
0000434D                          4422  
0000434D= 20 20 20 2D 28 41 00    4423  DISP_PRE    DC.B    '   -(A',0
00004354= 29 2B 00                4424  DISP_POST   DC.B    ')+',0
00004357= 20 20 20 23 00          4425  DISP_LB DC.B    '   #',0
0000435C= 30 00                   4426  DISP_0  DC.B    '0',0
0000435E= 31 00                   4427  DISP_1  DC.B    '1',0
00004360= 32 00                   4428  DISP_2  DC.B    '2',0
00004362= 33 00                   4429  DISP_3  DC.B    '3',0
00004364= 34 00                   4430  DISP_4  DC.B    '4',0
00004366= 35 00                   4431  DISP_5  DC.B    '5',0
00004368= 36 00                   4432  DISP_6  DC.B    '6',0
0000436A= 37 00                   4433  DISP_7  DC.B    '7',0
0000436C                          4434  
0000436C                          4435  *STACK INTERFACE VARIABLES*
0000436C                          4436  COUNTER         DS.W    1
0000436E                          4437  QUEUE_COUNTER   DS.W    1
00004370                          4438  
00004370                          4439  *EA DECODING INTERFACE VARIABLES* 
00004370                          4440  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004371                          4441  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004372                          4442  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004373                          4443  
00004373                          4444  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004373                          4445  * WORD + WORD = LONG
00004373                          4446  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004373                          4447  * A              + F            = AF         <= EXAMPLE
00004373                          4448  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004373                          4449  GET_DST_START_END    DS.B    1
00004374                          4450  GET_SRC_START_END    DS.B    1
00004375                          4451  
00004375                          4452  *STORES THE START + END BITS HERE (FROM ABOVE)
00004376                          4453  VAR_BYTE_START      DS.L    1
0000437A                          4454  VAR_BYTE_END        DS.L    1
0000437E                          4455  VAR_TEMP_CLEANCOPY  DS.L    1
00004382                          4456  
00004382                          4457  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004386                          4458  
00004386                          4459  *MORE FOR STACK USAGE*
00004386= 2C 00                   4460  DISP_COMMA  DC.B    ',',0
00004388= 20 20 20 00             4461  DISP_INDENT  DC.B    '   ',0
0000438C                          4462  
0000438C                          4463  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
0000438C                          4464  POINTER_WORD    DS.W       1
0000438E                          4465  
0000438E                          4466  
0000438E                          4467  
0000438E                          4468  *---------------------------------------------------------------------------*
0000438E                          4469  * Ends program
0000438E                          4470  *---------------------------------------------------------------------------*
0000438E                          4471              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1154
ASCII2HEX           114E
ASC_ERR             11B0
ASC_LOW             1192
ASC_NUM             11A2
ASC_SFT             11AA
ASC_UPP             119A
CHECK0              31BE
CHECK1              3248
CHECK2              32D2
CHECK3              336C
CHECK4              340E
CHECK7              34B0
CHECK_IMMEDIATE     3590
CHECK_LONG          3542
CHECK_WORD          34FC
CLEAR_RETURN        3AC6
CLEAR_STACK         3AB6
COUNTER             436C
CR                  D
DECREMENT           3AAE
DEST_CHECK0         35EE
DEST_CHECK1         3678
DEST_CHECK2         3702
DEST_CHECK3         379C
DEST_CHECK4         383E
DEST_CHECK7         38E0
DEST_CHECK_IMMEDIATE  39C0
DEST_CHECK_LONG     3972
DEST_CHECK_WORD     392C
DEST_LOOP_SHIFTING  3658
DEST_LOOP_SHIFTING1  36E2
DEST_LOOP_SHIFTING2  3774
DEST_LOOP_SHIFTING3  380E
DEST_LOOP_SHIFTING4  38B8
DEST_LOOP_SHIFTING7  3918
DEST_MASKING_NEXT   3666
DEST_MASKING_NEXT1  36F0
DEST_MASKING_NEXT2  3782
DEST_MASKING_NEXT3  381C
DEST_MASKING_NEXT4  38C6
DEST_MASKING_NEXT7  3926
DEST_MODE           2D76
DEST_REGISTER       3046
DEST_REGISTER_FORMAT  4370
DISPLAY_30_LINES    12FC
DISP_0              435C
DISP_1              435E
DISP_2              4360
DISP_3              4362
DISP_4              4364
DISP_5              4366
DISP_6              4368
DISP_7              436A
DISP_A              433B
DISP_ADDA_L         424C
DISP_ADDA_W         4242
DISP_ADDQ_B         4145
DISP_ADDQ_L         4159
DISP_ADDQ_W         414F
DISP_ADD_B          4227
DISP_ADD_L          4239
DISP_ADD_W          4230
DISP_AND_B          420C
DISP_AND_L          421E
DISP_AND_W          4215
DISP_AOP            4347
DISP_ASL_B          4295
DISP_ASL_L          42B9
DISP_ASL_W          42A7
DISP_ASR_B          428C
DISP_ASR_L          42B0
DISP_ASR_W          429E
DISP_BEQ            4306
DISP_BHI            4314
DISP_BLT            42FF
DISP_BNE            430D
DISP_BRA            42F8
DISP_BTST           4098
DISP_CMPA_L         41F8
DISP_CMPA_W         41EE
DISP_CMPI_B         40A0
DISP_CMPI_L         40B4
DISP_CMPI_W         40AA
DISP_CMP_B          41D3
DISP_CMP_L          41E5
DISP_CMP_W          41DC
DISP_COMMA          4386
DISP_CP             4345
DISP_D              4336
DISP_DATA           40BE
DISP_DIVS           4163
DISP_EORI_B         407A
DISP_EORI_L         408E
DISP_EORI_W         4084
DISP_EOR_B          41B8
DISP_EOR_L          41CA
DISP_EOR_W          41C1
DISP_HEX            4331
DISP_INDENT         4388
DISP_JSR            40EB
DISP_LB             4357
DISP_LEA            4128
DISP_LSL_B          425F
DISP_LSL_L          4283
DISP_LSL_W          4271
DISP_LSR_B          4256
DISP_LSR_L          427A
DISP_LSR_W          4268
DISP_MOVEA_L        4326
DISP_MOVEA_W        431B
DISP_MOVEM_L        413A
DISP_MOVEM_W        412F
DISP_MOVE_B         40C6
DISP_MOVE_L         40DA
DISP_MOVE_W         40D0
DISP_MULS_W         4202
DISP_NEG_B          40F2
DISP_NEG_L          4104
DISP_NEG_W          40FB
DISP_NEXT           3E0B
DISP_NOT_B          410D
DISP_NOT_L          411F
DISP_NOT_W          4116
DISP_OP             4340
DISP_ORI_B          405F
DISP_ORI_L          4071
DISP_ORI_W          4068
DISP_POST           4354
DISP_PRE            434D
DISP_ROL_B          42CB
DISP_ROL_L          42EF
DISP_ROL_W          42DD
DISP_ROR_B          42C2
DISP_ROR_L          42E6
DISP_ROR_W          42D4
DISP_RTS            40E4
DISP_SUBA_L         41AE
DISP_SUBA_W         41A4
DISP_SUBI_B         4186
DISP_SUBI_L         419A
DISP_SUBI_W         4190
DISP_SUB_B          416B
DISP_SUB_L          417D
DISP_SUB_W          4174
D_MODE000           2E18
D_MODE010           2E60
D_MODE011           2EC0
D_MODE100           2EE0
D_MODE111           2F32
EA_ARITH            2D10
EA_DATA             14DA
EA_GEN              2D5C
EA_MOVEA            2D36
EA_NOSRC            2CFC
ENDLINE_M           3FBC
END_ADDR            109A
ERRMSG_1            3EA3
ERRMSG_3            3EC2
ERRMSG_5            3EE7
ERROR_1             10FE
ERROR_2             110E
ERROR_3             111E
ERROR_4             112E
ERROR_5             113E
E_ADDR_HX           3FB8
FINMSG              3E78
GET_DST_FAILED      3A06
GET_DST_START_END   4373
GET_DST_SUCCESS     3A0A
GET_EA_EA_DEST      35DC
GET_EA_EA_SRC       31AC
GET_SRC_FAILED      35D6
GET_SRC_START_END   4374
GET_SRC_SUCCESS     35DA
HEX2ASCII           11B6
HEX2ASCII2STACK     11F8
HEX_CHAR            11E4
HEX_CONT            11E8
HEX_LOOP            11CA
IMMD_B              2FE6
IMMD_L              3026
IMMD_W              3006
IMMEDIATE           2FB6
INCREMENT           3AA6
INTRO               1028
IS_ODD              123C
IS_ODD_ERR          1252
JMPTABLE            1328
LF                  A
LONGMODE            2F8A
LOOP_SHIFTING       3228
LOOP_SHIFTING1      32B2
LOOP_SHIFTING2      3344
LOOP_SHIFTING3      33DE
LOOP_SHIFTING4      3488
MAIN                1258
MASKING_NEXT        3236
MASKING_NEXT1       32C0
MASKING_NEXT2       3352
MASKING_NEXT3       33EC
MASKING_NEXT4       3496
MODE000             2E04
MODE001             2E2C
MODE010             2E40
MODE011             2E80
MODE100             2EA0
MODE111             2F00
NEXTLINES           130A
OP0000              1388
OP0001              15AE
OP0010              161C
OP0011              171A
OP0100              1816
OP0101              1A6C
OP0101_ADDQ_B       1AE8
OP0101_ADDQ_B_0     1B64
OP0101_ADDQ_B_1     1B70
OP0101_ADDQ_B_2     1B7C
OP0101_ADDQ_B_3     1B88
OP0101_ADDQ_B_4     1B94
OP0101_ADDQ_B_5     1BA0
OP0101_ADDQ_B_6     1BAC
OP0101_ADDQ_B_7     1BB8
OP0101_ADDQ_B_8     1BC4
OP0101_ADDQ_L       1B00
OP0101_ADDQ_W       1AF4
OP0101_RETURN       1B08
OP0101_RETURN2      1BCC
OP0110              1C10
OP0111              1C9E
OP1000              1CA2
OP1000_DIVS_DN_EA_OR_EA_DN  1CB0
OP1000_DIVS_RETURN  1D94
OP1000_EA_DN_DIVS   1CDE
OP1000_PRINT_L_DIVS  1D4C
OP1000_PRINT_W_DIVS  1D04
OP1001              1DAA
OP1001_ADD_RETURN   20F8
OP1001_DETERMINE_DN_EA_OR_EA_DN  1EC0
OP1001_DN_EA        1EF8
OP1001_EA_DN        1FF8
OP1001_PRINT_B      2020
OP1001_PRINT_B2     1F20
OP1001_PRINT_L      20B0
OP1001_PRINT_L2     1FB0
OP1001_PRINT_W      2068
OP1001_PRINT_W2     1F68
OP1001_SUBA_L       1DDC
OP1001_SUBA_W       1E4E
OP1010              2166
OP1011              216A
OP1011_CMP          21C4
OP1011_CMPA         21C6
OP1011_EOR          21C8
OP1011_EOR_B        223C
OP1011_EOR_L        2254
OP1011_EOR_W        2248
OP1011_RETURN       225C
OP1100              231C
OP1100_AND_RETURN   266C
OP1100_DETERMINE_DN_EA_OR_EA_DN  2432
OP1100_DN_EA        246C
OP1100_EA_DN        256C
OP1100_EA_DN_MULS   237A
OP1100_MULS_DN_EA_OR_EA_DN  234C
OP1100_MULS_RETURN  2430
OP1100_PRINT_B      2594
OP1100_PRINT_B2     2494
OP1100_PRINT_L      2624
OP1100_PRINT_L2     2524
OP1100_PRINT_L_MULS  23E8
OP1100_PRINT_W      25DC
OP1100_PRINT_W2     24DC
OP1100_PRINT_W_MULS  23A0
OP1101              266E
OP1101_ADDA_L       26A0
OP1101_ADDA_W       2712
OP1101_ADD_RETURN   29BC
OP1101_DETERMINE_DN_EA_OR_EA_DN  2784
OP1101_DN_EA        27BC
OP1101_EA_DN        28BC
OP1101_PRINT_B      28E4
OP1101_PRINT_B2     27E4
OP1101_PRINT_L      2974
OP1101_PRINT_L2     2874
OP1101_PRINT_W      292C
OP1101_PRINT_W2     282C
OP1110              2A4A
OP1111              2CF8
OP_ADDA_L           2A32
OP_ADDA_W           2A1A
OP_ADDQ_B           1BDA
OP_ADDQ_L           1BFE
OP_ADDQ_W           1BEC
OP_ADD_B            29D2
OP_ADD_L            2A02
OP_ADD_W            29EA
OP_ASL              2BEA
OP_ASL_B            2C0E
OP_ASL_L            2C20
OP_ASL_W            2C32
OP_ASR              2B90
OP_ASR_B            2BB4
OP_ASR_L            2BC6
OP_ASR_W            2BD8
OP_ASX              2AAC
OP_BEQ              1C74
OP_BHI              1C58
OP_BLT              1C90
OP_BNE              1C66
OP_BRA              1C82
OP_BTST             13FC
OP_CMPA_L           228C
OP_CMPA_W           227A
OP_CMPI             1502
OP_CMPI_B           1522
OP_CMPI_L           1546
OP_CMPI_W           1534
OP_CMP_B            229E
OP_CMP_L            22CE
OP_CMP_W            22B6
OP_DATA             14B6
OP_DIVS             1D96
OP_EORI             140A
OP_EORI_B           142A
OP_EORI_L           144E
OP_EORI_W           143C
OP_EOR_B            22E6
OP_EOR_L            230A
OP_EOR_W            22F8
OP_JSR              1A3E
OP_LEA              18C4
OP_LEA_DN_EA_OR_EA_DN  18D2
OP_LEA_RETURN       1930
OP_LSL              2B36
OP_LSL_B            2B5A
OP_LSL_L            2B6C
OP_LSL_W            2B7E
OP_LSR              2ADC
OP_LSR_B            2B00
OP_LSR_L            2B12
OP_LSR_W            2B24
OP_LSX              2A94
OP_MOVEA_L          16AA
OP_MOVEA_W          17A6
OP_MOVEM_L          18B2
OP_MOVEM_W          18A0
OP_MOVE_B           15B4
OP_MOVE_L           1642
OP_MOVE_W           173E
OP_MULS             233E
OP_NEG              1932
OP_NEG_B            197E
OP_NEG_L            1996
OP_NEG_PRINT_EA     19A2
OP_NEG_W            198A
OP_NOT              19B8
OP_NOT_B            1A04
OP_NOT_L            1A1C
OP_NOT_PRINT_EA     1A28
OP_NOT_W            1A10
OP_ORI              1558
OP_ORI_B            1578
OP_ORI_L            159C
OP_ORI_W            158A
OP_PRINT_L_LEA      18F0
OP_ROL              2C9E
OP_ROL_B            2CC2
OP_ROL_L            2CD4
OP_ROL_W            2CE6
OP_ROR              2C44
OP_ROR_B            2C68
OP_ROR_L            2C7A
OP_ROR_W            2C8C
OP_ROX              2AC4
OP_RTS              1A52
OP_SUBA_L           2154
OP_SUBA_W           2142
OP_SUBI             1460
OP_SUBI_B           1480
OP_SUBI_L           14A4
OP_SUBI_W           1492
OP_SUB_B            20FA
OP_SUB_L            212A
OP_SUB_W            2112
OUTPUT_PROCESSED_DATA  12DC
POINTER_WORD        438C
POP_FRONT           3A60
POP_FRONT_RETURN    3A9A
POP_RETURN          3A5E
POP_SHIFT_LOOP      3A7C
POP_STACK           3A52
PRINT_QUEUE         3A26
PRINT_QUEUE_HELPER  3A32
PRINT_QUEUE_RETURN  3A48
PRINT_STACK         3A0C
PRINT_STACK_HELPER  3A18
PRINT_STACK_RETURN  3A24
PROGLP              100A
PROMPT_END          3DDE
PROMPT_START        3DAF
PUSH_STACK          3A4A
QUEUE_COUNTER       436E
REG_0               30FA
REG_1               3108
REG_2               3116
REG_3               3124
REG_4               3132
REG_5               3140
REG_6               314E
REG_7               315C
REPEAT              316A
REPEATMSG           3E35
RETURN              11B4
SRC_LOOP_SHIFTING   34E8
SRC_MASKING_NEXT    34F6
SRC_MODE            2DBA
SRC_REGISTER        30A2
SRC_REGISTER_FORMAT  4371
STACK               7000
STACK_HEX_CHAR      1226
STACK_HEX_CONT      122A
STACK_HEX_LOOP      120C
START               1004
START_ADDR          1048
S_ADDR_HX           3FB4
TEMP_REGISTER_FORMAT  4372
TERMINATE           3AC8
TESTING             1036
TMPINPUT            3FBF
TMPOUTPUT           400F
VAR_BYTE_END        437A
VAR_BYTE_START      4376
VAR_LONG_ADDRESS_MODE_CHECK  4382
VAR_TEMP_CLEANCOPY  437E
VR_E_ADDR           3F64
VR_S_ADDR           3F14
WELCOME             3ADA
WORDMODE            2F5E
