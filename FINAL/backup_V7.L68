00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/9/2014 12:21:41 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001038             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000108A             38              JSR     END_ADDR
00001016  43F9 00003C46             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 00001248             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003764             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036                            53  
00001036                            54              
00001036                            55  
00001036                            56              
00001036  4E75                      57              RTS
00001038                            58  *---------------------------------------------------------------------------*
00001038                            59  * START_ADDR: Compute the starting address
00001038                            60  *---------------------------------------------------------------------------*
00001038                            61  START_ADDR
00001038                            62              * Output
00001038  43F9 00003A39             63              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000103E  103C 000E                 64              MOVE.B  #14,D0                  * Display PROMPT_START
00001042  4E4F                      65              TRAP    #15
00001044                            66      
00001044                            67              * Input
00001044  43F9 00003B9E             68              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000104A  103C 0002                 69              MOVE.B  #2,D0                   * Ask user for input
0000104E  4E4F                      70              TRAP    #15
00001050                            71              
00001050                            72              * Error Checking (length)
00001050  0C01 0000                 73              CMPI.B  #0, D1                  * Check if input length <= 0
00001054  6F00 0098                 74              BLE     ERROR_1
00001058  0C01 0008                 75              CMPI.B  #8, D1                  * Check if input length > 8
0000105C  6E00 0090                 76              BGT     ERROR_1
00001060                            77              
00001060                            78              * Conversion & Storage
00001060  4EB9 0000113E             79              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001066  0C07 0001                 80              CMPI.B  #1, D7                  * Check for error
0000106A  6700 0082                 81              BEQ     ERROR_1                 
0000106E  23C1 00003C3E             82              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001074                            83              
00001074                            84              * Error Checking (Odd)
00001074  43F9 00003C3E             85              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000107A  4EB9 0000122C             86              JSR     IS_ODD                  * Check if the input address is odd
00001080  0C07 0001                 87              CMPI.B  #1, D7                  * Check for error
00001084  6700 0088                 88              BEQ     ERROR_3
00001088                            89              
00001088                            90              * Return
00001088  4E75                      91              RTS     
0000108A                            92  *---------------------------------------------------------------------------*
0000108A                            93  * END_ADDR: Compute the ending address
0000108A                            94  *---------------------------------------------------------------------------*
0000108A                            95  END_ADDR
0000108A                            96              * Output
0000108A  43F9 00003A68             97              LEA     PROMPT_END,A1           * Load PROMPT_END
00001090  103C 000E                 98              MOVE.B  #14,D0                  * Display PROMPT_END
00001094  4E4F                      99              TRAP    #15
00001096                           100  
00001096                           101              * Input
00001096  43F9 00003BEE            102              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
0000109C  103C 0002                103              MOVE.B  #2,D0                   * Ask user for input
000010A0  4E4F                     104              TRAP    #15
000010A2                           105              
000010A2                           106              * Error Checking (length)
000010A2  0C01 0000                107              CMPI.B  #0, D1                  * Check if input length <= 0
000010A6  6F00 0056                108              BLE     ERROR_2
000010AA  0C01 0008                109              CMPI.B  #8, D1                  * Check if input length > 8
000010AE  6E00 004E                110              BGT     ERROR_2
000010B2                           111              
000010B2                           112              * Conversion & Storage
000010B2  4EB9 0000113E            113              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010B8  0C07 0001                114              CMPI.B  #1, D7                  * Check for error
000010BC  6700 0040                115              BEQ     ERROR_2
000010C0  23C1 00003C42            116              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010C6                           117              
000010C6                           118              * Error Checking (start > end case)
000010C6  2439 00003C3E            119              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010CC  B282                     120              CMP.L   D2, D1                  * Compare starting and ending address
000010CE  6300 005E                121              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010D2                           122              
000010D2                           123              * Error Checking (Odd case)
000010D2  43F9 00003C42            124              LEA     E_ADDR_HX, A1           * Move the ending address
000010D8  4EB9 0000122C            125              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010DE  0C07 0001                126              CMPI.B  #1, D7                  * Check for an error flag
000010E2  6700 003A                127              BEQ     ERROR_4
000010E6                           128              
000010E6                           129              * Inputs are valid
000010E6  2A79 00003C3E            130              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010EC                           131              
000010EC  4E75                     132              RTS
000010EE                           133              
000010EE                           134  *---------------------------------------------------------------------------*
000010EE                           135  * ERROR_1: Address error (Invalid starting address)
000010EE                           136  *---------------------------------------------------------------------------*
000010EE                           137  ERROR_1
000010EE  43F9 00003B2D            138              LEA     ERRMSG_1, A1            * Load ERRMSG_1
000010F4  103C 000E                139              MOVE.B  #14, D0                 * Display ERRMSG_1
000010F8  4E4F                     140              TRAP    #15
000010FA  4EF8 1038                141              JMP     START_ADDR              * Jump to START_ADDR
000010FE                           142      
000010FE                           143  *---------------------------------------------------------------------------*
000010FE                           144  * ERROR_2: Address error (Invalid ending address)
000010FE                           145  *---------------------------------------------------------------------------*
000010FE                           146  ERROR_2
000010FE  43F9 00003B2D            147              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001104  103C 000E                148              MOVE.B  #14, D0                 * Display ERRMSG_1
00001108  4E4F                     149              TRAP    #15
0000110A  4EF8 108A                150              JMP     END_ADDR                * Jump to END_ADDR
0000110E                           151  
0000110E                           152  *---------------------------------------------------------------------------*
0000110E                           153  * ERROR_3: Address error (Odd starting address)
0000110E                           154  *---------------------------------------------------------------------------*
0000110E                           155  ERROR_3
0000110E  43F9 00003B4C            156              LEA     ERRMSG_3, A1
00001114  103C 000E                157              MOVE.B  #14, D0
00001118  4E4F                     158              TRAP    #15
0000111A  4EF8 1038                159              JMP     START_ADDR
0000111E                           160     
0000111E                           161  *---------------------------------------------------------------------------*
0000111E                           162  * ERROR_4: Address error (Odd ending address)
0000111E                           163  *---------------------------------------------------------------------------*         
0000111E                           164  ERROR_4
0000111E  43F9 00003B4C            165              LEA     ERRMSG_3, A1
00001124  103C 000E                166              MOVE.B  #14, D0
00001128  4E4F                     167              TRAP    #15
0000112A  4EF8 108A                168              JMP     END_ADDR
0000112E                           169            
0000112E                           170  *---------------------------------------------------------------------------*
0000112E                           171  * ERROR_3: Address error (Ending address is less than starting address)
0000112E                           172  *---------------------------------------------------------------------------*
0000112E                           173  ERROR_5
0000112E  43F9 00003B71            174              LEA     ERRMSG_5, A1
00001134  103C 000E                175              MOVE.B  #14, D0
00001138  4E4F                     176              TRAP    #15
0000113A  4EF8 108A                177              JMP     END_ADDR
0000113E                           178    
0000113E                           179  *---------------------------------------------------------------------------*
0000113E                           180  * ASCII2HEX: Convert ASCii to Hexadecimal
0000113E                           181  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000113E                           182  *---------------------------------------------------------------------------*
0000113E  4281                     183  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001140  4287                     184              CLR.L   D7                      * Set the error flag to 0
00001142  4282                     185              CLR.L   D2                      * Clear D2 for temp storage
00001144                           186              
00001144  1419                     187  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001146  0C02 0000                188              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000114A  6700 0058                189              BEQ     RETURN                  * If it's NULL, go to return
0000114E  0C02 0066                190              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001152  6E00 004C                191              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001156  0C02 0061                192              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000115A  6C00 0026                193              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000115E  0C02 0046                194              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001162  6E00 003C                195              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001166  0C02 0041                196              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000116A  6C00 001E                197              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000116E  0C02 0039                198              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001172  6E00 002C                199              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001176  0C02 0030                200              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000117A  6C00 0016                201              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000117E  6000 0020                202              BRA     ASC_ERR                 * Invalid input
00001182                           203  
00001182  0442 0057                204  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001186  6000 0012                205              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000118A                           206              
0000118A  0442 0037                207  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000118E  6000 000A                208              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
00001192                           209              
00001192  0442 0030                210  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
00001196  6000 0002                211              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119A                           212              
0000119A  E981                     213  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
0000119C  D202                     214              ADD.B   D2, D1                  * Add the converted input to D1
0000119E  60A4                     215              BRA     ASC2HXLP                * Loop
000011A0                           216  
000011A0  1E3C 0001                217  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011A4  4E75                     218  RETURN      RTS     
000011A6                           219  
000011A6                           220  *---------------------------------------------------------------------------*
000011A6                           221  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011A6                           222  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011A6                           223  *---------------------------------------------------------------------------*
000011A6  0C02 0008                224  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011AA  6700 000E                225              BEQ     HEX_LOOP
000011AE  4841                     226              SWAP    D1
000011B0  0C02 0002                227              CMPI.B  #2,D2
000011B4  6600 0004                228              BNE     HEX_LOOP
000011B8  E189                     229              LSL.L   #8,D1
000011BA                           230             
000011BA  E999                     231  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011BC  2601                     232              MOVE.L  D1, D3                  * Move D1 to D3
000011BE  0283 0000000F            233              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011C4  0C03 0009                234              CMPI.B  #9, D3                  * Compare te digit
000011C8  6E00 000A                235              BGT     HEX_CHAR              
000011CC  0603 0030                236              ADDI.B  #48,D3                  * Add 48 for numerical output
000011D0  6000 0006                237              BRA     HEX_CONT
000011D4                           238              
000011D4  0603 0037                239  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011D8                           240  
000011D8  12C3                     241  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011DA  5342                     242              SUBI    #1, D2                  * Decrement the size
000011DC  0C02 0000                243              CMPI.B  #0, D2                  * Check if D2 is 0
000011E0  66D8                     244              BNE     HEX_LOOP                * Loop
000011E2  12BC 0000                245              MOVE.B  #$0,(A1)                * Null terminator
000011E6  4E75                     246              RTS
000011E8                           247  *---------------------------------------------------------------------------*
000011E8                           248  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
000011E8                           249  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011E8                           250  *---------------------------------------------------------------------------*
000011E8                           251  HEX2ASCII2STACK
000011E8  0C02 0008                252              CMPI.B  #8, D2                  * Check to see if the size is long
000011EC  6700 000E                253              BEQ     STACK_HEX_LOOP
000011F0  4841                     254              SWAP    D1
000011F2  0C02 0002                255              CMPI.B  #2,D2
000011F6  6600 0004                256              BNE     STACK_HEX_LOOP
000011FA  E189                     257              LSL.L   #8,D1
000011FC                           258             
000011FC                           259  STACK_HEX_LOOP    
000011FC  E999                     260              ROL.L   #4, D1                  * Roll D1 to left
000011FE  2601                     261              MOVE.L  D1, D3                  * Move D1 to D3
00001200  0283 0000000F            262              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001206  0C03 0009                263              CMPI.B  #9, D3                  * Compare te digit
0000120A  6E00 000A                264              BGT     STACK_HEX_CHAR              
0000120E  0603 0030                265              ADDI.B  #48,D3                  * Add 48 for numerical output
00001212  6000 0006                266              BRA     STACK_HEX_CONT
00001216                           267              
00001216                           268  STACK_HEX_CHAR    
00001216  0603 0037                269              ADDI.B  #55,D3                  * Add 55 for character output
0000121A                           270  
0000121A                           271  STACK_HEX_CONT    
0000121A  6100 24B8                272              BSR     PUSH_STACK              *PLACE INTO STACK
0000121E  5342                     273              SUBI    #1, D2                  * Decrement the size
00001220  0C02 0000                274              CMPI.B  #0, D2                  * Check if D2 is 0
00001224  66D6                     275              BNE     STACK_HEX_LOOP                * Loop
00001226  12BC 0000                276              MOVE.B  #$0,(A1)                * Null terminator
0000122A  4E75                     277              RTS
0000122C                           278  
0000122C                           279  
0000122C                           280  *---------------------------------------------------------------------------*
0000122C                           281  * IS_ODD: Check whether the source address is odd
0000122C                           282  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000122C                           283  *---------------------------------------------------------------------------*
0000122C  4281                     284  IS_ODD      CLR.L   D1                      * Clear the result
0000122E  4287                     285              CLR.L   D7                      * Set the error flag to 0
00001230  2211                     286              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001232  82FC 0002                287              DIVU    #2, D1                  * Divide the result by 2
00001236  4841                     288              SWAP    D1                      * Swap remainder with quotient
00001238  0C01 0001                289              CMPI.B  #1, D1                  * Check for error
0000123C  6700 0004                290              BEQ     IS_ODD_ERR
00001240  4E75                     291              RTS
00001242                           292              
00001242  1E3C 0001                293  IS_ODD_ERR  MOVE.B  #1, D7
00001246  4E75                     294              RTS
00001248                           295  
00001248                           296  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
00001248                           297  * MAIN                    
00001248                           298  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
00001248                           299  * A5: Processing address
00001248                           300  *
00001248                           301  * D3: USED FOR PUSHING INTO STACK
00001248                           302  *     To push into stack => MOVE.W #DATA,D3 
00001248                           303  *                           BSR    PUSH_STACK
00001248                           304  *     To print stack     => BSR    PRINT_STACK 
00001248                           305  *     To clear stack     => BSR    CLEAR_STACK
00001248                           306  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
00001248                           307  MAIN        
00001248                           308              *initialize stack pointer
00001248  33FC 0000 00003FF6       309              MOVE.W  #0,COUNTER
00001250  347C 7000                310              MOVEA.W #STACK,A2
00001254  163C 0020                311              MOVE.B  #' ',D3
00001258  6100 247A                312              BSR     PUSH_STACK
0000125C  6100 2476                313              BSR     PUSH_STACK
00001260  6100 2472                314              BSR     PUSH_STACK
00001264                           315              
00001264                           316              * clear registers for temp storage
00001264  4280                     317              CLR.L   D0                   
00001266  4281                     318              CLR.L   D1                   
00001268  227C 00000000            319              MOVEA.L #0, A1                
0000126E                           320              
0000126E  220D                     321              MOVE.L  A5,D1                   * check to see if the address is fully read
00001270  23CD 00003C3E            322              MOVE.L  A5,S_ADDR_HX
00001276  B2B9 00003C42            323              CMP.L   E_ADDR_HX,D1
0000127C  6C00 1B76                324              BGE     REPEAT                  * go to repeat for user action
00001280                           325  
00001280  43F9 00003C99            326              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001286  143C 0008                327              MOVE.B  #8,D2                   * set the output size
0000128A  4EB8 11A6                328              JSR     HEX2ASCII               
0000128E  43F9 00003C99            329              LEA     TMPOUTPUT,A1
00001294  103C 000E                330              MOVE.B  #14,D0
00001298  4E4F                     331              TRAP    #15
0000129A                           332              
0000129A  4285                     333              CLR.L    D5                      * clear the processing data
0000129C  3A1D                     334              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
0000129E                           335                                               * advance the current instruction pointer to the next
0000129E                           336                                               * instruction in memory
0000129E                           337  *----------------------------------------*
0000129E                           338  * Registers          
0000129E                           339  * [D1] - COPY OF D5
0000129E                           340  * [D5] - DATA TO BE PROCESSED
0000129E                           341  * [D6] - COUNTER FOR LINES PROCESSED
0000129E                           342  *
0000129E                           343  * [D4]      - ERROR FLAG BEFORE PRINTING
0000129E                           344  * [STACK]   - PRINTS PROCESS DATA
0000129E                           345  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
0000129E                           346  *
0000129E                           347  * [A1] - USED FOR JUMPING/PRINTING
0000129E                           348  *
0000129E                           349  *----------------------------------------*
0000129E                           350  
0000129E                           351              
0000129E                           352              *Processing the first 4 most significant bits 
0000129E  2205                     353              MOVE.L  D5,D1                    * copy the current processing data to D1
000012A0  143C 000C                354              MOVE.B  #12,D2                   * shift to right by 12 bits
000012A4  E469                     355              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012A6  C2FC 0006                356              MULU    #6,D1                    * form offset
000012AA  43F9 00001318            357              LEA     JMPTABLE,A1              * index into table
000012B0  4EB1 1000                358              JSR     0(A1,D1)                 * jump indirect with index
000012B4                           359              
000012B4                           360              *SECURED EA*
000012B4  B83C 0001                361              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012B8  6600 0012                362              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012BC  6100 01E8                363              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012C0  6100 247E                364              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012C4  183C 0000                365              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012C8  6000 0022                366              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012CC                           367             
000012CC                           368  OUTPUT_PROCESSED_DATA       
000012CC  163C 000D                369              MOVE.B  #$D,D3                  *carriage return
000012D0  6100 2402                370              BSR     PUSH_STACK
000012D4  163C 000A                371              MOVE.B  #$A,D3                  *new line feed
000012D8  6100 23FA                372              BSR     PUSH_STACK
000012DC  163C 0000                373              MOVE.B  #$0,D3                  *null
000012E0  6100 23F2                374              BSR     PUSH_STACK
000012E4                           375       
000012E4  6100 23CA                376              BSR     PRINT_QUEUE
000012E8  183C 0000                377              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012EC                           378  DISPLAY_30_LINES
000012EC                           379              * display 30 lines per page
000012EC  5206                     380              ADDI.B  #1,D6
000012EE  0C06 001E                381              CMPI.B  #30,D6
000012F2  6C00 0006                382              BGE     NEXTLINES
000012F6  6000 FF50                383              BRA     MAIN
000012FA                           384            
000012FA                           385  *---------------------------------------------------------------------------*
000012FA                           386  * NEXTLINES: receive input from user to print the next 30 lines
000012FA                           387  *---------------------------------------------------------------------------*  
000012FA  4206                     388  NEXTLINES   CLR.B   D6
000012FC  43F9 00003A95            389              LEA     DISP_NEXT,A1
00001302  103C 000E                390              MOVE.B  #14,D0
00001306  4E4F                     391              TRAP    #15
00001308  43F9 00003C49            392              LEA     TMPINPUT,A1
0000130E  103C 0002                393              MOVE.B  #2,D0
00001312  4E4F                     394              TRAP    #15
00001314  4EF8 1248                395              JMP     MAIN
00001318                           396    
00001318                           397  *---------------------------------------------------------------------------*
00001318                           398  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001318                           399  *---------------------------------------------------------------------------*  
00001318  4EF9 00001378            400  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST
0000131E  4EF9 0000159E            401              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001324  4EF9 0000160C            402              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000132A  4EF9 0000170A            403              JMP     OP0011  * MOVE.W/MOVEA.W
00001330  4EF9 00001806            404              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS
00001336  4EF9 000019A0            405              JMP     OP0101  * ADDQ  
0000133C  4EF9 00001A1C            406              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)
00001342  4EF9 00001AAA            407              JMP     OP0111  * MOVEQ (unassigned)
00001348  4EF9 00001AAE            408              JMP     OP1000  * DIVS
0000134E  4EF9 00001AEA            409              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001354  4EF9 00001EA6            410              JMP     OP1010  * Unassigned 
0000135A  4EF9 00001EAA            411              JMP     OP1011  * CMP/EOR/CMPA
00001360  4EF9 00001FA6            412              JMP     OP1100  * MULS/AND                                      *FINISHED "AND" - JOSEPH
00001366  4EF9 000022F8            413              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000136C  4EF9 000026D4            414              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001372  4EF9 00002982            415              JMP     OP1111  * Special/Reserved
00001378                           416              
00001378                           417  *---------------------------------------------------------------------------*
00001378                           418  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
00001378                           419  *---------------------------------------------------------------------------*           
00001378                           420  OP0000                                                                                  
00001378  4281                     421              CLR.L   D1          * to temporarily store the address to process
0000137A  4280                     422              CLR.L   D0  
0000137C  4284                     423              CLR.L   D4                 
0000137E  227C 00000000            424              MOVEA.L #0, A1                
00001384                           425              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001384                           426              * Check if bit 11,10,9,8 are 0000)
00001384  2205                     427              MOVE.L  D5,D1
00001386  0281 00000F00            428              ANDI.L  #$0F00,D1
0000138C  0C81 00000000            429              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
00001392  6700 01B4                430              BEQ     OP_ORI
00001396                           431  
00001396                           432              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
00001396                           433              * check if bit 11,10,9,8 are 1100
00001396  4281                     434              CLR.L   D1
00001398  2205                     435              MOVE.L  D5,D1
0000139A  0281 00000F00            436              ANDI.L  #$0F00,D1
000013A0  0C81 00000C00            437              CMPI.L  #$0C00,D1
000013A6  6700 014A                438              BEQ     OP_CMPI
000013AA                           439              
000013AA                           440              * check for SUBI
000013AA  4281                     441              CLR.L   D1
000013AC  2205                     442              MOVE.L  D5,D1
000013AE  0281 00000F00            443              ANDI.L  #$0F00,D1
000013B4  0C81 00000400            444              CMPI.L  #$0400,D1
000013BA  6700 0094                445              BEQ     OP_SUBI
000013BE                           446              
000013BE                           447              * check for EORI
000013BE  4281                     448              CLR.L   D1
000013C0  2205                     449              MOVE.L  D5,D1
000013C2  0281 00000F00            450              ANDI.L  #$0F00,D1
000013C8  0C81 00000A00            451              CMPI.L  #$0A00,D1
000013CE  6700 002A                452              BEQ     OP_EORI
000013D2                           453              
000013D2                           454              * check for BTST
000013D2  4281                     455              CLR.L   D1
000013D4  2205                     456              MOVE.L  D5,D1
000013D6  EA99                     457              ROR.L   #5,D1
000013D8  0281 00000008            458              ANDI.L  #$8,D1
000013DE  0C01 0008                459              CMPI.B  #8,D1
000013E2  6700 0008                460              BEQ     OP_BTST
000013E6                           461  
000013E6                           462              * OP0000 series other than ORI/CMPI/BTST/EORI
000013E6  4EF9 000014A6            463              JMP     OP_DATA
000013EC                           464              
000013EC                           465  *---------------------------------------------------------------------------*
000013EC                           466  * OP_BTST: display BTST
000013EC                           467  *---------------------------------------------------------------------------* 
000013EC  43F9 00003D22            468  OP_BTST     LEA     DISP_BTST,A1
000013F2  103C 000E                469              MOVE.B  #14,D0
000013F6  4E4F                     470              TRAP    #15
000013F8  4E75                     471              RTS
000013FA                           472  
000013FA                           473  *---------------------------------------------------------------------------*
000013FA                           474  * OP_EORI: decode and display EORI
000013FA                           475  *---------------------------------------------------------------------------* 
000013FA                           476  OP_EORI
000013FA  4281                     477              CLR.L   D1
000013FC  4284                     478              CLR.L   D4
000013FE  2205                     479              MOVE.L  D5,D1
00001400  EC99                     480              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001402  0C01 0000                481              CMPI.B  #0,D1
00001406  6700 0012                482              BEQ     OP_EORI_B    * size is byte
0000140A  0C01 0001                483              CMPI.B  #1,D1
0000140E  6700 001C                484              BEQ     OP_EORI_W    * size is word
00001412  0C01 0002                485              CMPI.B  #2,D1
00001416  6700 0026                486              BEQ     OP_EORI_L    * size is long
0000141A                           487  
0000141A                           488  OP_EORI_B    * size is byte    
0000141A  183C 0000                489              MOVE.B  #0,D4
0000141E  43F9 00003D04            490              LEA     DISP_EORI_B,A1
00001424  103C 000E                491              MOVE.B  #14,D0
00001428  4E4F                     492              TRAP    #15
0000142A  4E75                     493              RTS
0000142C                           494              
0000142C                           495  OP_EORI_W    * size is word
0000142C  183C 0001                496              MOVE.B  #1,D4
00001430  43F9 00003D0E            497              LEA     DISP_EORI_W,A1
00001436  103C 000E                498              MOVE.B  #14,D0
0000143A  4E4F                     499              TRAP    #15
0000143C  4E75                     500              RTS
0000143E                           501              
0000143E                           502  OP_EORI_L    * size is long
0000143E  183C 0002                503              MOVE.B  #2,D4
00001442  43F9 00003D18            504              LEA     DISP_EORI_L,A1
00001448  103C 000E                505              MOVE.B  #14,D0
0000144C  4E4F                     506              TRAP    #15
0000144E  4E75                     507              RTS
00001450                           508              
00001450                           509  *---------------------------------------------------------------------------*
00001450                           510  * OP_SUBI: decode SUBI.B/.W/.L
00001450                           511  *---------------------------------------------------------------------------* 
00001450                           512  OP_SUBI
00001450  4281                     513              CLR.L   D1
00001452  4284                     514              CLR.L   D4
00001454  2205                     515              MOVE.L  D5,D1
00001456  EC99                     516              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001458  0C01 0000                517              CMPI.B  #0,D1
0000145C  6700 0012                518              BEQ     OP_SUBI_B    * size is byte
00001460  0C01 0001                519              CMPI.B  #1,D1
00001464  6700 001C                520              BEQ     OP_SUBI_W    * size is word
00001468  0C01 0002                521              CMPI.B  #2,D1
0000146C  6700 0026                522              BEQ     OP_SUBI_L    * size is long
00001470                           523  
00001470                           524  OP_SUBI_B    * size is byte    
00001470  183C 0000                525              MOVE.B  #0,D4
00001474  43F9 00003E10            526              LEA     DISP_SUBI_B,A1
0000147A  103C 000E                527              MOVE.B  #14,D0
0000147E  4E4F                     528              TRAP    #15
00001480  4E75                     529              RTS
00001482                           530              
00001482                           531  OP_SUBI_W    * size is word
00001482  183C 0001                532              MOVE.B  #1,D4
00001486  43F9 00003E1A            533              LEA     DISP_SUBI_W,A1
0000148C  103C 000E                534              MOVE.B  #14,D0
00001490  4E4F                     535              TRAP    #15
00001492  4E75                     536              RTS
00001494                           537              
00001494                           538  OP_SUBI_L    * size is long
00001494  183C 0002                539              MOVE.B  #2,D4
00001498  43F9 00003E24            540              LEA     DISP_SUBI_L,A1
0000149E  103C 000E                541              MOVE.B  #14,D0
000014A2  4E4F                     542              TRAP    #15
000014A4  4E75                     543              RTS
000014A6                           544              
000014A6                           545  *---------------------------------------------------------------------------*
000014A6                           546  * OP_DATA : unidentified opcode
000014A6                           547  *---------------------------------------------------------------------------* 
000014A6                           548  OP_DATA
000014A6  4280                     549              CLR.L   D0                   
000014A8  4281                     550              CLR.L   D1     
000014AA  4284                     551              CLR.L   D4                    
000014AC  227C 00000000            552              MOVEA.L #0, A1             
000014B2  4287                     553              CLR.L   D7
000014B4  1E3C 0001                554              MOVE.B  #1,D7                   * error flag is true
000014B8                           555              
000014B8  43F9 00003D48            556              LEA     DISP_DATA,A1
000014BE  103C 000E                557              MOVE.B  #14,D0
000014C2  4E4F                     558              TRAP    #15
000014C4                           559              
000014C4  4EF9 000014CA            560              JMP     EA_DATA
000014CA                           561             
000014CA                           562             
000014CA                           563  *---------------------------------------------------------------------------*
000014CA                           564  * EA_DATA
000014CA                           565  *---------------------------------------------------------------------------*       
000014CA  43F9 00003C99            566  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000014D0  2205                     567              MOVE.L  D5,D1           * transfer the processing data to D1
000014D2  7404                     568              MOVE.L  #4,D2           * set to word size
000014D4  4EB8 11A6                569              JSR     HEX2ASCII       * prepare output in ascii
000014D8  43F9 00003FBB            570              LEA     DISP_HEX,A1     * display $ symbol
000014DE  103C 000E                571              MOVE.B  #14,D0      
000014E2  4E4F                     572              TRAP    #15
000014E4  43F9 00003C99            573              LEA     TMPOUTPUT,A1    * display with a new line
000014EA  103C 000D                574              MOVE.B  #13,D0
000014EE  4E4F                     575              TRAP    #15
000014F0                           576  
000014F0  4E75                     577              RTS
000014F2                           578              
000014F2                           579  *---------------------------------------------------------------------------*
000014F2                           580  * OP_CMPI : decode CMPI and its size
000014F2                           581  *---------------------------------------------------------------------------*          
000014F2                           582  OP_CMPI
000014F2  4281                     583              CLR.L   D1
000014F4  4284                     584              CLR.L   D4
000014F6  2205                     585              MOVE.L  D5,D1
000014F8  EC99                     586              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000014FA  0C01 0000                587              CMPI.B  #0,D1
000014FE  6700 0012                588              BEQ     OP_CMPI_B    * size is byte
00001502  0C01 0001                589              CMPI.B  #1,D1
00001506  6700 001C                590              BEQ     OP_CMPI_W    * size is word
0000150A  0C01 0002                591              CMPI.B  #2,D1
0000150E  6700 0026                592              BEQ     OP_CMPI_L    * size is long
00001512                           593  
00001512                           594  OP_CMPI_B    * size is byte    
00001512  183C 0000                595              MOVE.B  #0,D4
00001516  43F9 00003D2A            596              LEA     DISP_CMPI_B,A1
0000151C  103C 000E                597              MOVE.B  #14,D0
00001520  4E4F                     598              TRAP    #15
00001522  4E75                     599              RTS
00001524                           600              
00001524                           601  OP_CMPI_W    * size is word
00001524  183C 0001                602              MOVE.B  #1,D4
00001528  43F9 00003D34            603              LEA     DISP_CMPI_W,A1
0000152E  103C 000E                604              MOVE.B  #14,D0
00001532  4E4F                     605              TRAP    #15
00001534  4E75                     606              RTS
00001536                           607              
00001536                           608  OP_CMPI_L    * size is long
00001536  183C 0002                609              MOVE.B  #2,D4
0000153A  43F9 00003D3E            610              LEA     DISP_CMPI_L,A1
00001540  103C 000E                611              MOVE.B  #14,D0
00001544  4E4F                     612              TRAP    #15
00001546  4E75                     613              RTS
00001548                           614   
00001548                           615  *---------------------------------------------------------------------------*
00001548                           616  * OP_ORI : decode ORI and its size
00001548                           617  *---------------------------------------------------------------------------* 
00001548                           618  OP_ORI      
00001548  4281                     619              CLR.L   D1
0000154A  4284                     620              CLR.L   D4
0000154C  2205                     621              MOVE.L  D5,D1
0000154E  EC99                     622              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001550  0C01 0000                623              CMPI.B  #0,D1
00001554  6700 0012                624              BEQ     OP_ORI_B    * size is byte
00001558  0C01 0001                625              CMPI.B  #1,D1
0000155C  6700 001C                626              BEQ     OP_ORI_W    * size is word
00001560  0C01 0002                627              CMPI.B  #2,D1
00001564  6700 0026                628              BEQ     OP_ORI_L    * size is long
00001568                           629  
00001568                           630  OP_ORI_B    * size is byte    
00001568  183C 0000                631              MOVE.B  #0,D4
0000156C  43F9 00003CE9            632              LEA     DISP_ORI_B,A1
00001572  103C 000E                633              MOVE.B  #14,D0
00001576  4E4F                     634              TRAP    #15
00001578  4E75                     635              RTS
0000157A                           636              
0000157A                           637  OP_ORI_W    * size is word
0000157A  183C 0001                638              MOVE.B  #1,D4
0000157E  43F9 00003CF2            639              LEA     DISP_ORI_W,A1
00001584  103C 000E                640              MOVE.B  #14,D0
00001588  4E4F                     641              TRAP    #15
0000158A  4E75                     642              RTS
0000158C                           643              
0000158C                           644  OP_ORI_L    * size is long
0000158C  183C 0002                645              MOVE.B  #2,D4
00001590  43F9 00003CFB            646              LEA     DISP_ORI_L,A1
00001596  103C 000E                647              MOVE.B  #14,D0
0000159A  4E4F                     648              TRAP    #15
0000159C  4E75                     649              RTS
0000159E                           650          
0000159E                           651  *---------------------------------------------------------------------------*
0000159E                           652  * OP0001: MOVE.B
0000159E                           653  *---------------------------------------------------------------------------*
0000159E                           654  OP0001      
0000159E  4EF9 000015A4            655              JMP     OP_MOVE_B   * display MOVE.B
000015A4                           656              
000015A4                           657  *---------------------------------------------------------------------------*
000015A4                           658  * OP_MOVE_B: display MOVE_B and proceed to EA
000015A4                           659  *---------------------------------------------------------------------------*
000015A4                           660  OP_MOVE_B                                                                       
000015A4                           661             
000015A4                           662             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015A4  13FC 0082 00003FFA       663             MOVE.B   #$82,DEST_REGISTER_FORMAT
000015AC  13FC 0000 00003FFB       664             MOVE.B   #$00,SRC_REGISTER_FORMAT
000015B4                           665             
000015B4                           666             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015B4  13FC 00B9 00003FFD       667             MOVE.B   #$B9,GET_DST_START_END
000015BC  13FC 0020 00003FFE       668             MOVE.B   #$20,GET_SRC_START_END
000015C4                           669             
000015C4                           670              *CLEAR D3
000015C4  4283                     671              CLR.L   D3
000015C6                           672              *LOAD STACK WITH THIS OPMODE
000015C6  6100 210C                673              BSR     PUSH_STACK
000015CA  163C 004D                674              MOVE.B  #'M',D3
000015CE  6100 2104                675              BSR     PUSH_STACK
000015D2  163C 004F                676              MOVE.B  #'O',D3
000015D6  6100 20FC                677              BSR     PUSH_STACK
000015DA  163C 0056                678              MOVE.B  #'V',D3
000015DE  6100 20F4                679              BSR     PUSH_STACK
000015E2  163C 0045                680              MOVE.B  #'E',D3
000015E6  6100 20EC                681              BSR     PUSH_STACK
000015EA  163C 002E                682              MOVE.B  #'.',D3
000015EE  6100 20E4                683              BSR     PUSH_STACK
000015F2  163C 0042                684              MOVE.B  #'B',D3
000015F6  6100 20DC                685              BSR     PUSH_STACK
000015FA                           686              
000015FA  6100 183A                687              BSR     GET_EA_EA_SRC
000015FE  163C 002C                688              MOVE.B  #',',D3
00001602  6100 20D0                689              BSR     PUSH_STACK
00001606  6100 1C5E                690              BSR     GET_EA_EA_DEST
0000160A                           691              
0000160A  4E75                     692              RTS
0000160C                           693              
0000160C                           694             
0000160C                           695  *---------------------------------------------------------------------------*
0000160C                           696  * OP0010: decode MOVE.L/MOVEA.L
0000160C                           697  *---------------------------------------------------------------------------*
0000160C                           698  OP0010      
0000160C  183C 0002                699              MOVE.B  #2,D4
00001610  4280                     700              CLR.L   D0                     
00001612  4281                     701              CLR.L   D1                      
00001614  227C 00000000            702              MOVEA.L #0, A1                 
0000161A                           703              
0000161A  2205                     704              MOVE.L  D5,D1
0000161C  EA99                     705              ROR.L   #5,D1
0000161E  0281 0000000E            706              ANDI.L  #$E,D1
00001624  0C01 0002                707              CMPI.B  #2,D1
00001628  6700 0070                708              BEQ     OP_MOVEA_L
0000162C                           709  
0000162C  4EF9 00001632            710              JMP     OP_MOVE_L
00001632                           711             
00001632                           712  
00001632                           713  *---------------------------------------------------------------------------*
00001632                           714  * OP_MOVE_L: display MOVE_L and proceed to EA
00001632                           715  *---------------------------------------------------------------------------*
00001632                           716  OP_MOVE_L   
00001632                           717             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001632  13FC 0082 00003FFA       718             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000163A  13FC 0000 00003FFB       719             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001642                           720             
00001642                           721             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001642  13FC 00B9 00003FFD       722             MOVE.B   #$B9,GET_DST_START_END
0000164A  13FC 0020 00003FFE       723             MOVE.B   #$20,GET_SRC_START_END
00001652                           724             
00001652                           725              *CLEAR D3
00001652  4283                     726              CLR.L   D3
00001654                           727              *LOAD STACK WITH THIS OPMODE
00001654  6100 207E                728              BSR     PUSH_STACK
00001658  163C 004D                729              MOVE.B  #'M',D3
0000165C  6100 2076                730              BSR     PUSH_STACK
00001660  163C 004F                731              MOVE.B  #'O',D3
00001664  6100 206E                732              BSR     PUSH_STACK
00001668  163C 0056                733              MOVE.B  #'V',D3
0000166C  6100 2066                734              BSR     PUSH_STACK
00001670  163C 0045                735              MOVE.B  #'E',D3
00001674  6100 205E                736              BSR     PUSH_STACK
00001678  163C 002E                737              MOVE.B  #'.',D3
0000167C  6100 2056                738              BSR     PUSH_STACK
00001680  163C 004C                739              MOVE.B  #'L',D3
00001684  6100 204E                740              BSR     PUSH_STACK
00001688                           741              
00001688  6100 17AC                742              BSR     GET_EA_EA_SRC
0000168C  163C 002C                743              MOVE.B  #',',D3
00001690  6100 2042                744              BSR     PUSH_STACK
00001694  6100 1BD0                745              BSR     GET_EA_EA_DEST
00001698                           746              
00001698  4E75                     747              RTS
0000169A                           748  
0000169A                           749  
0000169A                           750  *---------------------------------------------------------------------------*
0000169A                           751  * OP_MOVEA_L: display MOVEA_L and proceed to EA
0000169A                           752  *---------------------------------------------------------------------------*
0000169A                           753  OP_MOVEA_L 
0000169A                           754             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000169A  13FC 00FD 00003FFA       755             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000016A2  13FC 0000 00003FFB       756             MOVE.B   #$00,SRC_REGISTER_FORMAT
000016AA                           757             
000016AA                           758             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000016AA  13FC 00B9 00003FFD       759             MOVE.B   #$B9,GET_DST_START_END
000016B2  13FC 0020 00003FFE       760             MOVE.B   #$20,GET_SRC_START_END
000016BA                           761             
000016BA                           762              *CLEAR D3
000016BA  4283                     763              CLR.L   D3
000016BC                           764              *LOAD STACK WITH THIS OPMODE
000016BC  6100 2016                765              BSR     PUSH_STACK
000016C0  163C 004D                766              MOVE.B  #'M',D3
000016C4  6100 200E                767              BSR     PUSH_STACK
000016C8  163C 004F                768              MOVE.B  #'O',D3
000016CC  6100 2006                769              BSR     PUSH_STACK
000016D0  163C 0056                770              MOVE.B  #'V',D3
000016D4  6100 1FFE                771              BSR     PUSH_STACK
000016D8  163C 0045                772              MOVE.B  #'E',D3
000016DC  6100 1FF6                773              BSR     PUSH_STACK           
000016E0  163C 0041                774              MOVE.B  #'A',D3
000016E4  6100 1FEE                775              BSR     PUSH_STACK
000016E8  163C 002E                776              MOVE.B  #'.',D3
000016EC  6100 1FE6                777              BSR     PUSH_STACK
000016F0  163C 004C                778              MOVE.B  #'L',D3
000016F4  6100 1FDE                779              BSR     PUSH_STACK
000016F8                           780              
000016F8  6100 173C                781              BSR     GET_EA_EA_SRC
000016FC  163C 002C                782              MOVE.B  #',',D3
00001700  6100 1FD2                783              BSR     PUSH_STACK
00001704  6100 1B60                784              BSR     GET_EA_EA_DEST
00001708                           785              
00001708  4E75                     786              RTS
0000170A                           787  
0000170A                           788              
0000170A                           789  *---------------------------------------------------------------------------*
0000170A                           790  * OP0011: decode MOVE.W/MOVEA.W
0000170A                           791  *---------------------------------------------------------------------------*
0000170A                           792  OP0011      
0000170A  4280                     793              CLR.L   D0                      
0000170C  4281                     794              CLR.L   D1  
0000170E  4284                     795              CLR.L   D4                   
00001710  227C 00000000            796              MOVEA.L #0, A1 
00001716                           797                
00001716  2205                     798              MOVE.L  D5,D1
00001718  EC99                     799              ROR.L   #6,D1
0000171A  0281 00000007            800              ANDI.L  #$07,D1
00001720  0C01 0001                801              CMPI.B  #1,D1
00001724  6700 0070                802              BEQ     OP_MOVEA_W
00001728                           803              
00001728  4EF9 0000172E            804              JMP     OP_MOVE_W
0000172E                           805            
0000172E                           806  *---------------------------------------------------------------------------*
0000172E                           807  * OP_MOVE_W: display MOVE_W and proceed to EA
0000172E                           808  *---------------------------------------------------------------------------*
0000172E                           809  OP_MOVE_W   
0000172E                           810             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000172E  13FC 0082 00003FFA       811             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001736  13FC 0000 00003FFB       812             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000173E                           813             
0000173E                           814             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000173E  13FC 00B9 00003FFD       815             MOVE.B   #$B9,GET_DST_START_END
00001746  13FC 0020 00003FFE       816             MOVE.B   #$20,GET_SRC_START_END
0000174E                           817             
0000174E                           818              *CLEAR D3
0000174E  4283                     819              CLR.L   D3
00001750                           820              *LOAD STACK WITH THIS OPMODE
00001750  6100 1F82                821              BSR     PUSH_STACK
00001754  163C 004D                822              MOVE.B  #'M',D3
00001758  6100 1F7A                823              BSR     PUSH_STACK
0000175C  163C 004F                824              MOVE.B  #'O',D3
00001760  6100 1F72                825              BSR     PUSH_STACK
00001764  163C 0056                826              MOVE.B  #'V',D3
00001768  6100 1F6A                827              BSR     PUSH_STACK
0000176C  163C 0045                828              MOVE.B  #'E',D3
00001770  6100 1F62                829              BSR     PUSH_STACK
00001774  163C 002E                830              MOVE.B  #'.',D3
00001778  6100 1F5A                831              BSR     PUSH_STACK
0000177C  163C 0057                832              MOVE.B  #'W',D3
00001780  6100 1F52                833              BSR     PUSH_STACK
00001784                           834              
00001784  6100 16B0                835              BSR     GET_EA_EA_SRC
00001788  163C 002C                836              MOVE.B  #',',D3
0000178C  6100 1F46                837              BSR     PUSH_STACK
00001790  6100 1AD4                838              BSR     GET_EA_EA_DEST
00001794                           839              
00001794  4E75                     840              RTS
00001796                           841  
00001796                           842  *---------------------------------------------------------------------------*
00001796                           843  * OP_MOVEA_W: display MOVEA and proceed to EA
00001796                           844  *---------------------------------------------------------------------------*
00001796                           845  OP_MOVEA_W 
00001796                           846             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001796  13FC 00FD 00003FFA       847             MOVE.B   #$FD,DEST_REGISTER_FORMAT
0000179E  13FC 0000 00003FFB       848             MOVE.B   #$00,SRC_REGISTER_FORMAT
000017A6                           849             
000017A6                           850             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017A6  13FC 00B9 00003FFD       851             MOVE.B   #$B9,GET_DST_START_END
000017AE  13FC 0020 00003FFE       852             MOVE.B   #$20,GET_SRC_START_END
000017B6                           853             
000017B6                           854              *CLEAR D3
000017B6  4283                     855              CLR.L   D3
000017B8                           856              *LOAD STACK WITH THIS OPMODE
000017B8  6100 1F1A                857              BSR     PUSH_STACK
000017BC  163C 004D                858              MOVE.B  #'M',D3
000017C0  6100 1F12                859              BSR     PUSH_STACK
000017C4  163C 004F                860              MOVE.B  #'O',D3
000017C8  6100 1F0A                861              BSR     PUSH_STACK
000017CC  163C 0056                862              MOVE.B  #'V',D3
000017D0  6100 1F02                863              BSR     PUSH_STACK
000017D4  163C 0045                864              MOVE.B  #'E',D3
000017D8  6100 1EFA                865              BSR     PUSH_STACK           
000017DC  163C 0041                866              MOVE.B  #'A',D3
000017E0  6100 1EF2                867              BSR     PUSH_STACK
000017E4  163C 002E                868              MOVE.B  #'.',D3
000017E8  6100 1EEA                869              BSR     PUSH_STACK
000017EC  163C 0057                870              MOVE.B  #'W',D3
000017F0  6100 1EE2                871              BSR     PUSH_STACK
000017F4                           872              
000017F4  6100 1640                873              BSR     GET_EA_EA_SRC
000017F8  163C 002C                874              MOVE.B  #',',D3
000017FC  6100 1ED6                875              BSR     PUSH_STACK
00001800  6100 1A64                876              BSR     GET_EA_EA_DEST
00001804                           877            
00001804  4E75                     878              RTS
00001806                           879  *---------------------------------------------------------------------------*
00001806                           880  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001806                           881  *---------------------------------------------------------------------------*
00001806                           882  OP0100
00001806  4280                     883              CLR.L   D0                      
00001808  4281                     884              CLR.L   D1  
0000180A  4284                     885              CLR.L   D4                      
0000180C  227C 00000000            886              MOVEA.L #0, A1                  
00001812  2205                     887              MOVE.L  D5,D1  
00001814                           888              
00001814                           889              * check for RTS
00001814  0C41 4E75                890              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001818  6700 0178                891              BEQ     OP_RTS
0000181C                           892              
0000181C                           893              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
0000181C  4281                     894              CLR.L   D1 
0000181E  2205                     895              MOVE.L  D5,D1  
00001820  0241 0F00                896              ANDI.W  #$0F00,D1
00001824  0C41 0E00                897              CMPI.W  #$0E00,D1
00001828  6700 0154                898              BEQ     OP_JSR
0000182C                           899  
0000182C                           900              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
0000182C  4281                     901              CLR.L   D1 
0000182E  2205                     902              MOVE.L  D5,D1  
00001830  0241 0F00                903              ANDI.W  #$0F00,D1
00001834  0C41 0400                904              CMPI.W  #$0400,D1
00001838  6700 0086                905              BEQ     OP_NEG
0000183C                           906              
0000183C                           907              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
0000183C  4281                     908              CLR.L   D1 
0000183E  2205                     909              MOVE.L  D5,D1  
00001840  0241 0F00                910              ANDI.W  #$0F00,D1
00001844  0C41 0600                911              CMPI.W  #$0600,D1
00001848  6700 00DE                912              BEQ     OP_NOT
0000184C                           913              
0000184C                           914              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
0000184C  4281                     915              CLR.L   D1 
0000184E  2205                     916              MOVE.L  D5,D1  
00001850  E099                     917              ROR.L   #8,D1
00001852  0C01 0001                918              CMPI.B  #1,D1
00001856  6700 0054                919              BEQ     OP_LEA
0000185A                           920              
0000185A                           921              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
0000185A  4281                     922              CLR.L   D1 
0000185C  2205                     923              MOVE.L  D5,D1  
0000185E  EB59                     924              ROL.W   #5,D1
00001860  0C01 0001                925              CMPI.B  #1,D1
00001864  6600 FC40                926              BNE     OP_DATA
00001868  E959                     927              ROL.W   #4,D1
0000186A  0C01 0001                928              CMPI.B  #1,D1
0000186E  6600 FC36                929              BNE     OP_DATA
00001872  E359                     930              ROL.W   #1,D1
00001874  0C01 0000                931              CMPI.B  #0,D1
00001878  6700 000E                932              BEQ     OP_MOVEM_W
0000187C  0C01 0001                933              CMPI.B  #1,D1
00001880  6700 0018                934              BEQ     OP_MOVEM_L
00001884  4EF8 14A6                935              JMP     OP_DATA
00001888                           936  
00001888                           937  *---------------------------------------------------------------------------*
00001888                           938  * OP_MOVEM_W: display MOVEM_W
00001888                           939  *---------------------------------------------------------------------------*    
00001888                           940  OP_MOVEM_W  
00001888  183C 0001                941              MOVE.B  #1,D4
0000188C  43F9 00003DB9            942              LEA     DISP_MOVEM_W,A1
00001892  103C 000E                943              MOVE.B  #14,D0
00001896  4E4F                     944              TRAP    #15
00001898  4E75                     945              RTS
0000189A                           946  
0000189A                           947  *---------------------------------------------------------------------------*
0000189A                           948  * OP_MOVEM_L: display MOVEM_L
0000189A                           949  *---------------------------------------------------------------------------*
0000189A                           950  OP_MOVEM_L  
0000189A  183C 0002                951              MOVE.B  #2,D4
0000189E  43F9 00003DC4            952              LEA     DISP_MOVEM_L,A1
000018A4  103C 000E                953              MOVE.B  #14,D0
000018A8  4E4F                     954              TRAP    #15
000018AA  4E75                     955              RTS
000018AC                           956     
000018AC                           957  *---------------------------------------------------------------------------*
000018AC                           958  * OP_LEA: decode and display LEA
000018AC                           959  *---------------------------------------------------------------------------*
000018AC                           960  OP_LEA      
000018AC  43F9 00003DB2            961              LEA     DISP_LEA,A1
000018B2  103C 000E                962              MOVE.B  #14,D0
000018B6  4E4F                     963              TRAP    #15
000018B8  4EF9 000029C0            964              JMP     EA_MOVEA
000018BE                           965  
000018BE  4E75                     966              RTS
000018C0                           967  
000018C0                           968  *---------------------------------------------------------------------------*
000018C0                           969  * OP_NEG: decode and display NEG 
000018C0                           970  *---------------------------------------------------------------------------*
000018C0                           971  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
000018C0  4281                     972              CLR.L   D1
000018C2  4284                     973              CLR.L   D4
000018C4  2205                     974              MOVE.L  D5,D1
000018C6  EC99                     975              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000018C8  0C01 0000                976              CMPI.B  #0,D1
000018CC  6700 0012                977              BEQ     OP_NEG_B    * size is byte
000018D0  0C01 0001                978              CMPI.B  #1,D1
000018D4  6700 0022                979              BEQ     OP_NEG_W    * size is word
000018D8  0C01 0002                980              CMPI.B  #2,D1
000018DC  6700 0032                981              BEQ     OP_NEG_L    * size is long
000018E0                           982                         
000018E0                           983  OP_NEG_B    * size is byte   
000018E0  183C 0000                984              MOVE.B  #0,D4 
000018E4  43F9 00003D7C            985              LEA     DISP_NEG_B,A1
000018EA  103C 000E                986              MOVE.B  #14,D0
000018EE  4E4F                     987              TRAP    #15
000018F0                           988              
000018F0  4EB9 00002986            989              JSR     EA_NOSRC
000018F6  4E75                     990              RTS
000018F8                           991              
000018F8                           992  OP_NEG_W    * size is word
000018F8  183C 0001                993              MOVE.B  #1,D4
000018FC  43F9 00003D85            994              LEA     DISP_NEG_W,A1
00001902  103C 000E                995              MOVE.B  #14,D0
00001906  4E4F                     996              TRAP    #15
00001908  4EB9 00002986            997              JSR     EA_NOSRC
0000190E  4E75                     998              RTS
00001910                           999              
00001910                          1000  OP_NEG_L    * size is long
00001910  183C 0002               1001              MOVE.B  #2,D4
00001914  43F9 00003D8E           1002              LEA     DISP_NEG_L,A1
0000191A  103C 000E               1003              MOVE.B  #14,D0
0000191E  4E4F                    1004              TRAP    #15
00001920  4EB9 00002986           1005              JSR     EA_NOSRC
00001926                          1006              
00001926  4E75                    1007              RTS
00001928                          1008  
00001928                          1009  *---------------------------------------------------------------------------*
00001928                          1010  * OP_NOT: decode and display NOT 
00001928                          1011  *---------------------------------------------------------------------------*
00001928                          1012  OP_NOT
00001928  4281                    1013              CLR.L   D1
0000192A  4284                    1014              CLR.L   D4
0000192C  2205                    1015              MOVE.L  D5,D1
0000192E  EC99                    1016              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001930  0C01 0000               1017              CMPI.B  #0,D1
00001934  6700 0012               1018              BEQ     OP_NOT_B    * size is byte
00001938  0C01 0001               1019              CMPI.B  #1,D1
0000193C  6700 001C               1020              BEQ     OP_NOT_W    * size is word
00001940  0C01 0002               1021              CMPI.B  #2,D1
00001944  6700 0026               1022              BEQ     OP_NOT_L    * size is long
00001948                          1023                         
00001948                          1024  OP_NOT_B    * size is byte   
00001948  183C 0000               1025              MOVE.B  #0,D4 
0000194C  43F9 00003D97           1026              LEA     DISP_NOT_B,A1
00001952  103C 000E               1027              MOVE.B  #14,D0
00001956  4E4F                    1028              TRAP    #15
00001958  4E75                    1029              RTS
0000195A                          1030              
0000195A                          1031  OP_NOT_W    * size is word
0000195A  183C 0001               1032              MOVE.B  #1,D4
0000195E  43F9 00003DA0           1033              LEA     DISP_NOT_W,A1
00001964  103C 000E               1034              MOVE.B  #14,D0
00001968  4E4F                    1035              TRAP    #15
0000196A  4E75                    1036              RTS
0000196C                          1037              
0000196C                          1038  OP_NOT_L    * size is long
0000196C  183C 0002               1039              MOVE.B  #2,D4
00001970  43F9 00003DA9           1040              LEA     DISP_NOT_L,A1
00001976  103C 000E               1041              MOVE.B  #14,D0
0000197A  4E4F                    1042              TRAP    #15
0000197C  4E75                    1043              RTS
0000197E                          1044  
0000197E                          1045  *---------------------------------------------------------------------------*
0000197E                          1046  * OP_JSR: display JSR     
0000197E                          1047  *---------------------------------------------------------------------------*
0000197E  43F9 00003D75           1048  OP_JSR      LEA     DISP_JSR,A1
00001984  103C 000E               1049              MOVE.B  #14,D0
00001988  4E4F                    1050              TRAP    #15
0000198A  4EB9 00002986           1051              JSR     EA_NOSRC
00001990                          1052  
00001990  4E75                    1053              RTS
00001992                          1054  
00001992                          1055  *---------------------------------------------------------------------------*
00001992                          1056  * OP_RTS: display RTS     
00001992                          1057  *---------------------------------------------------------------------------* 
00001992  43F9 00003D6E           1058  OP_RTS      LEA     DISP_RTS,A1
00001998  103C 000E               1059              MOVE.B  #14,D0
0000199C  4E4F                    1060              TRAP    #15
0000199E  4E75                    1061              RTS
000019A0                          1062  
000019A0                          1063  *---------------------------------------------------------------------------*
000019A0                          1064  * OP0101: decode ADDQ
000019A0                          1065  *---------------------------------------------------------------------------* 
000019A0  4280                    1066  OP0101      CLR.L   D0               * clear registers for temp storage       
000019A2  4281                    1067              CLR.L   D1
000019A4  4284                    1068              CLR.L   D4                  
000019A6  227C 00000000           1069              MOVEA.L #0, A1  
000019AC                          1070              
000019AC  2205                    1071              MOVE.L  D5,D1           * copy the processing data 
000019AE  E089                    1072              LSR.L   #8,D1           * shift to right by 8 bits to check the value of bit 8
000019B0  0201 0001               1073              ANDI.B  #$1,D1          * mask all bits except the last 2 bits
000019B4  0C01 0000               1074              CMPI.B  #0,D1           * if the value is 0, it's ADDQ
000019B8  6700 0006               1075              BEQ     OP_ADDQ
000019BC                          1076              
000019BC  4EF8 14A6               1077              JMP     OP_DATA
000019C0                          1078       
000019C0  4281                    1079  OP_ADDQ     CLR.L   D1
000019C2  2205                    1080              MOVE.L  D5,D1
000019C4  EC99                    1081              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
000019C6  0281 00000003           1082              ANDI.L  #$3,D1
000019CC  0C01 0000               1083              CMPI.B  #0,D1
000019D0  6700 0014               1084              BEQ     OP_ADDQ_B    * size is byte
000019D4  0C41 0001               1085              CMPI.W  #1,D1
000019D8  6700 001E               1086              BEQ     OP_ADDQ_W    * size is word
000019DC  0C81 00000002           1087              CMPI.L  #2,D1
000019E2  6700 0026               1088              BEQ     OP_ADDQ_L    * size is long
000019E6                          1089              
000019E6                          1090  *---------------------------------------------------------------------------*
000019E6                          1091  * OP_ADDQ: display ADDQ
000019E6                          1092  *---------------------------------------------------------------------------*              
000019E6                          1093  OP_ADDQ_B    * size is byte   
000019E6  183C 0000               1094              MOVE.B  #0,D4 
000019EA  43F9 00003DCF           1095              LEA     DISP_ADDQ_B,A1
000019F0  103C 000E               1096              MOVE.B  #14,D0
000019F4  4E4F                    1097              TRAP    #15
000019F6  4E75                    1098              RTS
000019F8                          1099              
000019F8                          1100  OP_ADDQ_W    * size is word
000019F8  183C 0001               1101              MOVE.B  #1,D4
000019FC  43F9 00003DD9           1102              LEA     DISP_ADDQ_W,A1
00001A02  103C 000E               1103              MOVE.B  #14,D0
00001A06  4E4F                    1104              TRAP    #15
00001A08  4E75                    1105              RTS
00001A0A                          1106              
00001A0A                          1107  OP_ADDQ_L    * size is long
00001A0A  183C 0002               1108              MOVE.B  #2,D4
00001A0E  43F9 00003DE3           1109              LEA     DISP_ADDQ_L,A1
00001A14  103C 000E               1110              MOVE.B  #14,D0
00001A18  4E4F                    1111              TRAP    #15
00001A1A  4E75                    1112              RTS
00001A1C                          1113  
00001A1C                          1114  *---------------------------------------------------------------------------*
00001A1C                          1115  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001A1C                          1116  *---------------------------------------------------------------------------*              
00001A1C  4280                    1117  OP0110      CLR.L   D0                  
00001A1E  4281                    1118              CLR.L   D1   
00001A20  4284                    1119              CLR.L   D4                 
00001A22  227C 00000000           1120              MOVEA.L #0,A1
00001A28  2205                    1121              MOVE.L  D5, D1                
00001A2A  0281 000000FF           1122              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001A30  2205                    1123              MOVE.L  D5,D1                  
00001A32  0281 00000F00           1124              ANDI.L  #$0F00,D1
00001A38                          1125                 
00001A38  0C41 0000               1126              CMPI.W  #$0000,D1               * Check for BRA
00001A3C  6700 0050               1127              BEQ     OP_BRA                  
00001A40                          1128                          
00001A40  0C41 0D00               1129              CMPI.W  #$0D00,D1               * Check for BLT
00001A44  6700 0056               1130              BEQ     OP_BLT      
00001A48                          1131  
00001A48  0C41 0700               1132              CMPI.W  #$0700,D1               * Check for BEQ
00001A4C  6700 0032               1133              BEQ     OP_BEQ      
00001A50                          1134  
00001A50  0C41 0600               1135              CMPI.W  #$0600,D1               * Check for BNE
00001A54  6700 001C               1136              BEQ     OP_BNE  
00001A58                          1137              
00001A58  0C41 0200               1138              CMPI.W  #$0200,D1               * Check for BHI
00001A5C  6700 0006               1139              BEQ     OP_BHI
00001A60                          1140  
00001A60  4EF8 14A6               1141              JMP     OP_DATA
00001A64                          1142              
00001A64  43F9 00003F9E           1143  OP_BHI      LEA     DISP_BHI,A1             
00001A6A  103C 000E               1144              MOVE.B  #14,D0
00001A6E  4E4F                    1145              TRAP    #15
00001A70  4E75                    1146              RTS
00001A72                          1147  
00001A72  43F9 00003F97           1148  OP_BNE      LEA     DISP_BNE,A1             
00001A78  103C 000E               1149              MOVE.B  #14,D0
00001A7C  4E4F                    1150              TRAP    #15
00001A7E  4E75                    1151              RTS
00001A80                          1152  
00001A80  43F9 00003F90           1153  OP_BEQ      LEA     DISP_BEQ,A1             
00001A86  103C 000E               1154              MOVE.B  #14,D0
00001A8A  4E4F                    1155              TRAP    #15
00001A8C  4E75                    1156              RTS          
00001A8E                          1157                          
00001A8E  43F9 00003F82           1158  OP_BRA      LEA     DISP_BRA,A1             
00001A94  103C 000E               1159              MOVE.B  #14,D0
00001A98  4E4F                    1160              TRAP    #15
00001A9A  4E75                    1161              RTS
00001A9C                          1162              
00001A9C  43F9 00003F89           1163  OP_BLT      LEA     DISP_BLT,A1          
00001AA2  103C 000E               1164              MOVE.B  #14,D0
00001AA6  4E4F                    1165              TRAP    #15
00001AA8  4E75                    1166              RTS
00001AAA                          1167     
00001AAA                          1168  *---------------------------------------------------------------------------*
00001AAA                          1169  * OP0111 : MOVEQ not required
00001AAA                          1170  *---------------------------------------------------------------------------*           
00001AAA  4EF8 14A6               1171  OP0111      JMP     OP_DATA
00001AAE                          1172             
00001AAE                          1173  *---------------------------------------------------------------------------*
00001AAE                          1174  * OP1000 : decode DIVS
00001AAE                          1175  *---------------------------------------------------------------------------*           
00001AAE                          1176  OP1000      
00001AAE  4280                    1177              CLR.L   D0                
00001AB0  4281                    1178              CLR.L   D1   
00001AB2  4284                    1179              CLR.L   D4                
00001AB4  207C 00000000           1180              MOVEA.L #0, A0               
00001ABA  227C 00000000           1181              MOVEA.L #0, A1               
00001AC0                          1182              
00001AC0  2205                    1183              MOVE.L  D5,D1
00001AC2  EA89                    1184              LSR.L   #5,D1
00001AC4  0281 0000000E           1185              ANDI.L  #$E,D1
00001ACA                          1186    
00001ACA  0C01 000E               1187              CMPI.B  #$E,D1
00001ACE  6700 0006               1188              BEQ     OP_DIVS
00001AD2                          1189              
00001AD2  4EF8 14A6               1190              JMP     OP_DATA
00001AD6                          1191  
00001AD6                          1192  *---------------------------------------------------------------------------*
00001AD6                          1193  * OP_DIVS: display DIVS and proceed to EA
00001AD6                          1194  *---------------------------------------------------------------------------*  
00001AD6  43F9 00003DED           1195  OP_DIVS     LEA     DISP_DIVS,A1
00001ADC  103C 000E               1196              MOVE.B  #14,D0
00001AE0  4E4F                    1197              TRAP    #15
00001AE2  4EF9 0000299A           1198              JMP     EA_ARITH
00001AE8                          1199  
00001AE8  4E75                    1200              RTS
00001AEA                          1201              
00001AEA                          1202  *---------------------------------------------------------------------------*
00001AEA                          1203  * OP1001: decode SUB/SUBA
00001AEA                          1204  *---------------------------------------------------------------------------*      
00001AEA                          1205  OP1001      
00001AEA  4280                    1206              CLR.L   D0                  
00001AEC  4281                    1207              CLR.L   D1       
00001AEE  4284                    1208              CLR.L   D4                   
00001AF0  227C 00000000           1209              MOVEA.L #0, A1              
00001AF6  2205                    1210              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001AF8                          1211              
00001AF8                          1212              *CLEAR D3
00001AF8  4283                    1213              CLR.L   D3
00001AFA                          1214              
00001AFA                          1215              
00001AFA                          1216              
00001AFA                          1217              **INTEGRATING SUB.W/.L INTO THIS CODE**
00001AFA  2205                    1218              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001AFC                          1219              *BITS (INDEX 8) 
00001AFC                          1220              *0 = ADD.B/W/L <EA>,Dn
00001AFC                          1221              *1 = ADD.B/W/L Dn,<EA> 
00001AFC  EC99                    1222              ROR.L   #6,D1
00001AFE  0281 00000007           1223              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00001B04  0C81 00000007           1224              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00001B0A  6700 0010               1225              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00001B0E  0C81 00000003           1226              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00001B14  6700 0078               1227              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00001B18  6000 00E6               1228              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00001B1C                          1229              
00001B1C                          1230  OP1001_SUBA_L
00001B1C                          1231              *LOAD STACK WITH THIS OPMODE
00001B1C  6100 1BB6               1232              BSR     PUSH_STACK
00001B20  163C 0053               1233              MOVE.B  #'S',D3
00001B24  6100 1BAE               1234              BSR     PUSH_STACK
00001B28  163C 0055               1235              MOVE.B  #'U',D3
00001B2C  6100 1BA6               1236              BSR     PUSH_STACK
00001B30  163C 0042               1237              MOVE.B  #'B',D3
00001B34  6100 1B9E               1238              BSR     PUSH_STACK
00001B38  163C 0041               1239              MOVE.B  #'A',D3
00001B3C  6100 1B96               1240              BSR     PUSH_STACK
00001B40  163C 002E               1241              MOVE.B  #'.',D3
00001B44  6100 1B8E               1242              BSR     PUSH_STACK
00001B48  163C 004C               1243              MOVE.B  #'L',D3
00001B4C  6100 1B86               1244              BSR     PUSH_STACK
00001B50                          1245              
00001B50                          1246             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B50  13FC 0000 00003FFA      1247             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B58  13FC 0000 00003FFB      1248             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B60                          1249             
00001B60                          1250             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B60  13FC 00B9 00003FFD      1251             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B68  13FC 0020 00003FFE      1252             MOVE.B   #$20,GET_SRC_START_END
00001B70                          1253  
00001B70                          1254              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001B70  0285 0000FE3F           1255              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001B76  0685 00000040           1256              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001B7C                          1257       
00001B7C                          1258              *PRINT <EA>,AN
00001B7C  6100 12B8               1259              BSR     GET_EA_EA_SRC       *GETS <ea>
00001B80  163C 002C               1260              MOVE.B  #',',D3
00001B84  6100 1B4E               1261              BSR     PUSH_STACK                     
00001B88  6100 16DC               1262              BSR     GET_EA_EA_DEST      *GETS Dn
00001B8C                          1263  
00001B8C                          1264              
00001B8C                          1265              
00001B8C  4E75                    1266              RTS
00001B8E                          1267  OP1001_SUBA_W
00001B8E                          1268              *LOAD STACK WITH THIS OPMODE
00001B8E  6100 1B44               1269              BSR     PUSH_STACK
00001B92  163C 0053               1270              MOVE.B  #'S',D3
00001B96  6100 1B3C               1271              BSR     PUSH_STACK
00001B9A  163C 0055               1272              MOVE.B  #'U',D3
00001B9E  6100 1B34               1273              BSR     PUSH_STACK
00001BA2  163C 0042               1274              MOVE.B  #'B',D3
00001BA6  6100 1B2C               1275              BSR     PUSH_STACK
00001BAA  163C 0041               1276              MOVE.B  #'A',D3
00001BAE  6100 1B24               1277              BSR     PUSH_STACK
00001BB2  163C 002E               1278              MOVE.B  #'.',D3
00001BB6  6100 1B1C               1279              BSR     PUSH_STACK
00001BBA  163C 0057               1280              MOVE.B  #'W',D3
00001BBE  6100 1B14               1281              BSR     PUSH_STACK
00001BC2                          1282              
00001BC2                          1283             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001BC2  13FC 0000 00003FFA      1284             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001BCA  13FC 0000 00003FFB      1285             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001BD2                          1286             
00001BD2                          1287             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001BD2  13FC 00B9 00003FFD      1288             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001BDA  13FC 0020 00003FFE      1289             MOVE.B   #$20,GET_SRC_START_END
00001BE2                          1290  
00001BE2                          1291              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001BE2  0285 0000FE3F           1292              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001BE8  0685 00000040           1293              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001BEE                          1294       
00001BEE                          1295              *PRINT <EA>,AN
00001BEE  6100 1246               1296              BSR     GET_EA_EA_SRC       *GETS <ea>
00001BF2  163C 002C               1297              MOVE.B  #',',D3
00001BF6  6100 1ADC               1298              BSR     PUSH_STACK                     
00001BFA  6100 166A               1299              BSR     GET_EA_EA_DEST      *GETS Dn
00001BFE                          1300  
00001BFE  4E75                    1301              RTS
00001C00                          1302  
00001C00                          1303  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00001C00                          1304              *LOAD STACK WITH THIS OPMODE
00001C00  6100 1AD2               1305              BSR     PUSH_STACK
00001C04  163C 0053               1306              MOVE.B  #'S',D3
00001C08  6100 1ACA               1307              BSR     PUSH_STACK
00001C0C  163C 0055               1308              MOVE.B  #'U',D3
00001C10  6100 1AC2               1309              BSR     PUSH_STACK
00001C14  163C 0042               1310              MOVE.B  #'B',D3
00001C18  6100 1ABA               1311              BSR     PUSH_STACK
00001C1C  163C 002E               1312              MOVE.B  #'.',D3
00001C20  6100 1AB2               1313              BSR     PUSH_STACK
00001C24                          1314              
00001C24  2205                    1315              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001C26                          1316              
00001C26                          1317              *BITS (INDEX 8) 
00001C26                          1318              *0 = ADD.B/W/L <EA>,Dn
00001C26                          1319              *1 = ADD.B/W/L Dn,<EA> 
00001C26  E099                    1320              ROR.L   #8,D1
00001C28  0281 00000001           1321              ANDI.L  #$01,D1     *MASKS WITH 00000001
00001C2E  0C81 00000000           1322              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00001C34  6700 0102               1323              BEQ     OP1001_EA_DN
00001C38                          1324              *else procede to Dn_EA
00001C38                          1325              
00001C38                          1326  OP1001_DN_EA
00001C38                          1327              *BITS (7 TO 6) 
00001C38                          1328              *00 = .B
00001C38                          1329              *01 = .W
00001C38                          1330              *10 = .L 
00001C38  2205                    1331              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001C3A  EC99                    1332              ROR.L   #6,D1
00001C3C  0281 00000003           1333              ANDI.L  #$03,D1
00001C42  0C81 00000000           1334              CMPI.L  #$00,D1 *EQUALS .B
00001C48  6700 0016               1335              BEQ     OP1001_PRINT_B2
00001C4C  0C81 00000001           1336              CMPI.L  #$01,D1 *EQUALS .W
00001C52  6700 0054               1337              BEQ     OP1001_PRINT_W2
00001C56  0C81 00000002           1338              CMPI.L  #$02,D1 *EQUALS .L
00001C5C  6700 0092               1339              BEQ     OP1001_PRINT_L2
00001C60                          1340  OP1001_PRINT_B2
00001C60                          1341              *PUSH 'B'
00001C60  163C 0042               1342              MOVE.B  #'B',D3
00001C64  6100 1A6E               1343              BSR     PUSH_STACK
00001C68                          1344             
00001C68                          1345              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C68  13FC 0000 00003FFA      1346             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C70  13FC 0083 00003FFB      1347             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C78                          1348             
00001C78                          1349             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C78  13FC 00B9 00003FFD      1350             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001C80  13FC 0020 00003FFE      1351             MOVE.B   #$20,GET_SRC_START_END
00001C88                          1352  
00001C88                          1353              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001C88  0285 0000FE3F           1354              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001C8E  0685 00000040           1355              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001C94                          1356       
00001C94  6100 15D0               1357              BSR     GET_EA_EA_DEST      *GETS Dn
00001C98  163C 002C               1358              MOVE.B  #',',D3
00001C9C  6100 1A36               1359              BSR     PUSH_STACK                     
00001CA0  6100 1194               1360              BSR     GET_EA_EA_SRC       *GETS <ea>
00001CA4                          1361  
00001CA4                          1362              
00001CA4  6000 09A0               1363              BRA     OP1101_ADD_RETURN
00001CA8                          1364  OP1001_PRINT_W2
00001CA8  163C 0057               1365              MOVE.B  #'W',D3
00001CAC  6100 1A26               1366              BSR     PUSH_STACK
00001CB0                          1367  
00001CB0                          1368              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CB0  13FC 0000 00003FFA      1369              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CB8  13FC 0083 00003FFB      1370              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CC0                          1371             
00001CC0                          1372              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CC0  13FC 00B9 00003FFD      1373              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CC8  13FC 0020 00003FFE      1374              MOVE.B   #$20,GET_SRC_START_END
00001CD0                          1375  
00001CD0                          1376              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CD0  0285 0000FE3F           1377              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CD6  0685 00000040           1378              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00001CDC                          1379  
00001CDC                          1380        
00001CDC  6100 1588               1381              BSR     GET_EA_EA_DEST      *GETS Dn
00001CE0  163C 002C               1382              MOVE.B  #',',D3
00001CE4  6100 19EE               1383              BSR     PUSH_STACK               
00001CE8  6100 114C               1384              BSR     GET_EA_EA_SRC       *GETS <ea>       
00001CEC                          1385  
00001CEC                          1386  
00001CEC                          1387  
00001CEC  6000 0958               1388              BRA     OP1101_ADD_RETURN
00001CF0                          1389  OP1001_PRINT_L2 
00001CF0  163C 004C               1390              MOVE.B  #'L',D3
00001CF4  6100 19DE               1391              BSR     PUSH_STACK
00001CF8                          1392              
00001CF8                          1393              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CF8  13FC 0000 00003FFA      1394              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D00  13FC 0083 00003FFB      1395              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D08                          1396             
00001D08                          1397              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D08  13FC 00B9 00003FFD      1398              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D10  13FC 0020 00003FFE      1399              MOVE.B   #$20,GET_SRC_START_END
00001D18                          1400  
00001D18                          1401             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D18  0285 0000FE3F           1402              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D1E  0685 00000040           1403              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001D24                          1404  
00001D24                          1405               
00001D24  6100 1540               1406              BSR     GET_EA_EA_DEST       *GETS Dn
00001D28  163C 002C               1407              MOVE.B  #',',D3
00001D2C  6100 19A6               1408              BSR     PUSH_STACK          
00001D30  6100 1104               1409              BSR     GET_EA_EA_SRC        *GETS <ea>
00001D34                          1410  
00001D34  6000 0910               1411              BRA     OP1101_ADD_RETURN
00001D38                          1412              
00001D38                          1413  OP1001_EA_DN           
00001D38                          1414              *BITS (7 TO 6) 
00001D38                          1415              *00 = .B
00001D38                          1416              *01 = .W
00001D38                          1417              *10 = .L 
00001D38  2205                    1418              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001D3A  EC99                    1419              ROR.L   #6,D1
00001D3C  0281 00000003           1420              ANDI.L  #$03,D1
00001D42  0C81 00000000           1421              CMPI.L  #$00,D1 *EQUALS .B
00001D48  6700 0016               1422              BEQ     OP1001_PRINT_B
00001D4C  0C81 00000001           1423              CMPI.L  #$01,D1 *EQUALS .W
00001D52  6700 0054               1424              BEQ     OP1001_PRINT_W
00001D56  0C81 00000002           1425              CMPI.L  #$02,D1 *EQUALS .L
00001D5C  6700 0092               1426              BEQ     OP1001_PRINT_L
00001D60                          1427  OP1001_PRINT_B
00001D60  163C 0042               1428              MOVE.B  #'B',D3
00001D64  6100 196E               1429              BSR     PUSH_STACK
00001D68                          1430                
00001D68                          1431              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D68  13FC 0000 00003FFA      1432              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D70  13FC 0002 00003FFB      1433              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D78                          1434             
00001D78                          1435              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D78  13FC 00B9 00003FFD      1436              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D80  13FC 0020 00003FFE      1437              MOVE.B   #$20,GET_SRC_START_END
00001D88                          1438  
00001D88                          1439             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D88  0285 0000FE3F           1440              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D8E  0685 00000040           1441              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00001D94                          1442  
00001D94                          1443              
00001D94  6100 10A0               1444              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D98  163C 002C               1445              MOVE.B  #',',D3
00001D9C  6100 1936               1446              BSR     PUSH_STACK          
00001DA0  6100 14C4               1447              BSR     GET_EA_EA_DEST       *GETS Dn
00001DA4                          1448              
00001DA4  6000 08A0               1449              BRA     OP1101_ADD_RETURN
00001DA8                          1450  OP1001_PRINT_W
00001DA8  163C 0057               1451              MOVE.B  #'W',D3
00001DAC  6100 1926               1452              BSR     PUSH_STACK
00001DB0                          1453  
00001DB0                          1454              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DB0  13FC 0000 00003FFA      1455              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001DB8  13FC 0000 00003FFB      1456              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001DC0                          1457             
00001DC0                          1458              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DC0  13FC 00B9 00003FFD      1459              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001DC8  13FC 0020 00003FFE      1460              MOVE.B   #$20,GET_SRC_START_END
00001DD0                          1461  
00001DD0                          1462             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001DD0  0285 0000FE3F           1463              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001DD6  0685 00000040           1464              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001DDC                          1465  
00001DDC                          1466              
00001DDC  6100 1058               1467              BSR     GET_EA_EA_SRC      *GETS <ea>
00001DE0  163C 002C               1468              MOVE.B  #',',D3
00001DE4  6100 18EE               1469              BSR     PUSH_STACK
00001DE8  6100 147C               1470              BSR     GET_EA_EA_DEST       *GETS Dn    
00001DEC                          1471              
00001DEC  6000 004A               1472              BRA     OP1001_ADD_RETURN
00001DF0                          1473  OP1001_PRINT_L 
00001DF0  163C 004C               1474              MOVE.B  #'L',D3
00001DF4  6100 18DE               1475              BSR     PUSH_STACK
00001DF8                          1476              
00001DF8                          1477              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DF8  13FC 0000 00003FFA      1478              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001E00  13FC 0000 00003FFB      1479              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001E08                          1480             
00001E08                          1481              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E08  13FC 00B9 00003FFD      1482              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001E10  13FC 0020 00003FFE      1483              MOVE.B   #$20,GET_SRC_START_END
00001E18                          1484  
00001E18                          1485              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001E18  0285 0000FE3F           1486              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001E1E  0685 00000040           1487              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00001E24                          1488  
00001E24                          1489                     
00001E24  6100 1010               1490              BSR     GET_EA_EA_SRC      *GETS <ea>
00001E28  163C 002C               1491              MOVE.B  #',',D3
00001E2C  6100 18A6               1492              BSR     PUSH_STACK                  
00001E30  6100 1434               1493              BSR     GET_EA_EA_DEST       *GETS Dn    
00001E34                          1494  
00001E34                          1495              
00001E34  6000 0002               1496              BRA     OP1001_ADD_RETURN
00001E38                          1497              
00001E38                          1498  OP1001_ADD_RETURN
00001E38  4E75                    1499              RTS
00001E3A                          1500  
00001E3A                          1501    
00001E3A                          1502  *---------------------------------------------------------------------------*
00001E3A                          1503  * OP_SUB: display SUB and proceed to EA
00001E3A                          1504  *---------------------------------------------------------------------------*            
00001E3A  43F9 00003DF5           1505  OP_SUB_B    LEA     DISP_SUB_B,A1
00001E40  103C 000E               1506              MOVE.B  #14,D0
00001E44  4E4F                    1507              TRAP    #15
00001E46  183C 0000               1508              MOVE.B  #0,D4
00001E4A  4EF9 000029E6           1509              JMP     EA_GEN
00001E50                          1510  
00001E50  4E75                    1511              RTS
00001E52                          1512  
00001E52  43F9 00003DFE           1513  OP_SUB_W    LEA     DISP_SUB_W,A1
00001E58  103C 000E               1514              MOVE.B  #14,D0
00001E5C  4E4F                    1515              TRAP    #15
00001E5E  183C 0001               1516              MOVE.B  #1,D4
00001E62  4EF9 000029E6           1517              JMP     EA_GEN
00001E68                          1518  
00001E68  4E75                    1519              RTS
00001E6A                          1520  
00001E6A  43F9 00003E07           1521  OP_SUB_L    LEA     DISP_SUB_L,A1
00001E70  103C 000E               1522              MOVE.B  #14,D0
00001E74  4E4F                    1523              TRAP    #15
00001E76  183C 0002               1524              MOVE.B  #2,D4
00001E7A  4EF9 000029E6           1525              JMP     EA_GEN
00001E80                          1526  
00001E80  4E75                    1527              RTS
00001E82                          1528  
00001E82                          1529  *---------------------------------------------------------------------------*
00001E82                          1530  * OP_SUBA: display SUBA
00001E82                          1531  *---------------------------------------------------------------------------*  
00001E82  43F9 00003E2E           1532  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00001E88  103C 000E               1533              MOVE.B  #14,D0
00001E8C  4E4F                    1534              TRAP    #15
00001E8E  183C 0001               1535              MOVE.B  #1,D4
00001E92  4E75                    1536              RTS
00001E94                          1537  
00001E94  43F9 00003E38           1538  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00001E9A  103C 000E               1539              MOVE.B  #14,D0
00001E9E  4E4F                    1540              TRAP    #15
00001EA0  183C 0002               1541              MOVE.B  #2,D4
00001EA4  4E75                    1542              RTS         
00001EA6                          1543  *---------------------------------------------------------------------------*
00001EA6                          1544  * OP1010 : unassigned
00001EA6                          1545  *---------------------------------------------------------------------------*           
00001EA6  4EF8 14A6               1546  OP1010      JMP     OP_DATA
00001EAA                          1547              
00001EAA                          1548  *---------------------------------------------------------------------------*
00001EAA                          1549  * OP1011 : decode CMP/EOR/CMPA
00001EAA                          1550  *---------------------------------------------------------------------------*           
00001EAA  4280                    1551  OP1011      CLR.L   D0                
00001EAC  4281                    1552              CLR.L   D1            
00001EAE  4284                    1553              CLR.L   D4                   
00001EB0  227C 00000000           1554              MOVEA.L #0, A1               
00001EB6  2205                    1555              MOVE.L  D5,D1
00001EB8  EA99                    1556              ROR.L   #5,D1
00001EBA  0281 0000000E           1557              ANDI.L  #$E,D1
00001EC0  0C01 0000               1558              CMPI.B  #$0,D1
00001EC4  6700 0062               1559              BEQ     OP_CMP_B
00001EC8  0C01 0002               1560              CMPI.B  #$2,D1
00001ECC  6700 0072               1561              BEQ     OP_CMP_W
00001ED0  0C01 0004               1562              CMPI.B  #$4,D1
00001ED4  6700 0082               1563              BEQ     OP_CMP_L
00001ED8  0C01 0008               1564              CMPI.B  #$8,D1
00001EDC  6700 0092               1565              BEQ     OP_EOR_B
00001EE0  0C01 000A               1566              CMPI.B  #$A,D1
00001EE4  6700 009C               1567              BEQ     OP_EOR_W
00001EE8  0C01 000C               1568              CMPI.B  #$C,D1
00001EEC  6700 00A6               1569              BEQ     OP_EOR_L  
00001EF0  0C01 0006               1570              CMPI.B  #$6,D1
00001EF4  6700 000E               1571              BEQ     OP_CMPA_W
00001EF8  0C01 000E               1572              CMPI.B  #$E,D1
00001EFC  6700 0018               1573              BEQ     OP_CMPA_L 
00001F00                          1574  
00001F00  4EF8 14A6               1575              JMP     OP_DATA          
00001F04                          1576  
00001F04                          1577  *---------------------------------------------------------------------------*
00001F04                          1578  * OP_CMPA: display CMPA 
00001F04                          1579  *---------------------------------------------------------------------------
00001F04  43F9 00003E78           1580  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00001F0A  103C 000E               1581              MOVE.B  #14,D0
00001F0E  4E4F                    1582              TRAP    #15
00001F10  183C 0001               1583              MOVE.B  #1,D4
00001F14  4E75                    1584              RTS
00001F16                          1585  
00001F16  43F9 00003E82           1586  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00001F1C  103C 000E               1587              MOVE.B  #14,D0
00001F20  4E4F                    1588              TRAP    #15
00001F22  183C 0002               1589              MOVE.B  #2,D4
00001F26  4E75                    1590              RTS
00001F28                          1591  
00001F28                          1592  *---------------------------------------------------------------------------*
00001F28                          1593  * OP_CMP: display CMP and proceed to EA
00001F28                          1594  *---------------------------------------------------------------------------*  
00001F28  43F9 00003E5D           1595  OP_CMP_B    LEA     DISP_CMP_B,A1
00001F2E  103C 000E               1596              MOVE.B  #14,D0
00001F32  4E4F                    1597              TRAP    #15
00001F34  183C 0000               1598              MOVE.B  #0,D4
00001F38  4EF9 000029E6           1599              JMP     EA_GEN
00001F3E                          1600  
00001F3E  4E75                    1601              RTS
00001F40                          1602              
00001F40  43F9 00003E66           1603  OP_CMP_W    LEA     DISP_CMP_W,A1
00001F46  103C 000E               1604              MOVE.B  #14,D0
00001F4A  4E4F                    1605              TRAP    #15
00001F4C  183C 0001               1606              MOVE.B  #1,D4
00001F50  4EF9 000029E6           1607              JMP     EA_GEN
00001F56                          1608  
00001F56  4E75                    1609              RTS
00001F58                          1610              
00001F58  43F9 00003E6F           1611  OP_CMP_L    LEA     DISP_CMP_L,A1
00001F5E  103C 000E               1612              MOVE.B  #14,D0
00001F62  4E4F                    1613              TRAP    #15
00001F64  183C 0002               1614              MOVE.B  #2,D4
00001F68  4EF9 000029E6           1615              JMP     EA_GEN
00001F6E                          1616  
00001F6E  4E75                    1617              RTS
00001F70                          1618              
00001F70                          1619  *---------------------------------------------------------------------------*
00001F70                          1620  * OP_EOR: display EOR
00001F70                          1621  *---------------------------------------------------------------------------*  
00001F70  43F9 00003E42           1622  OP_EOR_B    LEA     DISP_EOR_B,A1
00001F76  103C 000E               1623              MOVE.B  #14,D0
00001F7A  4E4F                    1624              TRAP    #15
00001F7C  183C 0000               1625              MOVE.B  #0,D4
00001F80  4E75                    1626              RTS
00001F82                          1627              
00001F82  43F9 00003E4B           1628  OP_EOR_W    LEA     DISP_EOR_W,A1
00001F88  103C 000E               1629              MOVE.B  #14,D0
00001F8C  4E4F                    1630              TRAP    #15
00001F8E  183C 0001               1631              MOVE.B  #1,D4
00001F92  4E75                    1632              RTS
00001F94                          1633              
00001F94  43F9 00003E54           1634  OP_EOR_L    LEA     DISP_EOR_L,A1
00001F9A  103C 000E               1635              MOVE.B  #14,D0
00001F9E  4E4F                    1636              TRAP    #15
00001FA0  183C 0002               1637              MOVE.B  #2,D4
00001FA4  4E75                    1638              RTS    
00001FA6                          1639  
00001FA6                          1640  *---------------------------------------------------------------------------*
00001FA6                          1641  * OP1100: Decode and display MULS/AND and proceed to EA
00001FA6                          1642  *---------------------------------------------------------------------------* 
00001FA6  4280                    1643  OP1100      CLR.L   D0                 
00001FA8  4281                    1644              CLR.L   D1    
00001FAA  4284                    1645              CLR.L   D4                
00001FAC  227C 00000000           1646              MOVEA.L #0, A1        
00001FB2  2205                    1647              MOVE.L  D5,D1
00001FB4  EA89                    1648              LSR.L   #5,D1
00001FB6  0281 0000000E           1649              ANDI.L  #$E,D1
00001FBC  0C41 000E               1650              CMPI.W  #$E,D1
00001FC0  6700 0006               1651              BEQ     OP_MULS
00001FC4  6000 00F6               1652              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
00001FC8                          1653  
00001FC8                          1654  OP_MULS                      
00001FC8  4281                    1655              CLR.L   D1       
00001FCA  4284                    1656              CLR.L   D4                   
00001FCC  227C 00000000           1657              MOVEA.L #0, A1              
00001FD2  2205                    1658              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001FD4                          1659              *CLEAR D3
00001FD4  4283                    1660              CLR.L   D3
00001FD6                          1661  
00001FD6                          1662  OP1100_MULS_DN_EA_OR_EA_DN 
00001FD6                          1663              *LOAD STACK WITH THIS OPMODE
00001FD6  6100 16FC               1664              BSR     PUSH_STACK
00001FDA  163C 004D               1665              MOVE.B  #'M',D3
00001FDE  6100 16F4               1666              BSR     PUSH_STACK
00001FE2  163C 0055               1667              MOVE.B  #'U',D3
00001FE6  6100 16EC               1668              BSR     PUSH_STACK
00001FEA  163C 004C               1669              MOVE.B  #'L',D3
00001FEE  6100 16E4               1670              BSR     PUSH_STACK
00001FF2  163C 0053               1671              MOVE.B  #'S',D3
00001FF6  6100 16DC               1672              BSR     PUSH_STACK
00001FFA  163C 002E               1673              MOVE.B  #'.',D3
00001FFE  6100 16D4               1674              BSR     PUSH_STACK
00002002                          1675              
00002002  2205                    1676              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002004                          1677              
00002004                          1678  OP1100_EA_DN_MULS           
00002004                          1679              *BITS (7 TO 6) 
00002004                          1680              *00 = .B
00002004                          1681              *01 = .W
00002004                          1682              *10 = .L 
00002004  2205                    1683              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002006  EC99                    1684              ROR.L   #6,D1
00002008  0281 00000003           1685              ANDI.L  #$03,D1
0000200E  0C81 00000003           1686              CMPI.L  #%11,D1 *EQUALS .W
00002014  6700 0014               1687              BEQ     OP1100_PRINT_W_MULS
00002018  0C81 00000000           1688              CMPI.L  #%00,D1 *EQUALS .L
0000201E  6700 0052               1689              BEQ     OP1100_PRINT_L_MULS
00002022                          1690              
00002022  183C 0001               1691              MOVE.B  #1,D4               *ERROR READ
00002026  6000 0092               1692              BRA     OP1100_MULS_RETURN
0000202A                          1693  OP1100_PRINT_W_MULS
0000202A  163C 0057               1694              MOVE.B  #'W',D3
0000202E  6100 16A4               1695              BSR     PUSH_STACK
00002032                          1696  
00002032                          1697              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002032  13FC 0000 00003FFA      1698              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000203A  13FC 0000 00003FFB      1699              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002042                          1700             
00002042                          1701              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002042  13FC 00B9 00003FFD      1702              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000204A  13FC 0020 00003FFE      1703              MOVE.B   #$20,GET_SRC_START_END
00002052                          1704  
00002052                          1705             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002052  0285 0000FE3F           1706              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002058  0685 00000000           1707              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000205E                          1708  
0000205E                          1709              
0000205E  6100 0DD6               1710              BSR     GET_EA_EA_SRC      *GETS <ea>
00002062  163C 002C               1711              MOVE.B  #',',D3
00002066  6100 166C               1712              BSR     PUSH_STACK
0000206A  6100 11FA               1713              BSR     GET_EA_EA_DEST       *GETS Dn    
0000206E                          1714              
0000206E  6000 004A               1715              BRA     OP1100_MULS_RETURN
00002072                          1716  OP1100_PRINT_L_MULS 
00002072  163C 004C               1717              MOVE.B  #'L',D3
00002076  6100 165C               1718              BSR     PUSH_STACK
0000207A                          1719              
0000207A                          1720              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000207A  13FC 0000 00003FFA      1721              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002082  13FC 0000 00003FFB      1722              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000208A                          1723             
0000208A                          1724              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000208A  13FC 00B9 00003FFD      1725              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002092  13FC 0020 00003FFE      1726              MOVE.B   #$20,GET_SRC_START_END
0000209A                          1727  
0000209A                          1728              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000209A  0285 0000FE3F           1729              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020A0  0685 00000000           1730              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000020A6                          1731  
000020A6                          1732                     
000020A6  6100 0D8E               1733              BSR     GET_EA_EA_SRC      *GETS <ea>
000020AA  163C 002C               1734              MOVE.B  #',',D3
000020AE  6100 1624               1735              BSR     PUSH_STACK                  
000020B2  6100 11B2               1736              BSR     GET_EA_EA_DEST       *GETS Dn    
000020B6                          1737  
000020B6                          1738              
000020B6  6000 0002               1739              BRA     OP1100_MULS_RETURN
000020BA                          1740              
000020BA                          1741  OP1100_MULS_RETURN
000020BA  4E75                    1742              RTS
000020BC                          1743              
000020BC                          1744  
000020BC                          1745  
000020BC                          1746  
000020BC                          1747  
000020BC                          1748  
000020BC                          1749  
000020BC                          1750  
000020BC                          1751  
000020BC                          1752  
000020BC                          1753  
000020BC                          1754  
000020BC                          1755  
000020BC                          1756  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000020BC                          1757              *LOAD STACK WITH THIS OPMODE
000020BC  4283                    1758              CLR.L   D3
000020BE  6100 1614               1759              BSR     PUSH_STACK
000020C2  163C 0041               1760              MOVE.B  #'A',D3
000020C6  6100 160C               1761              BSR     PUSH_STACK
000020CA  163C 004E               1762              MOVE.B  #'N',D3
000020CE  6100 1604               1763              BSR     PUSH_STACK
000020D2  163C 0044               1764              MOVE.B  #'D',D3
000020D6  6100 15FC               1765              BSR     PUSH_STACK
000020DA  163C 002E               1766              MOVE.B  #'.',D3
000020DE  6100 15F4               1767              BSR     PUSH_STACK
000020E2                          1768              
000020E2  2205                    1769              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000020E4                          1770              
000020E4                          1771              *BITS (INDEX 8) 
000020E4                          1772              *0 = ADD.B/W/L <EA>,Dn
000020E4                          1773              *1 = ADD.B/W/L Dn,<EA> 
000020E4  E099                    1774              ROR.L   #8,D1
000020E6  0281 00000001           1775              ANDI.L  #$01,D1     *MASKS WITH 00000001
000020EC  0C81 00000000           1776              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000020F2  6700 0102               1777              BEQ     OP1100_EA_DN
000020F6                          1778              *else procede to Dn_EA
000020F6                          1779              
000020F6                          1780  OP1100_DN_EA
000020F6                          1781              *BITS (7 TO 6) 
000020F6                          1782              *00 = .B
000020F6                          1783              *01 = .W
000020F6                          1784              *10 = .L 
000020F6  2205                    1785              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000020F8  EC99                    1786              ROR.L   #6,D1
000020FA  0281 00000003           1787              ANDI.L  #$03,D1
00002100  0C81 00000000           1788              CMPI.L  #$00,D1 *EQUALS .B
00002106  6700 0016               1789              BEQ     OP1100_PRINT_B2
0000210A  0C81 00000001           1790              CMPI.L  #$01,D1 *EQUALS .W
00002110  6700 0054               1791              BEQ     OP1100_PRINT_W2
00002114  0C81 00000002           1792              CMPI.L  #$02,D1 *EQUALS .L
0000211A  6700 0092               1793              BEQ     OP1100_PRINT_L2
0000211E                          1794  OP1100_PRINT_B2
0000211E                          1795              *PUSH 'B'
0000211E  163C 0042               1796              MOVE.B  #'B',D3
00002122  6100 15B0               1797              BSR     PUSH_STACK
00002126                          1798             
00002126                          1799              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002126  13FC 0000 00003FFA      1800             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000212E  13FC 0083 00003FFB      1801             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002136                          1802             
00002136                          1803             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002136  13FC 00B9 00003FFD      1804             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000213E  13FC 0020 00003FFE      1805             MOVE.B   #$20,GET_SRC_START_END
00002146                          1806  
00002146                          1807              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002146  0285 0000FE3F           1808              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000214C  0685 00000000           1809              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002152                          1810       
00002152  6100 1112               1811              BSR     GET_EA_EA_DEST      *GETS Dn
00002156  163C 002C               1812              MOVE.B  #',',D3
0000215A  6100 1578               1813              BSR     PUSH_STACK                     
0000215E  6100 0CD6               1814              BSR     GET_EA_EA_SRC       *GETS <ea>
00002162                          1815  
00002162                          1816              
00002162  6000 0192               1817              BRA     OP1100_AND_RETURN
00002166                          1818  OP1100_PRINT_W2
00002166  163C 0057               1819              MOVE.B  #'W',D3
0000216A  6100 1568               1820              BSR     PUSH_STACK
0000216E                          1821  
0000216E                          1822              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000216E  13FC 0000 00003FFA      1823              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002176  13FC 0083 00003FFB      1824              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000217E                          1825             
0000217E                          1826              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000217E  13FC 00B9 00003FFD      1827              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002186  13FC 0020 00003FFE      1828              MOVE.B   #$20,GET_SRC_START_END
0000218E                          1829  
0000218E                          1830              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000218E  0285 0000FE3F           1831              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002194  0685 00000000           1832              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
0000219A                          1833  
0000219A                          1834        
0000219A  6100 10CA               1835              BSR     GET_EA_EA_DEST      *GETS Dn
0000219E  163C 002C               1836              MOVE.B  #',',D3
000021A2  6100 1530               1837              BSR     PUSH_STACK               
000021A6  6100 0C8E               1838              BSR     GET_EA_EA_SRC       *GETS <ea>       
000021AA                          1839  
000021AA                          1840  
000021AA                          1841  
000021AA  6000 049A               1842              BRA     OP1101_ADD_RETURN
000021AE                          1843  OP1100_PRINT_L2 
000021AE  163C 004C               1844              MOVE.B  #'L',D3
000021B2  6100 1520               1845              BSR     PUSH_STACK
000021B6                          1846              
000021B6                          1847              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021B6  13FC 0000 00003FFA      1848              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021BE  13FC 0083 00003FFB      1849              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021C6                          1850             
000021C6                          1851              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021C6  13FC 00B9 00003FFD      1852              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021CE  13FC 0020 00003FFE      1853              MOVE.B   #$20,GET_SRC_START_END
000021D6                          1854  
000021D6                          1855             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021D6  0285 0000FE3F           1856              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021DC  0685 00000000           1857              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000021E2                          1858  
000021E2                          1859               
000021E2  6100 1082               1860              BSR     GET_EA_EA_DEST       *GETS Dn
000021E6  163C 002C               1861              MOVE.B  #',',D3
000021EA  6100 14E8               1862              BSR     PUSH_STACK          
000021EE  6100 0C46               1863              BSR     GET_EA_EA_SRC        *GETS <ea>
000021F2                          1864  
000021F2  6000 0102               1865              BRA     OP1100_AND_RETURN
000021F6                          1866              
000021F6                          1867  OP1100_EA_DN           
000021F6                          1868              *BITS (7 TO 6) 
000021F6                          1869              *00 = .B
000021F6                          1870              *01 = .W
000021F6                          1871              *10 = .L 
000021F6  2205                    1872              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000021F8  EC99                    1873              ROR.L   #6,D1
000021FA  0281 00000003           1874              ANDI.L  #$03,D1
00002200  0C81 00000000           1875              CMPI.L  #$00,D1 *EQUALS .B
00002206  6700 0016               1876              BEQ     OP1100_PRINT_B
0000220A  0C81 00000001           1877              CMPI.L  #$01,D1 *EQUALS .W
00002210  6700 0054               1878              BEQ     OP1100_PRINT_W
00002214  0C81 00000002           1879              CMPI.L  #$02,D1 *EQUALS .L
0000221A  6700 0092               1880              BEQ     OP1100_PRINT_L
0000221E                          1881  OP1100_PRINT_B
0000221E  163C 0042               1882              MOVE.B  #'B',D3
00002222  6100 14B0               1883              BSR     PUSH_STACK
00002226                          1884                
00002226                          1885              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002226  13FC 0000 00003FFA      1886              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000222E  13FC 0002 00003FFB      1887              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002236                          1888             
00002236                          1889              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002236  13FC 00B9 00003FFD      1890              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000223E  13FC 0020 00003FFE      1891              MOVE.B   #$20,GET_SRC_START_END
00002246                          1892  
00002246                          1893             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002246  0285 0000FE3F           1894              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000224C  0685 00000000           1895              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002252                          1896  
00002252                          1897              
00002252  6100 0BE2               1898              BSR     GET_EA_EA_SRC      *GETS <ea>
00002256  163C 002C               1899              MOVE.B  #',',D3
0000225A  6100 1478               1900              BSR     PUSH_STACK          
0000225E  6100 1006               1901              BSR     GET_EA_EA_DEST       *GETS Dn
00002262                          1902              
00002262  6000 03E2               1903              BRA     OP1101_ADD_RETURN
00002266                          1904  OP1100_PRINT_W
00002266  163C 0057               1905              MOVE.B  #'W',D3
0000226A  6100 1468               1906              BSR     PUSH_STACK
0000226E                          1907  
0000226E                          1908              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000226E  13FC 0000 00003FFA      1909              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002276  13FC 0002 00003FFB      1910              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000227E                          1911             
0000227E                          1912              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000227E  13FC 00B9 00003FFD      1913              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002286  13FC 0020 00003FFE      1914              MOVE.B   #$20,GET_SRC_START_END
0000228E                          1915  
0000228E                          1916             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000228E  0285 0000FE3F           1917              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002294  0685 00000000           1918              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000229A                          1919  
0000229A                          1920              
0000229A  6100 0B9A               1921              BSR     GET_EA_EA_SRC      *GETS <ea>
0000229E  163C 002C               1922              MOVE.B  #',',D3
000022A2  6100 1430               1923              BSR     PUSH_STACK
000022A6  6100 0FBE               1924              BSR     GET_EA_EA_DEST       *GETS Dn    
000022AA                          1925              
000022AA  6000 FB8C               1926              BRA     OP1001_ADD_RETURN
000022AE                          1927  OP1100_PRINT_L 
000022AE  163C 004C               1928              MOVE.B  #'L',D3
000022B2  6100 1420               1929              BSR     PUSH_STACK
000022B6                          1930              
000022B6                          1931              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022B6  13FC 0000 00003FFA      1932              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022BE  13FC 0002 00003FFB      1933              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022C6                          1934             
000022C6                          1935              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022C6  13FC 00B9 00003FFD      1936              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022CE  13FC 0020 00003FFE      1937              MOVE.B   #$20,GET_SRC_START_END
000022D6                          1938  
000022D6                          1939              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022D6  0285 0000FE3F           1940              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022DC  0685 00000000           1941              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022E2                          1942  
000022E2                          1943                     
000022E2  6100 0B52               1944              BSR     GET_EA_EA_SRC      *GETS <ea>
000022E6  163C 002C               1945              MOVE.B  #',',D3
000022EA  6100 13E8               1946              BSR     PUSH_STACK                  
000022EE  6100 0F76               1947              BSR     GET_EA_EA_DEST       *GETS Dn    
000022F2                          1948  
000022F2                          1949              
000022F2  6000 0002               1950              BRA     OP1100_AND_RETURN
000022F6                          1951              
000022F6                          1952  OP1100_AND_RETURN
000022F6  4E75                    1953              RTS
000022F8                          1954  
000022F8                          1955  
000022F8                          1956  *---------------------------------------------------------------------------*
000022F8                          1957  * OP1101: Decode ADD/ADDA
000022F8                          1958  *---------------------------------------------------------------------------* 
000022F8  4280                    1959  OP1101      CLR.L   D0                  
000022FA  4281                    1960              CLR.L   D1       
000022FC  4284                    1961              CLR.L   D4                   
000022FE  227C 00000000           1962              MOVEA.L #0, A1              
00002304  2205                    1963              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002306                          1964              
00002306                          1965              *CLEAR D3
00002306  4283                    1966              CLR.L   D3
00002308                          1967              
00002308                          1968              
00002308                          1969              
00002308                          1970              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002308  2205                    1971              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000230A                          1972              *BITS (INDEX 8) 
0000230A                          1973              *0 = ADD.B/W/L <EA>,Dn
0000230A                          1974              *1 = ADD.B/W/L Dn,<EA> 
0000230A  EC99                    1975              ROR.L   #6,D1
0000230C  0281 00000007           1976              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002312  0C81 00000007           1977              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002318  6700 0010               1978              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
0000231C  0C81 00000003           1979              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002322  6700 0078               1980              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002326  6000 00E6               1981              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000232A                          1982              
0000232A                          1983  OP1101_ADDA_L
0000232A                          1984              *LOAD STACK WITH THIS OPMODE
0000232A  6100 13A8               1985              BSR     PUSH_STACK
0000232E  163C 0041               1986              MOVE.B  #'A',D3
00002332  6100 13A0               1987              BSR     PUSH_STACK
00002336  163C 0044               1988              MOVE.B  #'D',D3
0000233A  6100 1398               1989              BSR     PUSH_STACK
0000233E  163C 0044               1990              MOVE.B  #'D',D3
00002342  6100 1390               1991              BSR     PUSH_STACK
00002346  163C 0041               1992              MOVE.B  #'A',D3
0000234A  6100 1388               1993              BSR     PUSH_STACK
0000234E  163C 002E               1994              MOVE.B  #'.',D3
00002352  6100 1380               1995              BSR     PUSH_STACK
00002356  163C 004C               1996              MOVE.B  #'L',D3
0000235A  6100 1378               1997              BSR     PUSH_STACK
0000235E                          1998              
0000235E                          1999             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000235E  13FC 0000 00003FFA      2000             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002366  13FC 0000 00003FFB      2001             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000236E                          2002             
0000236E                          2003             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000236E  13FC 00B9 00003FFD      2004             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002376  13FC 0020 00003FFE      2005             MOVE.B   #$20,GET_SRC_START_END
0000237E                          2006  
0000237E                          2007              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000237E  0285 0000FE3F           2008              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002384  0685 00000040           2009              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000238A                          2010       
0000238A                          2011              *PRINT <EA>,AN
0000238A  6100 0AAA               2012              BSR     GET_EA_EA_SRC       *GETS <ea>
0000238E  163C 002C               2013              MOVE.B  #',',D3
00002392  6100 1340               2014              BSR     PUSH_STACK                     
00002396  6100 0ECE               2015              BSR     GET_EA_EA_DEST      *GETS Dn
0000239A                          2016  
0000239A                          2017              
0000239A                          2018              
0000239A  4E75                    2019              RTS
0000239C                          2020  OP1101_ADDA_W
0000239C                          2021              *LOAD STACK WITH THIS OPMODE
0000239C  6100 1336               2022              BSR     PUSH_STACK
000023A0  163C 0041               2023              MOVE.B  #'A',D3
000023A4  6100 132E               2024              BSR     PUSH_STACK
000023A8  163C 0044               2025              MOVE.B  #'D',D3
000023AC  6100 1326               2026              BSR     PUSH_STACK
000023B0  163C 0044               2027              MOVE.B  #'D',D3
000023B4  6100 131E               2028              BSR     PUSH_STACK
000023B8  163C 0041               2029              MOVE.B  #'A',D3
000023BC  6100 1316               2030              BSR     PUSH_STACK
000023C0  163C 002E               2031              MOVE.B  #'.',D3
000023C4  6100 130E               2032              BSR     PUSH_STACK
000023C8  163C 0057               2033              MOVE.B  #'W',D3
000023CC  6100 1306               2034              BSR     PUSH_STACK
000023D0                          2035              
000023D0                          2036             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023D0  13FC 0000 00003FFA      2037             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023D8  13FC 0000 00003FFB      2038             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023E0                          2039             
000023E0                          2040             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023E0  13FC 00B9 00003FFD      2041             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023E8  13FC 0020 00003FFE      2042             MOVE.B   #$20,GET_SRC_START_END
000023F0                          2043  
000023F0                          2044              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023F0  0285 0000FE3F           2045              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023F6  0685 00000040           2046              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023FC                          2047       
000023FC                          2048              *PRINT <EA>,AN
000023FC  6100 0A38               2049              BSR     GET_EA_EA_SRC       *GETS <ea>
00002400  163C 002C               2050              MOVE.B  #',',D3
00002404  6100 12CE               2051              BSR     PUSH_STACK                     
00002408  6100 0E5C               2052              BSR     GET_EA_EA_DEST      *GETS Dn
0000240C                          2053  
0000240C  4E75                    2054              RTS
0000240E                          2055  
0000240E                          2056  OP1101_DETERMINE_DN_EA_OR_EA_DN 
0000240E                          2057              *LOAD STACK WITH THIS OPMODE
0000240E  6100 12C4               2058              BSR     PUSH_STACK
00002412  163C 0041               2059              MOVE.B  #'A',D3
00002416  6100 12BC               2060              BSR     PUSH_STACK
0000241A  163C 0044               2061              MOVE.B  #'D',D3
0000241E  6100 12B4               2062              BSR     PUSH_STACK
00002422  163C 0044               2063              MOVE.B  #'D',D3
00002426  6100 12AC               2064              BSR     PUSH_STACK
0000242A  163C 002E               2065              MOVE.B  #'.',D3
0000242E  6100 12A4               2066              BSR     PUSH_STACK
00002432                          2067              
00002432  2205                    2068              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002434                          2069              
00002434                          2070              *BITS (INDEX 8) 
00002434                          2071              *0 = ADD.B/W/L <EA>,Dn
00002434                          2072              *1 = ADD.B/W/L Dn,<EA> 
00002434  E099                    2073              ROR.L   #8,D1
00002436  0281 00000001           2074              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000243C  0C81 00000000           2075              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002442  6700 0102               2076              BEQ     OP1101_EA_DN
00002446                          2077              *else procede to Dn_EA
00002446                          2078              
00002446                          2079  OP1101_DN_EA
00002446                          2080              *BITS (7 TO 6) 
00002446                          2081              *00 = .B
00002446                          2082              *01 = .W
00002446                          2083              *10 = .L 
00002446  2205                    2084              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002448  EC99                    2085              ROR.L   #6,D1
0000244A  0281 00000003           2086              ANDI.L  #$03,D1
00002450  0C81 00000000           2087              CMPI.L  #$00,D1 *EQUALS .B
00002456  6700 0016               2088              BEQ     OP1101_PRINT_B2
0000245A  0C81 00000001           2089              CMPI.L  #$01,D1 *EQUALS .W
00002460  6700 0054               2090              BEQ     OP1101_PRINT_W2
00002464  0C81 00000002           2091              CMPI.L  #$02,D1 *EQUALS .L
0000246A  6700 0092               2092              BEQ     OP1101_PRINT_L2
0000246E                          2093  OP1101_PRINT_B2
0000246E                          2094              *PUSH 'B'
0000246E  163C 0042               2095              MOVE.B  #'B',D3
00002472  6100 1260               2096              BSR     PUSH_STACK
00002476                          2097             
00002476                          2098              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002476  13FC 0002 00003FFA      2099             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000247E  13FC 0083 00003FFB      2100             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002486                          2101             
00002486                          2102             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002486  13FC 00B9 00003FFD      2103             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000248E  13FC 0020 00003FFE      2104             MOVE.B   #$20,GET_SRC_START_END
00002496                          2105  
00002496                          2106              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002496  0285 0000FE3F           2107              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000249C  0685 00000000           2108              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000024A2                          2109       
000024A2  6100 0DC2               2110              BSR     GET_EA_EA_DEST      *GETS Dn
000024A6  163C 002C               2111              MOVE.B  #',',D3
000024AA  6100 1228               2112              BSR     PUSH_STACK                     
000024AE  6100 0986               2113              BSR     GET_EA_EA_SRC       *GETS <ea>
000024B2                          2114  
000024B2                          2115              
000024B2  6000 0192               2116              BRA     OP1101_ADD_RETURN
000024B6                          2117  OP1101_PRINT_W2
000024B6  163C 0057               2118              MOVE.B  #'W',D3
000024BA  6100 1218               2119              BSR     PUSH_STACK
000024BE                          2120  
000024BE                          2121              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024BE  13FC 0000 00003FFA      2122              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024C6  13FC 0083 00003FFB      2123              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024CE                          2124             
000024CE                          2125              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024CE  13FC 00B9 00003FFD      2126              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024D6  13FC 0020 00003FFE      2127              MOVE.B   #$20,GET_SRC_START_END
000024DE                          2128  
000024DE                          2129              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024DE  0285 0000FE3F           2130              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024E4  0685 00000000           2131              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000024EA                          2132  
000024EA                          2133        
000024EA  6100 0D7A               2134              BSR     GET_EA_EA_DEST      *GETS Dn
000024EE  163C 002C               2135              MOVE.B  #',',D3
000024F2  6100 11E0               2136              BSR     PUSH_STACK               
000024F6  6100 093E               2137              BSR     GET_EA_EA_SRC       *GETS <ea>       
000024FA                          2138  
000024FA                          2139  
000024FA                          2140  
000024FA  6000 014A               2141              BRA     OP1101_ADD_RETURN
000024FE                          2142  OP1101_PRINT_L2 
000024FE  163C 004C               2143              MOVE.B  #'L',D3
00002502  6100 11D0               2144              BSR     PUSH_STACK
00002506                          2145              
00002506                          2146              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002506  13FC 0000 00003FFA      2147              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000250E  13FC 0083 00003FFB      2148              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002516                          2149             
00002516                          2150              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002516  13FC 00B9 00003FFD      2151              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000251E  13FC 0020 00003FFE      2152              MOVE.B   #$20,GET_SRC_START_END
00002526                          2153  
00002526                          2154             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002526  0285 0000FE3F           2155              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000252C  0685 00000000           2156              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002532                          2157  
00002532                          2158               
00002532  6100 0D32               2159              BSR     GET_EA_EA_DEST       *GETS Dn
00002536  163C 002C               2160              MOVE.B  #',',D3
0000253A  6100 1198               2161              BSR     PUSH_STACK          
0000253E  6100 08F6               2162              BSR     GET_EA_EA_SRC        *GETS <ea>
00002542                          2163  
00002542  6000 0102               2164              BRA     OP1101_ADD_RETURN
00002546                          2165              
00002546                          2166  OP1101_EA_DN           
00002546                          2167              *BITS (7 TO 6) 
00002546                          2168              *00 = .B
00002546                          2169              *01 = .W
00002546                          2170              *10 = .L 
00002546  2205                    2171              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002548  EC99                    2172              ROR.L   #6,D1
0000254A  0281 00000003           2173              ANDI.L  #$03,D1
00002550  0C81 00000000           2174              CMPI.L  #$00,D1 *EQUALS .B
00002556  6700 0016               2175              BEQ     OP1101_PRINT_B
0000255A  0C81 00000001           2176              CMPI.L  #$01,D1 *EQUALS .W
00002560  6700 0054               2177              BEQ     OP1101_PRINT_W
00002564  0C81 00000002           2178              CMPI.L  #$02,D1 *EQUALS .L
0000256A  6700 0092               2179              BEQ     OP1101_PRINT_L
0000256E                          2180  OP1101_PRINT_B
0000256E  163C 0042               2181              MOVE.B  #'B',D3
00002572  6100 1160               2182              BSR     PUSH_STACK
00002576                          2183                
00002576                          2184              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002576  13FC 0002 00003FFA      2185              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000257E  13FC 0002 00003FFB      2186              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002586                          2187             
00002586                          2188              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002586  13FC 00B9 00003FFD      2189              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000258E  13FC 0020 00003FFE      2190              MOVE.B   #$20,GET_SRC_START_END
00002596                          2191  
00002596                          2192             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002596  0285 0000FE3F           2193              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000259C  0685 00000000           2194              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000025A2                          2195  
000025A2                          2196              
000025A2  6100 0892               2197              BSR     GET_EA_EA_SRC      *GETS <ea>
000025A6  163C 002C               2198              MOVE.B  #',',D3
000025AA  6100 1128               2199              BSR     PUSH_STACK          
000025AE  6100 0CB6               2200              BSR     GET_EA_EA_DEST       *GETS Dn
000025B2                          2201              
000025B2  6000 0092               2202              BRA     OP1101_ADD_RETURN
000025B6                          2203  OP1101_PRINT_W
000025B6  163C 0057               2204              MOVE.B  #'W',D3
000025BA  6100 1118               2205              BSR     PUSH_STACK
000025BE                          2206  
000025BE                          2207              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025BE  13FC 0000 00003FFA      2208              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000025C6  13FC 0000 00003FFB      2209              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000025CE                          2210             
000025CE                          2211              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025CE  13FC 00B9 00003FFD      2212              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000025D6  13FC 0020 00003FFE      2213              MOVE.B   #$20,GET_SRC_START_END
000025DE                          2214  
000025DE                          2215             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025DE  0285 0000FE3F           2216              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000025E4  0685 00000000           2217              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000025EA                          2218  
000025EA                          2219              
000025EA  6100 084A               2220              BSR     GET_EA_EA_SRC      *GETS <ea>
000025EE  163C 002C               2221              MOVE.B  #',',D3
000025F2  6100 10E0               2222              BSR     PUSH_STACK
000025F6  6100 0C6E               2223              BSR     GET_EA_EA_DEST       *GETS Dn    
000025FA                          2224              
000025FA  6000 004A               2225              BRA     OP1101_ADD_RETURN
000025FE                          2226  OP1101_PRINT_L 
000025FE  163C 004C               2227              MOVE.B  #'L',D3
00002602  6100 10D0               2228              BSR     PUSH_STACK
00002606                          2229              
00002606                          2230              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002606  13FC 0000 00003FFA      2231              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000260E  13FC 0000 00003FFB      2232              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002616                          2233             
00002616                          2234              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002616  13FC 00B9 00003FFD      2235              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000261E  13FC 0020 00003FFE      2236              MOVE.B   #$20,GET_SRC_START_END
00002626                          2237  
00002626                          2238              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002626  0285 0000FE3F           2239              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000262C  0685 00000000           2240              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002632                          2241  
00002632                          2242                     
00002632  6100 0802               2243              BSR     GET_EA_EA_SRC      *GETS <ea>
00002636  163C 002C               2244              MOVE.B  #',',D3
0000263A  6100 1098               2245              BSR     PUSH_STACK                  
0000263E  6100 0C26               2246              BSR     GET_EA_EA_DEST       *GETS Dn    
00002642                          2247  
00002642                          2248              
00002642  6000 0002               2249              BRA     OP1101_ADD_RETURN
00002646                          2250              
00002646                          2251  OP1101_ADD_RETURN
00002646  4E75                    2252              RTS
00002648                          2253              
00002648                          2254              *ADDW
00002648  0C01 0006               2255              CMPI.B  #$6,D1
0000264C  6700 0056               2256              BEQ     OP_ADDA_W
00002650  0C01 000E               2257              CMPI.B  #$E,D1
00002654  6700 0066               2258              BEQ     OP_ADDA_L 
00002658                          2259  
00002658  4EF8 14A6               2260              JMP     OP_DATA  
0000265C                          2261            
0000265C                          2262  *---------------------------------------------------------------------------*
0000265C                          2263  * OP_ADD: display ADD and proceed to EA
0000265C                          2264  *---------------------------------------------------------------------------*  
0000265C  43F9 00003EB1           2265  OP_ADD_B    LEA     DISP_ADD_B,A1
00002662  103C 000E               2266              MOVE.B  #14,D0
00002666  4E4F                    2267              TRAP    #15
00002668  183C 0000               2268              MOVE.B  #0,D4
0000266C  4EF9 000029E6           2269              JMP     EA_GEN
00002672                          2270  
00002672  4E75                    2271              RTS
00002674                          2272  
00002674  43F9 00003EBA           2273  OP_ADD_W    LEA     DISP_ADD_W,A1
0000267A  103C 000E               2274              MOVE.B  #14,D0
0000267E  4E4F                    2275              TRAP    #15
00002680  183C 0001               2276              MOVE.B  #1,D4
00002684  4EF9 000029E6           2277              JMP     EA_GEN
0000268A                          2278  
0000268A  4E75                    2279              RTS
0000268C                          2280  
0000268C  43F9 00003EC3           2281  OP_ADD_L    LEA     DISP_ADD_L,A1
00002692  103C 000E               2282              MOVE.B  #14,D0
00002696  4E4F                    2283              TRAP    #15
00002698  183C 0002               2284              MOVE.B  #2,D4
0000269C  4EF9 000029E6           2285              JMP     EA_GEN
000026A2                          2286  
000026A2  4E75                    2287              RTS
000026A4                          2288  
000026A4                          2289  *---------------------------------------------------------------------------*
000026A4                          2290  * OP_ADDA: display ADDA and proceed to EA
000026A4                          2291  *---------------------------------------------------------------------------*  
000026A4  43F9 00003ECC           2292  OP_ADDA_W   LEA     DISP_ADDA_W,A1
000026AA  103C 000E               2293              MOVE.B  #14,D0
000026AE  4E4F                    2294              TRAP    #15
000026B0  183C 0001               2295              MOVE.B  #1,D4
000026B4  4EF9 000029E6           2296              JMP     EA_GEN
000026BA                          2297  
000026BA  4E75                    2298              RTS
000026BC                          2299  
000026BC  43F9 00003ED6           2300  OP_ADDA_L   LEA     DISP_ADDA_L,A1
000026C2  103C 000E               2301              MOVE.B  #14,D0
000026C6  4E4F                    2302              TRAP    #15
000026C8  183C 0002               2303              MOVE.B  #2,D4
000026CC  4EF9 000029E6           2304              JMP     EA_GEN
000026D2                          2305  
000026D2  4E75                    2306              RTS
000026D4                          2307              
000026D4                          2308  *---------------------------------------------------------------------------*
000026D4                          2309  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
000026D4                          2310  *---------------------------------------------------------------------------* 
000026D4  4280                    2311  OP1110      CLR.L   D0                  
000026D6  4281                    2312              CLR.L   D1   
000026D8  4284                    2313              CLR.L   D4                   
000026DA  227C 00000000           2314              MOVEA.L #0, A1                 
000026E0  2205                    2315              MOVE.L  D5,D1
000026E2                          2316              
000026E2                          2317              * check for LSX
000026E2  E699                    2318              ROR.L   #3,D1
000026E4  0281 00000001           2319              ANDI.L  #$1,D1
000026EA  0C01 0001               2320              CMPI.B  #1,D1
000026EE  6700 002E               2321              BEQ     OP_LSX
000026F2                          2322              
000026F2                          2323              * reset D1 and check for ASX
000026F2  4281                    2324              CLR.L   D1
000026F4  2205                    2325              MOVE.L  D5,D1
000026F6  E699                    2326              ROR.L   #3,D1
000026F8  0281 00000001           2327              ANDI.L  #$1,D1
000026FE  0C01 0000               2328              CMPI.B  #0,D1
00002702  6700 0032               2329              BEQ     OP_ASX
00002706                          2330  
00002706                          2331              * reset D1 and check for ROX
00002706  4281                    2332              CLR.L   D1
00002708  2205                    2333              MOVE.L  D5,D1
0000270A  E699                    2334              ROR.L   #3,D1
0000270C  0281 00000001           2335              ANDI.L  #$1,D1
00002712  0C01 0003               2336              CMPI.B  #3,D1
00002716  6700 0036               2337              BEQ     OP_ROX
0000271A                          2338              
0000271A  4EF8 14A6               2339              JMP     OP_DATA
0000271E                          2340  
0000271E                          2341  *---------------------------------------------------------------------------*
0000271E                          2342  * OP_LSX: process LSR/LSL
0000271E                          2343  *---------------------------------------------------------------------------*            
0000271E  EA99                    2344  OP_LSX      ROR.L   #5,D1
00002720  0281 00000001           2345              ANDI.L  #$1,D1
00002726  0C01 0000               2346              CMPI.B  #0,D1
0000272A  6700 003A               2347              BEQ     OP_LSR
0000272E  0C01 0001               2348              CMPI.B  #1,D1
00002732  6700 008C               2349              BEQ     OP_LSL
00002736                          2350              
00002736                          2351  *---------------------------------------------------------------------------*
00002736                          2352  * OP_ASX: process ASR/ASL
00002736                          2353  *---------------------------------------------------------------------------*  
00002736  EA99                    2354  OP_ASX      ROR.L   #5,D1
00002738  0281 00000001           2355              ANDI.L  #$1,D1
0000273E  0C01 0000               2356              CMPI.B  #0,D1
00002742  6700 00D6               2357              BEQ     OP_ASR
00002746  0C01 0001               2358              CMPI.B  #1,D1
0000274A  6700 0128               2359              BEQ     OP_ASL
0000274E                          2360              
0000274E                          2361  *---------------------------------------------------------------------------*
0000274E                          2362  * OP_ROX: process ROR/ROL
0000274E                          2363  *---------------------------------------------------------------------------*  
0000274E  EA99                    2364  OP_ROX      ROR.L   #5,D1
00002750  0281 00000001           2365              ANDI.L  #$1,D1
00002756  0C01 0000               2366              CMPI.B  #0,D1
0000275A  6700 0172               2367              BEQ     OP_ROR
0000275E  0C01 0001               2368              CMPI.B  #1,D1
00002762  6700 01C4               2369              BEQ     OP_ROL
00002766                          2370  
00002766                          2371  *---------------------------------------------------------------------------*
00002766                          2372  * OP_LSR: decode and display LSR
00002766                          2373  *---------------------------------------------------------------------------*        
00002766  E599                    2374  OP_LSR      ROL.L   #2,D1
00002768  0281 00000003           2375              ANDI.L  #$3,D1
0000276E  0C01 0000               2376              CMPI.B  #0,D1
00002772  6700 0016               2377              BEQ     OP_LSR_B
00002776  0C01 0001               2378              CMPI.B  #$1,D1
0000277A  6700 0032               2379              BEQ     OP_LSR_W
0000277E  0C01 0002               2380              CMPI.B  #$2,D1
00002782  6700 0018               2381              BEQ     OP_LSR_L
00002786                          2382              
00002786  4EF8 14A6               2383              JMP     OP_DATA
0000278A                          2384  
0000278A  43F9 00003EE0           2385  OP_LSR_B    LEA     DISP_LSR_B,A1
00002790  103C 000E               2386              MOVE.B  #14,D0
00002794  4E4F                    2387              TRAP    #15
00002796  183C 0000               2388              MOVE.B  #0,D4
0000279A  4E75                    2389              RTS
0000279C                          2390  
0000279C  43F9 00003F04           2391  OP_LSR_L    LEA     DISP_LSR_L,A1
000027A2  103C 000E               2392              MOVE.B  #14,D0
000027A6  4E4F                    2393              TRAP    #15
000027A8  183C 0002               2394              MOVE.B  #2,D4
000027AC  4E75                    2395              RTS
000027AE                          2396  
000027AE  43F9 00003EF2           2397  OP_LSR_W    LEA     DISP_LSR_W,A1
000027B4  103C 000E               2398              MOVE.B  #14,D0
000027B8  4E4F                    2399              TRAP    #15
000027BA  183C 0001               2400              MOVE.B  #1,D4
000027BE  4E75                    2401              RTS
000027C0                          2402   
000027C0                          2403  *---------------------------------------------------------------------------*
000027C0                          2404  * OP_LSL: decode and display LSL
000027C0                          2405  *---------------------------------------------------------------------------*             
000027C0  E599                    2406  OP_LSL      ROL.L   #2,D1
000027C2  0281 00000003           2407              ANDI.L  #$3,D1
000027C8  0C01 0000               2408              CMPI.B  #0,D1
000027CC  6700 0016               2409              BEQ     OP_LSL_B
000027D0  0C01 0001               2410              CMPI.B  #$1,D1
000027D4  6700 0032               2411              BEQ     OP_LSL_W
000027D8  0C01 0002               2412              CMPI.B  #$2,D1
000027DC  6700 0018               2413              BEQ     OP_LSL_L
000027E0                          2414              
000027E0  4EF8 14A6               2415              JMP OP_DATA
000027E4                          2416  
000027E4  43F9 00003EE9           2417  OP_LSL_B    LEA     DISP_LSL_B,A1
000027EA  103C 000E               2418              MOVE.B  #14,D0
000027EE  4E4F                    2419              TRAP    #15
000027F0  183C 0000               2420              MOVE.B  #0,D4
000027F4  4E75                    2421              RTS
000027F6                          2422  
000027F6  43F9 00003F0D           2423  OP_LSL_L    LEA     DISP_LSL_L,A1
000027FC  103C 000E               2424              MOVE.B  #14,D0
00002800  4E4F                    2425              TRAP    #15
00002802  183C 0002               2426              MOVE.B  #2,D4
00002806  4E75                    2427              RTS
00002808                          2428  
00002808  43F9 00003EFB           2429  OP_LSL_W    LEA     DISP_LSL_W,A1
0000280E  103C 000E               2430              MOVE.B  #14,D0
00002812  4E4F                    2431              TRAP    #15
00002814  183C 0001               2432              MOVE.B  #1,D4
00002818  4E75                    2433              RTS
0000281A                          2434   
0000281A                          2435  *---------------------------------------------------------------------------*
0000281A                          2436  * OP_ASR: decode and display ASR
0000281A                          2437  *---------------------------------------------------------------------------*             
0000281A  E599                    2438  OP_ASR      ROL.L   #2,D1
0000281C  0281 00000003           2439              ANDI.L  #$3,D1
00002822  0C01 0000               2440              CMPI.B  #0,D1
00002826  6700 0016               2441              BEQ     OP_ASR_B
0000282A  0C01 0001               2442              CMPI.B  #$1,D1
0000282E  6700 0032               2443              BEQ     OP_ASR_W
00002832  0C01 0002               2444              CMPI.B  #$2,D1
00002836  6700 0018               2445              BEQ     OP_ASR_L
0000283A                          2446              
0000283A  4EF8 14A6               2447              JMP OP_DATA
0000283E                          2448  
0000283E  43F9 00003F16           2449  OP_ASR_B    LEA     DISP_ASR_B,A1
00002844  103C 000E               2450              MOVE.B  #14,D0
00002848  4E4F                    2451              TRAP    #15
0000284A  183C 0000               2452              MOVE.B  #0,D4
0000284E  4E75                    2453              RTS
00002850                          2454  
00002850  43F9 00003F3A           2455  OP_ASR_L    LEA     DISP_ASR_L,A1
00002856  103C 000E               2456              MOVE.B  #14,D0
0000285A  4E4F                    2457              TRAP    #15
0000285C  183C 0002               2458              MOVE.B  #2,D4
00002860  4E75                    2459              RTS
00002862                          2460  
00002862  43F9 00003F28           2461  OP_ASR_W    LEA     DISP_ASR_W,A1
00002868  103C 000E               2462              MOVE.B  #14,D0
0000286C  4E4F                    2463              TRAP    #15
0000286E  183C 0001               2464              MOVE.B  #1,D4
00002872  4E75                    2465              RTS
00002874                          2466       
00002874                          2467  *---------------------------------------------------------------------------*
00002874                          2468  * OP_ASL: decode and display ASL
00002874                          2469  *---------------------------------------------------------------------------*         
00002874  E599                    2470  OP_ASL      ROL.L   #2,D1
00002876  0281 00000003           2471              ANDI.L  #$3,D1
0000287C  0C01 0000               2472              CMPI.B  #0,D1
00002880  6700 0016               2473              BEQ     OP_ASL_B
00002884  0C01 0001               2474              CMPI.B  #$1,D1
00002888  6700 0032               2475              BEQ     OP_ASL_W
0000288C  0C01 0002               2476              CMPI.B  #$2,D1
00002890  6700 0018               2477              BEQ     OP_ASL_L
00002894                          2478              
00002894  4EF8 14A6               2479              JMP OP_DATA
00002898                          2480  
00002898  43F9 00003F1F           2481  OP_ASL_B    LEA     DISP_ASL_B,A1
0000289E  103C 000E               2482              MOVE.B  #14,D0
000028A2  4E4F                    2483              TRAP    #15
000028A4  183C 0000               2484              MOVE.B  #0,D4
000028A8  4E75                    2485              RTS
000028AA                          2486  
000028AA  43F9 00003F43           2487  OP_ASL_L    LEA     DISP_ASL_L,A1
000028B0  103C 000E               2488              MOVE.B  #14,D0
000028B4  4E4F                    2489              TRAP    #15
000028B6  183C 0002               2490              MOVE.B  #2,D4
000028BA  4E75                    2491              RTS
000028BC                          2492  
000028BC  43F9 00003F31           2493  OP_ASL_W    LEA     DISP_ASL_W,A1
000028C2  103C 000E               2494              MOVE.B  #14,D0
000028C6  4E4F                    2495              TRAP    #15
000028C8  183C 0001               2496              MOVE.B  #1,D4
000028CC  4E75                    2497              RTS
000028CE                          2498   
000028CE                          2499  *---------------------------------------------------------------------------*
000028CE                          2500  * OP_ROR: decode and display ROR
000028CE                          2501  *---------------------------------------------------------------------------*             
000028CE  E599                    2502  OP_ROR      ROL.L   #2,D1
000028D0  0281 00000003           2503              ANDI.L  #$3,D1
000028D6  0C01 0000               2504              CMPI.B  #0,D1
000028DA  6700 0016               2505              BEQ     OP_ROR_B
000028DE  0C01 0001               2506              CMPI.B  #$1,D1
000028E2  6700 0032               2507              BEQ     OP_ROR_W
000028E6  0C01 0002               2508              CMPI.B  #$2,D1
000028EA  6700 0018               2509              BEQ     OP_ROR_L
000028EE                          2510              
000028EE  4EF8 14A6               2511              JMP OP_DATA
000028F2                          2512  
000028F2  43F9 00003F4C           2513  OP_ROR_B    LEA     DISP_ROR_B,A1
000028F8  103C 000E               2514              MOVE.B  #14,D0
000028FC  4E4F                    2515              TRAP    #15
000028FE  183C 0000               2516              MOVE.B  #0,D4
00002902  4E75                    2517              RTS
00002904                          2518  
00002904  43F9 00003F70           2519  OP_ROR_L    LEA     DISP_ROR_L,A1
0000290A  103C 000E               2520              MOVE.B  #14,D0
0000290E  4E4F                    2521              TRAP    #15
00002910  183C 0002               2522              MOVE.B  #2,D4
00002914  4E75                    2523              RTS
00002916                          2524  
00002916  43F9 00003F5E           2525  OP_ROR_W    LEA     DISP_ROR_W,A1
0000291C  103C 000E               2526              MOVE.B  #14,D0
00002920  4E4F                    2527              TRAP    #15
00002922  183C 0001               2528              MOVE.B  #1,D4
00002926  4E75                    2529              RTS
00002928                          2530  
00002928                          2531  *---------------------------------------------------------------------------*
00002928                          2532  * OP_ROL: decode and display ROL
00002928                          2533  *---------------------------------------------------------------------------*             
00002928  E599                    2534  OP_ROL      ROL.L   #2,D1
0000292A  0281 00000003           2535              ANDI.L  #$3,D1
00002930  0C01 0000               2536              CMPI.B  #0,D1
00002934  6700 0016               2537              BEQ     OP_ROL_B
00002938  0C01 0001               2538              CMPI.B  #$1,D1
0000293C  6700 0032               2539              BEQ     OP_ROL_W
00002940  0C01 0002               2540              CMPI.B  #$2,D1
00002944  6700 0018               2541              BEQ     OP_ROL_L
00002948                          2542              
00002948  4EF8 14A6               2543              JMP OP_DATA
0000294C                          2544  
0000294C                          2545  
0000294C  43F9 00003F55           2546  OP_ROL_B    LEA     DISP_ROL_B,A1
00002952  103C 000E               2547              MOVE.B  #14,D0
00002956  4E4F                    2548              TRAP    #15
00002958  183C 0000               2549              MOVE.B  #0,D4
0000295C  4E75                    2550              RTS
0000295E                          2551  
0000295E  43F9 00003F79           2552  OP_ROL_L    LEA     DISP_ROL_L,A1
00002964  103C 000E               2553              MOVE.B  #14,D0
00002968  4E4F                    2554              TRAP    #15
0000296A  183C 0002               2555              MOVE.B  #2,D4
0000296E  4E75                    2556              RTS
00002970                          2557  
00002970  43F9 00003F67           2558  OP_ROL_W    LEA     DISP_ROL_W,A1
00002976  103C 000E               2559              MOVE.B  #14,D0
0000297A  4E4F                    2560              TRAP    #15
0000297C  183C 0001               2561              MOVE.B  #1,D4
00002980  4E75                    2562              RTS
00002982                          2563              
00002982                          2564  *---------------------------------------------------------------------------*
00002982                          2565  * OP1111 : Special reserved
00002982                          2566  *---------------------------------------------------------------------------*           
00002982  4EF8 14A6               2567  OP1111      JMP     OP_DATA
00002986                          2568  
00002986                          2569  *---------------------------------------------------------------------------*
00002986                          2570  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00002986                          2571  *---------------------------------------------------------------------------*
00002986                          2572  EA_NOSRC    
00002986  4EB9 00002A44           2573              JSR     SRC_MODE
0000298C  43F9 00003C46           2574              LEA     ENDLINE_M,A1
00002992  103C 000E               2575              MOVE.B  #14,D0
00002996  4E4F                    2576              TRAP    #15
00002998  4E75                    2577              RTS
0000299A                          2578              
0000299A                          2579  *---------------------------------------------------------------------------*
0000299A                          2580  * EA_ARITH: decode and display effective addresses for DIVS/MULS
0000299A                          2581  *---------------------------------------------------------------------------*
0000299A                          2582  EA_ARITH
0000299A  4EB9 00002A44           2583              JSR     SRC_MODE
000029A0  43F9 00003FC0           2584              LEA     DISP_D,A1
000029A6  103C 000E               2585              MOVE.B  #14,D0
000029AA  4E4F                    2586              TRAP    #15
000029AC  4EB9 00002CD0           2587              JSR     DEST_REGISTER
000029B2  43F9 00003C46           2588              LEA     ENDLINE_M,A1
000029B8  103C 000E               2589              MOVE.B  #14,D0
000029BC  4E4F                    2590              TRAP    #15
000029BE  4E75                    2591              RTS
000029C0                          2592              
000029C0                          2593  *---------------------------------------------------------------------------*
000029C0                          2594  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000029C0                          2595  *---------------------------------------------------------------------------*
000029C0                          2596  EA_MOVEA
000029C0  4EB9 00002A44           2597              JSR     SRC_MODE
000029C6  43F9 00003FD1           2598              LEA     DISP_AOP,A1
000029CC  103C 000E               2599              MOVE.B  #14,D0
000029D0  4E4F                    2600              TRAP    #15
000029D2  4EB9 00002CD0           2601              JSR     DEST_REGISTER
000029D8  43F9 00003FCF           2602              LEA     DISP_CP,A1
000029DE  103C 000D               2603              MOVE.B  #13,D0
000029E2  4E4F                    2604              TRAP    #15
000029E4  4E75                    2605              RTS
000029E6                          2606              
000029E6                          2607  *---------------------------------------------------------------------------*
000029E6                          2608  * EA_GEN: decode and display effective addresses for MOVE
000029E6                          2609  *---------------------------------------------------------------------------*
000029E6                          2610  EA_GEN          
000029E6                          2611              * retrieve/display source mode/register
000029E6  4EB9 00002A44           2612              JSR     SRC_MODE
000029EC                          2613              
000029EC                          2614              * retrieve/display destination mode/register
000029EC  4EB9 00002A00           2615              JSR     DEST_MODE
000029F2                          2616              
000029F2  43F9 00003C46           2617              LEA     ENDLINE_M,A1
000029F8  103C 000E               2618              MOVE.B  #14,D0
000029FC  4E4F                    2619              TRAP    #15
000029FE                          2620              
000029FE  4E75                    2621              RTS
00002A00                          2622  
00002A00                          2623  *---------------------------------------------------------------------------*
00002A00                          2624  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00002A00                          2625  *---------------------------------------------------------------------------*           
00002A00                          2626  DEST_MODE   
00002A00                          2627              * clear registers to store temp data
00002A00  4280                    2628              CLR.L   D0                      
00002A02  4281                    2629              CLR.L   D1                      
00002A04  207C 00000000           2630              MOVEA.L #0, A0                  
00002A0A  227C 00000000           2631              MOVEA.L #0, A1                  
00002A10  2205                    2632              MOVE.L  D5,D1
00002A12  EC89                    2633              LSR.L   #6,D1
00002A14  0281 00000007           2634              ANDI.L  #$7,D1
00002A1A  0C01 0000               2635              CMPI.B  #0,D1   * Dn
00002A1E  6700 0082               2636              BEQ     D_MODE000
00002A22  0C01 0002               2637              CMPI.B  #2,D1   * (An)
00002A26  6700 00C2               2638              BEQ     D_MODE010
00002A2A  0C01 0003               2639              CMPI.B  #3,D1   * (An)+
00002A2E  6700 011A               2640              BEQ     D_MODE011
00002A32  0C01 0004               2641              CMPI.B  #4,D1   * -(An)
00002A36  6700 0132               2642              BEQ     D_MODE100
00002A3A  0C01 0007               2643              CMPI.B  #7,D1  * abs
00002A3E  6700 017C               2644              BEQ     D_MODE111 
00002A42  4E75                    2645              RTS
00002A44                          2646  
00002A44                          2647  *---------------------------------------------------------------------------*
00002A44                          2648  * SRC_MODE: decode and display source mode (bit 5 - 3)
00002A44                          2649  *---------------------------------------------------------------------------*  
00002A44                          2650  SRC_MODE    
00002A44                          2651              * clear registers to store temp data
00002A44  4280                    2652              CLR.L   D0                      
00002A46  4281                    2653              CLR.L   D1                      
00002A48  207C 00000000           2654              MOVEA.L #0, A0                  
00002A4E  227C 00000000           2655              MOVEA.L #0, A1                  
00002A54  2205                    2656              MOVE.L  D5,D1
00002A56  E489                    2657              LSR.L   #2,D1
00002A58  0281 0000000E           2658              ANDI.L  #$E,D1
00002A5E                          2659              
00002A5E  0C01 0000               2660              CMPI.B  #0,D1   * Dn
00002A62  6700 002A               2661              BEQ     MODE000
00002A66  0C01 0002               2662              CMPI.B  #2,D1   * An 
00002A6A  6700 004A               2663              BEQ     MODE001
00002A6E  0C01 0004               2664              CMPI.B  #4,D1   * (An)
00002A72  6700 0056               2665              BEQ     MODE010
00002A76  0C01 0006               2666              CMPI.B  #6,D1   * (An)+
00002A7A  6700 008E               2667              BEQ     MODE011
00002A7E  0C01 0008               2668              CMPI.B  #8,D1   * -(An)
00002A82  6700 00A6               2669              BEQ     MODE100
00002A86  0C01 000F               2670              CMPI.B  #15,D1  * abs/immediate
00002A8A  6700 00FE               2671              BEQ     MODE111 
00002A8E                          2672        
00002A8E                          2673  *---------------------------------------------------------------------------*
00002A8E                          2674  * MODE000: decode and display source mode Dn
00002A8E                          2675  *---------------------------------------------------------------------------*           
00002A8E                          2676  MODE000     *Dn
00002A8E  43F9 00003FC0           2677              LEA     DISP_D,A1
00002A94  103C 000E               2678              MOVE.B  #14,D0
00002A98  4E4F                    2679              TRAP    #15
00002A9A  4EB9 00002D2C           2680              JSR     SRC_REGISTER
00002AA0  4E75                    2681              RTS
00002AA2                          2682  
00002AA2                          2683  *---------------------------------------------------------------------------*
00002AA2                          2684  * D_MODE000: decode and display dest mode Dn
00002AA2                          2685  *---------------------------------------------------------------------------*
00002AA2                          2686  D_MODE000     *Dn
00002AA2  43F9 00003FC0           2687              LEA     DISP_D,A1
00002AA8  103C 000E               2688              MOVE.B  #14,D0
00002AAC  4E4F                    2689              TRAP    #15
00002AAE  4EB9 00002CD0           2690              JSR     DEST_REGISTER
00002AB4  4E75                    2691              RTS
00002AB6                          2692  
00002AB6                          2693  *---------------------------------------------------------------------------*
00002AB6                          2694  * MODE001: decode and display source mode An
00002AB6                          2695  *---------------------------------------------------------------------------* 
00002AB6                          2696  MODE001 *An
00002AB6  43F9 00003FC5           2697              LEA     DISP_A,A1
00002ABC  103C 000E               2698              MOVE.B  #14,D0
00002AC0  4E4F                    2699              TRAP    #15
00002AC2  4EB9 00002D2C           2700              JSR     SRC_REGISTER
00002AC8                          2701          
00002AC8  4E75                    2702              RTS
00002ACA                          2703  
00002ACA                          2704  *---------------------------------------------------------------------------*
00002ACA                          2705  * MODE010: decode and display source mode (An)
00002ACA                          2706  *---------------------------------------------------------------------------*    
00002ACA                          2707  MODE010 *(An)
00002ACA  43F9 00003FD1           2708              LEA     DISP_AOP,A1  *display (A
00002AD0  103C 000E               2709              MOVE.B  #14,D0
00002AD4  4E4F                    2710              TRAP    #15
00002AD6                          2711  
00002AD6  4EB9 00002D2C           2712              JSR     SRC_REGISTER * display register
00002ADC                          2713  
00002ADC  43F9 00003FCF           2714              LEA     DISP_CP,A1   *display )
00002AE2  103C 000E               2715              MOVE.B  #14,D0
00002AE6  4E4F                    2716              TRAP    #15
00002AE8                          2717              
00002AE8  4E75                    2718              RTS
00002AEA                          2719  
00002AEA                          2720  *---------------------------------------------------------------------------*
00002AEA                          2721  * D_MODE010: decode and display dest mode (An)
00002AEA                          2722  *---------------------------------------------------------------------------*
00002AEA                          2723  D_MODE010 *(An)
00002AEA  43F9 00003FD1           2724              LEA     DISP_AOP,A1  *display (A
00002AF0  103C 000E               2725              MOVE.B  #14,D0
00002AF4  4E4F                    2726              TRAP    #15
00002AF6                          2727     
00002AF6  4EB9 00002CD0           2728              JSR     DEST_REGISTER * display register
00002AFC                          2729  
00002AFC  43F9 00003FCF           2730              LEA     DISP_CP,A1   *display )
00002B02  103C 000E               2731              MOVE.B  #14,D0
00002B06  4E4F                    2732              TRAP    #15
00002B08                          2733              
00002B08  4E75                    2734              RTS
00002B0A                          2735  
00002B0A                          2736  *---------------------------------------------------------------------------*
00002B0A                          2737  * MODE011: decode and display source mode (An)+
00002B0A                          2738  *---------------------------------------------------------------------------*
00002B0A                          2739  MODE011 *(An)+
00002B0A  43F9 00003FD1           2740              LEA     DISP_AOP,A1      *display (A
00002B10  103C 000E               2741              MOVE.B  #14,D0
00002B14  4E4F                    2742              TRAP    #15
00002B16                          2743              
00002B16  4EB9 00002D2C           2744              JSR     SRC_REGISTER    * display register
00002B1C                          2745  
00002B1C  43F9 00003FDE           2746              LEA     DISP_POST,A1    *display )+
00002B22  103C 000E               2747              MOVE.B  #14,D0
00002B26  4E4F                    2748              TRAP    #15
00002B28                          2749              
00002B28  4E75                    2750              RTS
00002B2A                          2751              
00002B2A                          2752  *---------------------------------------------------------------------------*
00002B2A                          2753  * MODE100: decode and display source mode -(An)
00002B2A                          2754  *---------------------------------------------------------------------------*
00002B2A                          2755  MODE100 *-(An)
00002B2A  43F9 00003FD7           2756              LEA     DISP_PRE,A1    *display -(A
00002B30  103C 000E               2757              MOVE.B  #14,D0
00002B34  4E4F                    2758              TRAP    #15
00002B36                          2759  
00002B36  4EB9 00002D2C           2760              JSR     SRC_REGISTER    *display register
00002B3C                          2761  
00002B3C  43F9 00003FCF           2762              LEA     DISP_CP,A1   *display )
00002B42  103C 000E               2763              MOVE.B  #14,D0
00002B46  4E4F                    2764              TRAP    #15
00002B48                          2765              
00002B48  4E75                    2766              RTS
00002B4A                          2767  
00002B4A                          2768  *---------------------------------------------------------------------------*
00002B4A                          2769  * D_MODE011: decode and display dest mode (An)+
00002B4A                          2770  *---------------------------------------------------------------------------*
00002B4A                          2771  D_MODE011 *(An)+
00002B4A  43F9 00003FD1           2772              LEA     DISP_AOP,A1      *display (A
00002B50  103C 000E               2773              MOVE.B  #14,D0
00002B54  4E4F                    2774              TRAP    #15
00002B56                          2775  
00002B56  4EB9 00002CD0           2776              JSR     DEST_REGISTER    * display register
00002B5C                          2777  
00002B5C  43F9 00003FDE           2778              LEA     DISP_POST,A1    *display )+
00002B62  103C 000E               2779              MOVE.B  #14,D0
00002B66  4E4F                    2780              TRAP    #15
00002B68                          2781              
00002B68  4E75                    2782              RTS
00002B6A                          2783              
00002B6A                          2784  *---------------------------------------------------------------------------*
00002B6A                          2785  * D_MODE100: decode and display dest mode -(An)
00002B6A                          2786  *---------------------------------------------------------------------------*            
00002B6A                          2787  D_MODE100 *-(An)
00002B6A  43F9 00003FD7           2788              LEA     DISP_PRE,A1    *display -(A
00002B70  103C 000E               2789              MOVE.B  #14,D0
00002B74  4E4F                    2790              TRAP    #15
00002B76                          2791              
00002B76  4EB9 00002CD0           2792              JSR     DEST_REGISTER    *display register
00002B7C                          2793  
00002B7C  43F9 00003FCF           2794              LEA     DISP_CP,A1   *display )
00002B82  103C 000E               2795              MOVE.B  #14,D0
00002B86  4E4F                    2796              TRAP    #15
00002B88                          2797              
00002B88  4E75                    2798              RTS
00002B8A                          2799  
00002B8A                          2800  *---------------------------------------------------------------------------*
00002B8A                          2801  * MODE111: decode and display source mode absolute/immediate
00002B8A                          2802  *---------------------------------------------------------------------------*
00002B8A                          2803  MODE111     * abs/immediate
00002B8A                          2804              * clear registers to store temp data
00002B8A  4280                    2805              CLR.L   D0                      
00002B8C  4281                    2806              CLR.L   D1                      
00002B8E  207C 00000000           2807              MOVEA.L #0, A0                  
00002B94  227C 00000000           2808              MOVEA.L #0, A1                  
00002B9A  2205                    2809              MOVE.L  D5,D1
00002B9C                          2810              
00002B9C                          2811              * retrieve source register for MODE 111
00002B9C  E389                    2812              LSL.L   #1,D1   * shift the bits to left by 1
00002B9E  0281 0000000E           2813              ANDI.L  #$E,D1  * mask the first 4 bits 
00002BA4  0C01 0000               2814              CMPI.B  #0, D1  * if it's 0000, absolute word address
00002BA8  6700 003E               2815              BEQ     WORDMODE
00002BAC  0C01 0002               2816              CMPI.B  #2, D1  * if it's 0010, absolute long address
00002BB0  6700 0062               2817              BEQ     LONGMODE
00002BB4  0C01 0008               2818              CMPI.B  #8, D1  * if it's 1000, immediate data
00002BB8  6700 0086               2819              BEQ     IMMEDIATE
00002BBC                          2820       
00002BBC                          2821  *---------------------------------------------------------------------------*
00002BBC                          2822  * D_MODE111: decode and display dest mode absolute/immediate
00002BBC                          2823  *---------------------------------------------------------------------------*           
00002BBC                          2824  D_MODE111   * abs
00002BBC                          2825              * clear registers to store temp data
00002BBC  4280                    2826              CLR.L   D0                      
00002BBE  4281                    2827              CLR.L   D1                      
00002BC0  207C 00000000           2828              MOVEA.L #0, A0                  
00002BC6  227C 00000000           2829              MOVEA.L #0, A1                  
00002BCC  2205                    2830              MOVE.L  D5,D1
00002BCE                          2831              
00002BCE                          2832              * retrieve dest register for MODE 111
00002BCE  EC89                    2833              LSR.L   #6,D1   * shift the bits to right by 6
00002BD0  E689                    2834              LSR.L   #3,D1   * shift the bits to right by extra 3
00002BD2  0201 0001               2835              ANDI.B  #1,D1   * mask the first 2 bits 
00002BD6  0C01 0000               2836              CMPI.B  #0, D1  * if it's 000, absolute word address
00002BDA  6700 000C               2837              BEQ     WORDMODE
00002BDE  0C01 0001               2838              CMPI.B  #1, D1  * if it's 001, absolute long address
00002BE2  6700 0030               2839              BEQ     LONGMODE
00002BE6                          2840              *JSR     OP_DATA *not sure..
00002BE6  4E75                    2841              RTS
00002BE8                          2842  
00002BE8                          2843  
00002BE8                          2844  *---------------------------------------------------------------------------*
00002BE8                          2845  * WORDMODE: absolute word address
00002BE8                          2846  *---------------------------------------------------------------------------*
00002BE8  43F9 00003FBB           2847  WORDMODE    LEA     DISP_HEX,A1
00002BEE  103C 000E               2848              MOVE.B  #14,D0
00002BF2  4E4F                    2849              TRAP    #15
00002BF4                          2850              
00002BF4  4285                    2851              CLR.L   D5
00002BF6  3A1D                    2852              MOVE.W  (A5)+,D5
00002BF8                          2853              
00002BF8  43F9 00003C99           2854              LEA     TMPOUTPUT,A1
00002BFE  2205                    2855              MOVE.L  D5,D1
00002C00  7404                    2856              MOVE.L  #4,D2       *move word size 4
00002C02  4EB8 11A6               2857              JSR     HEX2ASCII
00002C06  43F9 00003C99           2858              LEA     TMPOUTPUT,A1
00002C0C  103C 000E               2859              MOVE.B  #14,D0
00002C10  4E4F                    2860              TRAP    #15
00002C12                          2861              
00002C12  4E75                    2862              RTS
00002C14                          2863  
00002C14                          2864  *---------------------------------------------------------------------------*
00002C14                          2865  * LONGMODE: absolute long address
00002C14                          2866  *---------------------------------------------------------------------------*
00002C14  43F9 00003FBB           2867  LONGMODE    LEA     DISP_HEX,A1
00002C1A  103C 000E               2868              MOVE.B  #14,D0
00002C1E  4E4F                    2869              TRAP    #15
00002C20                          2870              
00002C20  4285                    2871              CLR.L   D5
00002C22  2A1D                    2872              MOVE.L  (A5)+,D5
00002C24                          2873              
00002C24  43F9 00003C99           2874              LEA     TMPOUTPUT,A1
00002C2A  2205                    2875              MOVE.L  D5,D1
00002C2C  7408                    2876              MOVE.L  #8,D2           *move longword size 8
00002C2E  4EB8 11A6               2877              JSR     HEX2ASCII
00002C32  43F9 00003C99           2878              LEA     TMPOUTPUT,A1
00002C38  103C 000E               2879              MOVE.B  #14,D0
00002C3C  4E4F                    2880              TRAP    #15
00002C3E                          2881              
00002C3E  4E75                    2882              RTS
00002C40                          2883  
00002C40                          2884  
00002C40                          2885  *---------------------------------------------------------------------------*
00002C40                          2886  * IMMEDIATE: immediate address
00002C40                          2887  *---------------------------------------------------------------------------*
00002C40  43F9 00003FE1           2888  IMMEDIATE   LEA     DISP_LB,A1
00002C46  103C 000E               2889              MOVE.B  #14,D0
00002C4A  4E4F                    2890              TRAP    #15
00002C4C  43F9 00003FBB           2891              LEA     DISP_HEX,A1
00002C52  103C 000E               2892              MOVE.B  #14,D0
00002C56  4E4F                    2893              TRAP    #15
00002C58                          2894              
00002C58                          2895              * check for size
00002C58  0C04 0000               2896              CMPI.B  #0,D4
00002C5C  6700 0012               2897              BEQ     IMMD_B
00002C60  0C04 0001               2898              CMPI.B  #1,D4
00002C64  6700 002A               2899              BEQ     IMMD_W
00002C68  0C04 0002               2900              CMPI.B  #2,D4
00002C6C  6700 0042               2901              BEQ     IMMD_L
00002C70                          2902  
00002C70                          2903  IMMD_B
00002C70  4285                    2904              CLR.L   D5
00002C72  3A1D                    2905              MOVE.W  (A5)+,D5
00002C74                          2906              
00002C74  43F9 00003C99           2907              LEA     TMPOUTPUT,A1
00002C7A  2205                    2908              MOVE.L  D5,D1
00002C7C  7402                    2909              MOVE.L  #2,D2
00002C7E  4EB8 11A6               2910              JSR     HEX2ASCII
00002C82  43F9 00003C99           2911              LEA     TMPOUTPUT,A1
00002C88  103C 000E               2912              MOVE.B  #14,D0
00002C8C  4E4F                    2913              TRAP    #15
00002C8E  4E75                    2914              RTS
00002C90                          2915              
00002C90                          2916  IMMD_W
00002C90  4285                    2917              CLR.L   D5
00002C92  3A1D                    2918              MOVE.W  (A5)+,D5
00002C94                          2919              
00002C94  43F9 00003C99           2920              LEA     TMPOUTPUT,A1
00002C9A  2205                    2921              MOVE.L  D5,D1
00002C9C  7404                    2922              MOVE.L  #4,D2
00002C9E  4EB8 11A6               2923              JSR     HEX2ASCII
00002CA2  43F9 00003C99           2924              LEA     TMPOUTPUT,A1
00002CA8  103C 000E               2925              MOVE.B  #14,D0
00002CAC  4E4F                    2926              TRAP    #15
00002CAE  4E75                    2927              RTS
00002CB0                          2928              
00002CB0                          2929  
00002CB0                          2930  IMMD_L
00002CB0  4285                    2931              CLR.L   D5
00002CB2  3A1D                    2932              MOVE.W  (A5)+,D5
00002CB4                          2933              
00002CB4  43F9 00003C99           2934              LEA     TMPOUTPUT,A1
00002CBA  2205                    2935              MOVE.L  D5,D1
00002CBC  7408                    2936              MOVE.L  #8,D2
00002CBE  4EB8 11A6               2937              JSR     HEX2ASCII
00002CC2  43F9 00003C99           2938              LEA     TMPOUTPUT,A1
00002CC8  103C 000E               2939              MOVE.B  #14,D0
00002CCC  4E4F                    2940              TRAP    #15
00002CCE  4E75                    2941              RTS
00002CD0                          2942  
00002CD0                          2943  
00002CD0                          2944  *---------------------------------------------------------------------------*
00002CD0                          2945  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00002CD0                          2946  *---------------------------------------------------------------------------*
00002CD0                          2947  DEST_REGISTER
00002CD0                          2948              * clear registers to store temp data
00002CD0  4280                    2949              CLR.L   D0                      
00002CD2  4281                    2950              CLR.L   D1                      
00002CD4  207C 00000000           2951              MOVEA.L #0, A0                  
00002CDA  227C 00000000           2952              MOVEA.L #0, A1 
00002CE0                          2953              
00002CE0  2205                    2954              MOVE.L  D5,D1
00002CE2  EC89                    2955              LSR.L   #6,D1
00002CE4  E689                    2956              LSR.L   #3,D1
00002CE6  0281 00000007           2957              ANDI.L  #7,D1
00002CEC                          2958              
00002CEC  0C01 0000               2959              CMPI.B  #0,D1
00002CF0  6700 0092               2960              BEQ     REG_0
00002CF4  0C01 0001               2961              CMPI.B  #1,D1
00002CF8  6700 0098               2962              BEQ     REG_1
00002CFC  0C01 0002               2963              CMPI.B  #2,D1
00002D00  6700 009E               2964              BEQ     REG_2
00002D04  0C01 0003               2965              CMPI.B  #3,D1
00002D08  6700 00A4               2966              BEQ     REG_3
00002D0C  0C01 0004               2967              CMPI.B  #4,D1
00002D10  6700 00AA               2968              BEQ     REG_4
00002D14  0C01 0005               2969              CMPI.B  #5,D1
00002D18  6700 00B0               2970              BEQ     REG_5
00002D1C  0C01 0006               2971              CMPI.B  #6,D1
00002D20  6700 00B6               2972              BEQ     REG_6
00002D24  0C01 0007               2973              CMPI.B  #7,D1
00002D28  6700 00BC               2974              BEQ     REG_7
00002D2C                          2975  
00002D2C                          2976  *---------------------------------------------------------------------------*
00002D2C                          2977  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00002D2C                          2978  *---------------------------------------------------------------------------*           
00002D2C                          2979  SRC_REGISTER 
00002D2C                          2980              * clear registers to store temp data
00002D2C  4280                    2981              CLR.L   D0                      
00002D2E  4281                    2982              CLR.L   D1                      
00002D30  207C 00000000           2983              MOVEA.L #0, A0                  
00002D36  227C 00000000           2984              MOVEA.L #0, A1                  
00002D3C                          2985              
00002D3C  2205                    2986              MOVE.L  D5,D1   * temp store the processing data
00002D3E  0281 00000007           2987              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00002D44                          2988              
00002D44  0C01 0000               2989              CMPI.B  #0,D1
00002D48  6700 003A               2990              BEQ     REG_0
00002D4C  0C01 0001               2991              CMPI.B  #1,D1
00002D50  6700 0040               2992              BEQ     REG_1
00002D54  0C01 0002               2993              CMPI.B  #2,D1
00002D58  6700 0046               2994              BEQ     REG_2
00002D5C  0C01 0003               2995              CMPI.B  #3,D1
00002D60  6700 004C               2996              BEQ     REG_3
00002D64  0C01 0004               2997              CMPI.B  #4,D1
00002D68  6700 0052               2998              BEQ     REG_4
00002D6C  0C01 0005               2999              CMPI.B  #5,D1
00002D70  6700 0058               3000              BEQ     REG_5
00002D74  0C01 0006               3001              CMPI.B  #6,D1
00002D78  6700 005E               3002              BEQ     REG_6
00002D7C  0C01 0007               3003              CMPI.B  #7,D1
00002D80  6700 0064               3004              BEQ     REG_7
00002D84                          3005  
00002D84                          3006  *---------------------------------------------------------------------------*
00002D84                          3007  * REG_0 ~ REG_7: display register 0 to 7
00002D84                          3008  *---------------------------------------------------------------------------*
00002D84  43F9 00003FE6           3009  REG_0       LEA     DISP_0,A1
00002D8A  103C 000E               3010              MOVE.B  #14,D0
00002D8E  4E4F                    3011              TRAP    #15
00002D90  4E75                    3012              RTS
00002D92                          3013              
00002D92  43F9 00003FE8           3014  REG_1       LEA     DISP_1,A1
00002D98  103C 000E               3015              MOVE.B  #14,D0
00002D9C  4E4F                    3016              TRAP    #15
00002D9E  4E75                    3017              RTS
00002DA0                          3018              
00002DA0                          3019  
00002DA0  43F9 00003FEA           3020  REG_2       LEA     DISP_2,A1
00002DA6  103C 000E               3021              MOVE.B  #14,D0
00002DAA  4E4F                    3022              TRAP    #15
00002DAC  4E75                    3023              RTS
00002DAE                          3024            
00002DAE  43F9 00003FEC           3025  REG_3       LEA     DISP_3,A1
00002DB4  103C 000E               3026              MOVE.B  #14,D0
00002DB8  4E4F                    3027              TRAP    #15
00002DBA  4E75                    3028              RTS
00002DBC                          3029              
00002DBC  43F9 00003FEE           3030  REG_4       LEA     DISP_4,A1
00002DC2  103C 000E               3031              MOVE.B  #14,D0
00002DC6  4E4F                    3032              TRAP    #15
00002DC8  4E75                    3033              RTS
00002DCA                          3034              
00002DCA  43F9 00003FF0           3035  REG_5       LEA     DISP_5,A1
00002DD0  103C 000E               3036              MOVE.B  #14,D0
00002DD4  4E4F                    3037              TRAP    #15
00002DD6  4E75                    3038              RTS
00002DD8                          3039              
00002DD8  43F9 00003FF2           3040  REG_6       LEA     DISP_6,A1
00002DDE  103C 000E               3041              MOVE.B  #14,D0
00002DE2  4E4F                    3042              TRAP    #15
00002DE4  4E75                    3043              RTS
00002DE6                          3044              
00002DE6  43F9 00003FF4           3045  REG_7       LEA     DISP_7,A1
00002DEC  103C 000E               3046              MOVE.B  #14,D0
00002DF0  4E4F                    3047              TRAP    #15
00002DF2  4E75                    3048              RTS
00002DF4                          3049              
00002DF4                          3050  *---------------------------------------------------------------------------*
00002DF4                          3051  * REPEAT : Ask user whether they wish to run the program again
00002DF4                          3052  *---------------------------------------------------------------------------*           
00002DF4  4246                    3053  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00002DF6  43F9 00003ABF           3054              LEA     REPEATMSG,A1
00002DFC  103C 000E               3055              MOVE.B  #14,D0
00002E00  4E4F                    3056              TRAP    #15
00002E02                          3057              
00002E02  43F9 00003C49           3058              LEA     TMPINPUT,A1             * allocate space to temp store user input
00002E08  103C 0002               3059              MOVE.B  #2,D0
00002E0C  4E4F                    3060              TRAP    #15
00002E0E                          3061  
00002E0E  0C01 0001               3062              CMPI.B  #1,D1                   * check for length of user input
00002E12  66E0                    3063              BNE     REPEAT                  * return to the beginning of the function if unequal
00002E14                          3064              
00002E14  0C11 0059               3065              CMPI.B  #$59,(A1)               * compare the input with Y    
00002E18  6700 E1F0               3066              BEQ     PROGLP                  * repeat the program
00002E1C                          3067              
00002E1C  0C11 0079               3068              CMPI.B  #$79,(A1)               * compare the input with y    
00002E20  6700 E1E8               3069              BEQ     PROGLP                  * repeat the program
00002E24                          3070              
00002E24  0C11 004E               3071              CMPI.B  #$4E,(A1)               * compare the input with N    
00002E28  6700 0928               3072              BEQ     TERMINATE               * finish program
00002E2C                          3073              
00002E2C  0C11 006E               3074              CMPI.B  #$6E,(A1)               * compare the input with n    
00002E30  6700 0920               3075              BEQ     TERMINATE               * finish program
00002E34                          3076              
00002E34  60BE                    3077              BRA     REPEAT                  * invalid input/repeat the function
00002E36                          3078  
00002E36                          3079  *---------------------------------------------------------------------------*
00002E36                          3080  * EA DECODING INTERFACE
00002E36                          3081  * [A0] - RESERVED FOR USE
00002E36                          3082  * [D2] - RESERVED FOR USE
00002E36                          3083  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00002E36                          3084  *---------------------------------------------------------------------------*
00002E36                          3085  GET_EA_EA_SRC
00002E36                          3086      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00002E36                          3087      
00002E36                          3088      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00002E36  2405                    3089      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00002E38  E68A                    3090      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00002E3A  23C2 0000400C           3091      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00002E40  7407                    3092      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00002E42  C5B9 0000400C           3093      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00002E48                          3094                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00002E48                          3095      
00002E48                          3096      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00002E48                          3097      *DESTINATION REGISTER FORMAT STANDARD         *
00002E48                          3098      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00002E48                          3099      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00002E48                          3100      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00002E48                          3101      *0 - Dn                                       *
00002E48                          3102      *1 - An                                       *
00002E48                          3103      *2 - (An)                                     *
00002E48                          3104      *3 - (An)+                                    *
00002E48                          3105      *4 - -(An)                                    *
00002E48                          3106      *5 - (XXX).W                                  *
00002E48                          3107      *6 - (XXX).L                                  *
00002E48                          3108      *7 - #<data>                                  *
00002E48                          3109      ***********************************************
00002E48                          3110      
00002E48                          3111      *** Check if source ...  <ea> = Dn
00002E48                          3112  CHECK0    
00002E48  41F9 00003FFC           3113            LEA     TEMP_REGISTER_FORMAT,A0
00002E4E  1439 00003FFB           3114            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002E54  1082                    3115            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002E56  0239 0001 00003FFC      3116            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00002E5E  0C39 0001 00003FFC      3117            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00002E66  6700 006A               3118            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002E6A  0CB9 00000000 0000400C  3119            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00002E74  6600 005C               3120            BNE     CHECK1
00002E78                          3121            
00002E78                          3122            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002E78  163C 0020               3123            MOVE.B    #' ',D3
00002E7C  6100 0856               3124            BSR       PUSH_STACK
00002E80  163C 0044               3125            MOVE.B    #'D',D3
00002E84  6100 084E               3126            BSR       PUSH_STACK
00002E88                          3127  
00002E88                          3128            *FIND REGISTER NUMBER END LOCATION*  
00002E88  13F9 00003FFE 00004004  3129            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002E92  0239 000F 00004004      3130            AND.B   #$0F,VAR_BYTE_END
00002E9A                          3131            
00002E9A                          3132            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002E9A  23C5 00004008           3133            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002EA0  1439 00004004           3134            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002EA6                          3135            
00002EA6                          3136            *INTITIALIZE FOR BIT SHIFTING
00002EA6  41F9 00004008           3137            LEA     VAR_TEMP_CLEANCOPY,A0
00002EAC  2639 00004008           3138            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002EB2                          3139  LOOP_SHIFTING
00002EB2  0C02 0000               3140            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002EB6  6700 0008               3141            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002EBA  E24B                    3142            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002EBC  5302                    3143            SUB.B   #1,D2                     *DECREMENT COUNTER
00002EBE  60F2                    3144            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00002EC0                          3145  MASKING_NEXT
00002EC0  C6BC 00000007           3146            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002EC6  0603 0030               3147            ADD.B   #$30,D3                   *CONVERT TO CHAR
00002ECA  6100 0808               3148            BSR     PUSH_STACK                *PUSH TO STACK
00002ECE                          3149            
00002ECE  6000 0394               3150            BRA     GET_SRC_SUCCESS           *RETURN          
00002ED2                          3151            
00002ED2                          3152            
00002ED2                          3153            *** Check if source ...  <ea> = An
00002ED2  41F9 00003FFC           3154  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00002ED8  1439 00003FFB           3155            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002EDE  1082                    3156            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002EE0  0239 0002 00003FFC      3157            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00002EE8  0C39 0002 00003FFC      3158            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00002EF0  6700 006A               3159            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00002EF4  0CB9 00000001 0000400C  3160            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00002EFE  6600 005C               3161            BNE     CHECK2
00002F02                          3162            
00002F02                          3163            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00002F02  163C 0020               3164            MOVE.B    #' ',D3
00002F06  6100 07CC               3165            BSR       PUSH_STACK
00002F0A  163C 0041               3166            MOVE.B    #'A',D3
00002F0E  6100 07C4               3167            BSR       PUSH_STACK
00002F12                          3168  
00002F12                          3169            
00002F12                          3170            *FIND REGISTER NUMBER END LOCATION*  
00002F12  13F9 00003FFE 00004004  3171            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002F1C  0239 000F 00004004      3172            AND.B   #$0F,VAR_BYTE_END
00002F24                          3173            
00002F24                          3174            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002F24  23C5 00004008           3175            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002F2A  1439 00004004           3176            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00002F30                          3177            
00002F30                          3178            *INTITIALIZE FOR BIT SHIFTING
00002F30  41F9 00004008           3179            LEA     VAR_TEMP_CLEANCOPY,A0
00002F36  2639 00004008           3180            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002F3C                          3181  LOOP_SHIFTING1
00002F3C  0C02 0000               3182            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002F40  6700 0008               3183            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00002F44  E24B                    3184            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002F46  5302                    3185            SUB.B   #1,D2                     *DECREMENT COUNTER
00002F48  60F2                    3186            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00002F4A                          3187  MASKING_NEXT1
00002F4A  C6BC 00000007           3188            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002F50  0603 0030               3189            ADD.B   #$30,D3                   *CONVERT TO CHAR
00002F54  6100 077E               3190            BSR     PUSH_STACK                *PUSH TO STACK
00002F58                          3191            
00002F58  6000 030A               3192            BRA     GET_SRC_SUCCESS                   *RETURN 
00002F5C                          3193            
00002F5C                          3194            
00002F5C                          3195            
00002F5C                          3196            
00002F5C                          3197            *** Check if source ...  <ea> = (An)       
00002F5C  41F9 00003FFC           3198  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00002F62  1439 00003FFB           3199            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00002F68  1082                    3200            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00002F6A  0239 0004 00003FFC      3201            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00002F72  0C39 0004 00003FFC      3202            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00002F7A  6700 007A               3203            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00002F7E  0CB9 00000002 0000400C  3204            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00002F88  6600 006C               3205            BNE     CHECK3
00002F8C                          3206            
00002F8C                          3207            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00002F8C  163C 0020               3208            MOVE.B    #' ',D3
00002F90  6100 0742               3209            BSR       PUSH_STACK
00002F94  163C 0028               3210            MOVE.B    #'(',D3
00002F98  6100 073A               3211            BSR       PUSH_STACK
00002F9C  163C 0041               3212            MOVE.B    #'A',D3
00002FA0  6100 0732               3213            BSR       PUSH_STACK
00002FA4                          3214  
00002FA4                          3215            
00002FA4                          3216            *FIND REGISTER NUMBER END LOCATION*  
00002FA4  13F9 00003FFE 00004004  3217            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00002FAE  0239 000F 00004004      3218            AND.B   #$0F,VAR_BYTE_END
00002FB6                          3219            
00002FB6                          3220            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00002FB6  23C5 00004008           3221            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00002FBC  1439 00004004           3222            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00002FC2                          3223            
00002FC2                          3224            *INTITIALIZE FOR BIT SHIFTING
00002FC2  41F9 00004008           3225            LEA     VAR_TEMP_CLEANCOPY,A0
00002FC8  2639 00004008           3226            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00002FCE                          3227  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00002FCE  0C02 0000               3228            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00002FD2  6700 0008               3229            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00002FD6  E24B                    3230            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00002FD8  5302                    3231            SUB.B   #1,D2                     *DECREMENT COUNTER
00002FDA  60F2                    3232            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00002FDC                          3233  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00002FDC  0283 00000007           3234            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00002FE2  0603 0030               3235            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00002FE6  6100 06EC               3236            BSR     PUSH_STACK                *PUSH TO STACK
00002FEA                          3237            
00002FEA  163C 0029               3238            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00002FEE  6100 06E4               3239            BSR       PUSH_STACK
00002FF2                          3240            
00002FF2  6000 0270               3241            BRA     GET_SRC_SUCCESS                   *RETURN 
00002FF6                          3242  
00002FF6                          3243            
00002FF6                          3244            
00002FF6                          3245                      
00002FF6                          3246  *** Check if source ...  <ea> = (An)+       
00002FF6  41F9 00003FFC           3247  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00002FFC  1439 00003FFB           3248            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003002  1082                    3249            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003004  0239 0008 00003FFC      3250            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
0000300C  0C39 0008 00003FFC      3251            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003014  6700 0082               3252            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003018  0CB9 00000003 0000400C  3253            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003022  6600 0074               3254            BNE     CHECK4
00003026                          3255            
00003026                          3256            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003026  163C 0020               3257            MOVE.B    #' ',D3
0000302A  6100 06A8               3258            BSR       PUSH_STACK
0000302E  163C 0028               3259            MOVE.B    #'(',D3
00003032  6100 06A0               3260            BSR       PUSH_STACK
00003036  163C 0041               3261            MOVE.B    #'A',D3
0000303A  6100 0698               3262            BSR       PUSH_STACK
0000303E                          3263  
0000303E                          3264            
0000303E                          3265            *FIND REGISTER NUMBER END LOCATION*  
0000303E  13F9 00003FFE 00004004  3266            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003048  0239 000F 00004004      3267            ANDI.B   #$0F,VAR_BYTE_END
00003050                          3268            
00003050                          3269            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003050  23C5 00004008           3270            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003056  1439 00004004           3271            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000305C                          3272            
0000305C                          3273            *INTITIALIZE FOR BIT SHIFTING
0000305C  41F9 00004008           3274            LEA     VAR_TEMP_CLEANCOPY,A0
00003062  2639 00004008           3275            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003068                          3276            
00003068                          3277  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003068  0C02 0000               3278            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000306C  6700 0008               3279            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003070  E24B                    3280            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003072  5302                    3281            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003074  60F2                    3282            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003076                          3283                                               *change: NAME OF LABEL*
00003076                          3284  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003076  0283 00000007           3285            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000307C  0603 0030               3286            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003080  6100 0652               3287            BSR     PUSH_STACK                *PUSH TO STACK
00003084                          3288            
00003084  163C 0029               3289            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003088  6100 064A               3290            BSR       PUSH_STACK
0000308C  163C 002B               3291            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003090  6100 0642               3292            BSR       PUSH_STACK
00003094                          3293            
00003094  6000 01CE               3294            BRA       GET_SRC_SUCCESS                   *RETURN 
00003098                          3295  
00003098                          3296            
00003098                          3297            
00003098                          3298                      
00003098                          3299            *** Check if source ...  <ea> = -(An)       
00003098  41F9 00003FFC           3300  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
0000309E  1439 00003FFB           3301            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000030A4  1082                    3302            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000030A6  0239 0010 00003FFC      3303            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000030AE  0C39 0010 00003FFC      3304            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000030B6  6700 0082               3305            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000030BA  0CB9 00000004 0000400C  3306            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000030C4  6600 0074               3307            BNE     CHECK7
000030C8                          3308            
000030C8                          3309            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000030C8  163C 0020               3310            MOVE.B    #' ',D3
000030CC  6100 0606               3311            BSR       PUSH_STACK
000030D0  163C 002D               3312            MOVE.B    #'-',D3
000030D4  6100 05FE               3313            BSR       PUSH_STACK
000030D8  163C 0028               3314            MOVE.B    #'(',D3
000030DC  6100 05F6               3315            BSR       PUSH_STACK
000030E0  163C 0041               3316            MOVE.B    #'A',D3
000030E4  6100 05EE               3317            BSR       PUSH_STACK
000030E8                          3318  
000030E8                          3319            
000030E8                          3320            *FIND REGISTER NUMBER END LOCATION*  
000030E8  13F9 00003FFE 00004004  3321            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000030F2  0239 000F 00004004      3322            AND.B   #$0F,VAR_BYTE_END
000030FA                          3323            
000030FA                          3324            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000030FA  23C5 00004008           3325            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003100  1439 00004004           3326            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003106                          3327            
00003106                          3328            *INTITIALIZE FOR BIT SHIFTING
00003106  41F9 00004008           3329            LEA     VAR_TEMP_CLEANCOPY,A0
0000310C  2639 00004008           3330            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003112                          3331            
00003112                          3332  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003112  0C02 0000               3333            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003116  6700 0008               3334            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000311A  E24B                    3335            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000311C  5302                    3336            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000311E  60F2                    3337            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003120                          3338                                               *change: NAME OF LABEL*
00003120                          3339  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003120  0283 00000007           3340            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003126  0603 0030               3341            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000312A  6100 05A8               3342            BSR     PUSH_STACK                *PUSH TO STACK
0000312E                          3343            
0000312E  163C 0029               3344            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003132  6100 05A0               3345            BSR       PUSH_STACK
00003136                          3346            
00003136  6000 012C               3347            BRA     GET_SRC_SUCCESS                   *RETURN
0000313A                          3348            
0000313A                          3349                      
0000313A                          3350            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000313A  0CB9 00000007 0000400C  3351  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003144  6600 011A               3352            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003148                          3353                   
00003148                          3354            *NEXT: (MODE == 111) 
00003148                          3355            *NOW: CHECK FOR SRC REGISTER 
00003148                          3356                  *(000 = (xxx).W)
00003148                          3357                  *(001 = (xxx).L)
00003148                          3358                  *(010 = #<data>)
00003148                          3359                  
00003148                          3360            *FIND REGISTER NUMBER END LOCATION*  
00003148  13F9 00003FFE 00004004  3361            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003152  0239 000F 00004004      3362            AND.B   #$0F,VAR_BYTE_END
0000315A                          3363            
0000315A                          3364            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000315A  23C5 00004008           3365            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003160  1439 00004004           3366            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003166                          3367            
00003166                          3368            *INTITIALIZE FOR BIT SHIFTING
00003166  41F9 00004008           3369            LEA     VAR_TEMP_CLEANCOPY,A0
0000316C  2C39 00004008           3370            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003172                          3371  SRC_LOOP_SHIFTING
00003172  0C02 0000               3372            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003176  6700 0008               3373            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000317A  E24E                    3374            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000317C  5302                    3375            SUB.B   #1,D2                     *DECREMENT COUNTER
0000317E  60F2                    3376            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003180                          3377  SRC_MASKING_NEXT
00003180  CCBC 00000007           3378            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003186                          3379           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003186                          3380           
00003186                          3381  CHECK_WORD  
00003186  41F9 00003FFC           3382            LEA     TEMP_REGISTER_FORMAT,A0
0000318C  1439 00003FFB           3383            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003192  1082                    3384            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003194  0239 0020 00003FFC      3385            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
0000319C  0C39 0020 00003FFC      3386            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000031A4  6700 0026               3387            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000031A8  0C06 0000               3388            CMPI.B  #0,D6                          
000031AC  6600 001E               3389            BNE     CHECK_LONG 
000031B0                          3390            
000031B0                          3391            *IT IS A WORD AT THIS POINT*
000031B0                          3392            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000031B0  163C 0020               3393            MOVE.B    #' ',D3
000031B4  6100 051E               3394            BSR       PUSH_STACK
000031B8  163C 0024               3395            MOVE.B    #'$',D3
000031BC  6100 0516               3396            BSR       PUSH_STACK
000031C0  321D                    3397            MOVE.W    (A5)+,D1
000031C2  7404                    3398            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000031C4  6100 E022               3399            BSR       HEX2ASCII2STACK
000031C8  6000 009A               3400            BRA     GET_SRC_SUCCESS
000031CC                          3401  
000031CC                          3402  CHECK_LONG
000031CC  41F9 00003FFC           3403            LEA     TEMP_REGISTER_FORMAT,A0
000031D2  1439 00003FFB           3404            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000031D8  1082                    3405            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000031DA  0239 0040 00003FFC      3406            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000031E2  0C39 0040 00003FFC      3407            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000031EA  6700 002E               3408            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000031EE  0C06 0001               3409            CMPI.B  #1,D6                          
000031F2  6600 0026               3410            BNE     CHECK_IMMEDIATE  
000031F6                          3411  
000031F6                          3412            *IT IS A WORD AT THIS POINT*
000031F6                          3413            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000031F6  163C 0020               3414            MOVE.B    #' ',D3
000031FA  6100 04D8               3415            BSR       PUSH_STACK
000031FE  163C 0024               3416            MOVE.B    #'$',D3
00003202  6100 04D0               3417            BSR       PUSH_STACK
00003206  321D                    3418            MOVE.W    (A5)+,D1
00003208  7404                    3419            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000320A  6100 DFDC               3420            BSR       HEX2ASCII2STACK
0000320E  321D                    3421            MOVE.W    (A5)+,D1
00003210  7404                    3422            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003212  6100 DFD4               3423            BSR       HEX2ASCII2STACK
00003216  6000 004C               3424            BRA     GET_SRC_SUCCESS
0000321A                          3425            
0000321A                          3426  CHECK_IMMEDIATE
0000321A  41F9 00003FFC           3427            LEA     TEMP_REGISTER_FORMAT,A0
00003220  1439 00003FFB           3428            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003226  1082                    3429            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003228  0239 0080 00003FFC      3430            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003230  0C39 0080 00003FFC      3431            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003238  6700 0026               3432            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000323C  0C06 0004               3433            CMPI.B  #4,D6                          
00003240  6600 001E               3434            BNE     GET_SRC_FAILED 
00003244                          3435  
00003244                          3436            *IT IS A WORD AT THIS POINT*
00003244                          3437            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003244  163C 0020               3438            MOVE.B    #' ',D3
00003248  6100 048A               3439            BSR       PUSH_STACK
0000324C  163C 0023               3440            MOVE.B    #'#',D3
00003250  6100 0482               3441            BSR       PUSH_STACK
00003254  321D                    3442            MOVE.W    (A5)+,D1
00003256  7404                    3443            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003258  6100 DF8E               3444            BSR       HEX2ASCII2STACK
0000325C  6000 0006               3445            BRA     GET_SRC_SUCCESS
00003260                          3446            
00003260                          3447  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003260  7801                    3448            MOVE.L #1,D4
00003262  4E75                    3449            RTS
00003264                          3450  GET_SRC_SUCCESS 
00003264  4E75                    3451            RTS
00003266                          3452                                 
00003266                          3453      
00003266                          3454  
00003266                          3455  
00003266                          3456  
00003266                          3457  
00003266                          3458  
00003266                          3459  
00003266                          3460  GET_EA_EA_DEST
00003266                          3461  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003266                          3462      
00003266                          3463      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003266  2405                    3464      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003268  EC8A                    3465      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
0000326A  23C2 0000400C           3466      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003270  7407                    3467      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003272  C5B9 0000400C           3468      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003278                          3469                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003278                          3470      
00003278                          3471      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003278                          3472      *DESTINATION REGISTER FORMAT STANDARD         *
00003278                          3473      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003278                          3474      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003278                          3475      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003278                          3476      *0 - Dn                                       *
00003278                          3477      *1 - An                                       *
00003278                          3478      *2 - (An)                                     *
00003278                          3479      *3 - (An)+                                    *
00003278                          3480      *4 - -(An)                                    *
00003278                          3481      *5 - (XXX).W                                  *
00003278                          3482      *6 - (XXX).L                                  *
00003278                          3483      *7 - #<data>                                  *
00003278                          3484      ***********************************************
00003278                          3485      
00003278                          3486      *** Check if source ...  <ea> = Dn
00003278                          3487  DEST_CHECK0    
00003278  41F9 00003FFC           3488            LEA     TEMP_REGISTER_FORMAT,A0
0000327E  1439 00003FFA           3489            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003284  1082                    3490            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003286  0239 0001 00003FFC      3491            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
0000328E  0C39 0001 00003FFC      3492            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003296  6700 006A               3493            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000329A  0CB9 00000000 0000400C  3494            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000032A4  6600 005C               3495            BNE     DEST_CHECK1
000032A8                          3496            
000032A8                          3497            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000032A8  163C 0020               3498            MOVE.B    #' ',D3
000032AC  6100 0426               3499            BSR       PUSH_STACK
000032B0  163C 0044               3500            MOVE.B    #'D',D3
000032B4  6100 041E               3501            BSR       PUSH_STACK
000032B8                          3502  
000032B8                          3503            *FIND REGISTER NUMBER END LOCATION*  
000032B8  13F9 00003FFD 00004004  3504            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000032C2  0239 000F 00004004      3505            AND.B   #$0F,VAR_BYTE_END
000032CA                          3506            
000032CA                          3507            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000032CA  23C5 00004008           3508            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000032D0  1439 00004004           3509            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000032D6                          3510            
000032D6                          3511            *INTITIALIZE FOR BIT SHIFTING
000032D6  41F9 00004008           3512            LEA     VAR_TEMP_CLEANCOPY,A0
000032DC  2639 00004008           3513            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000032E2                          3514  DEST_LOOP_SHIFTING
000032E2  0C02 0000               3515            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000032E6  6700 0008               3516            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000032EA  E24B                    3517            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000032EC  5302                    3518            SUB.B   #1,D2                     *DECREMENT COUNTER
000032EE  60F2                    3519            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
000032F0                          3520  DEST_MASKING_NEXT
000032F0  C6BC 00000007           3521            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000032F6  0603 0030               3522            ADD.B   #$30,D3                   *CONVERT TO CHAR
000032FA  6100 03D8               3523            BSR     PUSH_STACK                *PUSH TO STACK
000032FE                          3524            
000032FE  6000 0394               3525            BRA     GET_DST_SUCCESS           *RETURN          
00003302                          3526            
00003302                          3527            
00003302                          3528            *** Check if source ...  <ea> = An
00003302                          3529  DEST_CHECK1    
00003302  41F9 00003FFC           3530            LEA     TEMP_REGISTER_FORMAT,A0
00003308  1439 00003FFA           3531            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000330E  1082                    3532            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003310  0239 0002 00003FFC      3533            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003318  0C39 0002 00003FFC      3534            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003320  6700 006A               3535            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003324  0CB9 00000001 0000400C  3536            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
0000332E  6600 005C               3537            BNE     DEST_CHECK2
00003332                          3538            
00003332                          3539            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003332  163C 0020               3540            MOVE.B    #' ',D3
00003336  6100 039C               3541            BSR       PUSH_STACK
0000333A  163C 0041               3542            MOVE.B    #'A',D3
0000333E  6100 0394               3543            BSR       PUSH_STACK
00003342                          3544  
00003342                          3545            
00003342                          3546            *FIND REGISTER NUMBER END LOCATION*  
00003342  13F9 00003FFD 00004004  3547            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000334C  0239 000F 00004004      3548            AND.B   #$0F,VAR_BYTE_END
00003354                          3549            
00003354                          3550            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003354  23C5 00004008           3551            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000335A  1439 00004004           3552            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003360                          3553            
00003360                          3554            *INTITIALIZE FOR BIT SHIFTING
00003360  41F9 00004008           3555            LEA     VAR_TEMP_CLEANCOPY,A0
00003366  2639 00004008           3556            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000336C                          3557  DEST_LOOP_SHIFTING1
0000336C  0C02 0000               3558            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003370  6700 0008               3559            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003374  E24B                    3560            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003376  5302                    3561            SUB.B   #1,D2                     *DECREMENT COUNTER
00003378  60F2                    3562            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
0000337A                          3563  DEST_MASKING_NEXT1
0000337A  C6BC 00000007           3564            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003380  0603 0030               3565            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003384  6100 034E               3566            BSR     PUSH_STACK                *PUSH TO STACK
00003388                          3567            
00003388  6000 030A               3568            BRA     GET_DST_SUCCESS                   *RETURN 
0000338C                          3569            
0000338C                          3570            
0000338C                          3571            
0000338C                          3572            
0000338C                          3573            *** Check if source ...  <ea> = (An)       
0000338C                          3574  DEST_CHECK2    
0000338C  41F9 00003FFC           3575            LEA     TEMP_REGISTER_FORMAT,A0
00003392  1439 00003FFA           3576            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003398  1082                    3577            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000339A  0239 0004 00003FFC      3578            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000033A2  0C39 0004 00003FFC      3579            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000033AA  6700 007A               3580            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000033AE  0CB9 00000002 0000400C  3581            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000033B8  6600 006C               3582            BNE     DEST_CHECK3
000033BC                          3583            
000033BC                          3584            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000033BC  163C 0020               3585            MOVE.B    #' ',D3
000033C0  6100 0312               3586            BSR       PUSH_STACK
000033C4  163C 0028               3587            MOVE.B    #'(',D3
000033C8  6100 030A               3588            BSR       PUSH_STACK
000033CC  163C 0041               3589            MOVE.B    #'A',D3
000033D0  6100 0302               3590            BSR       PUSH_STACK
000033D4                          3591  
000033D4                          3592            
000033D4                          3593            *FIND REGISTER NUMBER END LOCATION*  
000033D4  13F9 00003FFD 00004004  3594            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000033DE  0239 000F 00004004      3595            AND.B   #$0F,VAR_BYTE_END
000033E6                          3596            
000033E6                          3597            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000033E6  23C5 00004008           3598            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000033EC  1439 00004004           3599            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000033F2                          3600            
000033F2                          3601            *INTITIALIZE FOR BIT SHIFTING
000033F2  41F9 00004008           3602            LEA     VAR_TEMP_CLEANCOPY,A0
000033F8  2639 00004008           3603            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000033FE                          3604  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000033FE  0C02 0000               3605            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003402  6700 0008               3606            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003406  E24B                    3607            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003408  5302                    3608            SUB.B   #1,D2                     *DECREMENT COUNTER
0000340A  60F2                    3609            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
0000340C                          3610  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
0000340C  0283 00000007           3611            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003412  0603 0030               3612            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003416  6100 02BC               3613            BSR     PUSH_STACK                *PUSH TO STACK
0000341A                          3614            
0000341A  163C 0029               3615            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000341E  6100 02B4               3616            BSR       PUSH_STACK
00003422                          3617            
00003422  6000 0270               3618            BRA     GET_DST_SUCCESS                   *RETURN 
00003426                          3619  
00003426                          3620            
00003426                          3621            
00003426                          3622                      
00003426                          3623  *** Check if source ...  <ea> = (An)+       
00003426  41F9 00003FFC           3624  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
0000342C  1439 00003FFA           3625            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003432  1082                    3626            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003434  0239 0008 00003FFC      3627            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
0000343C  0C39 0008 00003FFC      3628            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003444  6700 0082               3629            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003448  0CB9 00000003 0000400C  3630            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003452  6600 0074               3631            BNE     DEST_CHECK4
00003456                          3632            
00003456                          3633            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003456  163C 0020               3634            MOVE.B    #' ',D3
0000345A  6100 0278               3635            BSR       PUSH_STACK
0000345E  163C 0028               3636            MOVE.B    #'(',D3
00003462  6100 0270               3637            BSR       PUSH_STACK
00003466  163C 0041               3638            MOVE.B    #'A',D3
0000346A  6100 0268               3639            BSR       PUSH_STACK
0000346E                          3640  
0000346E                          3641            
0000346E                          3642            *FIND REGISTER NUMBER END LOCATION*  
0000346E  13F9 00003FFD 00004004  3643            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003478  0239 000F 00004004      3644            ANDI.B   #$0F,VAR_BYTE_END
00003480                          3645            
00003480                          3646            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003480  23C5 00004008           3647            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003486  1439 00004004           3648            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000348C                          3649            
0000348C                          3650            *INTITIALIZE FOR BIT SHIFTING
0000348C  41F9 00004008           3651            LEA     VAR_TEMP_CLEANCOPY,A0
00003492  2639 00004008           3652            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003498                          3653            
00003498                          3654  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003498  0C02 0000               3655            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000349C  6700 0008               3656            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000034A0  E24B                    3657            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000034A2  5302                    3658            SUBI.B   #1,D2                     *DECREMENT COUNTER
000034A4  60F2                    3659            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
000034A6                          3660                                               *change: NAME OF LABEL*
000034A6                          3661  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000034A6  0283 00000007           3662            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000034AC  0603 0030               3663            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000034B0  6100 0222               3664            BSR     PUSH_STACK                *PUSH TO STACK
000034B4                          3665            
000034B4  163C 0029               3666            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000034B8  6100 021A               3667            BSR       PUSH_STACK
000034BC  163C 002B               3668            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000034C0  6100 0212               3669            BSR       PUSH_STACK
000034C4                          3670            
000034C4  6000 01CE               3671            BRA       GET_DST_SUCCESS                   *RETURN 
000034C8                          3672  
000034C8                          3673            
000034C8                          3674            
000034C8                          3675                      
000034C8                          3676            *** Check if source ...  <ea> = -(An)       
000034C8                          3677  DEST_CHECK4    
000034C8  41F9 00003FFC           3678            LEA     TEMP_REGISTER_FORMAT,A0
000034CE  1439 00003FFA           3679            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000034D4  1082                    3680            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000034D6  0239 0010 00003FFC      3681            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000034DE  0C39 0010 00003FFC      3682            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000034E6  6700 0082               3683            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000034EA  0CB9 00000004 0000400C  3684            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000034F4  6600 0074               3685            BNE     DEST_CHECK7
000034F8                          3686            
000034F8                          3687            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000034F8  163C 0020               3688            MOVE.B    #' ',D3
000034FC  6100 01D6               3689            BSR       PUSH_STACK
00003500  163C 002D               3690            MOVE.B    #'-',D3
00003504  6100 01CE               3691            BSR       PUSH_STACK
00003508  163C 0028               3692            MOVE.B    #'(',D3
0000350C  6100 01C6               3693            BSR       PUSH_STACK
00003510  163C 0041               3694            MOVE.B    #'A',D3
00003514  6100 01BE               3695            BSR       PUSH_STACK
00003518                          3696  
00003518                          3697            
00003518                          3698            *FIND REGISTER NUMBER END LOCATION*  
00003518  13F9 00003FFD 00004004  3699            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003522  0239 000F 00004004      3700            AND.B   #$0F,VAR_BYTE_END
0000352A                          3701            
0000352A                          3702            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000352A  23C5 00004008           3703            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003530  1439 00004004           3704            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003536                          3705            
00003536                          3706            *INTITIALIZE FOR BIT SHIFTING
00003536  41F9 00004008           3707            LEA     VAR_TEMP_CLEANCOPY,A0
0000353C  2639 00004008           3708            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003542                          3709            
00003542                          3710  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003542  0C02 0000               3711            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003546  6700 0008               3712            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000354A  E24B                    3713            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000354C  5302                    3714            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000354E  60F2                    3715            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003550                          3716                                               *change: NAME OF LABEL*
00003550                          3717  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003550  0283 00000007           3718            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003556  0603 0030               3719            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000355A  6100 0178               3720            BSR     PUSH_STACK                *PUSH TO STACK
0000355E                          3721            
0000355E  163C 0029               3722            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003562  6100 0170               3723            BSR       PUSH_STACK
00003566                          3724            
00003566  6000 012C               3725            BRA     GET_DST_SUCCESS                   *RETURN
0000356A                          3726            
0000356A                          3727                      
0000356A                          3728            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000356A                          3729  DEST_CHECK7    
0000356A  0CB9 00000007 0000400C  3730            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003574  6600 011A               3731            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003578                          3732                   
00003578                          3733            *NEXT: (MODE == 111) 
00003578                          3734            *NOW: CHECK FOR SRC REGISTER 
00003578                          3735                  *(000 = (xxx).W)
00003578                          3736                  *(001 = (xxx).L)
00003578                          3737                  *(010 = #<data>)
00003578                          3738                  
00003578                          3739            *FIND REGISTER NUMBER END LOCATION*  
00003578  13F9 00003FFD 00004004  3740            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003582  0239 000F 00004004      3741            AND.B   #$0F,VAR_BYTE_END
0000358A                          3742            
0000358A                          3743            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000358A  23C5 00004008           3744            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003590  1439 00004004           3745            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003596                          3746            
00003596                          3747            *INTITIALIZE FOR BIT SHIFTING
00003596  41F9 00004008           3748            LEA     VAR_TEMP_CLEANCOPY,A0
0000359C  2C39 00004008           3749            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000035A2                          3750  DEST_LOOP_SHIFTING7
000035A2  0C02 0000               3751            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000035A6  6700 0008               3752            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000035AA  E24E                    3753            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000035AC  5302                    3754            SUB.B   #1,D2                     *DECREMENT COUNTER
000035AE  60F2                    3755            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
000035B0                          3756  DEST_MASKING_NEXT7
000035B0  CCBC 00000007           3757            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000035B6                          3758           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000035B6                          3759            
000035B6                          3760  DEST_CHECK_WORD  
000035B6  41F9 00003FFC           3761            LEA     TEMP_REGISTER_FORMAT,A0
000035BC  1439 00003FFA           3762            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000035C2  1082                    3763            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000035C4  0239 0020 00003FFC      3764            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000035CC  0C39 0020 00003FFC      3765            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000035D4  6700 0026               3766            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000035D8  0C06 0000               3767            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
000035DC  6600 001E               3768            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
000035E0                          3769            *IT IS A WORD AT THIS POINT*
000035E0                          3770            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000035E0  163C 0020               3771            MOVE.B    #' ',D3
000035E4  6100 00EE               3772            BSR       PUSH_STACK
000035E8  163C 0024               3773            MOVE.B    #'$',D3
000035EC  6100 00E6               3774            BSR       PUSH_STACK
000035F0  321D                    3775            MOVE.W    (A5)+,D1
000035F2  7404                    3776            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000035F4  6100 DBF2               3777            BSR       HEX2ASCII2STACK
000035F8  6000 009A               3778            BRA       GET_DST_SUCCESS
000035FC                          3779  
000035FC                          3780  DEST_CHECK_LONG
000035FC  41F9 00003FFC           3781            LEA     TEMP_REGISTER_FORMAT,A0
00003602  1439 00003FFA           3782            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003608  1082                    3783            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000360A  0239 0040 00003FFC      3784            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003612  0C39 0040 00003FFC      3785            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000361A  6700 002E               3786            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000361E  0C06 0001               3787            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003622  6600 0026               3788            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003626                          3789            *IT IS A WORD AT THIS POINT*
00003626                          3790            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003626  163C 0020               3791            MOVE.B    #' ',D3
0000362A  6100 00A8               3792            BSR       PUSH_STACK
0000362E  163C 0024               3793            MOVE.B    #'$',D3
00003632  6100 00A0               3794            BSR       PUSH_STACK
00003636  321D                    3795            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003638  7404                    3796            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
0000363A  6100 DBAC               3797            BSR       HEX2ASCII2STACK
0000363E  321D                    3798            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003640  7404                    3799            MOVE.L    #4,D2          
00003642  6100 DBA4               3800            BSR       HEX2ASCII2STACK
00003646  6000 004C               3801            BRA     GET_DST_SUCCESS
0000364A                          3802            
0000364A                          3803  DEST_CHECK_IMMEDIATE
0000364A  41F9 00003FFC           3804            LEA     TEMP_REGISTER_FORMAT,A0
00003650  1439 00003FFA           3805            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003656  1082                    3806            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003658  0239 0080 00003FFC      3807            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003660  0C39 0080 00003FFC      3808            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003668  6700 0026               3809            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000366C  0C06 0004               3810            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003670  6600 001E               3811            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003674                          3812            
00003674                          3813            *IT IS A WORD AT THIS POINT*
00003674                          3814            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003674  163C 0020               3815            MOVE.B    #' ',D3
00003678  6100 005A               3816            BSR       PUSH_STACK
0000367C  163C 0023               3817            MOVE.B    #'#',D3
00003680  6100 0052               3818            BSR       PUSH_STACK
00003684  321D                    3819            MOVE.W    (A5)+,D1
00003686  7404                    3820            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003688  6100 DB5E               3821            BSR       HEX2ASCII2STACK
0000368C  6000 0006               3822            BRA       GET_DST_SUCCESS
00003690                          3823            
00003690                          3824  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003690  7801                    3825            MOVE.L #1,D4
00003692  4E75                    3826            RTS
00003694                          3827  GET_DST_SUCCESS 
00003694  4E75                    3828            RTS
00003696                          3829  
00003696                          3830  
00003696                          3831  *---------------------------------------------------------------------------*
00003696                          3832  * STACK/QUEUE INTERFACE
00003696                          3833  *---------------------------------------------------------------------------*
00003696                          3834  PRINT_STACK
00003696  0C39 0000 00003FF6      3835            CMP.B     #0,COUNTER
0000369E  6700 000E               3836            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
000036A2                          3837            
000036A2                          3838  PRINT_STACK_HELPER
000036A2  6100 0038               3839            BSR      POP_STACK          *PRINTS ADDRESS
000036A6  103C 0006               3840            MOVE.B   #6,D0              *Display single character in D1.B. 
000036AA  4E4F                    3841            TRAP     #15             *ACTIVATES PRINT
000036AC                          3842  
000036AC  60E8                    3843            BRA       PRINT_STACK
000036AE                          3844  PRINT_STACK_RETURN
000036AE  4E75                    3845            RTS
000036B0                          3846            
000036B0                          3847            
000036B0                          3848  PRINT_QUEUE
000036B0  0C39 0000 00003FF6      3849            CMP.B     #0,COUNTER
000036B8  6700 0018               3850            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
000036BC                          3851            
000036BC                          3852  PRINT_QUEUE_HELPER
000036BC  33F9 00003FF6 00003FF8  3853            MOVE.W   COUNTER,QUEUE_COUNTER
000036C6  6100 0022               3854            BSR      POP_FRONT          *PRINTS ADDRESS
000036CA  103C 0006               3855            MOVE.B   #6,D0              *Display single character in D1.B. 
000036CE  4E4F                    3856            TRAP     #15             *ACTIVATES PRINT
000036D0                          3857  
000036D0  60DE                    3858            BRA       PRINT_QUEUE
000036D2                          3859  PRINT_QUEUE_RETURN
000036D2  4E75                    3860            RTS
000036D4                          3861            
000036D4                          3862  *PUSHES.W CONTENTS OF [D3] INTO STACK          
000036D4                          3863  PUSH_STACK
000036D4  1503                    3864              MOVE.B  D3,-(A2)
000036D6  6100 0058               3865              BSR     INCREMENT
000036DA  4E75                    3866              RTS
000036DC                          3867  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
000036DC                          3868  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
000036DC                          3869  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
000036DC                          3870  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
000036DC                          3871  *         TRAP        #15             *ACTIVATES PRINT
000036DC                          3872  POP_STACK
000036DC  BECA                    3873              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
000036DE  6700 0008               3874              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
000036E2  121A                    3875              MOVE.B  (A2)+,D1 
000036E4  6100 0052               3876              BSR     DECREMENT
000036E8                          3877  POP_RETURN
000036E8  4E75                    3878              RTS 
000036EA                          3879        
000036EA                          3880  *USE [A4] AS SECOND POINTER IN SHIFTING      
000036EA  0C39 0000 00003FF8      3881  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000036F2  6700 0030               3882              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
000036F6                          3883              
000036F6                          3884              
000036F6                          3885              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
000036F6  347C 7000               3886              MOVEA.W #STACK,A2   *START A2 AT STACK
000036FA  0622 0000               3887              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
000036FE  384A                    3888              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003700  0624 0000               3889              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003704  1212                    3890              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003706                          3891  POP_SHIFT_LOOP
00003706  0C39 0000 00003FF8      3892              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000370E  6700 0014               3893              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003712  1494                    3894              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003714  0624 0000               3895              ADD.B   #0,-(A4)
00003718  0622 0000               3896              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
0000371C  5339 00003FF8           3897              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003722                          3898              
00003722  60E2                    3899              BRA     POP_SHIFT_LOOP
00003724                          3900                          
00003724                          3901  POP_FRONT_RETURN 
00003724                          3902              *RESET A2 BACK TO SP
00003724  347C 7000               3903              MOVEA.W #STACK,A2    
00003728  5339 00003FF6           3904              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
0000372E  4E75                    3905              RTS   
00003730                          3906  
00003730                          3907  INCREMENT
00003730  5239 00003FF6           3908              ADD.B   #1, COUNTER
00003736  4E75                    3909              RTS           
00003738                          3910  DECREMENT
00003738  5339 00003FF6           3911              SUB.B   #1, COUNTER
0000373E  4E75                    3912              RTS           
00003740                          3913  CLEAR_STACK
00003740  0C39 0000 00003FF6      3914              CMP.B     #0,COUNTER
00003748  6700 0006               3915              BEQ       CLEAR_RETURN
0000374C  618E                    3916              BSR       POP_STACK
0000374E  60F0                    3917              BRA       CLEAR_STACK
00003750                          3918   
00003750                          3919  CLEAR_RETURN
00003750  4E75                    3920              RTS    
00003752                          3921  *---------------------------------------------------------------------------*
00003752                          3922  * TERMINATE
00003752                          3923  *---------------------------------------------------------------------------*
00003752                          3924  TERMINATE   
00003752  43F9 00003B02           3925              LEA     FINMSG,A1
00003758  103C 000E               3926              MOVE.B  #14,D0
0000375C  4E4F                    3927              TRAP    #15
0000375E                          3928  
0000375E  103C 0009               3929              MOVE.B  #9,D0
00003762  4E4F                    3930              TRAP    #15
00003764                          3931  
00003764                          3932  *---------------------------------------------------------------------------*
00003764                          3933  * Data storage                                                 
00003764                          3934  *---------------------------------------------------------------------------*  
00003764                          3935  WELCOME
00003764= 20 20 20 20 20 20 ...   3936              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
000037B4= 3D 3D 3D 3D 3D 20 ...   3937              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003804= 3D 3D 3D 3D 3D 20 ...   3938              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003854                          3939      
00003854= 20 20 20 20 20 20 ...   3940              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
000038A4= 20 20 20 20 20 20 ...   3941              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
000038F4= 20 20 20 20 20 20 ...   3942              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00003944                          3943      
00003944= 20 20 20 20 20 20 ...   3944              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00003994= 3D 3D 3D 3D 3D 20 ...   3945              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
000039E4= 3D 3D 3D 3D 3D 20 ...   3946              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00003A39                          3947  
00003A39                          3948  PROMPT_START
00003A39= 50 6C 65 61 73 65 ...   3949              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00003A68                          3950      
00003A68                          3951  PROMPT_END
00003A68= 50 6C 65 61 73 65 ...   3952              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00003A95= 0D 0A 48 69 74 20 ...   3953  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00003ABF= 57 6F 75 6C 64 20 ...   3954  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00003B02= 54 68 61 6E 6B 20 ...   3955  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00003B2D= 45 72 72 6F 72 3A ...   3956  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00003B4C= 45 72 72 6F 72 3A ...   3957  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00003B71= 45 72 72 6F 72 3A ...   3958  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00003B9E                          3959  
00003B9E                          3960  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00003BEE                          3961  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00003C3E                          3962  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00003C42                          3963  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00003C46= 0D 0A 00                3964  ENDLINE_M   DC.B    CR,LF,0
00003C49                          3965  TMPINPUT    DS.B    80                      * temp store user input
00003C99                          3966  TMPOUTPUT   DS.B    80                      * temp store prog output
00003CE9= 20 20 20 4F 52 49 ...   3967  DISP_ORI_B  DC.B    '   ORI.B',0
00003CF2= 20 20 20 4F 52 49 ...   3968  DISP_ORI_W  DC.B    '   ORI.W',0
00003CFB= 20 20 20 4F 52 49 ...   3969  DISP_ORI_L  DC.B    '   ORI.L',0
00003D04= 20 20 20 45 4F 52 ...   3970  DISP_EORI_B  DC.B    '   EORI.B',0
00003D0E= 20 20 20 45 4F 52 ...   3971  DISP_EORI_W  DC.B    '   EORI.W',0
00003D18= 20 20 20 45 4F 52 ...   3972  DISP_EORI_L  DC.B    '   EORI.L',0
00003D22= 20 20 20 42 54 53 ...   3973  DISP_BTST   DC.B    '   BTST',0
00003D2A= 20 20 20 43 4D 50 ...   3974  DISP_CMPI_B  DC.B    '   CMPI.B',0
00003D34= 20 20 20 43 4D 50 ...   3975  DISP_CMPI_W  DC.B    '   CMPI.W',0
00003D3E= 20 20 20 43 4D 50 ...   3976  DISP_CMPI_L  DC.B    '   CMPI.L',0
00003D48= 20 20 20 44 41 54 ...   3977  DISP_DATA   DC.B    '   DATA',0
00003D50= 20 20 20 4D 4F 56 ...   3978  DISP_MOVE_B DC.B    '   MOVE.B',0
00003D5A= 20 20 20 4D 4F 56 ...   3979  DISP_MOVE_W DC.B    '   MOVE.W',0
00003D64= 20 20 20 4D 4F 56 ...   3980  DISP_MOVE_L DC.B    '   MOVE.L',0
00003D6E= 20 20 20 52 54 53 00    3981  DISP_RTS    DC.B    '   RTS',0
00003D75= 20 20 20 4A 53 52 00    3982  DISP_JSR    DC.B    '   JSR',0
00003D7C= 20 20 20 4E 45 47 ...   3983  DISP_NEG_B    DC.B    '   NEG.B',0
00003D85= 20 20 20 4E 45 47 ...   3984  DISP_NEG_W    DC.B    '   NEG.W',0
00003D8E= 20 20 20 4E 45 47 ...   3985  DISP_NEG_L    DC.B    '   NEG.L',0
00003D97= 20 20 20 4E 4F 54 ...   3986  DISP_NOT_B  DC.B    '   NOT.B',0
00003DA0= 20 20 20 4E 4F 54 ...   3987  DISP_NOT_W  DC.B    '   NOT.W',0
00003DA9= 20 20 20 4E 4F 54 ...   3988  DISP_NOT_L  DC.B    '   NOT.L',0
00003DB2= 20 20 20 4C 45 41 00    3989  DISP_LEA    DC.B    '   LEA',0
00003DB9= 20 20 20 4D 4F 56 ...   3990  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00003DC4= 20 20 20 4D 4F 56 ...   3991  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00003DCF= 20 20 20 41 44 44 ...   3992  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00003DD9= 20 20 20 41 44 44 ...   3993  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00003DE3= 20 20 20 41 44 44 ...   3994  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00003DED= 20 20 20 44 49 56 ...   3995  DISP_DIVS   DC.B    '   DIVS',0
00003DF5= 20 20 20 53 55 42 ...   3996  DISP_SUB_B  DC.B    '   SUB.B',0
00003DFE= 20 20 20 53 55 42 ...   3997  DISP_SUB_W  DC.B    '   SUB.W',0
00003E07= 20 20 20 53 55 42 ...   3998  DISP_SUB_L  DC.B    '   SUB.L',0
00003E10= 20 20 20 53 55 42 ...   3999  DISP_SUBI_B  DC.B    '   SUBI.B',0
00003E1A= 20 20 20 53 55 42 ...   4000  DISP_SUBI_W  DC.B    '   SUBI.W',0
00003E24= 20 20 20 53 55 42 ...   4001  DISP_SUBI_L  DC.B    '   SUBI.L',0
00003E2E= 20 20 20 53 55 42 ...   4002  DISP_SUBA_W  DC.B    '   SUBA.W',0
00003E38= 20 20 20 53 55 42 ...   4003  DISP_SUBA_L  DC.B    '   SUBA.L',0
00003E42= 20 20 20 45 4F 52 ...   4004  DISP_EOR_B  DC.B    '   EOR.B',0
00003E4B= 20 20 20 45 4F 52 ...   4005  DISP_EOR_W  DC.B    '   EOR.W',0
00003E54= 20 20 20 45 4F 52 ...   4006  DISP_EOR_L  DC.B    '   EOR.L',0
00003E5D= 20 20 20 43 4D 50 ...   4007  DISP_CMP_B  DC.B    '   CMP.B',0
00003E66= 20 20 20 43 4D 50 ...   4008  DISP_CMP_W  DC.B    '   CMP.W',0
00003E6F= 20 20 20 43 4D 50 ...   4009  DISP_CMP_L  DC.B    '   CMP.L',0
00003E78= 20 20 20 43 4D 50 ...   4010  DISP_CMPA_W  DC.B    '   CMPA.W',0
00003E82= 20 20 20 43 4D 50 ...   4011  DISP_CMPA_L  DC.B    '   CMPA.L',0
00003E8C= 20 20 20 4D 55 4C ...   4012  DISP_MULS_W DC.B    '   MULS.W',0
00003E96= 20 20 20 41 4E 44 ...   4013  DISP_AND_B  DC.B    '   AND.B',0
00003E9F= 20 20 20 41 4E 44 ...   4014  DISP_AND_W  DC.B    '   AND.W',0
00003EA8= 20 20 20 41 4E 44 ...   4015  DISP_AND_L  DC.B    '   AND.L',0
00003EB1= 20 20 20 41 44 44 ...   4016  DISP_ADD_B  DC.B    '   ADD.B',0
00003EBA= 20 20 20 41 44 44 ...   4017  DISP_ADD_W  DC.B    '   ADD.W',0
00003EC3= 20 20 20 41 44 44 ...   4018  DISP_ADD_L  DC.B    '   ADD.L',0
00003ECC= 20 20 20 41 44 44 ...   4019  DISP_ADDA_W DC.B    '   ADDA.W',0
00003ED6= 20 20 20 41 44 44 ...   4020  DISP_ADDA_L DC.B    '   ADDA.L',0
00003EE0= 20 20 20 4C 53 52 ...   4021  DISP_LSR_B  DC.B    '   LSR.B',0
00003EE9= 20 20 20 4C 53 4C ...   4022  DISP_LSL_B  DC.B    '   LSL.B',0
00003EF2= 20 20 20 4C 53 52 ...   4023  DISP_LSR_W  DC.B    '   LSR.W',0
00003EFB= 20 20 20 4C 53 4C ...   4024  DISP_LSL_W  DC.B    '   LSL.W',0
00003F04= 20 20 20 4C 53 52 ...   4025  DISP_LSR_L  DC.B    '   LSR.L',0
00003F0D= 20 20 20 4C 53 4C ...   4026  DISP_LSL_L  DC.B    '   LSL.L',0
00003F16= 20 20 20 41 53 52 ...   4027  DISP_ASR_B  DC.B    '   ASR.B',0
00003F1F= 20 20 20 41 53 4C ...   4028  DISP_ASL_B  DC.B    '   ASL.B',0
00003F28= 20 20 20 41 53 52 ...   4029  DISP_ASR_W  DC.B    '   ASR.W',0
00003F31= 20 20 20 41 53 4C ...   4030  DISP_ASL_W  DC.B    '   ASL.W',0
00003F3A= 20 20 20 41 53 52 ...   4031  DISP_ASR_L  DC.B    '   ASR.L',0
00003F43= 20 20 20 41 53 4C ...   4032  DISP_ASL_L  DC.B    '   ASL.L',0
00003F4C= 20 20 20 52 4F 52 ...   4033  DISP_ROR_B  DC.B    '   ROR.B',0
00003F55= 20 20 20 52 4F 4C ...   4034  DISP_ROL_B  DC.B    '   ROL.B',0
00003F5E= 20 20 20 52 4F 52 ...   4035  DISP_ROR_W  DC.B    '   ROR.W',0
00003F67= 20 20 20 52 4F 4C ...   4036  DISP_ROL_W  DC.B    '   ROL.W',0
00003F70= 20 20 20 52 4F 52 ...   4037  DISP_ROR_L  DC.B    '   ROR.L',0
00003F79= 20 20 20 52 4F 4C ...   4038  DISP_ROL_L  DC.B    '   ROL.L',0
00003F82= 20 20 20 42 52 41 00    4039  DISP_BRA    DC.B    '   BRA',0
00003F89= 20 20 20 42 4C 54 00    4040  DISP_BLT    DC.B    '   BLT',0
00003F90= 20 20 20 42 45 51 00    4041  DISP_BEQ    DC.B    '   BEQ',0
00003F97= 20 20 20 42 4E 45 00    4042  DISP_BNE    DC.B    '   BNE',0
00003F9E= 20 20 20 42 48 49 00    4043  DISP_BHI    DC.B    '   BHI',0
00003FA5= 20 20 20 4D 4F 56 ...   4044  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00003FB0= 20 20 20 4D 4F 56 ...   4045  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00003FBB                          4046  
00003FBB= 20 20 20 24 00          4047  DISP_HEX     DC.B    '   $',0
00003FC0= 20 20 20 44 00          4048  DISP_D  DC.B    '   D',0
00003FC5= 20 20 20 41 00          4049  DISP_A  DC.B    '   A',0
00003FCA= 20 20 20 28 00          4050  DISP_OP  DC.B    '   (',0
00003FCF= 29 00                   4051  DISP_CP  DC.B   ')',0
00003FD1= 20 20 20 28 41 00       4052  DISP_AOP  DC.B    '   (A',0
00003FD7                          4053  
00003FD7= 20 20 20 2D 28 41 00    4054  DISP_PRE    DC.B    '   -(A',0
00003FDE= 29 2B 00                4055  DISP_POST   DC.B    ')+',0
00003FE1= 20 20 20 23 00          4056  DISP_LB DC.B    '   #',0
00003FE6= 30 00                   4057  DISP_0  DC.B    '0',0
00003FE8= 31 00                   4058  DISP_1  DC.B    '1',0
00003FEA= 32 00                   4059  DISP_2  DC.B    '2',0
00003FEC= 33 00                   4060  DISP_3  DC.B    '3',0
00003FEE= 34 00                   4061  DISP_4  DC.B    '4',0
00003FF0= 35 00                   4062  DISP_5  DC.B    '5',0
00003FF2= 36 00                   4063  DISP_6  DC.B    '6',0
00003FF4= 37 00                   4064  DISP_7  DC.B    '7',0
00003FF6                          4065  
00003FF6                          4066  *STACK INTERFACE VARIABLES*
00003FF6                          4067  COUNTER         DS.W    1
00003FF8                          4068  QUEUE_COUNTER   DS.W    1
00003FFA                          4069  
00003FFA                          4070  *EA DECODING INTERFACE VARIABLES* 
00003FFA                          4071  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00003FFB                          4072  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00003FFC                          4073  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00003FFD                          4074  
00003FFD                          4075  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00003FFD                          4076  * WORD + WORD = LONG
00003FFD                          4077  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00003FFD                          4078  * A              + F            = AF         <= EXAMPLE
00003FFD                          4079  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00003FFD                          4080  GET_DST_START_END    DS.B    1
00003FFE                          4081  GET_SRC_START_END    DS.B    1
00003FFF                          4082  
00003FFF                          4083  *STORES THE START + END BITS HERE (FROM ABOVE)
00004000                          4084  VAR_BYTE_START      DS.L    1
00004004                          4085  VAR_BYTE_END        DS.L    1
00004008                          4086  VAR_TEMP_CLEANCOPY  DS.L    1
0000400C                          4087  
0000400C                          4088  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004010                          4089  
00004010                          4090  *MORE FOR STACK USAGE*
00004010= 2C 00                   4091  DISP_COMMA  DC.B    ',',0
00004012= 20 20 20 00             4092  DISP_INDENT  DC.B    '   ',0
00004016                          4093  
00004016                          4094  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004016                          4095  POINTER_WORD    DS.W       1
00004018                          4096  
00004018                          4097  
00004018                          4098  
00004018                          4099  *---------------------------------------------------------------------------*
00004018                          4100  * Ends program
00004018                          4101  *---------------------------------------------------------------------------*
00004018                          4102              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1144
ASCII2HEX           113E
ASC_ERR             11A0
ASC_LOW             1182
ASC_NUM             1192
ASC_SFT             119A
ASC_UPP             118A
CHECK0              2E48
CHECK1              2ED2
CHECK2              2F5C
CHECK3              2FF6
CHECK4              3098
CHECK7              313A
CHECK_IMMEDIATE     321A
CHECK_LONG          31CC
CHECK_WORD          3186
CLEAR_RETURN        3750
CLEAR_STACK         3740
COUNTER             3FF6
CR                  D
DECREMENT           3738
DEST_CHECK0         3278
DEST_CHECK1         3302
DEST_CHECK2         338C
DEST_CHECK3         3426
DEST_CHECK4         34C8
DEST_CHECK7         356A
DEST_CHECK_IMMEDIATE  364A
DEST_CHECK_LONG     35FC
DEST_CHECK_WORD     35B6
DEST_LOOP_SHIFTING  32E2
DEST_LOOP_SHIFTING1  336C
DEST_LOOP_SHIFTING2  33FE
DEST_LOOP_SHIFTING3  3498
DEST_LOOP_SHIFTING4  3542
DEST_LOOP_SHIFTING7  35A2
DEST_MASKING_NEXT   32F0
DEST_MASKING_NEXT1  337A
DEST_MASKING_NEXT2  340C
DEST_MASKING_NEXT3  34A6
DEST_MASKING_NEXT4  3550
DEST_MASKING_NEXT7  35B0
DEST_MODE           2A00
DEST_REGISTER       2CD0
DEST_REGISTER_FORMAT  3FFA
DISPLAY_30_LINES    12EC
DISP_0              3FE6
DISP_1              3FE8
DISP_2              3FEA
DISP_3              3FEC
DISP_4              3FEE
DISP_5              3FF0
DISP_6              3FF2
DISP_7              3FF4
DISP_A              3FC5
DISP_ADDA_L         3ED6
DISP_ADDA_W         3ECC
DISP_ADDQ_B         3DCF
DISP_ADDQ_L         3DE3
DISP_ADDQ_W         3DD9
DISP_ADD_B          3EB1
DISP_ADD_L          3EC3
DISP_ADD_W          3EBA
DISP_AND_B          3E96
DISP_AND_L          3EA8
DISP_AND_W          3E9F
DISP_AOP            3FD1
DISP_ASL_B          3F1F
DISP_ASL_L          3F43
DISP_ASL_W          3F31
DISP_ASR_B          3F16
DISP_ASR_L          3F3A
DISP_ASR_W          3F28
DISP_BEQ            3F90
DISP_BHI            3F9E
DISP_BLT            3F89
DISP_BNE            3F97
DISP_BRA            3F82
DISP_BTST           3D22
DISP_CMPA_L         3E82
DISP_CMPA_W         3E78
DISP_CMPI_B         3D2A
DISP_CMPI_L         3D3E
DISP_CMPI_W         3D34
DISP_CMP_B          3E5D
DISP_CMP_L          3E6F
DISP_CMP_W          3E66
DISP_COMMA          4010
DISP_CP             3FCF
DISP_D              3FC0
DISP_DATA           3D48
DISP_DIVS           3DED
DISP_EORI_B         3D04
DISP_EORI_L         3D18
DISP_EORI_W         3D0E
DISP_EOR_B          3E42
DISP_EOR_L          3E54
DISP_EOR_W          3E4B
DISP_HEX            3FBB
DISP_INDENT         4012
DISP_JSR            3D75
DISP_LB             3FE1
DISP_LEA            3DB2
DISP_LSL_B          3EE9
DISP_LSL_L          3F0D
DISP_LSL_W          3EFB
DISP_LSR_B          3EE0
DISP_LSR_L          3F04
DISP_LSR_W          3EF2
DISP_MOVEA_L        3FB0
DISP_MOVEA_W        3FA5
DISP_MOVEM_L        3DC4
DISP_MOVEM_W        3DB9
DISP_MOVE_B         3D50
DISP_MOVE_L         3D64
DISP_MOVE_W         3D5A
DISP_MULS_W         3E8C
DISP_NEG_B          3D7C
DISP_NEG_L          3D8E
DISP_NEG_W          3D85
DISP_NEXT           3A95
DISP_NOT_B          3D97
DISP_NOT_L          3DA9
DISP_NOT_W          3DA0
DISP_OP             3FCA
DISP_ORI_B          3CE9
DISP_ORI_L          3CFB
DISP_ORI_W          3CF2
DISP_POST           3FDE
DISP_PRE            3FD7
DISP_ROL_B          3F55
DISP_ROL_L          3F79
DISP_ROL_W          3F67
DISP_ROR_B          3F4C
DISP_ROR_L          3F70
DISP_ROR_W          3F5E
DISP_RTS            3D6E
DISP_SUBA_L         3E38
DISP_SUBA_W         3E2E
DISP_SUBI_B         3E10
DISP_SUBI_L         3E24
DISP_SUBI_W         3E1A
DISP_SUB_B          3DF5
DISP_SUB_L          3E07
DISP_SUB_W          3DFE
D_MODE000           2AA2
D_MODE010           2AEA
D_MODE011           2B4A
D_MODE100           2B6A
D_MODE111           2BBC
EA_ARITH            299A
EA_DATA             14CA
EA_GEN              29E6
EA_MOVEA            29C0
EA_NOSRC            2986
ENDLINE_M           3C46
END_ADDR            108A
ERRMSG_1            3B2D
ERRMSG_3            3B4C
ERRMSG_5            3B71
ERROR_1             10EE
ERROR_2             10FE
ERROR_3             110E
ERROR_4             111E
ERROR_5             112E
E_ADDR_HX           3C42
FINMSG              3B02
GET_DST_FAILED      3690
GET_DST_START_END   3FFD
GET_DST_SUCCESS     3694
GET_EA_EA_DEST      3266
GET_EA_EA_SRC       2E36
GET_SRC_FAILED      3260
GET_SRC_START_END   3FFE
GET_SRC_SUCCESS     3264
HEX2ASCII           11A6
HEX2ASCII2STACK     11E8
HEX_CHAR            11D4
HEX_CONT            11D8
HEX_LOOP            11BA
IMMD_B              2C70
IMMD_L              2CB0
IMMD_W              2C90
IMMEDIATE           2C40
INCREMENT           3730
INTRO               1028
IS_ODD              122C
IS_ODD_ERR          1242
JMPTABLE            1318
LF                  A
LONGMODE            2C14
LOOP_SHIFTING       2EB2
LOOP_SHIFTING1      2F3C
LOOP_SHIFTING2      2FCE
LOOP_SHIFTING3      3068
LOOP_SHIFTING4      3112
MAIN                1248
MASKING_NEXT        2EC0
MASKING_NEXT1       2F4A
MASKING_NEXT2       2FDC
MASKING_NEXT3       3076
MASKING_NEXT4       3120
MODE000             2A8E
MODE001             2AB6
MODE010             2ACA
MODE011             2B0A
MODE100             2B2A
MODE111             2B8A
NEXTLINES           12FA
OP0000              1378
OP0001              159E
OP0010              160C
OP0011              170A
OP0100              1806
OP0101              19A0
OP0110              1A1C
OP0111              1AAA
OP1000              1AAE
OP1001              1AEA
OP1001_ADD_RETURN   1E38
OP1001_DETERMINE_DN_EA_OR_EA_DN  1C00
OP1001_DN_EA        1C38
OP1001_EA_DN        1D38
OP1001_PRINT_B      1D60
OP1001_PRINT_B2     1C60
OP1001_PRINT_L      1DF0
OP1001_PRINT_L2     1CF0
OP1001_PRINT_W      1DA8
OP1001_PRINT_W2     1CA8
OP1001_SUBA_L       1B1C
OP1001_SUBA_W       1B8E
OP1010              1EA6
OP1011              1EAA
OP1100              1FA6
OP1100_AND_RETURN   22F6
OP1100_DETERMINE_DN_EA_OR_EA_DN  20BC
OP1100_DN_EA        20F6
OP1100_EA_DN        21F6
OP1100_EA_DN_MULS   2004
OP1100_MULS_DN_EA_OR_EA_DN  1FD6
OP1100_MULS_RETURN  20BA
OP1100_PRINT_B      221E
OP1100_PRINT_B2     211E
OP1100_PRINT_L      22AE
OP1100_PRINT_L2     21AE
OP1100_PRINT_L_MULS  2072
OP1100_PRINT_W      2266
OP1100_PRINT_W2     2166
OP1100_PRINT_W_MULS  202A
OP1101              22F8
OP1101_ADDA_L       232A
OP1101_ADDA_W       239C
OP1101_ADD_RETURN   2646
OP1101_DETERMINE_DN_EA_OR_EA_DN  240E
OP1101_DN_EA        2446
OP1101_EA_DN        2546
OP1101_PRINT_B      256E
OP1101_PRINT_B2     246E
OP1101_PRINT_L      25FE
OP1101_PRINT_L2     24FE
OP1101_PRINT_W      25B6
OP1101_PRINT_W2     24B6
OP1110              26D4
OP1111              2982
OP_ADDA_L           26BC
OP_ADDA_W           26A4
OP_ADDQ             19C0
OP_ADDQ_B           19E6
OP_ADDQ_L           1A0A
OP_ADDQ_W           19F8
OP_ADD_B            265C
OP_ADD_L            268C
OP_ADD_W            2674
OP_ASL              2874
OP_ASL_B            2898
OP_ASL_L            28AA
OP_ASL_W            28BC
OP_ASR              281A
OP_ASR_B            283E
OP_ASR_L            2850
OP_ASR_W            2862
OP_ASX              2736
OP_BEQ              1A80
OP_BHI              1A64
OP_BLT              1A9C
OP_BNE              1A72
OP_BRA              1A8E
OP_BTST             13EC
OP_CMPA_L           1F16
OP_CMPA_W           1F04
OP_CMPI             14F2
OP_CMPI_B           1512
OP_CMPI_L           1536
OP_CMPI_W           1524
OP_CMP_B            1F28
OP_CMP_L            1F58
OP_CMP_W            1F40
OP_DATA             14A6
OP_DIVS             1AD6
OP_EORI             13FA
OP_EORI_B           141A
OP_EORI_L           143E
OP_EORI_W           142C
OP_EOR_B            1F70
OP_EOR_L            1F94
OP_EOR_W            1F82
OP_JSR              197E
OP_LEA              18AC
OP_LSL              27C0
OP_LSL_B            27E4
OP_LSL_L            27F6
OP_LSL_W            2808
OP_LSR              2766
OP_LSR_B            278A
OP_LSR_L            279C
OP_LSR_W            27AE
OP_LSX              271E
OP_MOVEA_L          169A
OP_MOVEA_W          1796
OP_MOVEM_L          189A
OP_MOVEM_W          1888
OP_MOVE_B           15A4
OP_MOVE_L           1632
OP_MOVE_W           172E
OP_MULS             1FC8
OP_NEG              18C0
OP_NEG_B            18E0
OP_NEG_L            1910
OP_NEG_W            18F8
OP_NOT              1928
OP_NOT_B            1948
OP_NOT_L            196C
OP_NOT_W            195A
OP_ORI              1548
OP_ORI_B            1568
OP_ORI_L            158C
OP_ORI_W            157A
OP_ROL              2928
OP_ROL_B            294C
OP_ROL_L            295E
OP_ROL_W            2970
OP_ROR              28CE
OP_ROR_B            28F2
OP_ROR_L            2904
OP_ROR_W            2916
OP_ROX              274E
OP_RTS              1992
OP_SUBA_L           1E94
OP_SUBA_W           1E82
OP_SUBI             1450
OP_SUBI_B           1470
OP_SUBI_L           1494
OP_SUBI_W           1482
OP_SUB_B            1E3A
OP_SUB_L            1E6A
OP_SUB_W            1E52
OUTPUT_PROCESSED_DATA  12CC
POINTER_WORD        4016
POP_FRONT           36EA
POP_FRONT_RETURN    3724
POP_RETURN          36E8
POP_SHIFT_LOOP      3706
POP_STACK           36DC
PRINT_QUEUE         36B0
PRINT_QUEUE_HELPER  36BC
PRINT_QUEUE_RETURN  36D2
PRINT_STACK         3696
PRINT_STACK_HELPER  36A2
PRINT_STACK_RETURN  36AE
PROGLP              100A
PROMPT_END          3A68
PROMPT_START        3A39
PUSH_STACK          36D4
QUEUE_COUNTER       3FF8
REG_0               2D84
REG_1               2D92
REG_2               2DA0
REG_3               2DAE
REG_4               2DBC
REG_5               2DCA
REG_6               2DD8
REG_7               2DE6
REPEAT              2DF4
REPEATMSG           3ABF
RETURN              11A4
SRC_LOOP_SHIFTING   3172
SRC_MASKING_NEXT    3180
SRC_MODE            2A44
SRC_REGISTER        2D2C
SRC_REGISTER_FORMAT  3FFB
STACK               7000
STACK_HEX_CHAR      1216
STACK_HEX_CONT      121A
STACK_HEX_LOOP      11FC
START               1004
START_ADDR          1038
S_ADDR_HX           3C3E
TEMP_REGISTER_FORMAT  3FFC
TERMINATE           3752
TESTING             1036
TMPINPUT            3C49
TMPOUTPUT           3C99
VAR_BYTE_END        4004
VAR_BYTE_START      4000
VAR_LONG_ADDRESS_MODE_CHECK  400C
VAR_TEMP_CLEANCOPY  4008
VR_E_ADDR           3BEE
VR_S_ADDR           3B9E
WELCOME             3764
WORDMODE            2BE8
