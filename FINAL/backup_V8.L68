00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 3:24:16 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001048             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109A             38              JSR     END_ADDR
00001016  43F9 00004544             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012C0             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00004062             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  60FE                      53              BRA     TESTING
00001038  60FC                      54              BRA     TESTING
0000103A  60FA                      55              BRA     TESTING
0000103C  60F8                      56              BRA     TESTING
0000103E                            57              
0000103E                            58              
0000103E  67F6                      59              BEQ     TESTING
00001040  66F4                      60              BNE     TESTING
00001042  6DF2                      61              BLT     TESTING
00001044  62F0                      62              BHI     TESTING
00001046                            63  
00001046                            64  
00001046  4E75                      65              RTS
00001048                            66  *---------------------------------------------------------------------------*
00001048                            67  * START_ADDR: Compute the starting address
00001048                            68  *---------------------------------------------------------------------------*
00001048                            69  START_ADDR
00001048                            70              * Output
00001048  43F9 00004337             71              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000104E  103C 000E                 72              MOVE.B  #14,D0                  * Display PROMPT_START
00001052  4E4F                      73              TRAP    #15
00001054                            74      
00001054                            75              * Input
00001054  43F9 0000449C             76              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105A  103C 0002                 77              MOVE.B  #2,D0                   * Ask user for input
0000105E  4E4F                      78              TRAP    #15
00001060                            79              
00001060                            80              * Error Checking (length)
00001060  0C01 0000                 81              CMPI.B  #0, D1                  * Check if input length <= 0
00001064  6F00 0098                 82              BLE     ERROR_1
00001068  0C01 0008                 83              CMPI.B  #8, D1                  * Check if input length > 8
0000106C  6E00 0090                 84              BGT     ERROR_1
00001070                            85              
00001070                            86              * Conversion & Storage
00001070  4EB9 0000114E             87              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001076  0C07 0001                 88              CMPI.B  #1, D7                  * Check for error
0000107A  6700 0082                 89              BEQ     ERROR_1                 
0000107E  23C1 0000453C             90              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001084                            91              
00001084                            92              * Error Checking (Odd)
00001084  43F9 0000453C             93              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108A  4EB9 000012A4             94              JSR     IS_ODD                  * Check if the input address is odd
00001090  0C07 0001                 95              CMPI.B  #1, D7                  * Check for error
00001094  6700 0088                 96              BEQ     ERROR_3
00001098                            97              
00001098                            98              * Return
00001098  4E75                      99              RTS     
0000109A                           100  *---------------------------------------------------------------------------*
0000109A                           101  * END_ADDR: Compute the ending address
0000109A                           102  *---------------------------------------------------------------------------*
0000109A                           103  END_ADDR
0000109A                           104              * Output
0000109A  43F9 00004366            105              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A0  103C 000E                106              MOVE.B  #14,D0                  * Display PROMPT_END
000010A4  4E4F                     107              TRAP    #15
000010A6                           108  
000010A6                           109              * Input
000010A6  43F9 000044EC            110              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AC  103C 0002                111              MOVE.B  #2,D0                   * Ask user for input
000010B0  4E4F                     112              TRAP    #15
000010B2                           113              
000010B2                           114              * Error Checking (length)
000010B2  0C01 0000                115              CMPI.B  #0, D1                  * Check if input length <= 0
000010B6  6F00 0056                116              BLE     ERROR_2
000010BA  0C01 0008                117              CMPI.B  #8, D1                  * Check if input length > 8
000010BE  6E00 004E                118              BGT     ERROR_2
000010C2                           119              
000010C2                           120              * Conversion & Storage
000010C2  4EB9 0000114E            121              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010C8  0C07 0001                122              CMPI.B  #1, D7                  * Check for error
000010CC  6700 0040                123              BEQ     ERROR_2
000010D0  23C1 00004540            124              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D6                           125              
000010D6                           126              * Error Checking (start > end case)
000010D6  2439 0000453C            127              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DC  B282                     128              CMP.L   D2, D1                  * Compare starting and ending address
000010DE  6300 005E                129              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E2                           130              
000010E2                           131              * Error Checking (Odd case)
000010E2  43F9 00004540            132              LEA     E_ADDR_HX, A1           * Move the ending address
000010E8  4EB9 000012A4            133              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010EE  0C07 0001                134              CMPI.B  #1, D7                  * Check for an error flag
000010F2  6700 003A                135              BEQ     ERROR_4
000010F6                           136              
000010F6                           137              * Inputs are valid
000010F6  2A79 0000453C            138              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FC                           139              
000010FC  4E75                     140              RTS
000010FE                           141              
000010FE                           142  *---------------------------------------------------------------------------*
000010FE                           143  * ERROR_1: Address error (Invalid starting address)
000010FE                           144  *---------------------------------------------------------------------------*
000010FE                           145  ERROR_1
000010FE  43F9 0000442B            146              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001104  103C 000E                147              MOVE.B  #14, D0                 * Display ERRMSG_1
00001108  4E4F                     148              TRAP    #15
0000110A  4EF8 1048                149              JMP     START_ADDR              * Jump to START_ADDR
0000110E                           150      
0000110E                           151  *---------------------------------------------------------------------------*
0000110E                           152  * ERROR_2: Address error (Invalid ending address)
0000110E                           153  *---------------------------------------------------------------------------*
0000110E                           154  ERROR_2
0000110E  43F9 0000442B            155              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001114  103C 000E                156              MOVE.B  #14, D0                 * Display ERRMSG_1
00001118  4E4F                     157              TRAP    #15
0000111A  4EF8 109A                158              JMP     END_ADDR                * Jump to END_ADDR
0000111E                           159  
0000111E                           160  *---------------------------------------------------------------------------*
0000111E                           161  * ERROR_3: Address error (Odd starting address)
0000111E                           162  *---------------------------------------------------------------------------*
0000111E                           163  ERROR_3
0000111E  43F9 0000444A            164              LEA     ERRMSG_3, A1
00001124  103C 000E                165              MOVE.B  #14, D0
00001128  4E4F                     166              TRAP    #15
0000112A  4EF8 1048                167              JMP     START_ADDR
0000112E                           168     
0000112E                           169  *---------------------------------------------------------------------------*
0000112E                           170  * ERROR_4: Address error (Odd ending address)
0000112E                           171  *---------------------------------------------------------------------------*         
0000112E                           172  ERROR_4
0000112E  43F9 0000444A            173              LEA     ERRMSG_3, A1
00001134  103C 000E                174              MOVE.B  #14, D0
00001138  4E4F                     175              TRAP    #15
0000113A  4EF8 109A                176              JMP     END_ADDR
0000113E                           177            
0000113E                           178  *---------------------------------------------------------------------------*
0000113E                           179  * ERROR_3: Address error (Ending address is less than starting address)
0000113E                           180  *---------------------------------------------------------------------------*
0000113E                           181  ERROR_5
0000113E  43F9 0000446F            182              LEA     ERRMSG_5, A1
00001144  103C 000E                183              MOVE.B  #14, D0
00001148  4E4F                     184              TRAP    #15
0000114A  4EF8 109A                185              JMP     END_ADDR
0000114E                           186    
0000114E                           187  *---------------------------------------------------------------------------*
0000114E                           188  * ASCII2HEX: Convert ASCii to Hexadecimal
0000114E                           189  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000114E                           190  *---------------------------------------------------------------------------*
0000114E  4281                     191  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001150  4287                     192              CLR.L   D7                      * Set the error flag to 0
00001152  4282                     193              CLR.L   D2                      * Clear D2 for temp storage
00001154                           194              
00001154  1419                     195  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001156  0C02 0000                196              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115A  6700 0058                197              BEQ     RETURN                  * If it's NULL, go to return
0000115E  0C02 0066                198              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001162  6E00 004C                199              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001166  0C02 0061                200              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116A  6C00 0026                201              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000116E  0C02 0046                202              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001172  6E00 003C                203              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001176  0C02 0041                204              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117A  6C00 001E                205              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000117E  0C02 0039                206              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001182  6E00 002C                207              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001186  0C02 0030                208              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118A  6C00 0016                209              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000118E  6000 0020                210              BRA     ASC_ERR                 * Invalid input
00001192                           211  
00001192  0442 0057                212  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001196  6000 0012                213              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119A                           214              
0000119A  0442 0037                215  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000119E  6000 000A                216              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A2                           217              
000011A2  0442 0030                218  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A6  6000 0002                219              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AA                           220              
000011AA  E981                     221  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AC  D202                     222              ADD.B   D2, D1                  * Add the converted input to D1
000011AE  60A4                     223              BRA     ASC2HXLP                * Loop
000011B0                           224  
000011B0  1E3C 0001                225  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B4  4E75                     226  RETURN      RTS     
000011B6                           227  
000011B6                           228  *---------------------------------------------------------------------------*
000011B6                           229  * ASCII2HEX: Convert ASCii to Hexadecimal
000011B6                           230  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011B6                           231  *---------------------------------------------------------------------------*
000011B6                           232  ASCII2HEX2STACK
000011B6  4283                     233              CLR.L   D3                      * Clear the destination 
000011B8  4287                     234              CLR.L   D7                      * Set the error flag to 0
000011BA  4282                     235              CLR.L   D2                      * Clear D2 for temp storage
000011BC                           236              
000011BC                           237  ASC2HXLP2STACK
000011BC  1419                     238              MOVE.B  (A1)+, D2               * Read a byte to D2
000011BE  0C02 0000                239              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011C2  6700 0058                240              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011C6  0C02 0066                241              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011CA  6E00 004C                242              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011CE  0C02 0061                243              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011D2  6C00 0026                244              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011D6  0C02 0046                245              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011DA  6E00 003C                246              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011DE  0C02 0041                247              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011E2  6C00 001E                248              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011E6  0C02 0039                249              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011EA  6E00 002C                250              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
000011EE  0C02 0030                251              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011F2  6C00 0016                252              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
000011F6  6000 0020                253              BRA     ASC_ERR2STACK                 * Invalid input
000011FA                           254  
000011FA                           255  ASC_LOW2STACK
000011FA  0442 0057                256              SUBI    #87, D2                 * Convert the ASCII input to Hex
000011FE  6000 0012                257              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
00001202                           258              
00001202                           259  ASC_UPP2STACK
00001202  0442 0037                260              SUBI    #55, D2                 * Convert the ASCII input to Hex
00001206  6000 000A                261              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
0000120A                           262              
0000120A                           263  ASC_NUM2STACK
0000120A  0442 0030                264              SUBI    #48, D2                 * Convert the ASCII input to Hex
0000120E  6000 0002                265              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
00001212                           266              
00001212                           267  ASC_SFT2STACK
00001212  E983                     268              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
00001214  D602                     269              ADD.B   D2, D3                  * Add the converted input to D1
00001216  60A4                     270              BRA     ASC2HXLP2STACK                * Loop
00001218                           271  
00001218                           272  ASC_ERR2STACK
00001218  1E3C 0001                273              MOVE.B  #1, D7                  * Set the error flag to 1            
0000121C                           274  RETURN2STACK
0000121C  4E75                     275              RTS  
0000121E                           276  *---------------------------------------------------------------------------*
0000121E                           277  * HEX2ASCII: Convert Hexadecimal to ASCii 
0000121E                           278  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
0000121E                           279  *---------------------------------------------------------------------------*
0000121E  0C02 0008                280  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001222  6700 000E                281              BEQ     HEX_LOOP
00001226  4841                     282              SWAP    D1
00001228  0C02 0002                283              CMPI.B  #2,D2
0000122C  6600 0004                284              BNE     HEX_LOOP
00001230  E189                     285              LSL.L   #8,D1
00001232                           286             
00001232  E999                     287  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001234  2601                     288              MOVE.L  D1, D3                  * Move D1 to D3
00001236  0283 0000000F            289              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000123C  0C03 0009                290              CMPI.B  #9, D3                  * Compare te digit
00001240  6E00 000A                291              BGT     HEX_CHAR              
00001244  0603 0030                292              ADDI.B  #48,D3                  * Add 48 for numerical output
00001248  6000 0006                293              BRA     HEX_CONT
0000124C                           294              
0000124C  0603 0037                295  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001250                           296  
00001250  12C3                     297  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001252  5342                     298              SUBI    #1, D2                  * Decrement the size
00001254  0C02 0000                299              CMPI.B  #0, D2                  * Check if D2 is 0
00001258  66D8                     300              BNE     HEX_LOOP                * Loop
0000125A  12BC 0000                301              MOVE.B  #$0,(A1)                * Null terminator
0000125E  4E75                     302              RTS
00001260                           303  *---------------------------------------------------------------------------*
00001260                           304  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001260                           305  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
00001260                           306  *---------------------------------------------------------------------------*
00001260                           307  HEX2ASCII2STACK
00001260  0C02 0008                308              CMPI.B  #8, D2                  * Check to see if the size is long
00001264  6700 000E                309              BEQ     STACK_HEX_LOOP
00001268  4841                     310              SWAP    D1
0000126A  0C02 0002                311              CMPI.B  #2,D2
0000126E  6600 0004                312              BNE     STACK_HEX_LOOP
00001272  E189                     313              LSL.L   #8,D1
00001274                           314             
00001274                           315  STACK_HEX_LOOP    
00001274  E999                     316              ROL.L   #4, D1                  * Roll D1 to left
00001276  2601                     317              MOVE.L  D1, D3                  * Move D1 to D3
00001278  0283 0000000F            318              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000127E  0C03 0009                319              CMPI.B  #9, D3                  * Compare te digit
00001282  6E00 000A                320              BGT     STACK_HEX_CHAR              
00001286  0603 0030                321              ADDI.B  #48,D3                  * Add 48 for numerical output
0000128A  6000 0006                322              BRA     STACK_HEX_CONT
0000128E                           323              
0000128E                           324  STACK_HEX_CHAR    
0000128E  0603 0037                325              ADDI.B  #55,D3                  * Add 55 for character output
00001292                           326  
00001292                           327  STACK_HEX_CONT    
00001292  6100 2CDA                328              BSR     PUSH_STACK              *PLACE INTO STACK
00001296  5342                     329              SUBI    #1, D2                  * Decrement the size
00001298  0C02 0000                330              CMPI.B  #0, D2                  * Check if D2 is 0
0000129C  66D6                     331              BNE     STACK_HEX_LOOP                * Loop
0000129E  12BC 0000                332              MOVE.B  #$0,(A1)                * Null terminator
000012A2  4E75                     333              RTS
000012A4                           334  
000012A4                           335  
000012A4                           336  *---------------------------------------------------------------------------*
000012A4                           337  * IS_ODD: Check whether the source address is odd
000012A4                           338  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
000012A4                           339  *---------------------------------------------------------------------------*
000012A4  4281                     340  IS_ODD      CLR.L   D1                      * Clear the result
000012A6  4287                     341              CLR.L   D7                      * Set the error flag to 0
000012A8  2211                     342              MOVE.L  (A1),D1                * Temp store the checking address to D1
000012AA  82FC 0002                343              DIVU    #2, D1                  * Divide the result by 2
000012AE  4841                     344              SWAP    D1                      * Swap remainder with quotient
000012B0  0C01 0001                345              CMPI.B  #1, D1                  * Check for error
000012B4  6700 0004                346              BEQ     IS_ODD_ERR
000012B8  4E75                     347              RTS
000012BA                           348              
000012BA  1E3C 0001                349  IS_ODD_ERR  MOVE.B  #1, D7
000012BE  4E75                     350              RTS
000012C0                           351  
000012C0                           352  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012C0                           353  * MAINDEBUG                    
000012C0                           354  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012C0                           355  * A5: Processing address
000012C0                           356  *
000012C0                           357  * D3: USED FOR PUSHING INTO STACK
000012C0                           358  *     To push into stack => MOVE.W #DATA,D3 
000012C0                           359  *                           BSR    PUSH_STACK
000012C0                           360  *     To print stack     => BSR    PRINT_STACK 
000012C0                           361  *     To clear stack     => BSR    CLEAR_STACK
000012C0                           362  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012C0                           363  MAIN        
000012C0                           364              *initialize stack pointer
000012C0  33FC 0000 000048F4       365              MOVE.W  #0,COUNTER
000012C8  347C 7000                366              MOVEA.W #STACK,A2
000012CC  163C 0020                367              MOVE.B  #' ',D3
000012D0  6100 2C9C                368              BSR     PUSH_STACK
000012D4  6100 2C98                369              BSR     PUSH_STACK
000012D8  6100 2C94                370              BSR     PUSH_STACK
000012DC                           371              
000012DC                           372              * clear registers for temp storage
000012DC  4280                     373              CLR.L   D0                   
000012DE  4281                     374              CLR.L   D1                   
000012E0  227C 00000000            375              MOVEA.L #0, A1                
000012E6                           376              
000012E6  220D                     377              MOVE.L  A5,D1                   * check to see if the address is fully read
000012E8  23CD 0000453C            378              MOVE.L  A5,S_ADDR_HX
000012EE  B2B9 00004540            379              CMP.L   E_ADDR_HX,D1
000012F4  6C00 2398                380              BGE     REPEAT                  * go to repeat for user action
000012F8                           381  
000012F8  43F9 00004597            382              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012FE  143C 0008                383              MOVE.B  #8,D2                   * set the output size
00001302  4EB8 121E                384              JSR     HEX2ASCII               
00001306  43F9 00004597            385              LEA     TMPOUTPUT,A1
0000130C  103C 000E                386              MOVE.B  #14,D0
00001310  4E4F                     387              TRAP    #15
00001312                           388              
00001312  4285                     389              CLR.L    D5                      * clear the processing data
00001314  3A1D                     390              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
00001316                           391                                               * advance the current instruction pointer to the next
00001316                           392                                               * instruction in memory
00001316                           393  *----------------------------------------*
00001316                           394  * Registers          
00001316                           395  * [D1] - COPY OF D5
00001316                           396  * [D5] - DATA TO BE PROCESSED
00001316                           397  * [D6] - COUNTER FOR LINES PROCESSED
00001316                           398  *
00001316                           399  * [D4]      - ERROR FLAG BEFORE PRINTING
00001316                           400  * [STACK]   - PRINTS PROCESS DATA
00001316                           401  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
00001316                           402  *
00001316                           403  * [A1] - USED FOR JUMPING/PRINTING
00001316                           404  *
00001316                           405  *----------------------------------------*
00001316                           406  
00001316                           407              
00001316                           408              *Processing the first 4 most significant bits 
00001316  2205                     409              MOVE.L  D5,D1                    * copy the current processing data to D1
00001318  143C 000C                410              MOVE.B  #12,D2                   * shift to right by 12 bits
0000131C  E469                     411              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
0000131E  C2FC 0006                412              MULU    #6,D1                    * form offset
00001322  43F9 00001390            413              LEA     JMPTABLE,A1              * index into table
00001328  4EB1 1000                414              JSR     0(A1,D1)                 * jump indirect with index
0000132C                           415              
0000132C                           416              *SECURED EA*
0000132C  B83C 0001                417              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001330  6600 0012                418              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001334  6100 041A                419              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001338  6100 2CA0                420              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000133C  183C 0000                421              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001340  6000 0022                422              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001344                           423             
00001344                           424  OUTPUT_PROCESSED_DATA       
00001344  163C 000D                425              MOVE.B  #$D,D3                  *carriage return
00001348  6100 2C24                426              BSR     PUSH_STACK
0000134C  163C 000A                427              MOVE.B  #$A,D3                  *new line feed
00001350  6100 2C1C                428              BSR     PUSH_STACK
00001354  163C 0000                429              MOVE.B  #$0,D3                  *null
00001358  6100 2C14                430              BSR     PUSH_STACK
0000135C                           431       
0000135C  6100 2BEC                432              BSR     PRINT_QUEUE
00001360  183C 0000                433              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001364                           434  DISPLAY_30_LINES
00001364                           435              * display 30 lines per page
00001364  5206                     436              ADDI.B  #1,D6
00001366  0C06 001E                437              CMPI.B  #30,D6
0000136A  6C00 0006                438              BGE     NEXTLINES
0000136E  6000 FF50                439              BRA     MAIN
00001372                           440            
00001372                           441  *---------------------------------------------------------------------------*
00001372                           442  * NEXTLINES: receive input from user to print the next 30 lines
00001372                           443  *---------------------------------------------------------------------------*  
00001372  4206                     444  NEXTLINES   CLR.B   D6
00001374  43F9 00004393            445              LEA     DISP_NEXT,A1
0000137A  103C 000E                446              MOVE.B  #14,D0
0000137E  4E4F                     447              TRAP    #15
00001380  43F9 00004547            448              LEA     TMPINPUT,A1
00001386  103C 0002                449              MOVE.B  #2,D0
0000138A  4E4F                     450              TRAP    #15
0000138C  4EF8 12C0                451              JMP     MAIN
00001390                           452    
00001390                           453  *---------------------------------------------------------------------------*
00001390                           454  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001390                           455  *---------------------------------------------------------------------------*  
00001390  4EF9 000013F0            456  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - JOSEPH
00001396  4EF9 0000196C            457              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
0000139C  4EF9 000019DA            458              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
000013A2  4EF9 00001AD8            459              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
000013A8  4EF9 00001BD4            460              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
000013AE  4EF9 00001E2A            461              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
000013B4  4EF9 00001FCE            462              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *working on
000013BA  4EF9 00002074            463              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013C0  4EF9 00002078            464              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
000013C6  4EF9 00002180            465              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
000013CC  4EF9 0000253C            466              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013D2  4EF9 00002540            467              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - JOSEPH
000013D8  4EF9 00002840            468              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
000013DE  4EF9 00002B92            469              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
000013E4  4EF9 00002F6E            470              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
000013EA  4EF9 0000321C            471              JMP     OP1111  * Special/Reserved
000013F0                           472              
000013F0                           473  *---------------------------------------------------------------------------*
000013F0                           474  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013F0                           475  *---------------------------------------------------------------------------*           
000013F0                           476  OP0000                                                                                  
000013F0  4281                     477              CLR.L   D1          * to temporarily store the address to process
000013F2  4280                     478              CLR.L   D0  
000013F4  4284                     479              CLR.L   D4                 
000013F6  227C 00000000            480              MOVEA.L #0, A1                
000013FC                           481              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013FC                           482              * Check if bit 11,10,9,8 are 0000)
000013FC  2205                     483              MOVE.L  D5,D1
000013FE  0281 00000F00            484              ANDI.L  #$0F00,D1
00001404  0C81 00000000            485              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
0000140A  6700 047C                486              BEQ     OP_ORI
0000140E                           487  
0000140E                           488              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
0000140E                           489              * check if bit 11,10,9,8 are 1100
0000140E  4281                     490              CLR.L   D1
00001410  2205                     491              MOVE.L  D5,D1
00001412  0281 00000F00            492              ANDI.L  #$0F00,D1
00001418  0C81 00000C00            493              CMPI.L  #$0C00,D1
0000141E  6700 037C                494              BEQ     OP0000_CMPI
00001422                           495              
00001422                           496              * check for SUBI
00001422  4281                     497              CLR.L   D1
00001424  2205                     498              MOVE.L  D5,D1
00001426  0281 00000F00            499              ANDI.L  #$0F00,D1
0000142C  0C81 00000400            500              CMPI.L  #$0400,D1
00001432  6700 023A                501              BEQ     OP_SUBI
00001436                           502              
00001436                           503              * check for EORI
00001436  4281                     504              CLR.L   D1
00001438  2205                     505              MOVE.L  D5,D1
0000143A  0281 00000F00            506              ANDI.L  #$0F00,D1
00001440  0C81 00000A00            507              CMPI.L  #$0A00,D1
00001446  6700 0144                508              BEQ     OP_EORI
0000144A                           509              
0000144A                           510              * check for BTST
0000144A  4281                     511              CLR.L   D1
0000144C  2205                     512              MOVE.L  D5,D1
0000144E  E099                     513              ROR.L   #8,D1
00001450  0281 00000001            514              ANDI.L  #$1,D1
00001456  0C01 0001                515              CMPI.B  #$1,D1
0000145A  6700 001E                516              BEQ     OP_BTST
0000145E  4281                     517              CLR.L   D1
00001460  2205                     518              MOVE.L  D5,D1
00001462  EC99                     519              ROR.L   #6,D1
00001464  0281 000003FF            520              ANDI.L  #$03FF,D1
0000146A  0C81 00000020            521              CMPI.L  #%000100000,D1
00001470  6700 0008                522              BEQ     OP_BTST
00001474                           523  
00001474                           524  
00001474                           525              * OP0000 series other than ORI/CMPI/BTST/EORI
00001474  4EF9 00001750            526              JMP     OP_DATA
0000147A                           527              
0000147A                           528  *---------------------------------------------------------------------------*
0000147A                           529  * OP_BTST: display BTST
0000147A                           530  *---------------------------------------------------------------------------* 
0000147A                           531  OP_BTST       
0000147A                           532              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000147A                           533              *bits #8 indicates which
0000147A                           534              *0 - #immediate format
0000147A                           535              *1 - Dn format
0000147A  4281                     536              CLR.L   D1
0000147C  2205                     537              MOVE.L  D5,D1
0000147E  E099                     538              ROR.L   #8,D1
00001480  0281 00000001            539              ANDI.L  #1,D1
00001486  0C01 0001                540              CMPI.B  #1,D1
0000148A  6600 0078                541              BNE     OP_BTST_IMMEDIATE
0000148E                           542  
0000148E                           543             
0000148E                           544             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000148E  13FC 0000 000048F8       545             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001496  13FC 0002 000048F9       546             MOVE.B   #$02,SRC_REGISTER_FORMAT
0000149E                           547             
0000149E                           548             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000149E  13FC 00B9 000048FB       549             MOVE.B   #$B9,GET_DST_START_END
000014A6  13FC 0020 000048FC       550             MOVE.B   #$20,GET_SRC_START_END
000014AE                           551             
000014AE  0285 0000FE3F            552             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014B4  0685 00000000            553             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014BA                           554              
000014BA                           555              *CLEAR D3
000014BA  4283                     556              CLR.L   D3
000014BC                           557              *LOAD STACK WITH THIS OPMODE
000014BC  6100 2AB0                558              BSR     PUSH_STACK
000014C0  163C 0042                559              MOVE.B  #'B',D3
000014C4  6100 2AA8                560              BSR     PUSH_STACK
000014C8  163C 0054                561              MOVE.B  #'T',D3
000014CC  6100 2AA0                562              BSR     PUSH_STACK
000014D0  163C 0053                563              MOVE.B  #'S',D3
000014D4  6100 2A98                564              BSR     PUSH_STACK
000014D8  163C 0054                565              MOVE.B  #'T',D3
000014DC  6100 2A90                566              BSR     PUSH_STACK
000014E0  163C 002E                567              MOVE.B  #'.',D3
000014E4  6100 2A88                568              BSR     PUSH_STACK
000014E8  163C 0042                569              MOVE.B  #'B',D3
000014EC  6100 2A80                570              BSR     PUSH_STACK
000014F0                           571              
000014F0  6100 260E                572              BSR     GET_EA_EA_DEST
000014F4  163C 002C                573              MOVE.B  #',',D3
000014F8  6100 2A74                574              BSR     PUSH_STACK
000014FC  6100 21D2                575              BSR     GET_EA_EA_SRC
00001500                           576              
00001500  6000 0088                577              BRA     OP0000_RETURN_BTST
00001504                           578              
00001504                           579              
00001504                           580              *MOVE **** OR **** CMPI
00001504                           581              
00001504                           582  OP_BTST_IMMEDIATE              
00001504                           583   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001504  13FC 0000 000048F8       584             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000150C  13FC 0082 000048F9       585             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001514                           586             
00001514                           587             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001514  13FC 00B9 000048FB       588             MOVE.B   #$B9,GET_DST_START_END
0000151C  13FC 0020 000048FC       589             MOVE.B   #$20,GET_SRC_START_END
00001524                           590             
00001524                           591              *CLEAR D3
00001524  4283                     592              CLR.L   D3
00001526                           593              *LOAD STACK WITH THIS OPMODE
00001526  6100 2A46                594              BSR     PUSH_STACK
0000152A  163C 0042                595              MOVE.B  #'B',D3
0000152E  6100 2A3E                596              BSR     PUSH_STACK
00001532  163C 0054                597              MOVE.B  #'T',D3
00001536  6100 2A36                598              BSR     PUSH_STACK
0000153A  163C 0053                599              MOVE.B  #'S',D3
0000153E  6100 2A2E                600              BSR     PUSH_STACK
00001542  163C 0054                601              MOVE.B  #'T',D3
00001546  6100 2A26                602              BSR     PUSH_STACK
0000154A  163C 002E                603              MOVE.B  #'.',D3
0000154E  6100 2A1E                604              BSR     PUSH_STACK
00001552  163C 0042                605              MOVE.B  #'B',D3
00001556  6100 2A16                606              BSR     PUSH_STACK
0000155A                           607  
0000155A                           608  OP0000_BTST_B
0000155A                           609              *GET DATA FROM ADDQ AND PRINT #0-8
0000155A                           610              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000155A  0285 0000F03F            611              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001560  0685 000001C0            612              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001566                           613  
00001566                           614              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001566                           615             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001566                           616             * MOVE.W    (A5)+,D1
00001566                           617             * MOVE.B  #' ',D3
00001566                           618             * BSR     PUSH_STACK
00001566                           619             * MOVE.B  #'#',D3
00001566                           620             * BSR     PUSH_STACK
00001566                           621             * BSR     HEX2ASCII2STACK
00001566                           622             * BSR     PUSH_STACK
00001566                           623              
00001566  163C 0020                624              MOVE.B  #' ',D3
0000156A  6100 2A02                625              BSR     PUSH_STACK
0000156E  163C 0023                626              MOVE.B  #'#',D3
00001572  6100 29FA                627              BSR     PUSH_STACK
00001576  6100 2588                628              BSR     GET_EA_EA_DEST
0000157A  163C 002C                629              MOVE.B  #',',D3
0000157E  6100 29EE                630              BSR     PUSH_STACK
00001582  6100 214C                631              BSR     GET_EA_EA_SRC
00001586  6000 0002                632              BRA     OP0000_RETURN_BTST
0000158A                           633  OP0000_RETURN_BTST
0000158A                           634              
0000158A  4E75                     635              RTS
0000158C                           636  
0000158C                           637  
0000158C                           638  *---------------------------------------------------------------------------*
0000158C                           639  * OP_EORI: decode and display EORI
0000158C                           640  *---------------------------------------------------------------------------* 
0000158C                           641  OP_EORI
0000158C                           642                         
0000158C                           643  
0000158C                           644   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000158C  13FC 0000 000048F8       645             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001594  13FC 0080 000048F9       646             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000159C                           647             
0000159C                           648             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000159C  13FC 00B9 000048FB       649             MOVE.B   #$B9,GET_DST_START_END
000015A4  13FC 0020 000048FC       650             MOVE.B   #$20,GET_SRC_START_END
000015AC                           651             
000015AC                           652              *CLEAR D3
000015AC  4283                     653              CLR.L   D3
000015AE                           654              *LOAD STACK WITH THIS OPMODE
000015AE  6100 29BE                655              BSR     PUSH_STACK
000015B2  163C 0045                656              MOVE.B  #'E',D3
000015B6  6100 29B6                657              BSR     PUSH_STACK
000015BA  163C 004F                658              MOVE.B  #'O',D3
000015BE  6100 29AE                659              BSR     PUSH_STACK
000015C2  163C 0052                660              MOVE.B  #'R',D3
000015C6  6100 29A6                661              BSR     PUSH_STACK
000015CA  163C 0049                662              MOVE.B  #'I',D3
000015CE  6100 299E                663              BSR     PUSH_STACK
000015D2  163C 002E                664              MOVE.B  #'.',D3
000015D6  6100 2996                665              BSR     PUSH_STACK
000015DA                           666              
000015DA                           667              *FIGURE OUT SIZE*
000015DA                           668              *00 = BYTE
000015DA                           669              *01 = WORD
000015DA                           670              *10 = LONG
000015DA                           671              * BITS 7&6
000015DA                           672              
000015DA                           673              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015DA  2205                     674              MOVE.L  D5,D1
000015DC  EC99                     675              ROR.L   #6,D1
000015DE  0281 00000003            676              ANDI.L  #$03,D1
000015E4  0C01 0000                677              CMPI.B  #%00,D1
000015E8  6700 001E                678              BEQ     OP0000_EOR_B
000015EC  0281 00000003            679              ANDI.L  #$03,D1
000015F2  0C01 0001                680              CMPI.B  #%01,D1
000015F6  6700 0028                681              BEQ     OP0000_EOR_W
000015FA  0281 00000003            682              ANDI.L  #$03,D1
00001600  0C01 0002                683              CMPI.B  #%10,D1
00001604  6700 0032                684              BEQ     OP0000_EOR_L
00001608                           685            
00001608                           686  OP0000_EOR_B
00001608                           687              
00001608  163C 0042                688              MOVE.B  #'B',D3
0000160C  6100 2960                689              BSR     PUSH_STACK
00001610                           690              
00001610                           691              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001610  0285 0000F03F            692              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001616  0685 000001C0            693              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000161C                           694  
0000161C                           695              
0000161C  6000 002E                696              BRA     OP0000_RETURN_EOR
00001620                           697  OP0000_EOR_W
00001620                           698              
00001620  163C 0057                699              MOVE.B  #'W',D3
00001624  6100 2948                700              BSR     PUSH_STACK
00001628                           701              
00001628                           702              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001628  0285 0000F03F            703              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000162E  0685 000001C0            704              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001634                           705  
00001634                           706              
00001634  6000 0016                707              BRA     OP0000_RETURN_EOR
00001638                           708  OP0000_EOR_L
00001638                           709              
00001638  163C 004C                710              MOVE.B  #'L',D3
0000163C  6100 2930                711              BSR     PUSH_STACK
00001640                           712              
00001640                           713              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001640  0285 0000FE3F            714              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001646  0685 000009C0            715              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000164C                           716  
0000164C                           717  
0000164C                           718  OP0000_RETURN_EOR       
0000164C  163C 0020                719              MOVE.B  #' ',D3
00001650  6100 291C                720              BSR     PUSH_STACK
00001654  163C 0023                721              MOVE.B  #'#',D3
00001658  6100 2914                722              BSR     PUSH_STACK
0000165C  6100 24A2                723              BSR     GET_EA_EA_DEST
00001660  163C 002C                724              MOVE.B  #',',D3
00001664  6100 2908                725              BSR     PUSH_STACK
00001668  6100 2066                726              BSR     GET_EA_EA_SRC
0000166C                           727              
0000166C  4E75                     728              RTS
0000166E                           729  
0000166E                           730  *---------------------------------------------------------------------------*
0000166E                           731  * OP_SUBI: decode SUBI.B/.W/.L
0000166E                           732  *---------------------------------------------------------------------------* 
0000166E                           733  OP_SUBI
0000166E                           734             
0000166E                           735   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000166E  13FC 0000 000048F8       736             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001676  13FC 0080 000048F9       737             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000167E                           738             
0000167E                           739             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000167E  13FC 00B9 000048FB       740             MOVE.B   #$B9,GET_DST_START_END
00001686  13FC 0020 000048FC       741             MOVE.B   #$20,GET_SRC_START_END
0000168E                           742             
0000168E                           743              *CLEAR D3
0000168E  4283                     744              CLR.L   D3
00001690                           745              *LOAD STACK WITH THIS OPMODE
00001690  6100 28DC                746              BSR     PUSH_STACK
00001694  163C 0053                747              MOVE.B  #'S',D3
00001698  6100 28D4                748              BSR     PUSH_STACK
0000169C  163C 0055                749              MOVE.B  #'U',D3
000016A0  6100 28CC                750              BSR     PUSH_STACK
000016A4  163C 0042                751              MOVE.B  #'B',D3
000016A8  6100 28C4                752              BSR     PUSH_STACK
000016AC  163C 0049                753              MOVE.B  #'I',D3
000016B0  6100 28BC                754              BSR     PUSH_STACK
000016B4  163C 002E                755              MOVE.B  #'.',D3
000016B8  6100 28B4                756              BSR     PUSH_STACK
000016BC                           757              
000016BC                           758              *FIGURE OUT SIZE*
000016BC                           759              *00 = BYTE
000016BC                           760              *01 = WORD
000016BC                           761              *10 = LONG
000016BC                           762              * BITS 7&6
000016BC                           763              
000016BC                           764              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016BC  2205                     765              MOVE.L  D5,D1
000016BE  EC99                     766              ROR.L   #6,D1
000016C0  0281 00000003            767              ANDI.L  #$03,D1
000016C6  0C01 0000                768              CMPI.B  #%00,D1
000016CA  6700 001E                769              BEQ     OP0000_SUB_B
000016CE  0281 00000003            770              ANDI.L  #$03,D1
000016D4  0C01 0001                771              CMPI.B  #%01,D1
000016D8  6700 0028                772              BEQ     OP0000_SUB_W
000016DC  0281 00000003            773              ANDI.L  #$03,D1
000016E2  0C01 0002                774              CMPI.B  #%10,D1
000016E6  6700 0032                775              BEQ     OP0000_SUB_L
000016EA                           776            
000016EA                           777  OP0000_SUB_B
000016EA                           778              
000016EA  163C 0042                779              MOVE.B  #'B',D3
000016EE  6100 287E                780              BSR     PUSH_STACK
000016F2                           781              
000016F2                           782              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016F2  0285 0000F03F            783              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016F8  0685 000001C0            784              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000016FE                           785  
000016FE                           786              
000016FE  6000 002E                787              BRA     OP0000_RETURN_SUBI
00001702                           788  OP0000_SUB_W
00001702                           789              
00001702  163C 0057                790              MOVE.B  #'W',D3
00001706  6100 2866                791              BSR     PUSH_STACK
0000170A                           792              
0000170A                           793              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000170A  0285 0000F03F            794              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001710  0685 000001C0            795              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001716                           796  
00001716                           797              
00001716  6000 0016                798              BRA     OP0000_RETURN_SUBI
0000171A                           799  OP0000_SUB_L
0000171A                           800              
0000171A  163C 004C                801              MOVE.B  #'L',D3
0000171E  6100 284E                802              BSR     PUSH_STACK
00001722                           803              
00001722                           804              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001722  0285 0000F03F            805              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001728  0685 000003C0            806              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000172E                           807                      
0000172E                           808  OP0000_RETURN_SUBI            
0000172E  163C 0020                809              MOVE.B  #' ',D3
00001732  6100 283A                810              BSR     PUSH_STACK
00001736  163C 0023                811              MOVE.B  #'#',D3
0000173A  6100 2832                812              BSR     PUSH_STACK
0000173E  6100 23C0                813              BSR     GET_EA_EA_DEST
00001742  163C 002C                814              MOVE.B  #',',D3
00001746  6100 2826                815              BSR     PUSH_STACK
0000174A  6100 1F84                816              BSR     GET_EA_EA_SRC
0000174E                           817              
0000174E  4E75                     818              RTS
00001750                           819  
00001750                           820              
00001750                           821  *---------------------------------------------------------------------------*
00001750                           822  * OP_DATA : unidentified opcode
00001750                           823  *---------------------------------------------------------------------------* 
00001750                           824  OP_DATA
00001750  4280                     825              CLR.L   D0                   
00001752  4281                     826              CLR.L   D1     
00001754  4284                     827              CLR.L   D4                    
00001756  227C 00000000            828              MOVEA.L #0, A1             
0000175C  4287                     829              CLR.L   D7
0000175E  1E3C 0001                830              MOVE.B  #1,D7                   * error flag is true
00001762                           831              
00001762  43F9 00004646            832              LEA     DISP_DATA,A1
00001768  103C 000E                833              MOVE.B  #14,D0
0000176C  4E4F                     834              TRAP    #15
0000176E                           835              
0000176E  4EF9 00001774            836              JMP     EA_DATA
00001774                           837             
00001774                           838             
00001774                           839  *---------------------------------------------------------------------------*
00001774                           840  * EA_DATA
00001774                           841  *---------------------------------------------------------------------------*       
00001774  43F9 00004597            842  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000177A  2205                     843              MOVE.L  D5,D1           * transfer the processing data to D1
0000177C  7404                     844              MOVE.L  #4,D2           * set to word size
0000177E  4EB8 121E                845              JSR     HEX2ASCII       * prepare output in ascii
00001782  43F9 000048B9            846              LEA     DISP_HEX,A1     * display $ symbol
00001788  103C 000E                847              MOVE.B  #14,D0      
0000178C  4E4F                     848              TRAP    #15
0000178E  43F9 00004597            849              LEA     TMPOUTPUT,A1    * display with a new line
00001794  103C 000D                850              MOVE.B  #13,D0
00001798  4E4F                     851              TRAP    #15
0000179A                           852  
0000179A  4E75                     853              RTS
0000179C                           854              
0000179C                           855  *---------------------------------------------------------------------------*
0000179C                           856  * OP_CMPI : decode CMPI and its size
0000179C                           857  *---------------------------------------------------------------------------*          
0000179C                           858  OP0000_CMPI
0000179C                           859  
0000179C                           860              
0000179C                           861   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000179C  13FC 0000 000048F8       862             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017A4  13FC 0082 000048F9       863             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017AC                           864             
000017AC                           865             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017AC  13FC 00B9 000048FB       866             MOVE.B   #$B9,GET_DST_START_END
000017B4  13FC 0020 000048FC       867             MOVE.B   #$20,GET_SRC_START_END
000017BC                           868             
000017BC                           869              *CLEAR D3
000017BC  4283                     870              CLR.L   D3
000017BE                           871              *LOAD STACK WITH THIS OPMODE
000017BE  6100 27AE                872              BSR     PUSH_STACK
000017C2  163C 0043                873              MOVE.B  #'C',D3
000017C6  6100 27A6                874              BSR     PUSH_STACK
000017CA  163C 004D                875              MOVE.B  #'M',D3
000017CE  6100 279E                876              BSR     PUSH_STACK
000017D2  163C 0050                877              MOVE.B  #'P',D3
000017D6  6100 2796                878              BSR     PUSH_STACK
000017DA  163C 0049                879              MOVE.B  #'I',D3
000017DE  6100 278E                880              BSR     PUSH_STACK
000017E2  163C 002E                881              MOVE.B  #'.',D3
000017E6  6100 2786                882              BSR     PUSH_STACK
000017EA                           883              
000017EA                           884              *FIGURE OUT SIZE*
000017EA                           885              *00 = BYTE
000017EA                           886              *01 = WORD
000017EA                           887              *10 = LONG
000017EA                           888              * BITS 7&6
000017EA                           889              
000017EA                           890              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017EA  2205                     891              MOVE.L  D5,D1
000017EC  EC99                     892              ROR.L   #6,D1
000017EE  0281 00000003            893              ANDI.L  #$03,D1
000017F4  0C01 0000                894              CMPI.B  #%00,D1
000017F8  6700 0018                895              BEQ     OP0000_CMPI_B
000017FC  0C01 0001                896              CMPI.B  #%01,D1
00001800  6700 0038                897              BEQ     OP0000_CMPI_W
00001804  0281 00000003            898              ANDI.L  #$03,D1
0000180A  0C01 0002                899              CMPI.B  #%10,D1
0000180E  6700 0052                900              BEQ     OP0000_CMPI_L
00001812                           901  
00001812                           902  OP0000_CMPI_B
00001812  163C 0042                903              MOVE.B  #'B',D3
00001816  6100 2756                904              BSR     PUSH_STACK
0000181A                           905  *GET DATA FROM ADDQ AND PRINT #0-8
0000181A                           906              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000181A  0285 0000F03F            907              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001820  0685 000001C0            908              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001826  6100 22D8                909              BSR     GET_EA_EA_DEST
0000182A  163C 002C                910              MOVE.B  #',',D3
0000182E  6100 273E                911              BSR     PUSH_STACK
00001832  6100 1E9C                912              BSR     GET_EA_EA_SRC
00001836  6000 004E                913              BRA     OP0000_RETURN_CMPI
0000183A                           914  
0000183A                           915  OP0000_CMPI_W
0000183A  163C 0057                916              MOVE.B  #'W',D3
0000183E  6100 272E                917              BSR     PUSH_STACK
00001842                           918  *GET DATA FROM ADDQ AND PRINT #0-8
00001842                           919              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001842  0285 0000F03F            920              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001848  0685 000001C0            921              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000184E  6100 22B0                922              BSR     GET_EA_EA_DEST
00001852  163C 002C                923              MOVE.B  #',',D3
00001856  6100 2716                924              BSR     PUSH_STACK
0000185A  6100 1E74                925              BSR     GET_EA_EA_SRC
0000185E  6000 0026                926              BRA     OP0000_RETURN_CMPI
00001862                           927  
00001862                           928  OP0000_CMPI_L
00001862  163C 004C                929              MOVE.B  #'L',D3
00001866  6100 2706                930              BSR     PUSH_STACK
0000186A                           931              *GET DATA FROM ADDQ AND PRINT #0-8
0000186A                           932              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000186A  0285 0000F03F            933              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001870  0685 000003C0            934              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001876  6100 2288                935              BSR     GET_EA_EA_DEST
0000187A  163C 002C                936              MOVE.B  #',',D3
0000187E  6100 26EE                937              BSR     PUSH_STACK
00001882  6100 1E4C                938              BSR     GET_EA_EA_SRC
00001886                           939              
00001886                           940  OP0000_RETURN_CMPI
00001886                           941  
00001886                           942  
00001886                           943              
00001886  4E75                     944              RTS
00001888                           945   
00001888                           946  *---------------------------------------------------------------------------*
00001888                           947  * OP_ORI : decode ORI and its size
00001888                           948  *---------------------------------------------------------------------------* 
00001888                           949  OP_ORI      
00001888                           950           
00001888                           951   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001888  13FC 0000 000048F8       952             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001890  13FC 0082 000048F9       953             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001898                           954             
00001898                           955             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001898  13FC 00B9 000048FB       956             MOVE.B   #$B9,GET_DST_START_END
000018A0  13FC 0020 000048FC       957             MOVE.B   #$20,GET_SRC_START_END
000018A8                           958             
000018A8                           959              *CLEAR D3
000018A8  4283                     960              CLR.L   D3
000018AA                           961              *LOAD STACK WITH THIS OPMODE
000018AA  6100 26C2                962              BSR     PUSH_STACK
000018AE  163C 004F                963              MOVE.B  #'O',D3
000018B2  6100 26BA                964              BSR     PUSH_STACK
000018B6  163C 0052                965              MOVE.B  #'R',D3
000018BA  6100 26B2                966              BSR     PUSH_STACK
000018BE  163C 0049                967              MOVE.B  #'I',D3
000018C2  6100 26AA                968              BSR     PUSH_STACK
000018C6  163C 002E                969              MOVE.B  #'.',D3
000018CA  6100 26A2                970              BSR     PUSH_STACK
000018CE                           971              
000018CE                           972              *FIGURE OUT SIZE*
000018CE                           973              *00 = BYTE
000018CE                           974              *01 = WORD
000018CE                           975              *10 = LONG
000018CE                           976              * BITS 7&6
000018CE                           977              
000018CE                           978              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018CE  2205                     979              MOVE.L  D5,D1
000018D0  EC99                     980              ROR.L   #6,D1
000018D2  0281 00000003            981              ANDI.L  #$03,D1
000018D8  0C01 0000                982              CMPI.B  #%00,D1
000018DC  6700 0018                983              BEQ     OP0000_ORI_B
000018E0  0C01 0001                984              CMPI.B  #%01,D1
000018E4  6700 0038                985              BEQ     OP0000_ORI_W
000018E8  0281 00000003            986              ANDI.L  #$03,D1
000018EE  0C01 0002                987              CMPI.B  #%10,D1
000018F2  6700 0052                988              BEQ     OP0000_ORI_L
000018F6                           989  
000018F6                           990  OP0000_ORI_B
000018F6  163C 0042                991              MOVE.B  #'B',D3
000018FA  6100 2672                992              BSR     PUSH_STACK
000018FE                           993  *GET DATA FROM ADDQ AND PRINT #0-8
000018FE                           994              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000018FE  0285 0000F03F            995              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001904  0685 000001C0            996              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000190A  6100 21F4                997              BSR     GET_EA_EA_DEST
0000190E  163C 002C                998              MOVE.B  #',',D3
00001912  6100 265A                999              BSR     PUSH_STACK
00001916  6100 1DB8               1000              BSR     GET_EA_EA_SRC
0000191A  6000 004E               1001              BRA     OP0000_RETURN_ORI
0000191E                          1002  
0000191E                          1003  OP0000_ORI_W
0000191E  163C 0057               1004              MOVE.B  #'W',D3
00001922  6100 264A               1005              BSR     PUSH_STACK
00001926                          1006  *GET DATA FROM ADDQ AND PRINT #0-8
00001926                          1007              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001926  0285 0000F03F           1008              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000192C  0685 000001C0           1009              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001932  6100 21CC               1010              BSR     GET_EA_EA_DEST
00001936  163C 002C               1011              MOVE.B  #',',D3
0000193A  6100 2632               1012              BSR     PUSH_STACK
0000193E  6100 1D90               1013              BSR     GET_EA_EA_SRC
00001942  6000 0026               1014              BRA     OP0000_RETURN_ORI
00001946                          1015  
00001946                          1016  OP0000_ORI_L
00001946  163C 004C               1017              MOVE.B  #'L',D3
0000194A  6100 2622               1018              BSR     PUSH_STACK
0000194E                          1019              *GET DATA FROM ADDQ AND PRINT #0-8
0000194E                          1020              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000194E  0285 0000F03F           1021              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001954  0685 000003C0           1022              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000195A  6100 21A4               1023              BSR     GET_EA_EA_DEST
0000195E  163C 002C               1024              MOVE.B  #',',D3
00001962  6100 260A               1025              BSR     PUSH_STACK
00001966  6100 1D68               1026              BSR     GET_EA_EA_SRC
0000196A                          1027              
0000196A                          1028  OP0000_RETURN_ORI
0000196A                          1029  
0000196A                          1030  
0000196A                          1031              
0000196A  4E75                    1032              RTS
0000196C                          1033  
0000196C                          1034          
0000196C                          1035  *---------------------------------------------------------------------------*
0000196C                          1036  * OP0001: MOVE.B
0000196C                          1037  *---------------------------------------------------------------------------*
0000196C                          1038  OP0001      
0000196C  4EF9 00001972           1039              JMP     OP_MOVE_B   * display MOVE.B
00001972                          1040              
00001972                          1041  *---------------------------------------------------------------------------*
00001972                          1042  * OP_MOVE_B: display MOVE_B and proceed to EA
00001972                          1043  *---------------------------------------------------------------------------*
00001972                          1044  OP_MOVE_B                                                                       
00001972                          1045             
00001972                          1046             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001972  13FC 0082 000048F8      1047             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000197A  13FC 0000 000048F9      1048             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001982                          1049             
00001982                          1050             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001982  13FC 00B9 000048FB      1051             MOVE.B   #$B9,GET_DST_START_END
0000198A  13FC 0020 000048FC      1052             MOVE.B   #$20,GET_SRC_START_END
00001992                          1053             
00001992                          1054              *CLEAR D3
00001992  4283                    1055              CLR.L   D3
00001994                          1056              *LOAD STACK WITH THIS OPMODE
00001994  6100 25D8               1057              BSR     PUSH_STACK
00001998  163C 004D               1058              MOVE.B  #'M',D3
0000199C  6100 25D0               1059              BSR     PUSH_STACK
000019A0  163C 004F               1060              MOVE.B  #'O',D3
000019A4  6100 25C8               1061              BSR     PUSH_STACK
000019A8  163C 0056               1062              MOVE.B  #'V',D3
000019AC  6100 25C0               1063              BSR     PUSH_STACK
000019B0  163C 0045               1064              MOVE.B  #'E',D3
000019B4  6100 25B8               1065              BSR     PUSH_STACK
000019B8  163C 002E               1066              MOVE.B  #'.',D3
000019BC  6100 25B0               1067              BSR     PUSH_STACK
000019C0  163C 0042               1068              MOVE.B  #'B',D3
000019C4  6100 25A8               1069              BSR     PUSH_STACK
000019C8                          1070              
000019C8  6100 1D06               1071              BSR     GET_EA_EA_SRC
000019CC  163C 002C               1072              MOVE.B  #',',D3
000019D0  6100 259C               1073              BSR     PUSH_STACK
000019D4  6100 212A               1074              BSR     GET_EA_EA_DEST
000019D8                          1075              
000019D8  4E75                    1076              RTS
000019DA                          1077              
000019DA                          1078             
000019DA                          1079  *---------------------------------------------------------------------------*
000019DA                          1080  * OP0010: decode MOVE.L/MOVEA.L
000019DA                          1081  *---------------------------------------------------------------------------*
000019DA                          1082  OP0010      
000019DA  183C 0002               1083              MOVE.B  #2,D4
000019DE  4280                    1084              CLR.L   D0                     
000019E0  4281                    1085              CLR.L   D1                      
000019E2  227C 00000000           1086              MOVEA.L #0, A1                 
000019E8                          1087              
000019E8  2205                    1088              MOVE.L  D5,D1
000019EA  EA99                    1089              ROR.L   #5,D1
000019EC  0281 0000000E           1090              ANDI.L  #$E,D1
000019F2  0C01 0002               1091              CMPI.B  #2,D1
000019F6  6700 0070               1092              BEQ     OP_MOVEA_L
000019FA                          1093  
000019FA  4EF9 00001A00           1094              JMP     OP_MOVE_L
00001A00                          1095             
00001A00                          1096  
00001A00                          1097  *---------------------------------------------------------------------------*
00001A00                          1098  * OP_MOVE_L: display MOVE_L and proceed to EA
00001A00                          1099  *---------------------------------------------------------------------------*
00001A00                          1100  OP_MOVE_L   
00001A00                          1101             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A00  13FC 0082 000048F8      1102             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A08  13FC 0000 000048F9      1103             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A10                          1104             
00001A10                          1105             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A10  13FC 00B9 000048FB      1106             MOVE.B   #$B9,GET_DST_START_END
00001A18  13FC 0020 000048FC      1107             MOVE.B   #$20,GET_SRC_START_END
00001A20                          1108             
00001A20                          1109              *CLEAR D3
00001A20  4283                    1110              CLR.L   D3
00001A22                          1111              *LOAD STACK WITH THIS OPMODE
00001A22  6100 254A               1112              BSR     PUSH_STACK
00001A26  163C 004D               1113              MOVE.B  #'M',D3
00001A2A  6100 2542               1114              BSR     PUSH_STACK
00001A2E  163C 004F               1115              MOVE.B  #'O',D3
00001A32  6100 253A               1116              BSR     PUSH_STACK
00001A36  163C 0056               1117              MOVE.B  #'V',D3
00001A3A  6100 2532               1118              BSR     PUSH_STACK
00001A3E  163C 0045               1119              MOVE.B  #'E',D3
00001A42  6100 252A               1120              BSR     PUSH_STACK
00001A46  163C 002E               1121              MOVE.B  #'.',D3
00001A4A  6100 2522               1122              BSR     PUSH_STACK
00001A4E  163C 004C               1123              MOVE.B  #'L',D3
00001A52  6100 251A               1124              BSR     PUSH_STACK
00001A56                          1125              
00001A56  6100 1C78               1126              BSR     GET_EA_EA_SRC
00001A5A  163C 002C               1127              MOVE.B  #',',D3
00001A5E  6100 250E               1128              BSR     PUSH_STACK
00001A62  6100 209C               1129              BSR     GET_EA_EA_DEST
00001A66                          1130              
00001A66  4E75                    1131              RTS
00001A68                          1132  
00001A68                          1133  
00001A68                          1134  *---------------------------------------------------------------------------*
00001A68                          1135  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A68                          1136  *---------------------------------------------------------------------------*
00001A68                          1137  OP_MOVEA_L 
00001A68                          1138             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A68  13FC 00FD 000048F8      1139             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A70  13FC 0000 000048F9      1140             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A78                          1141             
00001A78                          1142             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A78  13FC 00B9 000048FB      1143             MOVE.B   #$B9,GET_DST_START_END
00001A80  13FC 0020 000048FC      1144             MOVE.B   #$20,GET_SRC_START_END
00001A88                          1145             
00001A88                          1146              *CLEAR D3
00001A88  4283                    1147              CLR.L   D3
00001A8A                          1148              *LOAD STACK WITH THIS OPMODE
00001A8A  6100 24E2               1149              BSR     PUSH_STACK
00001A8E  163C 004D               1150              MOVE.B  #'M',D3
00001A92  6100 24DA               1151              BSR     PUSH_STACK
00001A96  163C 004F               1152              MOVE.B  #'O',D3
00001A9A  6100 24D2               1153              BSR     PUSH_STACK
00001A9E  163C 0056               1154              MOVE.B  #'V',D3
00001AA2  6100 24CA               1155              BSR     PUSH_STACK
00001AA6  163C 0045               1156              MOVE.B  #'E',D3
00001AAA  6100 24C2               1157              BSR     PUSH_STACK           
00001AAE  163C 0041               1158              MOVE.B  #'A',D3
00001AB2  6100 24BA               1159              BSR     PUSH_STACK
00001AB6  163C 002E               1160              MOVE.B  #'.',D3
00001ABA  6100 24B2               1161              BSR     PUSH_STACK
00001ABE  163C 004C               1162              MOVE.B  #'L',D3
00001AC2  6100 24AA               1163              BSR     PUSH_STACK
00001AC6                          1164              
00001AC6  6100 1C08               1165              BSR     GET_EA_EA_SRC
00001ACA  163C 002C               1166              MOVE.B  #',',D3
00001ACE  6100 249E               1167              BSR     PUSH_STACK
00001AD2  6100 202C               1168              BSR     GET_EA_EA_DEST
00001AD6                          1169              
00001AD6  4E75                    1170              RTS
00001AD8                          1171  
00001AD8                          1172              
00001AD8                          1173  *---------------------------------------------------------------------------*
00001AD8                          1174  * OP0011: decode MOVE.W/MOVEA.W
00001AD8                          1175  *---------------------------------------------------------------------------*
00001AD8                          1176  OP0011      
00001AD8  4280                    1177              CLR.L   D0                      
00001ADA  4281                    1178              CLR.L   D1  
00001ADC  4284                    1179              CLR.L   D4                   
00001ADE  227C 00000000           1180              MOVEA.L #0, A1 
00001AE4                          1181                
00001AE4  2205                    1182              MOVE.L  D5,D1
00001AE6  EC99                    1183              ROR.L   #6,D1
00001AE8  0281 00000007           1184              ANDI.L  #$07,D1
00001AEE  0C01 0001               1185              CMPI.B  #1,D1
00001AF2  6700 0070               1186              BEQ     OP_MOVEA_W
00001AF6                          1187              
00001AF6  4EF9 00001AFC           1188              JMP     OP_MOVE_W
00001AFC                          1189            
00001AFC                          1190  *---------------------------------------------------------------------------*
00001AFC                          1191  * OP_MOVE_W: display MOVE_W and proceed to EA
00001AFC                          1192  *---------------------------------------------------------------------------*
00001AFC                          1193  OP_MOVE_W   
00001AFC                          1194             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001AFC  13FC 0082 000048F8      1195             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001B04  13FC 0000 000048F9      1196             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B0C                          1197             
00001B0C                          1198             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B0C  13FC 00B9 000048FB      1199             MOVE.B   #$B9,GET_DST_START_END
00001B14  13FC 0020 000048FC      1200             MOVE.B   #$20,GET_SRC_START_END
00001B1C                          1201             
00001B1C                          1202              *CLEAR D3
00001B1C  4283                    1203              CLR.L   D3
00001B1E                          1204              *LOAD STACK WITH THIS OPMODE
00001B1E  6100 244E               1205              BSR     PUSH_STACK
00001B22  163C 004D               1206              MOVE.B  #'M',D3
00001B26  6100 2446               1207              BSR     PUSH_STACK
00001B2A  163C 004F               1208              MOVE.B  #'O',D3
00001B2E  6100 243E               1209              BSR     PUSH_STACK
00001B32  163C 0056               1210              MOVE.B  #'V',D3
00001B36  6100 2436               1211              BSR     PUSH_STACK
00001B3A  163C 0045               1212              MOVE.B  #'E',D3
00001B3E  6100 242E               1213              BSR     PUSH_STACK
00001B42  163C 002E               1214              MOVE.B  #'.',D3
00001B46  6100 2426               1215              BSR     PUSH_STACK
00001B4A  163C 0057               1216              MOVE.B  #'W',D3
00001B4E  6100 241E               1217              BSR     PUSH_STACK
00001B52                          1218              
00001B52  6100 1B7C               1219              BSR     GET_EA_EA_SRC
00001B56  163C 002C               1220              MOVE.B  #',',D3
00001B5A  6100 2412               1221              BSR     PUSH_STACK
00001B5E  6100 1FA0               1222              BSR     GET_EA_EA_DEST
00001B62                          1223              
00001B62  4E75                    1224              RTS
00001B64                          1225  
00001B64                          1226  *---------------------------------------------------------------------------*
00001B64                          1227  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B64                          1228  *---------------------------------------------------------------------------*
00001B64                          1229  OP_MOVEA_W 
00001B64                          1230             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B64  13FC 00FD 000048F8      1231             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B6C  13FC 0000 000048F9      1232             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B74                          1233             
00001B74                          1234             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B74  13FC 00B9 000048FB      1235             MOVE.B   #$B9,GET_DST_START_END
00001B7C  13FC 0020 000048FC      1236             MOVE.B   #$20,GET_SRC_START_END
00001B84                          1237             
00001B84                          1238              *CLEAR D3
00001B84  4283                    1239              CLR.L   D3
00001B86                          1240              *LOAD STACK WITH THIS OPMODE
00001B86  6100 23E6               1241              BSR     PUSH_STACK
00001B8A  163C 004D               1242              MOVE.B  #'M',D3
00001B8E  6100 23DE               1243              BSR     PUSH_STACK
00001B92  163C 004F               1244              MOVE.B  #'O',D3
00001B96  6100 23D6               1245              BSR     PUSH_STACK
00001B9A  163C 0056               1246              MOVE.B  #'V',D3
00001B9E  6100 23CE               1247              BSR     PUSH_STACK
00001BA2  163C 0045               1248              MOVE.B  #'E',D3
00001BA6  6100 23C6               1249              BSR     PUSH_STACK           
00001BAA  163C 0041               1250              MOVE.B  #'A',D3
00001BAE  6100 23BE               1251              BSR     PUSH_STACK
00001BB2  163C 002E               1252              MOVE.B  #'.',D3
00001BB6  6100 23B6               1253              BSR     PUSH_STACK
00001BBA  163C 0057               1254              MOVE.B  #'W',D3
00001BBE  6100 23AE               1255              BSR     PUSH_STACK
00001BC2                          1256              
00001BC2  6100 1B0C               1257              BSR     GET_EA_EA_SRC
00001BC6  163C 002C               1258              MOVE.B  #',',D3
00001BCA  6100 23A2               1259              BSR     PUSH_STACK
00001BCE  6100 1F30               1260              BSR     GET_EA_EA_DEST
00001BD2                          1261            
00001BD2  4E75                    1262              RTS
00001BD4                          1263  *---------------------------------------------------------------------------*
00001BD4                          1264  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BD4                          1265  *---------------------------------------------------------------------------*
00001BD4                          1266  OP0100
00001BD4  4280                    1267              CLR.L   D0                      
00001BD6  4281                    1268              CLR.L   D1  
00001BD8  4284                    1269              CLR.L   D4                      
00001BDA  227C 00000000           1270              MOVEA.L #0, A1                  
00001BE0  2205                    1271              MOVE.L  D5,D1  
00001BE2                          1272              
00001BE2                          1273              * check for RTS
00001BE2  0C41 4E75               1274              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BE6  6700 0228               1275              BEQ     OP_RTS
00001BEA                          1276              
00001BEA                          1277              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BEA  4281                    1278              CLR.L   D1 
00001BEC  2205                    1279              MOVE.L  D5,D1  
00001BEE  0241 0F00               1280              ANDI.W  #$0F00,D1
00001BF2  0C41 0E00               1281              CMPI.W  #$0E00,D1
00001BF6  6700 0204               1282              BEQ     OP_JSR
00001BFA                          1283  
00001BFA                          1284              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001BFA  4281                    1285              CLR.L   D1 
00001BFC  2205                    1286              MOVE.L  D5,D1  
00001BFE  0241 0F00               1287              ANDI.W  #$0F00,D1
00001C02  0C41 0400               1288              CMPI.W  #$0400,D1
00001C06  6700 00E8               1289              BEQ     OP_NEG
00001C0A                          1290              
00001C0A                          1291              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001C0A  4281                    1292              CLR.L   D1 
00001C0C  2205                    1293              MOVE.L  D5,D1  
00001C0E  0241 0F00               1294              ANDI.W  #$0F00,D1
00001C12  0C41 0600               1295              CMPI.W  #$0600,D1
00001C16  6700 015E               1296              BEQ     OP_NOT
00001C1A                          1297              
00001C1A                          1298              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C1A  4281                    1299              CLR.L   D1 
00001C1C  2205                    1300              MOVE.L  D5,D1  
00001C1E  EC99                    1301              ROR.L   #6,D1
00001C20  0281 00000007           1302              ANDI.L  #7,D1
00001C26  0C81 00000007           1303              CMPI.L  #7,D1
00001C2C  6700 0054               1304              BEQ     OP_LEA
00001C30                          1305              
00001C30                          1306              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C30  4281                    1307              CLR.L   D1 
00001C32  2205                    1308              MOVE.L  D5,D1  
00001C34  EB59                    1309              ROL.W   #5,D1
00001C36  0C01 0001               1310              CMPI.B  #1,D1
00001C3A  6600 FB14               1311              BNE     OP_DATA
00001C3E  E959                    1312              ROL.W   #4,D1
00001C40  0C01 0001               1313              CMPI.B  #1,D1
00001C44  6600 FB0A               1314              BNE     OP_DATA
00001C48  E359                    1315              ROL.W   #1,D1
00001C4A  0C01 0000               1316              CMPI.B  #0,D1
00001C4E  6700 000E               1317              BEQ     OP_MOVEM_W
00001C52  0C01 0001               1318              CMPI.B  #1,D1
00001C56  6700 0018               1319              BEQ     OP_MOVEM_L
00001C5A  4EF8 1750               1320              JMP     OP_DATA
00001C5E                          1321  
00001C5E                          1322  *---------------------------------------------------------------------------*
00001C5E                          1323  * OP_MOVEM_W: display MOVEM_W
00001C5E                          1324  *---------------------------------------------------------------------------*    
00001C5E                          1325  OP_MOVEM_W  
00001C5E  183C 0001               1326              MOVE.B  #1,D4
00001C62  43F9 000046B7           1327              LEA     DISP_MOVEM_W,A1
00001C68  103C 000E               1328              MOVE.B  #14,D0
00001C6C  4E4F                    1329              TRAP    #15
00001C6E  4E75                    1330              RTS
00001C70                          1331  
00001C70                          1332  *---------------------------------------------------------------------------*
00001C70                          1333  * OP_MOVEM_L: display MOVEM_L
00001C70                          1334  *---------------------------------------------------------------------------*
00001C70                          1335  OP_MOVEM_L  
00001C70  183C 0002               1336              MOVE.B  #2,D4
00001C74  43F9 000046C2           1337              LEA     DISP_MOVEM_L,A1
00001C7A  103C 000E               1338              MOVE.B  #14,D0
00001C7E  4E4F                    1339              TRAP    #15
00001C80  4E75                    1340              RTS
00001C82                          1341     
00001C82                          1342  *---------------------------------------------------------------------------*
00001C82                          1343  * OP_LEA: decode and display LEA
00001C82                          1344  *---------------------------------------------------------------------------*
00001C82                          1345  OP_LEA      
00001C82  4281                    1346               CLR.L   D1       
00001C84  4284                    1347              CLR.L   D4                   
00001C86  227C 00000000           1348              MOVEA.L #0, A1              
00001C8C  2205                    1349              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C8E                          1350              *CLEAR D3
00001C8E  4283                    1351              CLR.L   D3
00001C90                          1352  
00001C90                          1353  OP_LEA_DN_EA_OR_EA_DN 
00001C90                          1354              *LOAD STACK WITH THIS OPMODE
00001C90  6100 22DC               1355              BSR     PUSH_STACK
00001C94  163C 004C               1356              MOVE.B  #'L',D3
00001C98  6100 22D4               1357              BSR     PUSH_STACK
00001C9C  163C 0045               1358              MOVE.B  #'E',D3
00001CA0  6100 22CC               1359              BSR     PUSH_STACK
00001CA4  163C 0041               1360              MOVE.B  #'A',D3
00001CA8  6100 22C4               1361              BSR     PUSH_STACK
00001CAC  2205                    1362              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CAE                          1363          
00001CAE                          1364  
00001CAE                          1365  OP_PRINT_L_LEA
00001CAE                          1366                          
00001CAE                          1367              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CAE  13FC 0000 000048F8      1368              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CB6  13FC 009B 000048F9      1369              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CBE                          1370             
00001CBE                          1371              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CBE  13FC 00B9 000048FB      1372              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CC6  13FC 0020 000048FC      1373              MOVE.B   #$20,GET_SRC_START_END
00001CCE                          1374  
00001CCE                          1375              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CCE  0285 0000FE3F           1376              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CD4  0685 00000040           1377              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CDA                          1378  
00001CDA  6100 19F4               1379              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CDE  163C 002C               1380              MOVE.B  #',',D3
00001CE2  6100 228A               1381              BSR     PUSH_STACK           
00001CE6  6100 1E18               1382              BSR     GET_EA_EA_DEST       *GETS Dn    
00001CEA                          1383  
00001CEA                          1384              
00001CEA  6000 0002               1385              BRA     OP_LEA_RETURN
00001CEE                          1386              
00001CEE                          1387  OP_LEA_RETURN
00001CEE  4E75                    1388              RTS
00001CF0                          1389              
00001CF0                          1390  
00001CF0                          1391  
00001CF0                          1392  *---------------------------------------------------------------------------*
00001CF0                          1393  * OP_NEG: decode and display NEG 
00001CF0                          1394  *---------------------------------------------------------------------------*
00001CF0                          1395  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001CF0  4281                    1396              CLR.L   D1
00001CF2  4284                    1397              CLR.L   D4
00001CF4  2205                    1398              MOVE.L  D5,D1
00001CF6                          1399              
00001CF6                          1400              *CLEAR D3
00001CF6  4283                    1401              CLR.L   D3
00001CF8                          1402              *LOAD STACK WITH THIS OPMODE
00001CF8  6100 2274               1403              BSR     PUSH_STACK
00001CFC  163C 004E               1404              MOVE.B  #'N',D3
00001D00  6100 226C               1405              BSR     PUSH_STACK
00001D04  163C 0045               1406              MOVE.B  #'E',D3
00001D08  6100 2264               1407              BSR     PUSH_STACK
00001D0C  163C 0047               1408              MOVE.B  #'G',D3
00001D10  6100 225C               1409              BSR     PUSH_STACK
00001D14  163C 002E               1410              MOVE.B  #'.',D3
00001D18  6100 2254               1411              BSR     PUSH_STACK
00001D1C                          1412              
00001D1C                          1413              
00001D1C  EC99                    1414              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D1E  0281 00000007           1415              ANDI.L  #$07,D1
00001D24                          1416              
00001D24  0C01 0000               1417              CMPI.B  #0,D1
00001D28  6700 0012               1418              BEQ     OP_NEG_B    * size is byte
00001D2C  0C01 0001               1419              CMPI.B  #1,D1
00001D30  6700 0016               1420              BEQ     OP_NEG_W    * size is word
00001D34  0C01 0002               1421              CMPI.B  #2,D1
00001D38  6700 001A               1422              BEQ     OP_NEG_L    * size is long
00001D3C                          1423                         
00001D3C                          1424  
00001D3C                          1425  OP_NEG_B    * size is byte   
00001D3C  163C 0042               1426              MOVE.B  #'B',D3
00001D40  6100 222C               1427              BSR     PUSH_STACK
00001D44  6000 001A               1428              BRA     OP_NEG_PRINT_EA
00001D48                          1429  
00001D48                          1430              
00001D48                          1431  OP_NEG_W    * size is word
00001D48  163C 0057               1432              MOVE.B  #'W',D3
00001D4C  6100 2220               1433              BSR     PUSH_STACK
00001D50  6000 000E               1434              BRA     OP_NEG_PRINT_EA
00001D54                          1435  
00001D54                          1436              
00001D54                          1437  OP_NEG_L    * size is long
00001D54  163C 004C               1438              MOVE.B  #'L',D3
00001D58  6100 2214               1439              BSR     PUSH_STACK
00001D5C  6000 0002               1440              BRA     OP_NEG_PRINT_EA
00001D60                          1441  
00001D60                          1442  
00001D60                          1443  OP_NEG_PRINT_EA
00001D60                          1444   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D60  13FC 0082 000048F9      1445             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D68                          1446             
00001D68                          1447             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D68  13FC 0020 000048FC      1448             MOVE.B   #$20,GET_SRC_START_END
00001D70                          1449                         
00001D70                          1450  
00001D70  6100 195E               1451              BSR     GET_EA_EA_SRC
00001D74                          1452              
00001D74  4E75                    1453              RTS
00001D76                          1454  
00001D76                          1455  *---------------------------------------------------------------------------*
00001D76                          1456  * OP_NOT: decode and display NOT 
00001D76                          1457  *---------------------------------------------------------------------------*
00001D76                          1458  OP_NOT
00001D76  4281                    1459              CLR.L   D1
00001D78  4284                    1460              CLR.L   D4
00001D7A  2205                    1461              MOVE.L  D5,D1
00001D7C                          1462              
00001D7C                          1463              *CLEAR D3
00001D7C  4283                    1464              CLR.L   D3
00001D7E                          1465              *LOAD STACK WITH THIS OPMODE
00001D7E  6100 21EE               1466              BSR     PUSH_STACK
00001D82  163C 004E               1467              MOVE.B  #'N',D3
00001D86  6100 21E6               1468              BSR     PUSH_STACK
00001D8A  163C 004F               1469              MOVE.B  #'O',D3
00001D8E  6100 21DE               1470              BSR     PUSH_STACK
00001D92  163C 0054               1471              MOVE.B  #'T',D3
00001D96  6100 21D6               1472              BSR     PUSH_STACK
00001D9A  163C 002E               1473              MOVE.B  #'.',D3
00001D9E  6100 21CE               1474              BSR     PUSH_STACK
00001DA2                          1475              
00001DA2                          1476              
00001DA2  EC99                    1477              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DA4  0281 00000007           1478              ANDI.L  #$07,D1
00001DAA                          1479              
00001DAA  0C01 0000               1480              CMPI.B  #0,D1
00001DAE  6700 0012               1481              BEQ     OP_NOT_B    * size is byte
00001DB2  0C01 0001               1482              CMPI.B  #1,D1
00001DB6  6700 0016               1483              BEQ     OP_NOT_W    * size is word
00001DBA  0C01 0002               1484              CMPI.B  #2,D1
00001DBE  6700 001A               1485              BEQ     OP_NOT_L    * size is long
00001DC2                          1486                         
00001DC2                          1487  
00001DC2                          1488  OP_NOT_B    * size is byte   
00001DC2  163C 0042               1489              MOVE.B  #'B',D3
00001DC6  6100 21A6               1490              BSR     PUSH_STACK
00001DCA  6000 001A               1491              BRA     OP_NOT_PRINT_EA
00001DCE                          1492  
00001DCE                          1493              
00001DCE                          1494  OP_NOT_W    * size is word
00001DCE  163C 0057               1495              MOVE.B  #'W',D3
00001DD2  6100 219A               1496              BSR     PUSH_STACK
00001DD6  6000 000E               1497              BRA     OP_NOT_PRINT_EA
00001DDA                          1498  
00001DDA                          1499              
00001DDA                          1500  OP_NOT_L    * size is long
00001DDA  163C 004C               1501              MOVE.B  #'L',D3
00001DDE  6100 218E               1502              BSR     PUSH_STACK
00001DE2  6000 0002               1503              BRA     OP_NOT_PRINT_EA
00001DE6                          1504  
00001DE6                          1505  
00001DE6                          1506  OP_NOT_PRINT_EA
00001DE6                          1507   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DE6  13FC 0082 000048F9      1508             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001DEE                          1509             
00001DEE                          1510             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DEE  13FC 0020 000048FC      1511             MOVE.B   #$20,GET_SRC_START_END
00001DF6  6100 18D8               1512              BSR     GET_EA_EA_SRC
00001DFA                          1513              
00001DFA  4E75                    1514              RTS
00001DFC                          1515  
00001DFC                          1516  
00001DFC                          1517  *---------------------------------------------------------------------------*
00001DFC                          1518  * OP_JSR: display JSR     
00001DFC                          1519  *---------------------------------------------------------------------------*
00001DFC  43F9 00004673           1520  OP_JSR      LEA     DISP_JSR,A1
00001E02  103C 000E               1521              MOVE.B  #14,D0
00001E06  4E4F                    1522              TRAP    #15
00001E08  4EB9 00003220           1523              JSR     EA_NOSRC
00001E0E                          1524  
00001E0E  4E75                    1525              RTS
00001E10                          1526  
00001E10                          1527  *---------------------------------------------------------------------------*
00001E10                          1528  * OP_RTS: display RTS     
00001E10                          1529  *---------------------------------------------------------------------------* 
00001E10                          1530  OP_RTS      
00001E10  163C 0052               1531              MOVE.B #'R',D3
00001E14  6100 2158               1532              BSR     PUSH_STACK
00001E18  163C 0054               1533              MOVE.B #'T',D3
00001E1C  6100 2150               1534              BSR     PUSH_STACK
00001E20  163C 0053               1535              MOVE.B #'S',D3
00001E24  6100 2148               1536              BSR     PUSH_STACK
00001E28  4E75                    1537              RTS
00001E2A                          1538  
00001E2A                          1539  *---------------------------------------------------------------------------*
00001E2A                          1540  * OP0101: decode ADDQ
00001E2A                          1541  *---------------------------------------------------------------------------* 
00001E2A                          1542  OP0101      
00001E2A                          1543             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E2A  13FC 0082 000048F8      1544             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E32  13FC 0080 000048F9      1545             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E3A                          1546             
00001E3A                          1547             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E3A  13FC 00B9 000048FB      1548             MOVE.B   #$B9,GET_DST_START_END
00001E42  13FC 0020 000048FC      1549             MOVE.B   #$20,GET_SRC_START_END
00001E4A                          1550             
00001E4A                          1551              *CLEAR D3
00001E4A  4283                    1552              CLR.L   D3
00001E4C                          1553              *LOAD STACK WITH THIS OPMODE
00001E4C  6100 2120               1554              BSR     PUSH_STACK
00001E50  163C 0041               1555              MOVE.B  #'A',D3
00001E54  6100 2118               1556              BSR     PUSH_STACK
00001E58  163C 0044               1557              MOVE.B  #'D',D3
00001E5C  6100 2110               1558              BSR     PUSH_STACK
00001E60  163C 0044               1559              MOVE.B  #'D',D3
00001E64  6100 2108               1560              BSR     PUSH_STACK
00001E68  163C 0051               1561              MOVE.B  #'Q',D3
00001E6C  6100 2100               1562              BSR     PUSH_STACK
00001E70  163C 002E               1563              MOVE.B  #'.',D3
00001E74  6100 20F8               1564              BSR     PUSH_STACK
00001E78                          1565              
00001E78                          1566              *FIGURE OUT SIZE*
00001E78                          1567              *00 = BYTE
00001E78                          1568              *01 = WORD
00001E78                          1569              *10 = LONG
00001E78                          1570              * BITS 7&6
00001E78                          1571              
00001E78                          1572              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E78  2205                    1573              MOVE.L  D5,D1
00001E7A  EC99                    1574              ROR.L   #6,D1
00001E7C  0281 00000003           1575              ANDI.L  #$03,D1
00001E82  0C01 0000               1576              CMPI.B  #%00,D1
00001E86  6700 001E               1577              BEQ     OP0101_ADDQ_B
00001E8A  0281 00000003           1578              ANDI.L  #$03,D1
00001E90  0C01 0001               1579              CMPI.B  #%01,D1
00001E94  6700 001C               1580              BEQ     OP0101_ADDQ_W
00001E98  0281 00000003           1581              ANDI.L  #$03,D1
00001E9E  0C01 0002               1582              CMPI.B  #%10,D1
00001EA2  6700 001A               1583              BEQ     OP0101_ADDQ_L
00001EA6                          1584            
00001EA6                          1585  OP0101_ADDQ_B
00001EA6                          1586              
00001EA6  163C 0042               1587              MOVE.B  #'B',D3
00001EAA  6100 20C2               1588              BSR     PUSH_STACK
00001EAE  6000 0016               1589              BRA     OP0101_RETURN
00001EB2                          1590  OP0101_ADDQ_W
00001EB2                          1591              
00001EB2  163C 0057               1592              MOVE.B  #'W',D3
00001EB6  6100 20B6               1593              BSR     PUSH_STACK
00001EBA  6000 000A               1594              BRA     OP0101_RETURN
00001EBE                          1595  OP0101_ADDQ_L
00001EBE                          1596              
00001EBE  163C 004C               1597              MOVE.B  #'L',D3
00001EC2  6100 20AA               1598              BSR     PUSH_STACK
00001EC6                          1599  OP0101_RETURN            
00001EC6                          1600  
00001EC6                          1601              
00001EC6                          1602  *GET DATA FROM ADDQ AND PRINT #0-8
00001EC6  163C 0020               1603              MOVE.B  #' ',D3
00001ECA  6100 20A2               1604              BSR     PUSH_STACK
00001ECE  163C 0023               1605              MOVE.B  #'#',D3
00001ED2  6100 209A               1606              BSR     PUSH_STACK 
00001ED6                          1607  
00001ED6                          1608                       
00001ED6                          1609              *GET DATA #   
00001ED6  2205                    1610              MOVE.L  D5,D1
00001ED8  EC99                    1611              ROR.L   #6,D1            
00001EDA  E699                    1612              ROR.L   #3,D1
00001EDC  0281 00000007           1613              ANDI.L  #$07,D1
00001EE2                          1614              
00001EE2  0C01 0000               1615              CMPI.B  #%000,D1
00001EE6  6700 009A               1616              BEQ     OP0101_ADDQ_B_8
00001EEA  0C01 0001               1617              CMPI.B  #%001,D1
00001EEE  6700 003E               1618              BEQ     OP0101_ADDQ_B_1
00001EF2  0C01 0002               1619              CMPI.B  #%010,D1
00001EF6  6700 0042               1620              BEQ     OP0101_ADDQ_B_2
00001EFA  0C01 0003               1621              CMPI.B  #%011,D1
00001EFE  6700 0046               1622              BEQ     OP0101_ADDQ_B_3
00001F02  0C01 0004               1623              CMPI.B  #%100,D1
00001F06  6700 004A               1624              BEQ     OP0101_ADDQ_B_4
00001F0A  0C01 0005               1625              CMPI.B  #%101,D1
00001F0E  6700 004E               1626              BEQ     OP0101_ADDQ_B_5
00001F12  0C01 0006               1627              CMPI.B  #%110,D1
00001F16  6700 0052               1628              BEQ     OP0101_ADDQ_B_6
00001F1A  0C01 0007               1629              CMPI.B  #%111,D1
00001F1E  6700 0056               1630              BEQ     OP0101_ADDQ_B_7
00001F22                          1631              
00001F22                          1632  OP0101_ADDQ_B_0
00001F22  163C 0030               1633              MOVE.B  #'0',D3
00001F26  6100 2046               1634              BSR     PUSH_STACK
00001F2A  6000 005E               1635              BRA     OP0101_RETURN2            
00001F2E                          1636  OP0101_ADDQ_B_1
00001F2E  163C 0031               1637              MOVE.B  #'1',D3
00001F32  6100 203A               1638              BSR     PUSH_STACK
00001F36  6000 0052               1639              BRA     OP0101_RETURN2            
00001F3A                          1640  OP0101_ADDQ_B_2
00001F3A  163C 0032               1641              MOVE.B  #'2',D3
00001F3E  6100 202E               1642              BSR     PUSH_STACK
00001F42  6000 0046               1643              BRA     OP0101_RETURN2            
00001F46                          1644  OP0101_ADDQ_B_3
00001F46  163C 0033               1645              MOVE.B  #'3',D3
00001F4A  6100 2022               1646              BSR     PUSH_STACK
00001F4E  6000 003A               1647              BRA     OP0101_RETURN2            
00001F52                          1648  OP0101_ADDQ_B_4
00001F52  163C 0034               1649              MOVE.B  #'4',D3
00001F56  6100 2016               1650              BSR     PUSH_STACK
00001F5A  6000 002E               1651              BRA     OP0101_RETURN2            
00001F5E                          1652  OP0101_ADDQ_B_5
00001F5E  163C 0035               1653              MOVE.B  #'5',D3
00001F62  6100 200A               1654              BSR     PUSH_STACK
00001F66  6000 0022               1655              BRA     OP0101_RETURN2
00001F6A                          1656  OP0101_ADDQ_B_6
00001F6A  163C 0036               1657              MOVE.B  #'6',D3
00001F6E  6100 1FFE               1658              BSR     PUSH_STACK
00001F72  6000 0016               1659              BRA     OP0101_RETURN2
00001F76                          1660  OP0101_ADDQ_B_7
00001F76  163C 0037               1661              MOVE.B  #'7',D3
00001F7A  6100 1FF2               1662              BSR     PUSH_STACK
00001F7E  6000 000A               1663              BRA     OP0101_RETURN2
00001F82                          1664  
00001F82                          1665  OP0101_ADDQ_B_8
00001F82  163C 0038               1666              MOVE.B  #'8',D3
00001F86  6100 1FE6               1667              BSR     PUSH_STACK
00001F8A                          1668              
00001F8A                          1669  OP0101_RETURN2            
00001F8A  163C 002C               1670              MOVE.B  #',',D3
00001F8E  6100 1FDE               1671              BSR     PUSH_STACK
00001F92  6100 173C               1672              BSR     GET_EA_EA_SRC
00001F96                          1673              
00001F96  4E75                    1674              RTS
00001F98                          1675  
00001F98                          1676  
00001F98                          1677              
00001F98                          1678  *---------------------------------------------------------------------------*
00001F98                          1679  * OP_ADDQ: display ADDQ
00001F98                          1680  *---------------------------------------------------------------------------*              
00001F98                          1681  OP_ADDQ_B    * size is byte   
00001F98  183C 0000               1682              MOVE.B  #0,D4 
00001F9C  43F9 000046CD           1683              LEA     DISP_ADDQ_B,A1
00001FA2  103C 000E               1684              MOVE.B  #14,D0
00001FA6  4E4F                    1685              TRAP    #15
00001FA8  4E75                    1686              RTS
00001FAA                          1687              
00001FAA                          1688  OP_ADDQ_W    * size is word
00001FAA  183C 0001               1689              MOVE.B  #1,D4
00001FAE  43F9 000046D7           1690              LEA     DISP_ADDQ_W,A1
00001FB4  103C 000E               1691              MOVE.B  #14,D0
00001FB8  4E4F                    1692              TRAP    #15
00001FBA  4E75                    1693              RTS
00001FBC                          1694              
00001FBC                          1695  OP_ADDQ_L    * size is long
00001FBC  183C 0002               1696              MOVE.B  #2,D4
00001FC0  43F9 000046E1           1697              LEA     DISP_ADDQ_L,A1
00001FC6  103C 000E               1698              MOVE.B  #14,D0
00001FCA  4E4F                    1699              TRAP    #15
00001FCC  4E75                    1700              RTS
00001FCE                          1701  
00001FCE                          1702  *---------------------------------------------------------------------------*
00001FCE                          1703  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FCE                          1704  *---------------------------------------------------------------------------*              
00001FCE  4280                    1705  OP0110      CLR.L   D0                  
00001FD0  4281                    1706              CLR.L   D1   
00001FD2  4284                    1707              CLR.L   D4                 
00001FD4  227C 00000000           1708              MOVEA.L #0,A1
00001FDA  2205                    1709              MOVE.L  D5, D1                
00001FDC  0281 000000FF           1710              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FE2  2205                    1711              MOVE.L  D5,D1                  
00001FE4  0281 00000F00           1712              ANDI.L  #$0F00,D1
00001FEA                          1713                 
00001FEA  0C41 0000               1714              CMPI.W  #$0000,D1               * Check for BRA
00001FEE  6700 0050               1715              BEQ     OP_BRA                  
00001FF2                          1716                          
00001FF2  0C41 0D00               1717              CMPI.W  #$0D00,D1               * Check for BLT
00001FF6  6700 006E               1718              BEQ     OP_BLT      
00001FFA                          1719  
00001FFA  0C41 0700               1720              CMPI.W  #$0700,D1               * Check for BEQ
00001FFE  6700 0032               1721              BEQ     OP_BEQ      
00002002                          1722  
00002002  0C41 0600               1723              CMPI.W  #$0600,D1               * Check for BNE
00002006  6700 001C               1724              BEQ     OP_BNE  
0000200A                          1725              
0000200A  0C41 0200               1726              CMPI.W  #$0200,D1               * Check for BHI
0000200E  6700 0006               1727              BEQ     OP_BHI
00002012                          1728  
00002012  4EF8 1750               1729              JMP     OP_DATA
00002016                          1730              
00002016  43F9 0000489C           1731  OP_BHI      LEA     DISP_BHI,A1             
0000201C  103C 000E               1732              MOVE.B  #14,D0
00002020  4E4F                    1733              TRAP    #15
00002022  4E75                    1734              RTS
00002024                          1735  
00002024  43F9 00004895           1736  OP_BNE      LEA     DISP_BNE,A1             
0000202A  103C 000E               1737              MOVE.B  #14,D0
0000202E  4E4F                    1738              TRAP    #15
00002030  4E75                    1739              RTS
00002032                          1740  
00002032  43F9 0000488E           1741  OP_BEQ      LEA     DISP_BEQ,A1             
00002038  103C 000E               1742              MOVE.B  #14,D0
0000203C  4E4F                    1743              TRAP    #15
0000203E  4E75                    1744              RTS          
00002040                          1745                          
00002040                          1746  OP_BRA      
00002040  163C 0042               1747              MOVE.B  #'B',D3
00002044  6100 1F28               1748              BSR     PUSH_STACK
00002048  163C 0052               1749              MOVE.B  #'R',D3
0000204C  6100 1F20               1750              BSR     PUSH_STACK
00002050  163C 0041               1751              MOVE.B  #'A',D3
00002054  6100 1F18               1752              BSR     PUSH_STACK
00002058  163C 0009               1753              MOVE.B  #$9,D3
0000205C  6100 1F10               1754              BSR     PUSH_STACK
00002060  6100 1F8A               1755              BSR     GET_DISPLACEMENT_ADDRESS
00002064                          1756              
00002064  4E75                    1757              RTS
00002066                          1758              
00002066  43F9 00004887           1759  OP_BLT      LEA     DISP_BLT,A1          
0000206C  103C 000E               1760              MOVE.B  #14,D0
00002070  4E4F                    1761              TRAP    #15
00002072  4E75                    1762              RTS
00002074                          1763     
00002074                          1764  *---------------------------------------------------------------------------*
00002074                          1765  * OP0111 : MOVEQ not required
00002074                          1766  *---------------------------------------------------------------------------*           
00002074  4EF8 1750               1767  OP0111      JMP     OP_DATA
00002078                          1768             
00002078                          1769  *---------------------------------------------------------------------------*
00002078                          1770  * OP1000 : decode DIVS
00002078                          1771  *---------------------------------------------------------------------------*           
00002078                          1772  OP1000                           
00002078  4281                    1773              CLR.L   D1       
0000207A  4284                    1774              CLR.L   D4                   
0000207C  227C 00000000           1775              MOVEA.L #0, A1              
00002082  2205                    1776              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002084                          1777              *CLEAR D3
00002084  4283                    1778              CLR.L   D3
00002086                          1779  
00002086                          1780  OP1000_DIVS_DN_EA_OR_EA_DN 
00002086                          1781              *LOAD STACK WITH THIS OPMODE
00002086  6100 1EE6               1782              BSR     PUSH_STACK
0000208A  163C 0044               1783              MOVE.B  #'D',D3
0000208E  6100 1EDE               1784              BSR     PUSH_STACK
00002092  163C 0049               1785              MOVE.B  #'I',D3
00002096  6100 1ED6               1786              BSR     PUSH_STACK
0000209A  163C 0056               1787              MOVE.B  #'V',D3
0000209E  6100 1ECE               1788              BSR     PUSH_STACK
000020A2  163C 0053               1789              MOVE.B  #'S',D3
000020A6  6100 1EC6               1790              BSR     PUSH_STACK
000020AA  163C 002E               1791              MOVE.B  #'.',D3
000020AE  6100 1EBE               1792              BSR     PUSH_STACK
000020B2                          1793              
000020B2  2205                    1794              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000020B4                          1795              
000020B4                          1796  OP1000_EA_DN_DIVS
000020B4                          1797              *BITS (7 TO 6) 
000020B4                          1798              *00 = .B
000020B4                          1799              *01 = .W
000020B4                          1800              *10 = .L 
000020B4  2205                    1801              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000020B6  EC99                    1802              ROR.L   #6,D1
000020B8  0281 00000003           1803              ANDI.L  #$03,D1
000020BE  0C81 00000003           1804              CMPI.L  #%11,D1 *EQUALS .W
000020C4  6700 0014               1805              BEQ     OP1000_PRINT_W_DIVS
000020C8  0C81 00000000           1806              CMPI.L  #%00,D1 *EQUALS .L
000020CE  6700 0052               1807              BEQ     OP1000_PRINT_L_DIVS
000020D2                          1808              
000020D2  183C 0001               1809              MOVE.B  #1,D4               *ERROR READ
000020D6  6000 0092               1810              BRA     OP1000_DIVS_RETURN
000020DA                          1811  OP1000_PRINT_W_DIVS
000020DA  163C 0057               1812              MOVE.B  #'W',D3
000020DE  6100 1E8E               1813              BSR     PUSH_STACK
000020E2                          1814  
000020E2                          1815              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020E2  13FC 0000 000048F8      1816              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020EA  13FC 0000 000048F9      1817              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020F2                          1818             
000020F2                          1819              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020F2  13FC 00B9 000048FB      1820              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020FA  13FC 0020 000048FC      1821              MOVE.B   #$20,GET_SRC_START_END
00002102                          1822  
00002102                          1823             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002102  0285 0000FE3F           1824              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002108  0685 00000000           1825              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000210E                          1826  
0000210E                          1827              
0000210E  6100 15C0               1828              BSR     GET_EA_EA_SRC      *GETS <ea>
00002112  163C 002C               1829              MOVE.B  #',',D3
00002116  6100 1E56               1830              BSR     PUSH_STACK
0000211A  6100 19E4               1831              BSR     GET_EA_EA_DEST       *GETS Dn    
0000211E                          1832              
0000211E  6000 004A               1833              BRA     OP1000_DIVS_RETURN
00002122                          1834  OP1000_PRINT_L_DIVS
00002122  163C 004C               1835              MOVE.B  #'L',D3
00002126  6100 1E46               1836              BSR     PUSH_STACK
0000212A                          1837              
0000212A                          1838              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000212A  13FC 0000 000048F8      1839              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002132  13FC 0000 000048F9      1840              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000213A                          1841             
0000213A                          1842              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000213A  13FC 00B9 000048FB      1843              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002142  13FC 0020 000048FC      1844              MOVE.B   #$20,GET_SRC_START_END
0000214A                          1845  
0000214A                          1846              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000214A  0285 0000FE3F           1847              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002150  0685 00000000           1848              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002156                          1849  
00002156                          1850                     
00002156  6100 1578               1851              BSR     GET_EA_EA_SRC      *GETS <ea>
0000215A  163C 002C               1852              MOVE.B  #',',D3
0000215E  6100 1E0E               1853              BSR     PUSH_STACK                  
00002162  6100 199C               1854              BSR     GET_EA_EA_DEST       *GETS Dn    
00002166                          1855  
00002166                          1856              
00002166  6000 0002               1857              BRA     OP1000_DIVS_RETURN
0000216A                          1858              
0000216A                          1859  OP1000_DIVS_RETURN
0000216A  4E75                    1860              RTS
0000216C                          1861              
0000216C                          1862  
0000216C                          1863  
0000216C                          1864  *---------------------------------------------------------------------------*
0000216C                          1865  * OP_DIVS: display DIVS and proceed to EA
0000216C                          1866  *---------------------------------------------------------------------------*  
0000216C  43F9 000046EB           1867  OP_DIVS     LEA     DISP_DIVS,A1
00002172  103C 000E               1868              MOVE.B  #14,D0
00002176  4E4F                    1869              TRAP    #15
00002178  4EF9 00003234           1870              JMP     EA_ARITH
0000217E                          1871  
0000217E  4E75                    1872              RTS
00002180                          1873              
00002180                          1874  *---------------------------------------------------------------------------*
00002180                          1875  * OP1001: decode SUB/SUBA
00002180                          1876  *---------------------------------------------------------------------------*      
00002180                          1877  OP1001      
00002180  4280                    1878              CLR.L   D0                  
00002182  4281                    1879              CLR.L   D1       
00002184  4284                    1880              CLR.L   D4                   
00002186  227C 00000000           1881              MOVEA.L #0, A1              
0000218C  2205                    1882              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000218E                          1883              
0000218E                          1884              *CLEAR D3
0000218E  4283                    1885              CLR.L   D3
00002190                          1886              
00002190                          1887              
00002190                          1888              
00002190                          1889              **INTEGRATING SUB.W/.L INTO THIS CODE**
00002190  2205                    1890              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002192                          1891              *BITS (INDEX 8) 
00002192                          1892              *0 = ADD.B/W/L <EA>,Dn
00002192                          1893              *1 = ADD.B/W/L Dn,<EA> 
00002192  EC99                    1894              ROR.L   #6,D1
00002194  0281 00000007           1895              ANDI.L  #$07,D1                 *MASKS WITH 00000111
0000219A  0C81 00000007           1896              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
000021A0  6700 0010               1897              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
000021A4  0C81 00000003           1898              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
000021AA  6700 0078               1899              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
000021AE  6000 00E6               1900              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
000021B2                          1901              
000021B2                          1902  OP1001_SUBA_L
000021B2                          1903              *LOAD STACK WITH THIS OPMODE
000021B2  6100 1DBA               1904              BSR     PUSH_STACK
000021B6  163C 0053               1905              MOVE.B  #'S',D3
000021BA  6100 1DB2               1906              BSR     PUSH_STACK
000021BE  163C 0055               1907              MOVE.B  #'U',D3
000021C2  6100 1DAA               1908              BSR     PUSH_STACK
000021C6  163C 0042               1909              MOVE.B  #'B',D3
000021CA  6100 1DA2               1910              BSR     PUSH_STACK
000021CE  163C 0041               1911              MOVE.B  #'A',D3
000021D2  6100 1D9A               1912              BSR     PUSH_STACK
000021D6  163C 002E               1913              MOVE.B  #'.',D3
000021DA  6100 1D92               1914              BSR     PUSH_STACK
000021DE  163C 004C               1915              MOVE.B  #'L',D3
000021E2  6100 1D8A               1916              BSR     PUSH_STACK
000021E6                          1917              
000021E6                          1918             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021E6  13FC 0000 000048F8      1919             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021EE  13FC 0000 000048F9      1920             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021F6                          1921             
000021F6                          1922             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021F6  13FC 00B9 000048FB      1923             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021FE  13FC 0020 000048FC      1924             MOVE.B   #$20,GET_SRC_START_END
00002206                          1925  
00002206                          1926              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002206  0285 0000FE3F           1927              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000220C  0685 00000040           1928              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002212                          1929       
00002212                          1930              *PRINT <EA>,AN
00002212  6100 14BC               1931              BSR     GET_EA_EA_SRC       *GETS <ea>
00002216  163C 002C               1932              MOVE.B  #',',D3
0000221A  6100 1D52               1933              BSR     PUSH_STACK                     
0000221E  6100 18E0               1934              BSR     GET_EA_EA_DEST      *GETS Dn
00002222                          1935  
00002222                          1936              
00002222                          1937              
00002222  4E75                    1938              RTS
00002224                          1939  OP1001_SUBA_W
00002224                          1940              *LOAD STACK WITH THIS OPMODE
00002224  6100 1D48               1941              BSR     PUSH_STACK
00002228  163C 0053               1942              MOVE.B  #'S',D3
0000222C  6100 1D40               1943              BSR     PUSH_STACK
00002230  163C 0055               1944              MOVE.B  #'U',D3
00002234  6100 1D38               1945              BSR     PUSH_STACK
00002238  163C 0042               1946              MOVE.B  #'B',D3
0000223C  6100 1D30               1947              BSR     PUSH_STACK
00002240  163C 0041               1948              MOVE.B  #'A',D3
00002244  6100 1D28               1949              BSR     PUSH_STACK
00002248  163C 002E               1950              MOVE.B  #'.',D3
0000224C  6100 1D20               1951              BSR     PUSH_STACK
00002250  163C 0057               1952              MOVE.B  #'W',D3
00002254  6100 1D18               1953              BSR     PUSH_STACK
00002258                          1954              
00002258                          1955             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002258  13FC 0000 000048F8      1956             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002260  13FC 0000 000048F9      1957             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002268                          1958             
00002268                          1959             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002268  13FC 00B9 000048FB      1960             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002270  13FC 0020 000048FC      1961             MOVE.B   #$20,GET_SRC_START_END
00002278                          1962  
00002278                          1963              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002278  0285 0000FE3F           1964              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000227E  0685 00000040           1965              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002284                          1966       
00002284                          1967              *PRINT <EA>,AN
00002284  6100 144A               1968              BSR     GET_EA_EA_SRC       *GETS <ea>
00002288  163C 002C               1969              MOVE.B  #',',D3
0000228C  6100 1CE0               1970              BSR     PUSH_STACK                     
00002290  6100 186E               1971              BSR     GET_EA_EA_DEST      *GETS Dn
00002294                          1972  
00002294  4E75                    1973              RTS
00002296                          1974  
00002296                          1975  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00002296                          1976              *LOAD STACK WITH THIS OPMODE
00002296  6100 1CD6               1977              BSR     PUSH_STACK
0000229A  163C 0053               1978              MOVE.B  #'S',D3
0000229E  6100 1CCE               1979              BSR     PUSH_STACK
000022A2  163C 0055               1980              MOVE.B  #'U',D3
000022A6  6100 1CC6               1981              BSR     PUSH_STACK
000022AA  163C 0042               1982              MOVE.B  #'B',D3
000022AE  6100 1CBE               1983              BSR     PUSH_STACK
000022B2  163C 002E               1984              MOVE.B  #'.',D3
000022B6  6100 1CB6               1985              BSR     PUSH_STACK
000022BA                          1986              
000022BA  2205                    1987              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000022BC                          1988              
000022BC                          1989              *BITS (INDEX 8) 
000022BC                          1990              *0 = ADD.B/W/L <EA>,Dn
000022BC                          1991              *1 = ADD.B/W/L Dn,<EA> 
000022BC  E099                    1992              ROR.L   #8,D1
000022BE  0281 00000001           1993              ANDI.L  #$01,D1     *MASKS WITH 00000001
000022C4  0C81 00000000           1994              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000022CA  6700 0102               1995              BEQ     OP1001_EA_DN
000022CE                          1996              *else procede to Dn_EA
000022CE                          1997              
000022CE                          1998  OP1001_DN_EA
000022CE                          1999              *BITS (7 TO 6) 
000022CE                          2000              *00 = .B
000022CE                          2001              *01 = .W
000022CE                          2002              *10 = .L 
000022CE  2205                    2003              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000022D0  EC99                    2004              ROR.L   #6,D1
000022D2  0281 00000003           2005              ANDI.L  #$03,D1
000022D8  0C81 00000000           2006              CMPI.L  #$00,D1 *EQUALS .B
000022DE  6700 0016               2007              BEQ     OP1001_PRINT_B2
000022E2  0C81 00000001           2008              CMPI.L  #$01,D1 *EQUALS .W
000022E8  6700 0054               2009              BEQ     OP1001_PRINT_W2
000022EC  0C81 00000002           2010              CMPI.L  #$02,D1 *EQUALS .L
000022F2  6700 0092               2011              BEQ     OP1001_PRINT_L2
000022F6                          2012  OP1001_PRINT_B2
000022F6                          2013              *PUSH 'B'
000022F6  163C 0042               2014              MOVE.B  #'B',D3
000022FA  6100 1C72               2015              BSR     PUSH_STACK
000022FE                          2016             
000022FE                          2017              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022FE  13FC 0000 000048F8      2018             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002306  13FC 0083 000048F9      2019             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000230E                          2020             
0000230E                          2021             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000230E  13FC 00B9 000048FB      2022             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002316  13FC 0020 000048FC      2023             MOVE.B   #$20,GET_SRC_START_END
0000231E                          2024  
0000231E                          2025              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000231E  0285 0000FE3F           2026              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002324  0685 00000040           2027              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000232A                          2028       
0000232A  6100 17D4               2029              BSR     GET_EA_EA_DEST      *GETS Dn
0000232E  163C 002C               2030              MOVE.B  #',',D3
00002332  6100 1C3A               2031              BSR     PUSH_STACK                     
00002336  6100 1398               2032              BSR     GET_EA_EA_SRC       *GETS <ea>
0000233A                          2033  
0000233A                          2034              
0000233A  6000 0BA4               2035              BRA     OP1101_ADD_RETURN
0000233E                          2036  OP1001_PRINT_W2
0000233E  163C 0057               2037              MOVE.B  #'W',D3
00002342  6100 1C2A               2038              BSR     PUSH_STACK
00002346                          2039  
00002346                          2040              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002346  13FC 0000 000048F8      2041              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000234E  13FC 0083 000048F9      2042              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002356                          2043             
00002356                          2044              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002356  13FC 00B9 000048FB      2045              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000235E  13FC 0020 000048FC      2046              MOVE.B   #$20,GET_SRC_START_END
00002366                          2047  
00002366                          2048              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002366  0285 0000FE3F           2049              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000236C  0685 00000040           2050              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002372                          2051  
00002372                          2052        
00002372  6100 178C               2053              BSR     GET_EA_EA_DEST      *GETS Dn
00002376  163C 002C               2054              MOVE.B  #',',D3
0000237A  6100 1BF2               2055              BSR     PUSH_STACK               
0000237E  6100 1350               2056              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002382                          2057  
00002382                          2058  
00002382                          2059  
00002382  6000 0B5C               2060              BRA     OP1101_ADD_RETURN
00002386                          2061  OP1001_PRINT_L2 
00002386  163C 004C               2062              MOVE.B  #'L',D3
0000238A  6100 1BE2               2063              BSR     PUSH_STACK
0000238E                          2064              
0000238E                          2065              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000238E  13FC 0000 000048F8      2066              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002396  13FC 0083 000048F9      2067              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000239E                          2068             
0000239E                          2069              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000239E  13FC 00B9 000048FB      2070              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023A6  13FC 0020 000048FC      2071              MOVE.B   #$20,GET_SRC_START_END
000023AE                          2072  
000023AE                          2073             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023AE  0285 0000FE3F           2074              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023B4  0685 00000040           2075              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023BA                          2076  
000023BA                          2077               
000023BA  6100 1744               2078              BSR     GET_EA_EA_DEST       *GETS Dn
000023BE  163C 002C               2079              MOVE.B  #',',D3
000023C2  6100 1BAA               2080              BSR     PUSH_STACK          
000023C6  6100 1308               2081              BSR     GET_EA_EA_SRC        *GETS <ea>
000023CA                          2082  
000023CA  6000 0B14               2083              BRA     OP1101_ADD_RETURN
000023CE                          2084              
000023CE                          2085  OP1001_EA_DN           
000023CE                          2086              *BITS (7 TO 6) 
000023CE                          2087              *00 = .B
000023CE                          2088              *01 = .W
000023CE                          2089              *10 = .L 
000023CE  2205                    2090              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000023D0  EC99                    2091              ROR.L   #6,D1
000023D2  0281 00000003           2092              ANDI.L  #$03,D1
000023D8  0C81 00000000           2093              CMPI.L  #$00,D1 *EQUALS .B
000023DE  6700 0016               2094              BEQ     OP1001_PRINT_B
000023E2  0C81 00000001           2095              CMPI.L  #$01,D1 *EQUALS .W
000023E8  6700 0054               2096              BEQ     OP1001_PRINT_W
000023EC  0C81 00000002           2097              CMPI.L  #$02,D1 *EQUALS .L
000023F2  6700 0092               2098              BEQ     OP1001_PRINT_L
000023F6                          2099  OP1001_PRINT_B
000023F6  163C 0042               2100              MOVE.B  #'B',D3
000023FA  6100 1B72               2101              BSR     PUSH_STACK
000023FE                          2102                
000023FE                          2103              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023FE  13FC 0000 000048F8      2104              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002406  13FC 0002 000048F9      2105              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000240E                          2106             
0000240E                          2107              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000240E  13FC 00B9 000048FB      2108              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002416  13FC 0020 000048FC      2109              MOVE.B   #$20,GET_SRC_START_END
0000241E                          2110  
0000241E                          2111             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000241E  0285 0000FE3F           2112              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002424  0685 00000040           2113              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
0000242A                          2114  
0000242A                          2115              
0000242A  6100 12A4               2116              BSR     GET_EA_EA_SRC      *GETS <ea>
0000242E  163C 002C               2117              MOVE.B  #',',D3
00002432  6100 1B3A               2118              BSR     PUSH_STACK          
00002436  6100 16C8               2119              BSR     GET_EA_EA_DEST       *GETS Dn
0000243A                          2120              
0000243A  6000 0AA4               2121              BRA     OP1101_ADD_RETURN
0000243E                          2122  OP1001_PRINT_W
0000243E  163C 0057               2123              MOVE.B  #'W',D3
00002442  6100 1B2A               2124              BSR     PUSH_STACK
00002446                          2125  
00002446                          2126              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002446  13FC 0000 000048F8      2127              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000244E  13FC 0000 000048F9      2128              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002456                          2129             
00002456                          2130              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002456  13FC 00B9 000048FB      2131              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000245E  13FC 0020 000048FC      2132              MOVE.B   #$20,GET_SRC_START_END
00002466                          2133  
00002466                          2134             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002466  0285 0000FE3F           2135              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000246C  0685 00000040           2136              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002472                          2137  
00002472                          2138              
00002472  6100 125C               2139              BSR     GET_EA_EA_SRC      *GETS <ea>
00002476  163C 002C               2140              MOVE.B  #',',D3
0000247A  6100 1AF2               2141              BSR     PUSH_STACK
0000247E  6100 1680               2142              BSR     GET_EA_EA_DEST       *GETS Dn    
00002482                          2143              
00002482  6000 004A               2144              BRA     OP1001_ADD_RETURN
00002486                          2145  OP1001_PRINT_L 
00002486  163C 004C               2146              MOVE.B  #'L',D3
0000248A  6100 1AE2               2147              BSR     PUSH_STACK
0000248E                          2148              
0000248E                          2149              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000248E  13FC 0000 000048F8      2150              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002496  13FC 0000 000048F9      2151              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000249E                          2152             
0000249E                          2153              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000249E  13FC 00B9 000048FB      2154              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024A6  13FC 0020 000048FC      2155              MOVE.B   #$20,GET_SRC_START_END
000024AE                          2156  
000024AE                          2157              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024AE  0285 0000FE3F           2158              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024B4  0685 00000040           2159              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024BA                          2160  
000024BA                          2161                     
000024BA  6100 1214               2162              BSR     GET_EA_EA_SRC      *GETS <ea>
000024BE  163C 002C               2163              MOVE.B  #',',D3
000024C2  6100 1AAA               2164              BSR     PUSH_STACK                  
000024C6  6100 1638               2165              BSR     GET_EA_EA_DEST       *GETS Dn    
000024CA                          2166  
000024CA                          2167              
000024CA  6000 0002               2168              BRA     OP1001_ADD_RETURN
000024CE                          2169              
000024CE                          2170  OP1001_ADD_RETURN
000024CE  4E75                    2171              RTS
000024D0                          2172  
000024D0                          2173    
000024D0                          2174  *---------------------------------------------------------------------------*
000024D0                          2175  * OP_SUB: display SUB and proceed to EA
000024D0                          2176  *---------------------------------------------------------------------------*            
000024D0  43F9 000046F3           2177  OP_SUB_B    LEA     DISP_SUB_B,A1
000024D6  103C 000E               2178              MOVE.B  #14,D0
000024DA  4E4F                    2179              TRAP    #15
000024DC  183C 0000               2180              MOVE.B  #0,D4
000024E0  4EF9 00003280           2181              JMP     EA_GEN
000024E6                          2182  
000024E6  4E75                    2183              RTS
000024E8                          2184  
000024E8  43F9 000046FC           2185  OP_SUB_W    LEA     DISP_SUB_W,A1
000024EE  103C 000E               2186              MOVE.B  #14,D0
000024F2  4E4F                    2187              TRAP    #15
000024F4  183C 0001               2188              MOVE.B  #1,D4
000024F8  4EF9 00003280           2189              JMP     EA_GEN
000024FE                          2190  
000024FE  4E75                    2191              RTS
00002500                          2192  
00002500  43F9 00004705           2193  OP_SUB_L    LEA     DISP_SUB_L,A1
00002506  103C 000E               2194              MOVE.B  #14,D0
0000250A  4E4F                    2195              TRAP    #15
0000250C  183C 0002               2196              MOVE.B  #2,D4
00002510  4EF9 00003280           2197              JMP     EA_GEN
00002516                          2198  
00002516  4E75                    2199              RTS
00002518                          2200  
00002518                          2201  *---------------------------------------------------------------------------*
00002518                          2202  * OP_SUBA: display SUBA
00002518                          2203  *---------------------------------------------------------------------------*  
00002518  43F9 0000472C           2204  OP_SUBA_W   LEA     DISP_SUBA_W,A1
0000251E  103C 000E               2205              MOVE.B  #14,D0
00002522  4E4F                    2206              TRAP    #15
00002524  183C 0001               2207              MOVE.B  #1,D4
00002528  4E75                    2208              RTS
0000252A                          2209  
0000252A  43F9 00004736           2210  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00002530  103C 000E               2211              MOVE.B  #14,D0
00002534  4E4F                    2212              TRAP    #15
00002536  183C 0002               2213              MOVE.B  #2,D4
0000253A  4E75                    2214              RTS         
0000253C                          2215  *---------------------------------------------------------------------------*
0000253C                          2216  * OP1010 : unassigned
0000253C                          2217  *---------------------------------------------------------------------------*           
0000253C  4EF8 1750               2218  OP1010      JMP     OP_DATA
00002540                          2219              
00002540                          2220  *---------------------------------------------------------------------------*
00002540                          2221  * OP1011 : decode CMP/EOR/CMPA
00002540                          2222  *---------------------------------------------------------------------------*           
00002540  4280                    2223  OP1011      CLR.L   D0                
00002542  4281                    2224              CLR.L   D1            
00002544  4284                    2225              CLR.L   D4                   
00002546  227C 00000000           2226              MOVEA.L #0, A1               
0000254C  2205                    2227              MOVE.L  D5,D1
0000254E  EA99                    2228              ROR.L   #5,D1
00002550  0281 0000000E           2229              ANDI.L  #$E,D1
00002556  0C01 0000               2230              CMPI.B  #$0,D1
0000255A  6700 003E               2231              BEQ     OP1011_CMP
0000255E  0C01 0002               2232              CMPI.B  #$2,D1
00002562  6700 0036               2233              BEQ     OP1011_CMP
00002566  0C01 0004               2234              CMPI.B  #$4,D1
0000256A  6700 002E               2235              BEQ     OP1011_CMP
0000256E  0C01 0008               2236              CMPI.B  #$8,D1
00002572  6700 0178               2237              BEQ     OP1011_EOR
00002576  0C01 000A               2238              CMPI.B  #$A,D1
0000257A  6700 0170               2239              BEQ     OP1011_EOR
0000257E  0C01 000C               2240              CMPI.B  #$C,D1
00002582  6700 0168               2241              BEQ     OP1011_EOR  
00002586  0C01 0006               2242              CMPI.B  #$6,D1
0000258A  6700 00C0               2243              BEQ     OP1011_CMPA
0000258E  0C01 000E               2244              CMPI.B  #$E,D1
00002592  6700 00B8               2245              BEQ     OP1011_CMPA 
00002596                          2246  
00002596  4EF8 1750               2247              JMP     OP_DATA          
0000259A                          2248  
0000259A                          2249  
0000259A                          2250  
0000259A                          2251  
0000259A                          2252  OP1011_CMP
0000259A                          2253             
0000259A                          2254   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000259A  13FC 0082 000048F8      2255             MOVE.B   #$82,DEST_REGISTER_FORMAT
000025A2  13FC 0000 000048F9      2256             MOVE.B   #$00,SRC_REGISTER_FORMAT
000025AA                          2257             
000025AA                          2258             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000025AA  13FC 00B9 000048FB      2259             MOVE.B   #$B9,GET_DST_START_END
000025B2  13FC 0020 000048FC      2260             MOVE.B   #$20,GET_SRC_START_END
000025BA                          2261             
000025BA                          2262              *CLEAR D3
000025BA  4283                    2263              CLR.L   D3
000025BC                          2264              *LOAD STACK WITH THIS OPMODE
000025BC  6100 19B0               2265              BSR     PUSH_STACK
000025C0  163C 0043               2266              MOVE.B  #'C',D3
000025C4  6100 19A8               2267              BSR     PUSH_STACK
000025C8  163C 004D               2268              MOVE.B  #'M',D3
000025CC  6100 19A0               2269              BSR     PUSH_STACK
000025D0  163C 0050               2270              MOVE.B  #'P',D3
000025D4  6100 1998               2271              BSR     PUSH_STACK
000025D8  163C 002E               2272              MOVE.B  #'.',D3
000025DC  6100 1990               2273              BSR     PUSH_STACK
000025E0                          2274              
000025E0                          2275              *FIGURE OUT SIZE*
000025E0                          2276              *00 = BYTE
000025E0                          2277              *01 = WORD
000025E0                          2278              *10 = LONG
000025E0                          2279              * BITS 7&6
000025E0                          2280              
000025E0                          2281              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000025E0  2205                    2282              MOVE.L  D5,D1
000025E2  EC99                    2283              ROR.L   #6,D1
000025E4  0281 00000003           2284              ANDI.L  #$03,D1
000025EA  0C01 0000               2285              CMPI.B  #%00,D1
000025EE  6700 001E               2286              BEQ     OP1011_CMP_B
000025F2  0281 00000003           2287              ANDI.L  #$03,D1
000025F8  0C01 0001               2288              CMPI.B  #%01,D1
000025FC  6700 001C               2289              BEQ     OP1011_CMP_W
00002600  0281 00000003           2290              ANDI.L  #$03,D1
00002606  0C01 0002               2291              CMPI.B  #%10,D1
0000260A  6700 001A               2292              BEQ     OP1011_CMP_L
0000260E                          2293            
0000260E                          2294  OP1011_CMP_B
0000260E                          2295              
0000260E  163C 0042               2296              MOVE.B  #'B',D3
00002612  6100 195A               2297              BSR     PUSH_STACK
00002616  6000 0016               2298              BRA     OP1011_RETURN_CMP  
0000261A                          2299  OP1011_CMP_W
0000261A                          2300              
0000261A  163C 0057               2301              MOVE.B  #'W',D3
0000261E  6100 194E               2302              BSR     PUSH_STACK
00002622  6000 000A               2303              BRA     OP1011_RETURN_CMP  
00002626                          2304  OP1011_CMP_L
00002626                          2305              
00002626  163C 004C               2306              MOVE.B  #'L',D3
0000262A  6100 1942               2307              BSR     PUSH_STACK
0000262E                          2308  OP1011_RETURN_CMP            
0000262E                          2309  
0000262E                          2310              
0000262E                          2311  *GET DATA FROM ADDQ AND PRINT #0-8
0000262E                          2312       
0000262E                          2313              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000262E  0285 0000FE3F           2314              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002634  0685 00000000           2315              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000263A                          2316  
0000263A  6100 1094               2317              BSR     GET_EA_EA_SRC
0000263E  163C 002C               2318              MOVE.B  #',',D3
00002642  6100 192A               2319              BSR     PUSH_STACK
00002646  6100 14B8               2320              BSR     GET_EA_EA_DEST
0000264A                          2321              
0000264A  4E75                    2322              RTS
0000264C                          2323              
0000264C                          2324  
0000264C                          2325  
0000264C                          2326  OP1011_CMPA
0000264C                          2327              
0000264C                          2328   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000264C  13FC 0080 000048F8      2329             MOVE.B   #$80,DEST_REGISTER_FORMAT
00002654  13FC 0000 000048F9      2330             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000265C                          2331             
0000265C                          2332             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000265C  13FC 00B9 000048FB      2333             MOVE.B   #$B9,GET_DST_START_END
00002664  13FC 0020 000048FC      2334             MOVE.B   #$20,GET_SRC_START_END
0000266C                          2335             
0000266C                          2336              *CLEAR D3
0000266C  4283                    2337              CLR.L   D3
0000266E                          2338              *LOAD STACK WITH THIS OPMODE
0000266E  6100 18FE               2339              BSR     PUSH_STACK
00002672  163C 0043               2340              MOVE.B  #'C',D3
00002676  6100 18F6               2341              BSR     PUSH_STACK
0000267A  163C 004D               2342              MOVE.B  #'M',D3
0000267E  6100 18EE               2343              BSR     PUSH_STACK
00002682  163C 0050               2344              MOVE.B  #'P',D3
00002686  6100 18E6               2345              BSR     PUSH_STACK
0000268A  163C 0041               2346              MOVE.B  #'A',D3
0000268E  6100 18DE               2347              BSR     PUSH_STACK
00002692  163C 002E               2348              MOVE.B  #'.',D3
00002696  6100 18D6               2349              BSR     PUSH_STACK
0000269A                          2350              
0000269A                          2351              *FIGURE OUT SIZE*
0000269A                          2352              *00 = BYTE
0000269A                          2353              *01 = WORD
0000269A                          2354              *10 = LONG
0000269A                          2355              * BITS 7&6
0000269A                          2356              
0000269A                          2357              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000269A  2205                    2358              MOVE.L  D5,D1
0000269C  EC99                    2359              ROR.L   #6,D1
0000269E  0281 00000003           2360              ANDI.L  #$03,D1
000026A4  0C01 0001               2361              CMPI.B  #%01,D1
000026A8  6700 0010               2362              BEQ     OP1011_CMPA_W
000026AC  0281 00000003           2363              ANDI.L  #$03,D1
000026B2  0C01 0002               2364              CMPI.B  #%10,D1
000026B6  6700 000E               2365              BEQ     OP1011_CMPA_L
000026BA                          2366  OP1011_CMPA_W
000026BA                          2367              
000026BA  163C 0057               2368              MOVE.B  #'W',D3
000026BE  6100 18AE               2369              BSR     PUSH_STACK
000026C2  6000 000A               2370              BRA     OP1011_RETURN_CMPA 
000026C6                          2371  OP1011_CMPA_L
000026C6                          2372              
000026C6  163C 004C               2373              MOVE.B  #'L',D3
000026CA  6100 18A2               2374              BSR     PUSH_STACK
000026CE                          2375  OP1011_RETURN_CMPA            
000026CE                          2376  
000026CE                          2377              
000026CE                          2378  *GET DATA FROM ADDQ AND PRINT #0-8
000026CE                          2379       
000026CE                          2380              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026CE  0285 0000FE3F           2381              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026D4  0685 00000040           2382              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000026DA                          2383  
000026DA  6100 0FF4               2384              BSR     GET_EA_EA_SRC
000026DE  163C 002C               2385              MOVE.B  #',',D3
000026E2  6100 188A               2386              BSR     PUSH_STACK
000026E6  6100 1418               2387              BSR     GET_EA_EA_DEST
000026EA                          2388              
000026EA  4E75                    2389              RTS
000026EC                          2390  
000026EC                          2391  OP1011_EOR
000026EC                          2392  
000026EC                          2393   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026EC  13FC 0082 000048F8      2394             MOVE.B   #$82,DEST_REGISTER_FORMAT
000026F4  13FC 0080 000048F9      2395             MOVE.B   #$80,SRC_REGISTER_FORMAT
000026FC                          2396             
000026FC                          2397             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026FC  13FC 00B9 000048FB      2398             MOVE.B   #$B9,GET_DST_START_END
00002704  13FC 0020 000048FC      2399             MOVE.B   #$20,GET_SRC_START_END
0000270C                          2400             
0000270C                          2401              *CLEAR D3
0000270C  4283                    2402              CLR.L   D3
0000270E                          2403              *LOAD STACK WITH THIS OPMODE
0000270E  6100 185E               2404              BSR     PUSH_STACK
00002712  163C 0045               2405              MOVE.B  #'E',D3
00002716  6100 1856               2406              BSR     PUSH_STACK
0000271A  163C 004F               2407              MOVE.B  #'O',D3
0000271E  6100 184E               2408              BSR     PUSH_STACK
00002722  163C 0052               2409              MOVE.B  #'R',D3
00002726  6100 1846               2410              BSR     PUSH_STACK
0000272A  163C 002E               2411              MOVE.B  #'.',D3
0000272E  6100 183E               2412              BSR     PUSH_STACK
00002732                          2413              
00002732                          2414              *FIGURE OUT SIZE*
00002732                          2415              *00 = BYTE
00002732                          2416              *01 = WORD
00002732                          2417              *10 = LONG
00002732                          2418              * BITS 7&6
00002732                          2419              
00002732                          2420              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002732  2205                    2421              MOVE.L  D5,D1
00002734  EC99                    2422              ROR.L   #6,D1
00002736  0281 00000003           2423              ANDI.L  #$03,D1
0000273C  0C01 0000               2424              CMPI.B  #%00,D1
00002740  6700 001E               2425              BEQ     OP1011_EOR_B
00002744  0281 00000003           2426              ANDI.L  #$03,D1
0000274A  0C01 0001               2427              CMPI.B  #%01,D1
0000274E  6700 001C               2428              BEQ     OP1011_EOR_W
00002752  0281 00000003           2429              ANDI.L  #$03,D1
00002758  0C01 0002               2430              CMPI.B  #%10,D1
0000275C  6700 001A               2431              BEQ     OP1011_EOR_L
00002760                          2432            
00002760                          2433  OP1011_EOR_B
00002760                          2434              
00002760  163C 0042               2435              MOVE.B  #'B',D3
00002764  6100 1808               2436              BSR     PUSH_STACK
00002768  6000 0016               2437              BRA     OP1011_RETURN
0000276C                          2438  OP1011_EOR_W
0000276C                          2439              
0000276C  163C 0057               2440              MOVE.B  #'W',D3
00002770  6100 17FC               2441              BSR     PUSH_STACK
00002774  6000 000A               2442              BRA     OP1011_RETURN
00002778                          2443  OP1011_EOR_L
00002778                          2444              
00002778  163C 004C               2445              MOVE.B  #'L',D3
0000277C  6100 17F0               2446              BSR     PUSH_STACK
00002780                          2447  OP1011_RETURN            
00002780                          2448  
00002780                          2449              
00002780                          2450  *GET DATA FROM ADDQ AND PRINT #0-8
00002780                          2451       
00002780                          2452              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002780  0285 0000FE3F           2453              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002786  0685 00000000           2454              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000278C                          2455  
0000278C  6100 1372               2456              BSR     GET_EA_EA_DEST
00002790  163C 002C               2457              MOVE.B  #',',D3
00002794  6100 17D8               2458              BSR     PUSH_STACK
00002798  6100 0F36               2459              BSR     GET_EA_EA_SRC
0000279C                          2460              
0000279C  4E75                    2461              RTS
0000279E                          2462              
0000279E                          2463              
0000279E                          2464              
0000279E                          2465              
0000279E                          2466  
0000279E                          2467  *---------------------------------------------------------------------------*
0000279E                          2468  * OP_CMPA: display CMPA 
0000279E                          2469  *---------------------------------------------------------------------------
0000279E  43F9 00004776           2470  OP_CMPA_W   LEA     DISP_CMPA_W,A1
000027A4  103C 000E               2471              MOVE.B  #14,D0
000027A8  4E4F                    2472              TRAP    #15
000027AA  183C 0001               2473              MOVE.B  #1,D4
000027AE  4E75                    2474              RTS
000027B0                          2475  
000027B0  43F9 00004780           2476  OP_CMPA_L   LEA     DISP_CMPA_L,A1
000027B6  103C 000E               2477              MOVE.B  #14,D0
000027BA  4E4F                    2478              TRAP    #15
000027BC  183C 0002               2479              MOVE.B  #2,D4
000027C0  4E75                    2480              RTS
000027C2                          2481  
000027C2                          2482  *---------------------------------------------------------------------------*
000027C2                          2483  * OP_CMP: display CMP and proceed to EA
000027C2                          2484  *---------------------------------------------------------------------------*  
000027C2  43F9 0000475B           2485  OP_CMP_B    LEA     DISP_CMP_B,A1
000027C8  103C 000E               2486              MOVE.B  #14,D0
000027CC  4E4F                    2487              TRAP    #15
000027CE  183C 0000               2488              MOVE.B  #0,D4
000027D2  4EF9 00003280           2489              JMP     EA_GEN
000027D8                          2490  
000027D8  4E75                    2491              RTS
000027DA                          2492              
000027DA  43F9 00004764           2493  OP_CMP_W    LEA     DISP_CMP_W,A1
000027E0  103C 000E               2494              MOVE.B  #14,D0
000027E4  4E4F                    2495              TRAP    #15
000027E6  183C 0001               2496              MOVE.B  #1,D4
000027EA  4EF9 00003280           2497              JMP     EA_GEN
000027F0                          2498  
000027F0  4E75                    2499              RTS
000027F2                          2500              
000027F2  43F9 0000476D           2501  OP_CMP_L    LEA     DISP_CMP_L,A1
000027F8  103C 000E               2502              MOVE.B  #14,D0
000027FC  4E4F                    2503              TRAP    #15
000027FE  183C 0002               2504              MOVE.B  #2,D4
00002802  4EF9 00003280           2505              JMP     EA_GEN
00002808                          2506  
00002808  4E75                    2507              RTS
0000280A                          2508              
0000280A                          2509  *---------------------------------------------------------------------------*
0000280A                          2510  * OP_EOR: display EOR
0000280A                          2511  *---------------------------------------------------------------------------*  
0000280A  43F9 00004740           2512  OP_EOR_B    LEA     DISP_EOR_B,A1
00002810  103C 000E               2513              MOVE.B  #14,D0
00002814  4E4F                    2514              TRAP    #15
00002816  183C 0000               2515              MOVE.B  #0,D4
0000281A  4E75                    2516              RTS
0000281C                          2517              
0000281C  43F9 00004749           2518  OP_EOR_W    LEA     DISP_EOR_W,A1
00002822  103C 000E               2519              MOVE.B  #14,D0
00002826  4E4F                    2520              TRAP    #15
00002828  183C 0001               2521              MOVE.B  #1,D4
0000282C  4E75                    2522              RTS
0000282E                          2523              
0000282E  43F9 00004752           2524  OP_EOR_L    LEA     DISP_EOR_L,A1
00002834  103C 000E               2525              MOVE.B  #14,D0
00002838  4E4F                    2526              TRAP    #15
0000283A  183C 0002               2527              MOVE.B  #2,D4
0000283E  4E75                    2528              RTS    
00002840                          2529  
00002840                          2530  *---------------------------------------------------------------------------*
00002840                          2531  * OP1100: Decode and display MULS/AND and proceed to EA
00002840                          2532  *---------------------------------------------------------------------------* 
00002840  4280                    2533  OP1100      CLR.L   D0                 
00002842  4281                    2534              CLR.L   D1    
00002844  4284                    2535              CLR.L   D4                
00002846  227C 00000000           2536              MOVEA.L #0, A1        
0000284C  2205                    2537              MOVE.L  D5,D1
0000284E  EA89                    2538              LSR.L   #5,D1
00002850  0281 0000000E           2539              ANDI.L  #$E,D1
00002856  0C41 000E               2540              CMPI.W  #$E,D1
0000285A  6700 0006               2541              BEQ     OP_MULS
0000285E  6000 00F6               2542              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002862                          2543  
00002862                          2544  OP_MULS                      
00002862  4281                    2545              CLR.L   D1       
00002864  4284                    2546              CLR.L   D4                   
00002866  227C 00000000           2547              MOVEA.L #0, A1              
0000286C  2205                    2548              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000286E                          2549              *CLEAR D3
0000286E  4283                    2550              CLR.L   D3
00002870                          2551  
00002870                          2552  OP1100_MULS_DN_EA_OR_EA_DN 
00002870                          2553              *LOAD STACK WITH THIS OPMODE
00002870  6100 16FC               2554              BSR     PUSH_STACK
00002874  163C 004D               2555              MOVE.B  #'M',D3
00002878  6100 16F4               2556              BSR     PUSH_STACK
0000287C  163C 0055               2557              MOVE.B  #'U',D3
00002880  6100 16EC               2558              BSR     PUSH_STACK
00002884  163C 004C               2559              MOVE.B  #'L',D3
00002888  6100 16E4               2560              BSR     PUSH_STACK
0000288C  163C 0053               2561              MOVE.B  #'S',D3
00002890  6100 16DC               2562              BSR     PUSH_STACK
00002894  163C 002E               2563              MOVE.B  #'.',D3
00002898  6100 16D4               2564              BSR     PUSH_STACK
0000289C                          2565              
0000289C  2205                    2566              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000289E                          2567              
0000289E                          2568  OP1100_EA_DN_MULS           
0000289E                          2569              *BITS (7 TO 6) 
0000289E                          2570              *00 = .B
0000289E                          2571              *01 = .W
0000289E                          2572              *10 = .L 
0000289E  2205                    2573              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000028A0  EC99                    2574              ROR.L   #6,D1
000028A2  0281 00000003           2575              ANDI.L  #$03,D1
000028A8  0C81 00000003           2576              CMPI.L  #%11,D1 *EQUALS .W
000028AE  6700 0014               2577              BEQ     OP1100_PRINT_W_MULS
000028B2  0C81 00000000           2578              CMPI.L  #%00,D1 *EQUALS .L
000028B8  6700 0052               2579              BEQ     OP1100_PRINT_L_MULS
000028BC                          2580              
000028BC  183C 0001               2581              MOVE.B  #1,D4               *ERROR READ
000028C0  6000 0092               2582              BRA     OP1100_MULS_RETURN
000028C4                          2583  OP1100_PRINT_W_MULS
000028C4  163C 0057               2584              MOVE.B  #'W',D3
000028C8  6100 16A4               2585              BSR     PUSH_STACK
000028CC                          2586  
000028CC                          2587              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028CC  13FC 0000 000048F8      2588              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028D4  13FC 0000 000048F9      2589              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028DC                          2590             
000028DC                          2591              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028DC  13FC 00B9 000048FB      2592              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028E4  13FC 0020 000048FC      2593              MOVE.B   #$20,GET_SRC_START_END
000028EC                          2594  
000028EC                          2595             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028EC  0285 0000FE3F           2596              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028F2  0685 00000000           2597              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028F8                          2598  
000028F8                          2599              
000028F8  6100 0DD6               2600              BSR     GET_EA_EA_SRC      *GETS <ea>
000028FC  163C 002C               2601              MOVE.B  #',',D3
00002900  6100 166C               2602              BSR     PUSH_STACK
00002904  6100 11FA               2603              BSR     GET_EA_EA_DEST       *GETS Dn    
00002908                          2604              
00002908  6000 004A               2605              BRA     OP1100_MULS_RETURN
0000290C                          2606  OP1100_PRINT_L_MULS 
0000290C  163C 004C               2607              MOVE.B  #'L',D3
00002910  6100 165C               2608              BSR     PUSH_STACK
00002914                          2609              
00002914                          2610              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002914  13FC 0000 000048F8      2611              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000291C  13FC 0000 000048F9      2612              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002924                          2613             
00002924                          2614              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002924  13FC 00B9 000048FB      2615              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000292C  13FC 0020 000048FC      2616              MOVE.B   #$20,GET_SRC_START_END
00002934                          2617  
00002934                          2618              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002934  0285 0000FE3F           2619              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000293A  0685 00000000           2620              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002940                          2621  
00002940                          2622                     
00002940  6100 0D8E               2623              BSR     GET_EA_EA_SRC      *GETS <ea>
00002944  163C 002C               2624              MOVE.B  #',',D3
00002948  6100 1624               2625              BSR     PUSH_STACK                  
0000294C  6100 11B2               2626              BSR     GET_EA_EA_DEST       *GETS Dn    
00002950                          2627  
00002950                          2628              
00002950  6000 0002               2629              BRA     OP1100_MULS_RETURN
00002954                          2630              
00002954                          2631  OP1100_MULS_RETURN
00002954  4E75                    2632              RTS
00002956                          2633              
00002956                          2634  
00002956                          2635  
00002956                          2636  
00002956                          2637  
00002956                          2638  
00002956                          2639  
00002956                          2640  
00002956                          2641  
00002956                          2642  
00002956                          2643  
00002956                          2644  
00002956                          2645  
00002956                          2646  OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002956                          2647              *LOAD STACK WITH THIS OPMODE
00002956  4283                    2648              CLR.L   D3
00002958  6100 1614               2649              BSR     PUSH_STACK
0000295C  163C 0041               2650              MOVE.B  #'A',D3
00002960  6100 160C               2651              BSR     PUSH_STACK
00002964  163C 004E               2652              MOVE.B  #'N',D3
00002968  6100 1604               2653              BSR     PUSH_STACK
0000296C  163C 0044               2654              MOVE.B  #'D',D3
00002970  6100 15FC               2655              BSR     PUSH_STACK
00002974  163C 002E               2656              MOVE.B  #'.',D3
00002978  6100 15F4               2657              BSR     PUSH_STACK
0000297C                          2658              
0000297C  2205                    2659              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000297E                          2660              
0000297E                          2661              *BITS (INDEX 8) 
0000297E                          2662              *0 = ADD.B/W/L <EA>,Dn
0000297E                          2663              *1 = ADD.B/W/L Dn,<EA> 
0000297E  E099                    2664              ROR.L   #8,D1
00002980  0281 00000001           2665              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002986  0C81 00000000           2666              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000298C  6700 0102               2667              BEQ     OP1100_EA_DN
00002990                          2668              *else procede to Dn_EA
00002990                          2669              
00002990                          2670  OP1100_DN_EA
00002990                          2671              *BITS (7 TO 6) 
00002990                          2672              *00 = .B
00002990                          2673              *01 = .W
00002990                          2674              *10 = .L 
00002990  2205                    2675              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002992  EC99                    2676              ROR.L   #6,D1
00002994  0281 00000003           2677              ANDI.L  #$03,D1
0000299A  0C81 00000000           2678              CMPI.L  #$00,D1 *EQUALS .B
000029A0  6700 0016               2679              BEQ     OP1100_PRINT_B2
000029A4  0C81 00000001           2680              CMPI.L  #$01,D1 *EQUALS .W
000029AA  6700 0054               2681              BEQ     OP1100_PRINT_W2
000029AE  0C81 00000002           2682              CMPI.L  #$02,D1 *EQUALS .L
000029B4  6700 0092               2683              BEQ     OP1100_PRINT_L2
000029B8                          2684  OP1100_PRINT_B2
000029B8                          2685              *PUSH 'B'
000029B8  163C 0042               2686              MOVE.B  #'B',D3
000029BC  6100 15B0               2687              BSR     PUSH_STACK
000029C0                          2688             
000029C0                          2689              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000029C0  13FC 0000 000048F8      2690             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000029C8  13FC 0083 000048F9      2691             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000029D0                          2692             
000029D0                          2693             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000029D0  13FC 00B9 000048FB      2694             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029D8  13FC 0020 000048FC      2695             MOVE.B   #$20,GET_SRC_START_END
000029E0                          2696  
000029E0                          2697              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029E0  0285 0000FE3F           2698              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029E6  0685 00000000           2699              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029EC                          2700       
000029EC  6100 1112               2701              BSR     GET_EA_EA_DEST      *GETS Dn
000029F0  163C 002C               2702              MOVE.B  #',',D3
000029F4  6100 1578               2703              BSR     PUSH_STACK                     
000029F8  6100 0CD6               2704              BSR     GET_EA_EA_SRC       *GETS <ea>
000029FC                          2705  
000029FC                          2706              
000029FC  6000 0192               2707              BRA     OP1100_AND_RETURN
00002A00                          2708  OP1100_PRINT_W2
00002A00  163C 0057               2709              MOVE.B  #'W',D3
00002A04  6100 1568               2710              BSR     PUSH_STACK
00002A08                          2711  
00002A08                          2712              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A08  13FC 0000 000048F8      2713              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A10  13FC 0083 000048F9      2714              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A18                          2715             
00002A18                          2716              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A18  13FC 00B9 000048FB      2717              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A20  13FC 0020 000048FC      2718              MOVE.B   #$20,GET_SRC_START_END
00002A28                          2719  
00002A28                          2720              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A28  0285 0000FE3F           2721              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A2E  0685 00000000           2722              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002A34                          2723  
00002A34                          2724        
00002A34  6100 10CA               2725              BSR     GET_EA_EA_DEST      *GETS Dn
00002A38  163C 002C               2726              MOVE.B  #',',D3
00002A3C  6100 1530               2727              BSR     PUSH_STACK               
00002A40  6100 0C8E               2728              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002A44                          2729  
00002A44                          2730  
00002A44                          2731  
00002A44  6000 049A               2732              BRA     OP1101_ADD_RETURN
00002A48                          2733  OP1100_PRINT_L2 
00002A48  163C 004C               2734              MOVE.B  #'L',D3
00002A4C  6100 1520               2735              BSR     PUSH_STACK
00002A50                          2736              
00002A50                          2737              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A50  13FC 0000 000048F8      2738              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A58  13FC 0083 000048F9      2739              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A60                          2740             
00002A60                          2741              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A60  13FC 00B9 000048FB      2742              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A68  13FC 0020 000048FC      2743              MOVE.B   #$20,GET_SRC_START_END
00002A70                          2744  
00002A70                          2745             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A70  0285 0000FE3F           2746              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A76  0685 00000000           2747              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A7C                          2748  
00002A7C                          2749               
00002A7C  6100 1082               2750              BSR     GET_EA_EA_DEST       *GETS Dn
00002A80  163C 002C               2751              MOVE.B  #',',D3
00002A84  6100 14E8               2752              BSR     PUSH_STACK          
00002A88  6100 0C46               2753              BSR     GET_EA_EA_SRC        *GETS <ea>
00002A8C                          2754  
00002A8C  6000 0102               2755              BRA     OP1100_AND_RETURN
00002A90                          2756              
00002A90                          2757  OP1100_EA_DN           
00002A90                          2758              *BITS (7 TO 6) 
00002A90                          2759              *00 = .B
00002A90                          2760              *01 = .W
00002A90                          2761              *10 = .L 
00002A90  2205                    2762              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002A92  EC99                    2763              ROR.L   #6,D1
00002A94  0281 00000003           2764              ANDI.L  #$03,D1
00002A9A  0C81 00000000           2765              CMPI.L  #$00,D1 *EQUALS .B
00002AA0  6700 0016               2766              BEQ     OP1100_PRINT_B
00002AA4  0C81 00000001           2767              CMPI.L  #$01,D1 *EQUALS .W
00002AAA  6700 0054               2768              BEQ     OP1100_PRINT_W
00002AAE  0C81 00000002           2769              CMPI.L  #$02,D1 *EQUALS .L
00002AB4  6700 0092               2770              BEQ     OP1100_PRINT_L
00002AB8                          2771  OP1100_PRINT_B
00002AB8  163C 0042               2772              MOVE.B  #'B',D3
00002ABC  6100 14B0               2773              BSR     PUSH_STACK
00002AC0                          2774                
00002AC0                          2775              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AC0  13FC 0000 000048F8      2776              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AC8  13FC 0002 000048F9      2777              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AD0                          2778             
00002AD0                          2779              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AD0  13FC 00B9 000048FB      2780              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AD8  13FC 0020 000048FC      2781              MOVE.B   #$20,GET_SRC_START_END
00002AE0                          2782  
00002AE0                          2783             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AE0  0285 0000FE3F           2784              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AE6  0685 00000000           2785              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002AEC                          2786  
00002AEC                          2787              
00002AEC  6100 0BE2               2788              BSR     GET_EA_EA_SRC      *GETS <ea>
00002AF0  163C 002C               2789              MOVE.B  #',',D3
00002AF4  6100 1478               2790              BSR     PUSH_STACK          
00002AF8  6100 1006               2791              BSR     GET_EA_EA_DEST       *GETS Dn
00002AFC                          2792              
00002AFC  6000 03E2               2793              BRA     OP1101_ADD_RETURN
00002B00                          2794  OP1100_PRINT_W
00002B00  163C 0057               2795              MOVE.B  #'W',D3
00002B04  6100 1468               2796              BSR     PUSH_STACK
00002B08                          2797  
00002B08                          2798              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B08  13FC 0000 000048F8      2799              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B10  13FC 0002 000048F9      2800              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B18                          2801             
00002B18                          2802              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B18  13FC 00B9 000048FB      2803              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B20  13FC 0020 000048FC      2804              MOVE.B   #$20,GET_SRC_START_END
00002B28                          2805  
00002B28                          2806             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B28  0285 0000FE3F           2807              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B2E  0685 00000000           2808              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B34                          2809  
00002B34                          2810              
00002B34  6100 0B9A               2811              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B38  163C 002C               2812              MOVE.B  #',',D3
00002B3C  6100 1430               2813              BSR     PUSH_STACK
00002B40  6100 0FBE               2814              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B44                          2815              
00002B44  6000 F988               2816              BRA     OP1001_ADD_RETURN
00002B48                          2817  OP1100_PRINT_L 
00002B48  163C 004C               2818              MOVE.B  #'L',D3
00002B4C  6100 1420               2819              BSR     PUSH_STACK
00002B50                          2820              
00002B50                          2821              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B50  13FC 0000 000048F8      2822              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B58  13FC 0002 000048F9      2823              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B60                          2824             
00002B60                          2825              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B60  13FC 00B9 000048FB      2826              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B68  13FC 0020 000048FC      2827              MOVE.B   #$20,GET_SRC_START_END
00002B70                          2828  
00002B70                          2829              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B70  0285 0000FE3F           2830              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B76  0685 00000000           2831              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B7C                          2832  
00002B7C                          2833                     
00002B7C  6100 0B52               2834              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B80  163C 002C               2835              MOVE.B  #',',D3
00002B84  6100 13E8               2836              BSR     PUSH_STACK                  
00002B88  6100 0F76               2837              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B8C                          2838  
00002B8C                          2839              
00002B8C  6000 0002               2840              BRA     OP1100_AND_RETURN
00002B90                          2841              
00002B90                          2842  OP1100_AND_RETURN
00002B90  4E75                    2843              RTS
00002B92                          2844  
00002B92                          2845  
00002B92                          2846  *---------------------------------------------------------------------------*
00002B92                          2847  * OP1101: Decode ADD/ADDA
00002B92                          2848  *---------------------------------------------------------------------------* 
00002B92  4280                    2849  OP1101      CLR.L   D0                  
00002B94  4281                    2850              CLR.L   D1       
00002B96  4284                    2851              CLR.L   D4                   
00002B98  227C 00000000           2852              MOVEA.L #0, A1              
00002B9E  2205                    2853              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002BA0                          2854              
00002BA0                          2855              *CLEAR D3
00002BA0  4283                    2856              CLR.L   D3
00002BA2                          2857              
00002BA2                          2858              
00002BA2                          2859              
00002BA2                          2860              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002BA2  2205                    2861              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002BA4                          2862              *BITS (INDEX 8) 
00002BA4                          2863              *0 = ADD.B/W/L <EA>,Dn
00002BA4                          2864              *1 = ADD.B/W/L Dn,<EA> 
00002BA4  EC99                    2865              ROR.L   #6,D1
00002BA6  0281 00000007           2866              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002BAC  0C81 00000007           2867              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002BB2  6700 0010               2868              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002BB6  0C81 00000003           2869              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002BBC  6700 0078               2870              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002BC0  6000 00E6               2871              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002BC4                          2872              
00002BC4                          2873  OP1101_ADDA_L
00002BC4                          2874              *LOAD STACK WITH THIS OPMODE
00002BC4  6100 13A8               2875              BSR     PUSH_STACK
00002BC8  163C 0041               2876              MOVE.B  #'A',D3
00002BCC  6100 13A0               2877              BSR     PUSH_STACK
00002BD0  163C 0044               2878              MOVE.B  #'D',D3
00002BD4  6100 1398               2879              BSR     PUSH_STACK
00002BD8  163C 0044               2880              MOVE.B  #'D',D3
00002BDC  6100 1390               2881              BSR     PUSH_STACK
00002BE0  163C 0041               2882              MOVE.B  #'A',D3
00002BE4  6100 1388               2883              BSR     PUSH_STACK
00002BE8  163C 002E               2884              MOVE.B  #'.',D3
00002BEC  6100 1380               2885              BSR     PUSH_STACK
00002BF0  163C 004C               2886              MOVE.B  #'L',D3
00002BF4  6100 1378               2887              BSR     PUSH_STACK
00002BF8                          2888              
00002BF8                          2889             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BF8  13FC 0000 000048F8      2890             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C00  13FC 0000 000048F9      2891             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C08                          2892             
00002C08                          2893             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C08  13FC 00B9 000048FB      2894             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C10  13FC 0020 000048FC      2895             MOVE.B   #$20,GET_SRC_START_END
00002C18                          2896  
00002C18                          2897              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C18  0285 0000FE3F           2898              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C1E  0685 00000040           2899              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C24                          2900       
00002C24                          2901              *PRINT <EA>,AN
00002C24  6100 0AAA               2902              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C28  163C 002C               2903              MOVE.B  #',',D3
00002C2C  6100 1340               2904              BSR     PUSH_STACK                     
00002C30  6100 0ECE               2905              BSR     GET_EA_EA_DEST      *GETS Dn
00002C34                          2906  
00002C34                          2907              
00002C34                          2908              
00002C34  4E75                    2909              RTS
00002C36                          2910  OP1101_ADDA_W
00002C36                          2911              *LOAD STACK WITH THIS OPMODE
00002C36  6100 1336               2912              BSR     PUSH_STACK
00002C3A  163C 0041               2913              MOVE.B  #'A',D3
00002C3E  6100 132E               2914              BSR     PUSH_STACK
00002C42  163C 0044               2915              MOVE.B  #'D',D3
00002C46  6100 1326               2916              BSR     PUSH_STACK
00002C4A  163C 0044               2917              MOVE.B  #'D',D3
00002C4E  6100 131E               2918              BSR     PUSH_STACK
00002C52  163C 0041               2919              MOVE.B  #'A',D3
00002C56  6100 1316               2920              BSR     PUSH_STACK
00002C5A  163C 002E               2921              MOVE.B  #'.',D3
00002C5E  6100 130E               2922              BSR     PUSH_STACK
00002C62  163C 0057               2923              MOVE.B  #'W',D3
00002C66  6100 1306               2924              BSR     PUSH_STACK
00002C6A                          2925              
00002C6A                          2926             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C6A  13FC 0000 000048F8      2927             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C72  13FC 0000 000048F9      2928             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C7A                          2929             
00002C7A                          2930             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C7A  13FC 00B9 000048FB      2931             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C82  13FC 0020 000048FC      2932             MOVE.B   #$20,GET_SRC_START_END
00002C8A                          2933  
00002C8A                          2934              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C8A  0285 0000FE3F           2935              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C90  0685 00000040           2936              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C96                          2937       
00002C96                          2938              *PRINT <EA>,AN
00002C96  6100 0A38               2939              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C9A  163C 002C               2940              MOVE.B  #',',D3
00002C9E  6100 12CE               2941              BSR     PUSH_STACK                     
00002CA2  6100 0E5C               2942              BSR     GET_EA_EA_DEST      *GETS Dn
00002CA6                          2943  
00002CA6  4E75                    2944              RTS
00002CA8                          2945  
00002CA8                          2946  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002CA8                          2947              *LOAD STACK WITH THIS OPMODE
00002CA8  6100 12C4               2948              BSR     PUSH_STACK
00002CAC  163C 0041               2949              MOVE.B  #'A',D3
00002CB0  6100 12BC               2950              BSR     PUSH_STACK
00002CB4  163C 0044               2951              MOVE.B  #'D',D3
00002CB8  6100 12B4               2952              BSR     PUSH_STACK
00002CBC  163C 0044               2953              MOVE.B  #'D',D3
00002CC0  6100 12AC               2954              BSR     PUSH_STACK
00002CC4  163C 002E               2955              MOVE.B  #'.',D3
00002CC8  6100 12A4               2956              BSR     PUSH_STACK
00002CCC                          2957              
00002CCC  2205                    2958              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002CCE                          2959              
00002CCE                          2960              *BITS (INDEX 8) 
00002CCE                          2961              *0 = ADD.B/W/L <EA>,Dn
00002CCE                          2962              *1 = ADD.B/W/L Dn,<EA> 
00002CCE  E099                    2963              ROR.L   #8,D1
00002CD0  0281 00000001           2964              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002CD6  0C81 00000000           2965              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002CDC  6700 0102               2966              BEQ     OP1101_EA_DN
00002CE0                          2967              *else procede to Dn_EA
00002CE0                          2968              
00002CE0                          2969  OP1101_DN_EA
00002CE0                          2970              *BITS (7 TO 6) 
00002CE0                          2971              *00 = .B
00002CE0                          2972              *01 = .W
00002CE0                          2973              *10 = .L 
00002CE0  2205                    2974              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002CE2  EC99                    2975              ROR.L   #6,D1
00002CE4  0281 00000003           2976              ANDI.L  #$03,D1
00002CEA  0C81 00000000           2977              CMPI.L  #$00,D1 *EQUALS .B
00002CF0  6700 0016               2978              BEQ     OP1101_PRINT_B2
00002CF4  0C81 00000001           2979              CMPI.L  #$01,D1 *EQUALS .W
00002CFA  6700 0054               2980              BEQ     OP1101_PRINT_W2
00002CFE  0C81 00000002           2981              CMPI.L  #$02,D1 *EQUALS .L
00002D04  6700 0092               2982              BEQ     OP1101_PRINT_L2
00002D08                          2983  OP1101_PRINT_B2
00002D08                          2984              *PUSH 'B'
00002D08  163C 0042               2985              MOVE.B  #'B',D3
00002D0C  6100 1260               2986              BSR     PUSH_STACK
00002D10                          2987             
00002D10                          2988              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D10  13FC 0002 000048F8      2989             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D18  13FC 0083 000048F9      2990             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D20                          2991             
00002D20                          2992             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D20  13FC 00B9 000048FB      2993             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D28  13FC 0020 000048FC      2994             MOVE.B   #$20,GET_SRC_START_END
00002D30                          2995  
00002D30                          2996              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D30  0285 0000FE3F           2997              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D36  0685 00000000           2998              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D3C                          2999       
00002D3C  6100 0DC2               3000              BSR     GET_EA_EA_DEST      *GETS Dn
00002D40  163C 002C               3001              MOVE.B  #',',D3
00002D44  6100 1228               3002              BSR     PUSH_STACK                     
00002D48  6100 0986               3003              BSR     GET_EA_EA_SRC       *GETS <ea>
00002D4C                          3004  
00002D4C                          3005              
00002D4C  6000 0192               3006              BRA     OP1101_ADD_RETURN
00002D50                          3007  OP1101_PRINT_W2
00002D50  163C 0057               3008              MOVE.B  #'W',D3
00002D54  6100 1218               3009              BSR     PUSH_STACK
00002D58                          3010  
00002D58                          3011              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D58  13FC 0000 000048F8      3012              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D60  13FC 0083 000048F9      3013              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D68                          3014             
00002D68                          3015              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D68  13FC 00B9 000048FB      3016              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D70  13FC 0020 000048FC      3017              MOVE.B   #$20,GET_SRC_START_END
00002D78                          3018  
00002D78                          3019              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D78  0285 0000FE3F           3020              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D7E  0685 00000000           3021              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D84                          3022  
00002D84                          3023        
00002D84  6100 0D7A               3024              BSR     GET_EA_EA_DEST      *GETS Dn
00002D88  163C 002C               3025              MOVE.B  #',',D3
00002D8C  6100 11E0               3026              BSR     PUSH_STACK               
00002D90  6100 093E               3027              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002D94                          3028  
00002D94                          3029  
00002D94                          3030  
00002D94  6000 014A               3031              BRA     OP1101_ADD_RETURN
00002D98                          3032  OP1101_PRINT_L2 
00002D98  163C 004C               3033              MOVE.B  #'L',D3
00002D9C  6100 11D0               3034              BSR     PUSH_STACK
00002DA0                          3035              
00002DA0                          3036              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DA0  13FC 0000 000048F8      3037              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DA8  13FC 0083 000048F9      3038              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DB0                          3039             
00002DB0                          3040              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DB0  13FC 00B9 000048FB      3041              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DB8  13FC 0020 000048FC      3042              MOVE.B   #$20,GET_SRC_START_END
00002DC0                          3043  
00002DC0                          3044             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DC0  0285 0000FE3F           3045              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DC6  0685 00000000           3046              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DCC                          3047  
00002DCC                          3048               
00002DCC  6100 0D32               3049              BSR     GET_EA_EA_DEST       *GETS Dn
00002DD0  163C 002C               3050              MOVE.B  #',',D3
00002DD4  6100 1198               3051              BSR     PUSH_STACK          
00002DD8  6100 08F6               3052              BSR     GET_EA_EA_SRC        *GETS <ea>
00002DDC                          3053  
00002DDC  6000 0102               3054              BRA     OP1101_ADD_RETURN
00002DE0                          3055              
00002DE0                          3056  OP1101_EA_DN           
00002DE0                          3057              *BITS (7 TO 6) 
00002DE0                          3058              *00 = .B
00002DE0                          3059              *01 = .W
00002DE0                          3060              *10 = .L 
00002DE0  2205                    3061              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002DE2  EC99                    3062              ROR.L   #6,D1
00002DE4  0281 00000003           3063              ANDI.L  #$03,D1
00002DEA  0C81 00000000           3064              CMPI.L  #$00,D1 *EQUALS .B
00002DF0  6700 0016               3065              BEQ     OP1101_PRINT_B
00002DF4  0C81 00000001           3066              CMPI.L  #$01,D1 *EQUALS .W
00002DFA  6700 0054               3067              BEQ     OP1101_PRINT_W
00002DFE  0C81 00000002           3068              CMPI.L  #$02,D1 *EQUALS .L
00002E04  6700 0092               3069              BEQ     OP1101_PRINT_L
00002E08                          3070  OP1101_PRINT_B
00002E08  163C 0042               3071              MOVE.B  #'B',D3
00002E0C  6100 1160               3072              BSR     PUSH_STACK
00002E10                          3073                
00002E10                          3074              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E10  13FC 0002 000048F8      3075              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E18  13FC 0002 000048F9      3076              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E20                          3077             
00002E20                          3078              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E20  13FC 00B9 000048FB      3079              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E28  13FC 0020 000048FC      3080              MOVE.B   #$20,GET_SRC_START_END
00002E30                          3081  
00002E30                          3082             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E30  0285 0000FE3F           3083              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E36  0685 00000000           3084              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E3C                          3085  
00002E3C                          3086              
00002E3C  6100 0892               3087              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E40  163C 002C               3088              MOVE.B  #',',D3
00002E44  6100 1128               3089              BSR     PUSH_STACK          
00002E48  6100 0CB6               3090              BSR     GET_EA_EA_DEST       *GETS Dn
00002E4C                          3091              
00002E4C  6000 0092               3092              BRA     OP1101_ADD_RETURN
00002E50                          3093  OP1101_PRINT_W
00002E50  163C 0057               3094              MOVE.B  #'W',D3
00002E54  6100 1118               3095              BSR     PUSH_STACK
00002E58                          3096  
00002E58                          3097              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E58  13FC 0000 000048F8      3098              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E60  13FC 0000 000048F9      3099              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E68                          3100             
00002E68                          3101              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E68  13FC 00B9 000048FB      3102              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E70  13FC 0020 000048FC      3103              MOVE.B   #$20,GET_SRC_START_END
00002E78                          3104  
00002E78                          3105             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E78  0285 0000FE3F           3106              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E7E  0685 00000000           3107              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E84                          3108  
00002E84                          3109              
00002E84  6100 084A               3110              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E88  163C 002C               3111              MOVE.B  #',',D3
00002E8C  6100 10E0               3112              BSR     PUSH_STACK
00002E90  6100 0C6E               3113              BSR     GET_EA_EA_DEST       *GETS Dn    
00002E94                          3114              
00002E94  6000 004A               3115              BRA     OP1101_ADD_RETURN
00002E98                          3116  OP1101_PRINT_L 
00002E98  163C 004C               3117              MOVE.B  #'L',D3
00002E9C  6100 10D0               3118              BSR     PUSH_STACK
00002EA0                          3119              
00002EA0                          3120              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002EA0  13FC 0000 000048F8      3121              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002EA8  13FC 0000 000048F9      3122              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002EB0                          3123             
00002EB0                          3124              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002EB0  13FC 00B9 000048FB      3125              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002EB8  13FC 0020 000048FC      3126              MOVE.B   #$20,GET_SRC_START_END
00002EC0                          3127  
00002EC0                          3128              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002EC0  0285 0000FE3F           3129              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EC6  0685 00000000           3130              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002ECC                          3131  
00002ECC                          3132                     
00002ECC  6100 0802               3133              BSR     GET_EA_EA_SRC      *GETS <ea>
00002ED0  163C 002C               3134              MOVE.B  #',',D3
00002ED4  6100 1098               3135              BSR     PUSH_STACK                  
00002ED8  6100 0C26               3136              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EDC                          3137  
00002EDC                          3138              
00002EDC  6000 0002               3139              BRA     OP1101_ADD_RETURN
00002EE0                          3140              
00002EE0                          3141  OP1101_ADD_RETURN
00002EE0  4E75                    3142              RTS
00002EE2                          3143              
00002EE2                          3144              *ADDW
00002EE2  0C01 0006               3145              CMPI.B  #$6,D1
00002EE6  6700 0056               3146              BEQ     OP_ADDA_W
00002EEA  0C01 000E               3147              CMPI.B  #$E,D1
00002EEE  6700 0066               3148              BEQ     OP_ADDA_L 
00002EF2                          3149  
00002EF2  4EF8 1750               3150              JMP     OP_DATA  
00002EF6                          3151            
00002EF6                          3152  *---------------------------------------------------------------------------*
00002EF6                          3153  * OP_ADD: display ADD and proceed to EA
00002EF6                          3154  *---------------------------------------------------------------------------*  
00002EF6  43F9 000047AF           3155  OP_ADD_B    LEA     DISP_ADD_B,A1
00002EFC  103C 000E               3156              MOVE.B  #14,D0
00002F00  4E4F                    3157              TRAP    #15
00002F02  183C 0000               3158              MOVE.B  #0,D4
00002F06  4EF9 00003280           3159              JMP     EA_GEN
00002F0C                          3160  
00002F0C  4E75                    3161              RTS
00002F0E                          3162  
00002F0E  43F9 000047B8           3163  OP_ADD_W    LEA     DISP_ADD_W,A1
00002F14  103C 000E               3164              MOVE.B  #14,D0
00002F18  4E4F                    3165              TRAP    #15
00002F1A  183C 0001               3166              MOVE.B  #1,D4
00002F1E  4EF9 00003280           3167              JMP     EA_GEN
00002F24                          3168  
00002F24  4E75                    3169              RTS
00002F26                          3170  
00002F26  43F9 000047C1           3171  OP_ADD_L    LEA     DISP_ADD_L,A1
00002F2C  103C 000E               3172              MOVE.B  #14,D0
00002F30  4E4F                    3173              TRAP    #15
00002F32  183C 0002               3174              MOVE.B  #2,D4
00002F36  4EF9 00003280           3175              JMP     EA_GEN
00002F3C                          3176  
00002F3C  4E75                    3177              RTS
00002F3E                          3178  
00002F3E                          3179  *---------------------------------------------------------------------------*
00002F3E                          3180  * OP_ADDA: display ADDA and proceed to EA
00002F3E                          3181  *---------------------------------------------------------------------------*  
00002F3E  43F9 000047CA           3182  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002F44  103C 000E               3183              MOVE.B  #14,D0
00002F48  4E4F                    3184              TRAP    #15
00002F4A  183C 0001               3185              MOVE.B  #1,D4
00002F4E  4EF9 00003280           3186              JMP     EA_GEN
00002F54                          3187  
00002F54  4E75                    3188              RTS
00002F56                          3189  
00002F56  43F9 000047D4           3190  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002F5C  103C 000E               3191              MOVE.B  #14,D0
00002F60  4E4F                    3192              TRAP    #15
00002F62  183C 0002               3193              MOVE.B  #2,D4
00002F66  4EF9 00003280           3194              JMP     EA_GEN
00002F6C                          3195  
00002F6C  4E75                    3196              RTS
00002F6E                          3197              
00002F6E                          3198  *---------------------------------------------------------------------------*
00002F6E                          3199  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002F6E                          3200  *---------------------------------------------------------------------------* 
00002F6E  4280                    3201  OP1110      CLR.L   D0                  
00002F70  4281                    3202              CLR.L   D1   
00002F72  4284                    3203              CLR.L   D4                   
00002F74  227C 00000000           3204              MOVEA.L #0, A1                 
00002F7A  2205                    3205              MOVE.L  D5,D1
00002F7C                          3206              
00002F7C                          3207              * check for LSX
00002F7C  E699                    3208              ROR.L   #3,D1
00002F7E  0281 00000001           3209              ANDI.L  #$1,D1
00002F84  0C01 0001               3210              CMPI.B  #1,D1
00002F88  6700 002E               3211              BEQ     OP_LSX
00002F8C                          3212              
00002F8C                          3213              * reset D1 and check for ASX
00002F8C  4281                    3214              CLR.L   D1
00002F8E  2205                    3215              MOVE.L  D5,D1
00002F90  E699                    3216              ROR.L   #3,D1
00002F92  0281 00000001           3217              ANDI.L  #$1,D1
00002F98  0C01 0000               3218              CMPI.B  #0,D1
00002F9C  6700 0032               3219              BEQ     OP_ASX
00002FA0                          3220  
00002FA0                          3221              * reset D1 and check for ROX
00002FA0  4281                    3222              CLR.L   D1
00002FA2  2205                    3223              MOVE.L  D5,D1
00002FA4  E699                    3224              ROR.L   #3,D1
00002FA6  0281 00000001           3225              ANDI.L  #$1,D1
00002FAC  0C01 0003               3226              CMPI.B  #3,D1
00002FB0  6700 0036               3227              BEQ     OP_ROX
00002FB4                          3228              
00002FB4  4EF8 1750               3229              JMP     OP_DATA
00002FB8                          3230  
00002FB8                          3231  *---------------------------------------------------------------------------*
00002FB8                          3232  * OP_LSX: process LSR/LSL
00002FB8                          3233  *---------------------------------------------------------------------------*            
00002FB8  EA99                    3234  OP_LSX      ROR.L   #5,D1
00002FBA  0281 00000001           3235              ANDI.L  #$1,D1
00002FC0  0C01 0000               3236              CMPI.B  #0,D1
00002FC4  6700 003A               3237              BEQ     OP_LSR
00002FC8  0C01 0001               3238              CMPI.B  #1,D1
00002FCC  6700 008C               3239              BEQ     OP_LSL
00002FD0                          3240              
00002FD0                          3241  *---------------------------------------------------------------------------*
00002FD0                          3242  * OP_ASX: process ASR/ASL
00002FD0                          3243  *---------------------------------------------------------------------------*  
00002FD0  EA99                    3244  OP_ASX      ROR.L   #5,D1
00002FD2  0281 00000001           3245              ANDI.L  #$1,D1
00002FD8  0C01 0000               3246              CMPI.B  #0,D1
00002FDC  6700 00D6               3247              BEQ     OP_ASR
00002FE0  0C01 0001               3248              CMPI.B  #1,D1
00002FE4  6700 0128               3249              BEQ     OP_ASL
00002FE8                          3250              
00002FE8                          3251  *---------------------------------------------------------------------------*
00002FE8                          3252  * OP_ROX: process ROR/ROL
00002FE8                          3253  *---------------------------------------------------------------------------*  
00002FE8  EA99                    3254  OP_ROX      ROR.L   #5,D1
00002FEA  0281 00000001           3255              ANDI.L  #$1,D1
00002FF0  0C01 0000               3256              CMPI.B  #0,D1
00002FF4  6700 0172               3257              BEQ     OP_ROR
00002FF8  0C01 0001               3258              CMPI.B  #1,D1
00002FFC  6700 01C4               3259              BEQ     OP_ROL
00003000                          3260  
00003000                          3261  *---------------------------------------------------------------------------*
00003000                          3262  * OP_LSR: decode and display LSR
00003000                          3263  *---------------------------------------------------------------------------*        
00003000  E599                    3264  OP_LSR      ROL.L   #2,D1
00003002  0281 00000003           3265              ANDI.L  #$3,D1
00003008  0C01 0000               3266              CMPI.B  #0,D1
0000300C  6700 0016               3267              BEQ     OP_LSR_B
00003010  0C01 0001               3268              CMPI.B  #$1,D1
00003014  6700 0032               3269              BEQ     OP_LSR_W
00003018  0C01 0002               3270              CMPI.B  #$2,D1
0000301C  6700 0018               3271              BEQ     OP_LSR_L
00003020                          3272              
00003020  4EF8 1750               3273              JMP     OP_DATA
00003024                          3274  
00003024  43F9 000047DE           3275  OP_LSR_B    LEA     DISP_LSR_B,A1
0000302A  103C 000E               3276              MOVE.B  #14,D0
0000302E  4E4F                    3277              TRAP    #15
00003030  183C 0000               3278              MOVE.B  #0,D4
00003034  4E75                    3279              RTS
00003036                          3280  
00003036  43F9 00004802           3281  OP_LSR_L    LEA     DISP_LSR_L,A1
0000303C  103C 000E               3282              MOVE.B  #14,D0
00003040  4E4F                    3283              TRAP    #15
00003042  183C 0002               3284              MOVE.B  #2,D4
00003046  4E75                    3285              RTS
00003048                          3286  
00003048  43F9 000047F0           3287  OP_LSR_W    LEA     DISP_LSR_W,A1
0000304E  103C 000E               3288              MOVE.B  #14,D0
00003052  4E4F                    3289              TRAP    #15
00003054  183C 0001               3290              MOVE.B  #1,D4
00003058  4E75                    3291              RTS
0000305A                          3292   
0000305A                          3293  *---------------------------------------------------------------------------*
0000305A                          3294  * OP_LSL: decode and display LSL
0000305A                          3295  *---------------------------------------------------------------------------*             
0000305A  E599                    3296  OP_LSL      ROL.L   #2,D1
0000305C  0281 00000003           3297              ANDI.L  #$3,D1
00003062  0C01 0000               3298              CMPI.B  #0,D1
00003066  6700 0016               3299              BEQ     OP_LSL_B
0000306A  0C01 0001               3300              CMPI.B  #$1,D1
0000306E  6700 0032               3301              BEQ     OP_LSL_W
00003072  0C01 0002               3302              CMPI.B  #$2,D1
00003076  6700 0018               3303              BEQ     OP_LSL_L
0000307A                          3304              
0000307A  4EF8 1750               3305              JMP OP_DATA
0000307E                          3306  
0000307E  43F9 000047E7           3307  OP_LSL_B    LEA     DISP_LSL_B,A1
00003084  103C 000E               3308              MOVE.B  #14,D0
00003088  4E4F                    3309              TRAP    #15
0000308A  183C 0000               3310              MOVE.B  #0,D4
0000308E  4E75                    3311              RTS
00003090                          3312  
00003090  43F9 0000480B           3313  OP_LSL_L    LEA     DISP_LSL_L,A1
00003096  103C 000E               3314              MOVE.B  #14,D0
0000309A  4E4F                    3315              TRAP    #15
0000309C  183C 0002               3316              MOVE.B  #2,D4
000030A0  4E75                    3317              RTS
000030A2                          3318  
000030A2  43F9 000047F9           3319  OP_LSL_W    LEA     DISP_LSL_W,A1
000030A8  103C 000E               3320              MOVE.B  #14,D0
000030AC  4E4F                    3321              TRAP    #15
000030AE  183C 0001               3322              MOVE.B  #1,D4
000030B2  4E75                    3323              RTS
000030B4                          3324   
000030B4                          3325  *---------------------------------------------------------------------------*
000030B4                          3326  * OP_ASR: decode and display ASR
000030B4                          3327  *---------------------------------------------------------------------------*             
000030B4  E599                    3328  OP_ASR      ROL.L   #2,D1
000030B6  0281 00000003           3329              ANDI.L  #$3,D1
000030BC  0C01 0000               3330              CMPI.B  #0,D1
000030C0  6700 0016               3331              BEQ     OP_ASR_B
000030C4  0C01 0001               3332              CMPI.B  #$1,D1
000030C8  6700 0032               3333              BEQ     OP_ASR_W
000030CC  0C01 0002               3334              CMPI.B  #$2,D1
000030D0  6700 0018               3335              BEQ     OP_ASR_L
000030D4                          3336              
000030D4  4EF8 1750               3337              JMP OP_DATA
000030D8                          3338  
000030D8  43F9 00004814           3339  OP_ASR_B    LEA     DISP_ASR_B,A1
000030DE  103C 000E               3340              MOVE.B  #14,D0
000030E2  4E4F                    3341              TRAP    #15
000030E4  183C 0000               3342              MOVE.B  #0,D4
000030E8  4E75                    3343              RTS
000030EA                          3344  
000030EA  43F9 00004838           3345  OP_ASR_L    LEA     DISP_ASR_L,A1
000030F0  103C 000E               3346              MOVE.B  #14,D0
000030F4  4E4F                    3347              TRAP    #15
000030F6  183C 0002               3348              MOVE.B  #2,D4
000030FA  4E75                    3349              RTS
000030FC                          3350  
000030FC  43F9 00004826           3351  OP_ASR_W    LEA     DISP_ASR_W,A1
00003102  103C 000E               3352              MOVE.B  #14,D0
00003106  4E4F                    3353              TRAP    #15
00003108  183C 0001               3354              MOVE.B  #1,D4
0000310C  4E75                    3355              RTS
0000310E                          3356       
0000310E                          3357  *---------------------------------------------------------------------------*
0000310E                          3358  * OP_ASL: decode and display ASL
0000310E                          3359  *---------------------------------------------------------------------------*         
0000310E  E599                    3360  OP_ASL      ROL.L   #2,D1
00003110  0281 00000003           3361              ANDI.L  #$3,D1
00003116  0C01 0000               3362              CMPI.B  #0,D1
0000311A  6700 0016               3363              BEQ     OP_ASL_B
0000311E  0C01 0001               3364              CMPI.B  #$1,D1
00003122  6700 0032               3365              BEQ     OP_ASL_W
00003126  0C01 0002               3366              CMPI.B  #$2,D1
0000312A  6700 0018               3367              BEQ     OP_ASL_L
0000312E                          3368              
0000312E  4EF8 1750               3369              JMP OP_DATA
00003132                          3370  
00003132  43F9 0000481D           3371  OP_ASL_B    LEA     DISP_ASL_B,A1
00003138  103C 000E               3372              MOVE.B  #14,D0
0000313C  4E4F                    3373              TRAP    #15
0000313E  183C 0000               3374              MOVE.B  #0,D4
00003142  4E75                    3375              RTS
00003144                          3376  
00003144  43F9 00004841           3377  OP_ASL_L    LEA     DISP_ASL_L,A1
0000314A  103C 000E               3378              MOVE.B  #14,D0
0000314E  4E4F                    3379              TRAP    #15
00003150  183C 0002               3380              MOVE.B  #2,D4
00003154  4E75                    3381              RTS
00003156                          3382  
00003156  43F9 0000482F           3383  OP_ASL_W    LEA     DISP_ASL_W,A1
0000315C  103C 000E               3384              MOVE.B  #14,D0
00003160  4E4F                    3385              TRAP    #15
00003162  183C 0001               3386              MOVE.B  #1,D4
00003166  4E75                    3387              RTS
00003168                          3388   
00003168                          3389  *---------------------------------------------------------------------------*
00003168                          3390  * OP_ROR: decode and display ROR
00003168                          3391  *---------------------------------------------------------------------------*             
00003168  E599                    3392  OP_ROR      ROL.L   #2,D1
0000316A  0281 00000003           3393              ANDI.L  #$3,D1
00003170  0C01 0000               3394              CMPI.B  #0,D1
00003174  6700 0016               3395              BEQ     OP_ROR_B
00003178  0C01 0001               3396              CMPI.B  #$1,D1
0000317C  6700 0032               3397              BEQ     OP_ROR_W
00003180  0C01 0002               3398              CMPI.B  #$2,D1
00003184  6700 0018               3399              BEQ     OP_ROR_L
00003188                          3400              
00003188  4EF8 1750               3401              JMP OP_DATA
0000318C                          3402  
0000318C  43F9 0000484A           3403  OP_ROR_B    LEA     DISP_ROR_B,A1
00003192  103C 000E               3404              MOVE.B  #14,D0
00003196  4E4F                    3405              TRAP    #15
00003198  183C 0000               3406              MOVE.B  #0,D4
0000319C  4E75                    3407              RTS
0000319E                          3408  
0000319E  43F9 0000486E           3409  OP_ROR_L    LEA     DISP_ROR_L,A1
000031A4  103C 000E               3410              MOVE.B  #14,D0
000031A8  4E4F                    3411              TRAP    #15
000031AA  183C 0002               3412              MOVE.B  #2,D4
000031AE  4E75                    3413              RTS
000031B0                          3414  
000031B0  43F9 0000485C           3415  OP_ROR_W    LEA     DISP_ROR_W,A1
000031B6  103C 000E               3416              MOVE.B  #14,D0
000031BA  4E4F                    3417              TRAP    #15
000031BC  183C 0001               3418              MOVE.B  #1,D4
000031C0  4E75                    3419              RTS
000031C2                          3420  
000031C2                          3421  *---------------------------------------------------------------------------*
000031C2                          3422  * OP_ROL: decode and display ROL
000031C2                          3423  *---------------------------------------------------------------------------*             
000031C2  E599                    3424  OP_ROL      ROL.L   #2,D1
000031C4  0281 00000003           3425              ANDI.L  #$3,D1
000031CA  0C01 0000               3426              CMPI.B  #0,D1
000031CE  6700 0016               3427              BEQ     OP_ROL_B
000031D2  0C01 0001               3428              CMPI.B  #$1,D1
000031D6  6700 0032               3429              BEQ     OP_ROL_W
000031DA  0C01 0002               3430              CMPI.B  #$2,D1
000031DE  6700 0018               3431              BEQ     OP_ROL_L
000031E2                          3432              
000031E2  4EF8 1750               3433              JMP OP_DATA
000031E6                          3434  
000031E6                          3435  
000031E6  43F9 00004853           3436  OP_ROL_B    LEA     DISP_ROL_B,A1
000031EC  103C 000E               3437              MOVE.B  #14,D0
000031F0  4E4F                    3438              TRAP    #15
000031F2  183C 0000               3439              MOVE.B  #0,D4
000031F6  4E75                    3440              RTS
000031F8                          3441  
000031F8  43F9 00004877           3442  OP_ROL_L    LEA     DISP_ROL_L,A1
000031FE  103C 000E               3443              MOVE.B  #14,D0
00003202  4E4F                    3444              TRAP    #15
00003204  183C 0002               3445              MOVE.B  #2,D4
00003208  4E75                    3446              RTS
0000320A                          3447  
0000320A  43F9 00004865           3448  OP_ROL_W    LEA     DISP_ROL_W,A1
00003210  103C 000E               3449              MOVE.B  #14,D0
00003214  4E4F                    3450              TRAP    #15
00003216  183C 0001               3451              MOVE.B  #1,D4
0000321A  4E75                    3452              RTS
0000321C                          3453              
0000321C                          3454  *---------------------------------------------------------------------------*
0000321C                          3455  * OP1111 : Special reserved
0000321C                          3456  *---------------------------------------------------------------------------*           
0000321C  4EF8 1750               3457  OP1111      JMP     OP_DATA
00003220                          3458  
00003220                          3459  *---------------------------------------------------------------------------*
00003220                          3460  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00003220                          3461  *---------------------------------------------------------------------------*
00003220                          3462  EA_NOSRC    
00003220  4EB9 000032DE           3463              JSR     SRC_MODE
00003226  43F9 00004544           3464              LEA     ENDLINE_M,A1
0000322C  103C 000E               3465              MOVE.B  #14,D0
00003230  4E4F                    3466              TRAP    #15
00003232  4E75                    3467              RTS
00003234                          3468              
00003234                          3469  *---------------------------------------------------------------------------*
00003234                          3470  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00003234                          3471  *---------------------------------------------------------------------------*
00003234                          3472  EA_ARITH
00003234  4EB9 000032DE           3473              JSR     SRC_MODE
0000323A  43F9 000048BE           3474              LEA     DISP_D,A1
00003240  103C 000E               3475              MOVE.B  #14,D0
00003244  4E4F                    3476              TRAP    #15
00003246  4EB9 0000356A           3477              JSR     DEST_REGISTER
0000324C  43F9 00004544           3478              LEA     ENDLINE_M,A1
00003252  103C 000E               3479              MOVE.B  #14,D0
00003256  4E4F                    3480              TRAP    #15
00003258  4E75                    3481              RTS
0000325A                          3482              
0000325A                          3483  *---------------------------------------------------------------------------*
0000325A                          3484  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
0000325A                          3485  *---------------------------------------------------------------------------*
0000325A                          3486  EA_MOVEA
0000325A  4EB9 000032DE           3487              JSR     SRC_MODE
00003260  43F9 000048CF           3488              LEA     DISP_AOP,A1
00003266  103C 000E               3489              MOVE.B  #14,D0
0000326A  4E4F                    3490              TRAP    #15
0000326C  4EB9 0000356A           3491              JSR     DEST_REGISTER
00003272  43F9 000048CD           3492              LEA     DISP_CP,A1
00003278  103C 000D               3493              MOVE.B  #13,D0
0000327C  4E4F                    3494              TRAP    #15
0000327E  4E75                    3495              RTS
00003280                          3496              
00003280                          3497  *---------------------------------------------------------------------------*
00003280                          3498  * EA_GEN: decode and display effective addresses for MOVE
00003280                          3499  *---------------------------------------------------------------------------*
00003280                          3500  EA_GEN          
00003280                          3501              * retrieve/display source mode/register
00003280  4EB9 000032DE           3502              JSR     SRC_MODE
00003286                          3503              
00003286                          3504              * retrieve/display destination mode/register
00003286  4EB9 0000329A           3505              JSR     DEST_MODE
0000328C                          3506              
0000328C  43F9 00004544           3507              LEA     ENDLINE_M,A1
00003292  103C 000E               3508              MOVE.B  #14,D0
00003296  4E4F                    3509              TRAP    #15
00003298                          3510              
00003298  4E75                    3511              RTS
0000329A                          3512  
0000329A                          3513  *---------------------------------------------------------------------------*
0000329A                          3514  * DEST_MODE: decode and display destination mode (bit 8 - 6)
0000329A                          3515  *---------------------------------------------------------------------------*           
0000329A                          3516  DEST_MODE   
0000329A                          3517              * clear registers to store temp data
0000329A  4280                    3518              CLR.L   D0                      
0000329C  4281                    3519              CLR.L   D1                      
0000329E  207C 00000000           3520              MOVEA.L #0, A0                  
000032A4  227C 00000000           3521              MOVEA.L #0, A1                  
000032AA  2205                    3522              MOVE.L  D5,D1
000032AC  EC89                    3523              LSR.L   #6,D1
000032AE  0281 00000007           3524              ANDI.L  #$7,D1
000032B4  0C01 0000               3525              CMPI.B  #0,D1   * Dn
000032B8  6700 0082               3526              BEQ     D_MODE000
000032BC  0C01 0002               3527              CMPI.B  #2,D1   * (An)
000032C0  6700 00C2               3528              BEQ     D_MODE010
000032C4  0C01 0003               3529              CMPI.B  #3,D1   * (An)+
000032C8  6700 011A               3530              BEQ     D_MODE011
000032CC  0C01 0004               3531              CMPI.B  #4,D1   * -(An)
000032D0  6700 0132               3532              BEQ     D_MODE100
000032D4  0C01 0007               3533              CMPI.B  #7,D1  * abs
000032D8  6700 017C               3534              BEQ     D_MODE111 
000032DC  4E75                    3535              RTS
000032DE                          3536  
000032DE                          3537  *---------------------------------------------------------------------------*
000032DE                          3538  * SRC_MODE: decode and display source mode (bit 5 - 3)
000032DE                          3539  *---------------------------------------------------------------------------*  
000032DE                          3540  SRC_MODE    
000032DE                          3541              * clear registers to store temp data
000032DE  4280                    3542              CLR.L   D0                      
000032E0  4281                    3543              CLR.L   D1                      
000032E2  207C 00000000           3544              MOVEA.L #0, A0                  
000032E8  227C 00000000           3545              MOVEA.L #0, A1                  
000032EE  2205                    3546              MOVE.L  D5,D1
000032F0  E489                    3547              LSR.L   #2,D1
000032F2  0281 0000000E           3548              ANDI.L  #$E,D1
000032F8                          3549              
000032F8  0C01 0000               3550              CMPI.B  #0,D1   * Dn
000032FC  6700 002A               3551              BEQ     MODE000
00003300  0C01 0002               3552              CMPI.B  #2,D1   * An 
00003304  6700 004A               3553              BEQ     MODE001
00003308  0C01 0004               3554              CMPI.B  #4,D1   * (An)
0000330C  6700 0056               3555              BEQ     MODE010
00003310  0C01 0006               3556              CMPI.B  #6,D1   * (An)+
00003314  6700 008E               3557              BEQ     MODE011
00003318  0C01 0008               3558              CMPI.B  #8,D1   * -(An)
0000331C  6700 00A6               3559              BEQ     MODE100
00003320  0C01 000F               3560              CMPI.B  #15,D1  * abs/immediate
00003324  6700 00FE               3561              BEQ     MODE111 
00003328                          3562        
00003328                          3563  *---------------------------------------------------------------------------*
00003328                          3564  * MODE000: decode and display source mode Dn
00003328                          3565  *---------------------------------------------------------------------------*           
00003328                          3566  MODE000     *Dn
00003328  43F9 000048BE           3567              LEA     DISP_D,A1
0000332E  103C 000E               3568              MOVE.B  #14,D0
00003332  4E4F                    3569              TRAP    #15
00003334  4EB9 000035C6           3570              JSR     SRC_REGISTER
0000333A  4E75                    3571              RTS
0000333C                          3572  
0000333C                          3573  *---------------------------------------------------------------------------*
0000333C                          3574  * D_MODE000: decode and display dest mode Dn
0000333C                          3575  *---------------------------------------------------------------------------*
0000333C                          3576  D_MODE000     *Dn
0000333C  43F9 000048BE           3577              LEA     DISP_D,A1
00003342  103C 000E               3578              MOVE.B  #14,D0
00003346  4E4F                    3579              TRAP    #15
00003348  4EB9 0000356A           3580              JSR     DEST_REGISTER
0000334E  4E75                    3581              RTS
00003350                          3582  
00003350                          3583  *---------------------------------------------------------------------------*
00003350                          3584  * MODE001: decode and display source mode An
00003350                          3585  *---------------------------------------------------------------------------* 
00003350                          3586  MODE001 *An
00003350  43F9 000048C3           3587              LEA     DISP_A,A1
00003356  103C 000E               3588              MOVE.B  #14,D0
0000335A  4E4F                    3589              TRAP    #15
0000335C  4EB9 000035C6           3590              JSR     SRC_REGISTER
00003362                          3591          
00003362  4E75                    3592              RTS
00003364                          3593  
00003364                          3594  *---------------------------------------------------------------------------*
00003364                          3595  * MODE010: decode and display source mode (An)
00003364                          3596  *---------------------------------------------------------------------------*    
00003364                          3597  MODE010 *(An)
00003364  43F9 000048CF           3598              LEA     DISP_AOP,A1  *display (A
0000336A  103C 000E               3599              MOVE.B  #14,D0
0000336E  4E4F                    3600              TRAP    #15
00003370                          3601  
00003370  4EB9 000035C6           3602              JSR     SRC_REGISTER * display register
00003376                          3603  
00003376  43F9 000048CD           3604              LEA     DISP_CP,A1   *display )
0000337C  103C 000E               3605              MOVE.B  #14,D0
00003380  4E4F                    3606              TRAP    #15
00003382                          3607              
00003382  4E75                    3608              RTS
00003384                          3609  
00003384                          3610  *---------------------------------------------------------------------------*
00003384                          3611  * D_MODE010: decode and display dest mode (An)
00003384                          3612  *---------------------------------------------------------------------------*
00003384                          3613  D_MODE010 *(An)
00003384  43F9 000048CF           3614              LEA     DISP_AOP,A1  *display (A
0000338A  103C 000E               3615              MOVE.B  #14,D0
0000338E  4E4F                    3616              TRAP    #15
00003390                          3617     
00003390  4EB9 0000356A           3618              JSR     DEST_REGISTER * display register
00003396                          3619  
00003396  43F9 000048CD           3620              LEA     DISP_CP,A1   *display )
0000339C  103C 000E               3621              MOVE.B  #14,D0
000033A0  4E4F                    3622              TRAP    #15
000033A2                          3623              
000033A2  4E75                    3624              RTS
000033A4                          3625  
000033A4                          3626  *---------------------------------------------------------------------------*
000033A4                          3627  * MODE011: decode and display source mode (An)+
000033A4                          3628  *---------------------------------------------------------------------------*
000033A4                          3629  MODE011 *(An)+
000033A4  43F9 000048CF           3630              LEA     DISP_AOP,A1      *display (A
000033AA  103C 000E               3631              MOVE.B  #14,D0
000033AE  4E4F                    3632              TRAP    #15
000033B0                          3633              
000033B0  4EB9 000035C6           3634              JSR     SRC_REGISTER    * display register
000033B6                          3635  
000033B6  43F9 000048DC           3636              LEA     DISP_POST,A1    *display )+
000033BC  103C 000E               3637              MOVE.B  #14,D0
000033C0  4E4F                    3638              TRAP    #15
000033C2                          3639              
000033C2  4E75                    3640              RTS
000033C4                          3641              
000033C4                          3642  *---------------------------------------------------------------------------*
000033C4                          3643  * MODE100: decode and display source mode -(An)
000033C4                          3644  *---------------------------------------------------------------------------*
000033C4                          3645  MODE100 *-(An)
000033C4  43F9 000048D5           3646              LEA     DISP_PRE,A1    *display -(A
000033CA  103C 000E               3647              MOVE.B  #14,D0
000033CE  4E4F                    3648              TRAP    #15
000033D0                          3649  
000033D0  4EB9 000035C6           3650              JSR     SRC_REGISTER    *display register
000033D6                          3651  
000033D6  43F9 000048CD           3652              LEA     DISP_CP,A1   *display )
000033DC  103C 000E               3653              MOVE.B  #14,D0
000033E0  4E4F                    3654              TRAP    #15
000033E2                          3655              
000033E2  4E75                    3656              RTS
000033E4                          3657  
000033E4                          3658  *---------------------------------------------------------------------------*
000033E4                          3659  * D_MODE011: decode and display dest mode (An)+
000033E4                          3660  *---------------------------------------------------------------------------*
000033E4                          3661  D_MODE011 *(An)+
000033E4  43F9 000048CF           3662              LEA     DISP_AOP,A1      *display (A
000033EA  103C 000E               3663              MOVE.B  #14,D0
000033EE  4E4F                    3664              TRAP    #15
000033F0                          3665  
000033F0  4EB9 0000356A           3666              JSR     DEST_REGISTER    * display register
000033F6                          3667  
000033F6  43F9 000048DC           3668              LEA     DISP_POST,A1    *display )+
000033FC  103C 000E               3669              MOVE.B  #14,D0
00003400  4E4F                    3670              TRAP    #15
00003402                          3671              
00003402  4E75                    3672              RTS
00003404                          3673              
00003404                          3674  *---------------------------------------------------------------------------*
00003404                          3675  * D_MODE100: decode and display dest mode -(An)
00003404                          3676  *---------------------------------------------------------------------------*            
00003404                          3677  D_MODE100 *-(An)
00003404  43F9 000048D5           3678              LEA     DISP_PRE,A1    *display -(A
0000340A  103C 000E               3679              MOVE.B  #14,D0
0000340E  4E4F                    3680              TRAP    #15
00003410                          3681              
00003410  4EB9 0000356A           3682              JSR     DEST_REGISTER    *display register
00003416                          3683  
00003416  43F9 000048CD           3684              LEA     DISP_CP,A1   *display )
0000341C  103C 000E               3685              MOVE.B  #14,D0
00003420  4E4F                    3686              TRAP    #15
00003422                          3687              
00003422  4E75                    3688              RTS
00003424                          3689  
00003424                          3690  *---------------------------------------------------------------------------*
00003424                          3691  * MODE111: decode and display source mode absolute/immediate
00003424                          3692  *---------------------------------------------------------------------------*
00003424                          3693  MODE111     * abs/immediate
00003424                          3694              * clear registers to store temp data
00003424  4280                    3695              CLR.L   D0                      
00003426  4281                    3696              CLR.L   D1                      
00003428  207C 00000000           3697              MOVEA.L #0, A0                  
0000342E  227C 00000000           3698              MOVEA.L #0, A1                  
00003434  2205                    3699              MOVE.L  D5,D1
00003436                          3700              
00003436                          3701              * retrieve source register for MODE 111
00003436  E389                    3702              LSL.L   #1,D1   * shift the bits to left by 1
00003438  0281 0000000E           3703              ANDI.L  #$E,D1  * mask the first 4 bits 
0000343E  0C01 0000               3704              CMPI.B  #0, D1  * if it's 0000, absolute word address
00003442  6700 003E               3705              BEQ     WORDMODE
00003446  0C01 0002               3706              CMPI.B  #2, D1  * if it's 0010, absolute long address
0000344A  6700 0062               3707              BEQ     LONGMODE
0000344E  0C01 0008               3708              CMPI.B  #8, D1  * if it's 1000, immediate data
00003452  6700 0086               3709              BEQ     IMMEDIATE
00003456                          3710       
00003456                          3711  *---------------------------------------------------------------------------*
00003456                          3712  * D_MODE111: decode and display dest mode absolute/immediate
00003456                          3713  *---------------------------------------------------------------------------*           
00003456                          3714  D_MODE111   * abs
00003456                          3715              * clear registers to store temp data
00003456  4280                    3716              CLR.L   D0                      
00003458  4281                    3717              CLR.L   D1                      
0000345A  207C 00000000           3718              MOVEA.L #0, A0                  
00003460  227C 00000000           3719              MOVEA.L #0, A1                  
00003466  2205                    3720              MOVE.L  D5,D1
00003468                          3721              
00003468                          3722              * retrieve dest register for MODE 111
00003468  EC89                    3723              LSR.L   #6,D1   * shift the bits to right by 6
0000346A  E689                    3724              LSR.L   #3,D1   * shift the bits to right by extra 3
0000346C  0201 0001               3725              ANDI.B  #1,D1   * mask the first 2 bits 
00003470  0C01 0000               3726              CMPI.B  #0, D1  * if it's 000, absolute word address
00003474  6700 000C               3727              BEQ     WORDMODE
00003478  0C01 0001               3728              CMPI.B  #1, D1  * if it's 001, absolute long address
0000347C  6700 0030               3729              BEQ     LONGMODE
00003480                          3730              *JSR     OP_DATA *not sure..
00003480  4E75                    3731              RTS
00003482                          3732  
00003482                          3733  
00003482                          3734  *---------------------------------------------------------------------------*
00003482                          3735  * WORDMODE: absolute word address
00003482                          3736  *---------------------------------------------------------------------------*
00003482  43F9 000048B9           3737  WORDMODE    LEA     DISP_HEX,A1
00003488  103C 000E               3738              MOVE.B  #14,D0
0000348C  4E4F                    3739              TRAP    #15
0000348E                          3740              
0000348E  4285                    3741              CLR.L   D5
00003490  3A1D                    3742              MOVE.W  (A5)+,D5
00003492                          3743              
00003492  43F9 00004597           3744              LEA     TMPOUTPUT,A1
00003498  2205                    3745              MOVE.L  D5,D1
0000349A  7404                    3746              MOVE.L  #4,D2       *move word size 4
0000349C  4EB8 121E               3747              JSR     HEX2ASCII
000034A0  43F9 00004597           3748              LEA     TMPOUTPUT,A1
000034A6  103C 000E               3749              MOVE.B  #14,D0
000034AA  4E4F                    3750              TRAP    #15
000034AC                          3751              
000034AC  4E75                    3752              RTS
000034AE                          3753  
000034AE                          3754  *---------------------------------------------------------------------------*
000034AE                          3755  * LONGMODE: absolute long address
000034AE                          3756  *---------------------------------------------------------------------------*
000034AE  43F9 000048B9           3757  LONGMODE    LEA     DISP_HEX,A1
000034B4  103C 000E               3758              MOVE.B  #14,D0
000034B8  4E4F                    3759              TRAP    #15
000034BA                          3760              
000034BA  4285                    3761              CLR.L   D5
000034BC  2A1D                    3762              MOVE.L  (A5)+,D5
000034BE                          3763              
000034BE  43F9 00004597           3764              LEA     TMPOUTPUT,A1
000034C4  2205                    3765              MOVE.L  D5,D1
000034C6  7408                    3766              MOVE.L  #8,D2           *move longword size 8
000034C8  4EB8 121E               3767              JSR     HEX2ASCII
000034CC  43F9 00004597           3768              LEA     TMPOUTPUT,A1
000034D2  103C 000E               3769              MOVE.B  #14,D0
000034D6  4E4F                    3770              TRAP    #15
000034D8                          3771              
000034D8  4E75                    3772              RTS
000034DA                          3773  
000034DA                          3774  
000034DA                          3775  *---------------------------------------------------------------------------*
000034DA                          3776  * IMMEDIATE: immediate address
000034DA                          3777  *---------------------------------------------------------------------------*
000034DA  43F9 000048DF           3778  IMMEDIATE   LEA     DISP_LB,A1
000034E0  103C 000E               3779              MOVE.B  #14,D0
000034E4  4E4F                    3780              TRAP    #15
000034E6  43F9 000048B9           3781              LEA     DISP_HEX,A1
000034EC  103C 000E               3782              MOVE.B  #14,D0
000034F0  4E4F                    3783              TRAP    #15
000034F2                          3784              
000034F2                          3785              * check for size
000034F2  0C04 0000               3786              CMPI.B  #0,D4
000034F6  6700 0012               3787              BEQ     IMMD_B
000034FA  0C04 0001               3788              CMPI.B  #1,D4
000034FE  6700 002A               3789              BEQ     IMMD_W
00003502  0C04 0002               3790              CMPI.B  #2,D4
00003506  6700 0042               3791              BEQ     IMMD_L
0000350A                          3792  
0000350A                          3793  IMMD_B
0000350A  4285                    3794              CLR.L   D5
0000350C  3A1D                    3795              MOVE.W  (A5)+,D5
0000350E                          3796              
0000350E  43F9 00004597           3797              LEA     TMPOUTPUT,A1
00003514  2205                    3798              MOVE.L  D5,D1
00003516  7402                    3799              MOVE.L  #2,D2
00003518  4EB8 121E               3800              JSR     HEX2ASCII
0000351C  43F9 00004597           3801              LEA     TMPOUTPUT,A1
00003522  103C 000E               3802              MOVE.B  #14,D0
00003526  4E4F                    3803              TRAP    #15
00003528  4E75                    3804              RTS
0000352A                          3805              
0000352A                          3806  IMMD_W
0000352A  4285                    3807              CLR.L   D5
0000352C  3A1D                    3808              MOVE.W  (A5)+,D5
0000352E                          3809              
0000352E  43F9 00004597           3810              LEA     TMPOUTPUT,A1
00003534  2205                    3811              MOVE.L  D5,D1
00003536  7404                    3812              MOVE.L  #4,D2
00003538  4EB8 121E               3813              JSR     HEX2ASCII
0000353C  43F9 00004597           3814              LEA     TMPOUTPUT,A1
00003542  103C 000E               3815              MOVE.B  #14,D0
00003546  4E4F                    3816              TRAP    #15
00003548  4E75                    3817              RTS
0000354A                          3818              
0000354A                          3819  
0000354A                          3820  IMMD_L
0000354A  4285                    3821              CLR.L   D5
0000354C  3A1D                    3822              MOVE.W  (A5)+,D5
0000354E                          3823              
0000354E  43F9 00004597           3824              LEA     TMPOUTPUT,A1
00003554  2205                    3825              MOVE.L  D5,D1
00003556  7408                    3826              MOVE.L  #8,D2
00003558  4EB8 121E               3827              JSR     HEX2ASCII
0000355C  43F9 00004597           3828              LEA     TMPOUTPUT,A1
00003562  103C 000E               3829              MOVE.B  #14,D0
00003566  4E4F                    3830              TRAP    #15
00003568  4E75                    3831              RTS
0000356A                          3832  
0000356A                          3833  
0000356A                          3834  *---------------------------------------------------------------------------*
0000356A                          3835  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
0000356A                          3836  *---------------------------------------------------------------------------*
0000356A                          3837  DEST_REGISTER
0000356A                          3838              * clear registers to store temp data
0000356A  4280                    3839              CLR.L   D0                      
0000356C  4281                    3840              CLR.L   D1                      
0000356E  207C 00000000           3841              MOVEA.L #0, A0                  
00003574  227C 00000000           3842              MOVEA.L #0, A1 
0000357A                          3843              
0000357A  2205                    3844              MOVE.L  D5,D1
0000357C  EC89                    3845              LSR.L   #6,D1
0000357E  E689                    3846              LSR.L   #3,D1
00003580  0281 00000007           3847              ANDI.L  #7,D1
00003586                          3848              
00003586  0C01 0000               3849              CMPI.B  #0,D1
0000358A  6700 0092               3850              BEQ     REG_0
0000358E  0C01 0001               3851              CMPI.B  #1,D1
00003592  6700 0098               3852              BEQ     REG_1
00003596  0C01 0002               3853              CMPI.B  #2,D1
0000359A  6700 009E               3854              BEQ     REG_2
0000359E  0C01 0003               3855              CMPI.B  #3,D1
000035A2  6700 00A4               3856              BEQ     REG_3
000035A6  0C01 0004               3857              CMPI.B  #4,D1
000035AA  6700 00AA               3858              BEQ     REG_4
000035AE  0C01 0005               3859              CMPI.B  #5,D1
000035B2  6700 00B0               3860              BEQ     REG_5
000035B6  0C01 0006               3861              CMPI.B  #6,D1
000035BA  6700 00B6               3862              BEQ     REG_6
000035BE  0C01 0007               3863              CMPI.B  #7,D1
000035C2  6700 00BC               3864              BEQ     REG_7
000035C6                          3865  
000035C6                          3866  *---------------------------------------------------------------------------*
000035C6                          3867  * SRC_REGISTER: decode and display source register (bit 2 - 0)
000035C6                          3868  *---------------------------------------------------------------------------*           
000035C6                          3869  SRC_REGISTER 
000035C6                          3870              * clear registers to store temp data
000035C6  4280                    3871              CLR.L   D0                      
000035C8  4281                    3872              CLR.L   D1                      
000035CA  207C 00000000           3873              MOVEA.L #0, A0                  
000035D0  227C 00000000           3874              MOVEA.L #0, A1                  
000035D6                          3875              
000035D6  2205                    3876              MOVE.L  D5,D1   * temp store the processing data
000035D8  0281 00000007           3877              ANDI.L  #7,D1   * mask the first 4 bits with 0111
000035DE                          3878              
000035DE  0C01 0000               3879              CMPI.B  #0,D1
000035E2  6700 003A               3880              BEQ     REG_0
000035E6  0C01 0001               3881              CMPI.B  #1,D1
000035EA  6700 0040               3882              BEQ     REG_1
000035EE  0C01 0002               3883              CMPI.B  #2,D1
000035F2  6700 0046               3884              BEQ     REG_2
000035F6  0C01 0003               3885              CMPI.B  #3,D1
000035FA  6700 004C               3886              BEQ     REG_3
000035FE  0C01 0004               3887              CMPI.B  #4,D1
00003602  6700 0052               3888              BEQ     REG_4
00003606  0C01 0005               3889              CMPI.B  #5,D1
0000360A  6700 0058               3890              BEQ     REG_5
0000360E  0C01 0006               3891              CMPI.B  #6,D1
00003612  6700 005E               3892              BEQ     REG_6
00003616  0C01 0007               3893              CMPI.B  #7,D1
0000361A  6700 0064               3894              BEQ     REG_7
0000361E                          3895  
0000361E                          3896  *---------------------------------------------------------------------------*
0000361E                          3897  * REG_0 ~ REG_7: display register 0 to 7
0000361E                          3898  *---------------------------------------------------------------------------*
0000361E  43F9 000048E4           3899  REG_0       LEA     DISP_0,A1
00003624  103C 000E               3900              MOVE.B  #14,D0
00003628  4E4F                    3901              TRAP    #15
0000362A  4E75                    3902              RTS
0000362C                          3903              
0000362C  43F9 000048E6           3904  REG_1       LEA     DISP_1,A1
00003632  103C 000E               3905              MOVE.B  #14,D0
00003636  4E4F                    3906              TRAP    #15
00003638  4E75                    3907              RTS
0000363A                          3908              
0000363A                          3909  
0000363A  43F9 000048E8           3910  REG_2       LEA     DISP_2,A1
00003640  103C 000E               3911              MOVE.B  #14,D0
00003644  4E4F                    3912              TRAP    #15
00003646  4E75                    3913              RTS
00003648                          3914            
00003648  43F9 000048EA           3915  REG_3       LEA     DISP_3,A1
0000364E  103C 000E               3916              MOVE.B  #14,D0
00003652  4E4F                    3917              TRAP    #15
00003654  4E75                    3918              RTS
00003656                          3919              
00003656  43F9 000048EC           3920  REG_4       LEA     DISP_4,A1
0000365C  103C 000E               3921              MOVE.B  #14,D0
00003660  4E4F                    3922              TRAP    #15
00003662  4E75                    3923              RTS
00003664                          3924              
00003664  43F9 000048EE           3925  REG_5       LEA     DISP_5,A1
0000366A  103C 000E               3926              MOVE.B  #14,D0
0000366E  4E4F                    3927              TRAP    #15
00003670  4E75                    3928              RTS
00003672                          3929              
00003672  43F9 000048F0           3930  REG_6       LEA     DISP_6,A1
00003678  103C 000E               3931              MOVE.B  #14,D0
0000367C  4E4F                    3932              TRAP    #15
0000367E  4E75                    3933              RTS
00003680                          3934              
00003680  43F9 000048F2           3935  REG_7       LEA     DISP_7,A1
00003686  103C 000E               3936              MOVE.B  #14,D0
0000368A  4E4F                    3937              TRAP    #15
0000368C  4E75                    3938              RTS
0000368E                          3939              
0000368E                          3940  *---------------------------------------------------------------------------*
0000368E                          3941  * REPEAT : Ask user whether they wish to run the program again
0000368E                          3942  *---------------------------------------------------------------------------*           
0000368E  4246                    3943  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00003690  43F9 000043BD           3944              LEA     REPEATMSG,A1
00003696  103C 000E               3945              MOVE.B  #14,D0
0000369A  4E4F                    3946              TRAP    #15
0000369C                          3947              
0000369C  43F9 00004547           3948              LEA     TMPINPUT,A1             * allocate space to temp store user input
000036A2  103C 0002               3949              MOVE.B  #2,D0
000036A6  4E4F                    3950              TRAP    #15
000036A8                          3951  
000036A8  0C01 0001               3952              CMPI.B  #1,D1                   * check for length of user input
000036AC  66E0                    3953              BNE     REPEAT                  * return to the beginning of the function if unequal
000036AE                          3954              
000036AE  0C11 0059               3955              CMPI.B  #$59,(A1)               * compare the input with Y    
000036B2  6700 D956               3956              BEQ     PROGLP                  * repeat the program
000036B6                          3957              
000036B6  0C11 0079               3958              CMPI.B  #$79,(A1)               * compare the input with y    
000036BA  6700 D94E               3959              BEQ     PROGLP                  * repeat the program
000036BE                          3960              
000036BE  0C11 004E               3961              CMPI.B  #$4E,(A1)               * compare the input with N    
000036C2  6700 098C               3962              BEQ     TERMINATE               * finish program
000036C6                          3963              
000036C6  0C11 006E               3964              CMPI.B  #$6E,(A1)               * compare the input with n    
000036CA  6700 0984               3965              BEQ     TERMINATE               * finish program
000036CE                          3966              
000036CE  60BE                    3967              BRA     REPEAT                  * invalid input/repeat the function
000036D0                          3968  
000036D0                          3969  *---------------------------------------------------------------------------*
000036D0                          3970  * EA DECODING INTERFACE
000036D0                          3971  * [A0] - RESERVED FOR USE
000036D0                          3972  * [D2] - RESERVED FOR USE
000036D0                          3973  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
000036D0                          3974  *---------------------------------------------------------------------------*
000036D0                          3975  GET_EA_EA_SRC
000036D0                          3976      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
000036D0                          3977      
000036D0                          3978      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
000036D0  2405                    3979      MOVE.L  D5,D2                           * CLEAN COPY TO D2
000036D2  E68A                    3980      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
000036D4  23C2 0000490A           3981      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000036DA  7407                    3982      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000036DC  C5B9 0000490A           3983      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000036E2                          3984                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000036E2                          3985      
000036E2                          3986      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000036E2                          3987      *DESTINATION REGISTER FORMAT STANDARD         *
000036E2                          3988      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000036E2                          3989      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000036E2                          3990      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000036E2                          3991      *0 - Dn                                       *
000036E2                          3992      *1 - An                                       *
000036E2                          3993      *2 - (An)                                     *
000036E2                          3994      *3 - (An)+                                    *
000036E2                          3995      *4 - -(An)                                    *
000036E2                          3996      *5 - (XXX).W                                  *
000036E2                          3997      *6 - (XXX).L                                  *
000036E2                          3998      *7 - #<data>                                  *
000036E2                          3999      ***********************************************
000036E2                          4000      
000036E2                          4001      *** Check if source ...  <ea> = Dn
000036E2                          4002  CHECK0    
000036E2  41F9 000048FA           4003            LEA     TEMP_REGISTER_FORMAT,A0
000036E8  1439 000048F9           4004            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036EE  1082                    4005            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036F0  0239 0001 000048FA      4006            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000036F8  0C39 0001 000048FA      4007            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003700  6700 006A               4008            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003704  0CB9 00000000 0000490A  4009            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
0000370E  6600 005C               4010            BNE     CHECK1
00003712                          4011            
00003712                          4012            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003712  163C 0020               4013            MOVE.B    #' ',D3
00003716  6100 0856               4014            BSR       PUSH_STACK
0000371A  163C 0044               4015            MOVE.B    #'D',D3
0000371E  6100 084E               4016            BSR       PUSH_STACK
00003722                          4017  
00003722                          4018            *FIND REGISTER NUMBER END LOCATION*  
00003722  13F9 000048FC 00004902  4019            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000372C  0239 000F 00004902      4020            AND.B   #$0F,VAR_BYTE_END
00003734                          4021            
00003734                          4022            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003734  23C5 00004906           4023            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000373A  1439 00004902           4024            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003740                          4025            
00003740                          4026            *INTITIALIZE FOR BIT SHIFTING
00003740  41F9 00004906           4027            LEA     VAR_TEMP_CLEANCOPY,A0
00003746  2639 00004906           4028            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000374C                          4029  LOOP_SHIFTING
0000374C  0C02 0000               4030            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003750  6700 0008               4031            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003754  E24B                    4032            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003756  5302                    4033            SUB.B   #1,D2                     *DECREMENT COUNTER
00003758  60F2                    4034            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
0000375A                          4035  MASKING_NEXT
0000375A  C6BC 00000007           4036            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003760  0603 0030               4037            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003764  6100 0808               4038            BSR     PUSH_STACK                *PUSH TO STACK
00003768                          4039            
00003768  6000 0394               4040            BRA     GET_SRC_SUCCESS           *RETURN          
0000376C                          4041            
0000376C                          4042            
0000376C                          4043            *** Check if source ...  <ea> = An
0000376C  41F9 000048FA           4044  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00003772  1439 000048F9           4045            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003778  1082                    4046            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000377A  0239 0002 000048FA      4047            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003782  0C39 0002 000048FA      4048            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
0000378A  6700 006A               4049            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000378E  0CB9 00000001 0000490A  4050            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003798  6600 005C               4051            BNE     CHECK2
0000379C                          4052            
0000379C                          4053            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000379C  163C 0020               4054            MOVE.B    #' ',D3
000037A0  6100 07CC               4055            BSR       PUSH_STACK
000037A4  163C 0041               4056            MOVE.B    #'A',D3
000037A8  6100 07C4               4057            BSR       PUSH_STACK
000037AC                          4058  
000037AC                          4059            
000037AC                          4060            *FIND REGISTER NUMBER END LOCATION*  
000037AC  13F9 000048FC 00004902  4061            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000037B6  0239 000F 00004902      4062            AND.B   #$0F,VAR_BYTE_END
000037BE                          4063            
000037BE                          4064            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037BE  23C5 00004906           4065            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037C4  1439 00004902           4066            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
000037CA                          4067            
000037CA                          4068            *INTITIALIZE FOR BIT SHIFTING
000037CA  41F9 00004906           4069            LEA     VAR_TEMP_CLEANCOPY,A0
000037D0  2639 00004906           4070            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037D6                          4071  LOOP_SHIFTING1
000037D6  0C02 0000               4072            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037DA  6700 0008               4073            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000037DE  E24B                    4074            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037E0  5302                    4075            SUB.B   #1,D2                     *DECREMENT COUNTER
000037E2  60F2                    4076            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
000037E4                          4077  MASKING_NEXT1
000037E4  C6BC 00000007           4078            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037EA  0603 0030               4079            ADD.B   #$30,D3                   *CONVERT TO CHAR
000037EE  6100 077E               4080            BSR     PUSH_STACK                *PUSH TO STACK
000037F2                          4081            
000037F2  6000 030A               4082            BRA     GET_SRC_SUCCESS                   *RETURN 
000037F6                          4083            
000037F6                          4084            
000037F6                          4085            
000037F6                          4086            
000037F6                          4087            *** Check if source ...  <ea> = (An)       
000037F6  41F9 000048FA           4088  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
000037FC  1439 000048F9           4089            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003802  1082                    4090            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003804  0239 0004 000048FA      4091            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
0000380C  0C39 0004 000048FA      4092            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003814  6700 007A               4093            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003818  0CB9 00000002 0000490A  4094            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003822  6600 006C               4095            BNE     CHECK3
00003826                          4096            
00003826                          4097            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003826  163C 0020               4098            MOVE.B    #' ',D3
0000382A  6100 0742               4099            BSR       PUSH_STACK
0000382E  163C 0028               4100            MOVE.B    #'(',D3
00003832  6100 073A               4101            BSR       PUSH_STACK
00003836  163C 0041               4102            MOVE.B    #'A',D3
0000383A  6100 0732               4103            BSR       PUSH_STACK
0000383E                          4104  
0000383E                          4105            
0000383E                          4106            *FIND REGISTER NUMBER END LOCATION*  
0000383E  13F9 000048FC 00004902  4107            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003848  0239 000F 00004902      4108            AND.B   #$0F,VAR_BYTE_END
00003850                          4109            
00003850                          4110            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003850  23C5 00004906           4111            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003856  1439 00004902           4112            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000385C                          4113            
0000385C                          4114            *INTITIALIZE FOR BIT SHIFTING
0000385C  41F9 00004906           4115            LEA     VAR_TEMP_CLEANCOPY,A0
00003862  2639 00004906           4116            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003868                          4117  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003868  0C02 0000               4118            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000386C  6700 0008               4119            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003870  E24B                    4120            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003872  5302                    4121            SUB.B   #1,D2                     *DECREMENT COUNTER
00003874  60F2                    4122            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003876                          4123  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003876  0283 00000007           4124            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000387C  0603 0030               4125            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003880  6100 06EC               4126            BSR     PUSH_STACK                *PUSH TO STACK
00003884                          4127            
00003884  163C 0029               4128            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003888  6100 06E4               4129            BSR       PUSH_STACK
0000388C                          4130            
0000388C  6000 0270               4131            BRA     GET_SRC_SUCCESS                   *RETURN 
00003890                          4132  
00003890                          4133            
00003890                          4134            
00003890                          4135                      
00003890                          4136  *** Check if source ...  <ea> = (An)+       
00003890  41F9 000048FA           4137  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003896  1439 000048F9           4138            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000389C  1082                    4139            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000389E  0239 0008 000048FA      4140            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000038A6  0C39 0008 000048FA      4141            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
000038AE  6700 0082               4142            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000038B2  0CB9 00000003 0000490A  4143            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000038BC  6600 0074               4144            BNE     CHECK4
000038C0                          4145            
000038C0                          4146            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000038C0  163C 0020               4147            MOVE.B    #' ',D3
000038C4  6100 06A8               4148            BSR       PUSH_STACK
000038C8  163C 0028               4149            MOVE.B    #'(',D3
000038CC  6100 06A0               4150            BSR       PUSH_STACK
000038D0  163C 0041               4151            MOVE.B    #'A',D3
000038D4  6100 0698               4152            BSR       PUSH_STACK
000038D8                          4153  
000038D8                          4154            
000038D8                          4155            *FIND REGISTER NUMBER END LOCATION*  
000038D8  13F9 000048FC 00004902  4156            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038E2  0239 000F 00004902      4157            ANDI.B   #$0F,VAR_BYTE_END
000038EA                          4158            
000038EA                          4159            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038EA  23C5 00004906           4160            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038F0  1439 00004902           4161            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038F6                          4162            
000038F6                          4163            *INTITIALIZE FOR BIT SHIFTING
000038F6  41F9 00004906           4164            LEA     VAR_TEMP_CLEANCOPY,A0
000038FC  2639 00004906           4165            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003902                          4166            
00003902                          4167  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003902  0C02 0000               4168            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003906  6700 0008               4169            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000390A  E24B                    4170            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000390C  5302                    4171            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000390E  60F2                    4172            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003910                          4173                                               *change: NAME OF LABEL*
00003910                          4174  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003910  0283 00000007           4175            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003916  0603 0030               4176            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000391A  6100 0652               4177            BSR     PUSH_STACK                *PUSH TO STACK
0000391E                          4178            
0000391E  163C 0029               4179            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003922  6100 064A               4180            BSR       PUSH_STACK
00003926  163C 002B               4181            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000392A  6100 0642               4182            BSR       PUSH_STACK
0000392E                          4183            
0000392E  6000 01CE               4184            BRA       GET_SRC_SUCCESS                   *RETURN 
00003932                          4185  
00003932                          4186            
00003932                          4187            
00003932                          4188                      
00003932                          4189            *** Check if source ...  <ea> = -(An)       
00003932  41F9 000048FA           4190  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003938  1439 000048F9           4191            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000393E  1082                    4192            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003940  0239 0010 000048FA      4193            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003948  0C39 0010 000048FA      4194            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003950  6700 0082               4195            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003954  0CB9 00000004 0000490A  4196            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000395E  6600 0074               4197            BNE     CHECK7
00003962                          4198            
00003962                          4199            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003962  163C 0020               4200            MOVE.B    #' ',D3
00003966  6100 0606               4201            BSR       PUSH_STACK
0000396A  163C 002D               4202            MOVE.B    #'-',D3
0000396E  6100 05FE               4203            BSR       PUSH_STACK
00003972  163C 0028               4204            MOVE.B    #'(',D3
00003976  6100 05F6               4205            BSR       PUSH_STACK
0000397A  163C 0041               4206            MOVE.B    #'A',D3
0000397E  6100 05EE               4207            BSR       PUSH_STACK
00003982                          4208  
00003982                          4209            
00003982                          4210            *FIND REGISTER NUMBER END LOCATION*  
00003982  13F9 000048FC 00004902  4211            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000398C  0239 000F 00004902      4212            AND.B   #$0F,VAR_BYTE_END
00003994                          4213            
00003994                          4214            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003994  23C5 00004906           4215            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000399A  1439 00004902           4216            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000039A0                          4217            
000039A0                          4218            *INTITIALIZE FOR BIT SHIFTING
000039A0  41F9 00004906           4219            LEA     VAR_TEMP_CLEANCOPY,A0
000039A6  2639 00004906           4220            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000039AC                          4221            
000039AC                          4222  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
000039AC  0C02 0000               4223            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000039B0  6700 0008               4224            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000039B4  E24B                    4225            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000039B6  5302                    4226            SUBI.B   #1,D2                     *DECREMENT COUNTER
000039B8  60F2                    4227            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
000039BA                          4228                                               *change: NAME OF LABEL*
000039BA                          4229  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
000039BA  0283 00000007           4230            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000039C0  0603 0030               4231            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000039C4  6100 05A8               4232            BSR     PUSH_STACK                *PUSH TO STACK
000039C8                          4233            
000039C8  163C 0029               4234            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000039CC  6100 05A0               4235            BSR       PUSH_STACK
000039D0                          4236            
000039D0  6000 012C               4237            BRA     GET_SRC_SUCCESS                   *RETURN
000039D4                          4238            
000039D4                          4239                      
000039D4                          4240            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
000039D4  0CB9 00000007 0000490A  4241  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000039DE  6600 011A               4242            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000039E2                          4243                   
000039E2                          4244            *NEXT: (MODE == 111) 
000039E2                          4245            *NOW: CHECK FOR SRC REGISTER 
000039E2                          4246                  *(000 = (xxx).W)
000039E2                          4247                  *(001 = (xxx).L)
000039E2                          4248                  *(010 = #<data>)
000039E2                          4249                  
000039E2                          4250            *FIND REGISTER NUMBER END LOCATION*  
000039E2  13F9 000048FC 00004902  4251            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000039EC  0239 000F 00004902      4252            AND.B   #$0F,VAR_BYTE_END
000039F4                          4253            
000039F4                          4254            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000039F4  23C5 00004906           4255            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000039FA  1439 00004902           4256            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A00                          4257            
00003A00                          4258            *INTITIALIZE FOR BIT SHIFTING
00003A00  41F9 00004906           4259            LEA     VAR_TEMP_CLEANCOPY,A0
00003A06  2C39 00004906           4260            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003A0C                          4261  SRC_LOOP_SHIFTING
00003A0C  0C02 0000               4262            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A10  6700 0008               4263            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003A14  E24E                    4264            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A16  5302                    4265            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A18  60F2                    4266            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003A1A                          4267  SRC_MASKING_NEXT
00003A1A  CCBC 00000007           4268            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003A20                          4269           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003A20                          4270           
00003A20                          4271  CHECK_WORD  
00003A20  41F9 000048FA           4272            LEA     TEMP_REGISTER_FORMAT,A0
00003A26  1439 000048F9           4273            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A2C  1082                    4274            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A2E  0239 0020 000048FA      4275            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003A36  0C39 0020 000048FA      4276            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A3E  6700 0026               4277            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A42  0C06 0000               4278            CMPI.B  #0,D6                          
00003A46  6600 001E               4279            BNE     CHECK_LONG 
00003A4A                          4280            
00003A4A                          4281            *IT IS A WORD AT THIS POINT*
00003A4A                          4282            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A4A  163C 0020               4283            MOVE.B    #' ',D3
00003A4E  6100 051E               4284            BSR       PUSH_STACK
00003A52  163C 0024               4285            MOVE.B    #'$',D3
00003A56  6100 0516               4286            BSR       PUSH_STACK
00003A5A  321D                    4287            MOVE.W    (A5)+,D1
00003A5C  7404                    4288            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A5E  6100 D800               4289            BSR       HEX2ASCII2STACK
00003A62  6000 009A               4290            BRA     GET_SRC_SUCCESS
00003A66                          4291  
00003A66                          4292  CHECK_LONG
00003A66  41F9 000048FA           4293            LEA     TEMP_REGISTER_FORMAT,A0
00003A6C  1439 000048F9           4294            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A72  1082                    4295            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A74  0239 0040 000048FA      4296            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003A7C  0C39 0040 000048FA      4297            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A84  6700 002E               4298            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A88  0C06 0001               4299            CMPI.B  #1,D6                          
00003A8C  6600 0026               4300            BNE     CHECK_IMMEDIATE  
00003A90                          4301  
00003A90                          4302            *IT IS A WORD AT THIS POINT*
00003A90                          4303            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A90  163C 0020               4304            MOVE.B    #' ',D3
00003A94  6100 04D8               4305            BSR       PUSH_STACK
00003A98  163C 0024               4306            MOVE.B    #'$',D3
00003A9C  6100 04D0               4307            BSR       PUSH_STACK
00003AA0  321D                    4308            MOVE.W    (A5)+,D1
00003AA2  7404                    4309            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003AA4  6100 D7BA               4310            BSR       HEX2ASCII2STACK
00003AA8  321D                    4311            MOVE.W    (A5)+,D1
00003AAA  7404                    4312            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003AAC  6100 D7B2               4313            BSR       HEX2ASCII2STACK
00003AB0  6000 004C               4314            BRA     GET_SRC_SUCCESS
00003AB4                          4315            
00003AB4                          4316  CHECK_IMMEDIATE
00003AB4  41F9 000048FA           4317            LEA     TEMP_REGISTER_FORMAT,A0
00003ABA  1439 000048F9           4318            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AC0  1082                    4319            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AC2  0239 0080 000048FA      4320            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003ACA  0C39 0080 000048FA      4321            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003AD2  6700 0026               4322            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003AD6  0C06 0004               4323            CMPI.B  #4,D6                          
00003ADA  6600 001E               4324            BNE     GET_SRC_FAILED 
00003ADE                          4325  
00003ADE                          4326            *IT IS A WORD AT THIS POINT*
00003ADE                          4327            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003ADE  163C 0020               4328            MOVE.B    #' ',D3
00003AE2  6100 048A               4329            BSR       PUSH_STACK
00003AE6  163C 0023               4330            MOVE.B    #'#',D3
00003AEA  6100 0482               4331            BSR       PUSH_STACK
00003AEE  321D                    4332            MOVE.W    (A5)+,D1
00003AF0  7404                    4333            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003AF2  6100 D76C               4334            BSR       HEX2ASCII2STACK
00003AF6  6000 0006               4335            BRA     GET_SRC_SUCCESS
00003AFA                          4336            
00003AFA                          4337  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003AFA  7801                    4338            MOVE.L #1,D4
00003AFC  4E75                    4339            RTS
00003AFE                          4340  GET_SRC_SUCCESS 
00003AFE  4E75                    4341            RTS
00003B00                          4342                                 
00003B00                          4343      
00003B00                          4344  
00003B00                          4345  
00003B00                          4346  
00003B00                          4347  
00003B00                          4348  
00003B00                          4349  
00003B00                          4350  GET_EA_EA_DEST
00003B00                          4351  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003B00                          4352      
00003B00                          4353      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003B00  2405                    4354      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003B02  EC8A                    4355      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003B04  23C2 0000490A           4356      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003B0A  7407                    4357      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003B0C  C5B9 0000490A           4358      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003B12                          4359                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003B12                          4360      
00003B12                          4361      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003B12                          4362      *DESTINATION REGISTER FORMAT STANDARD         *
00003B12                          4363      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003B12                          4364      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003B12                          4365      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003B12                          4366      *0 - Dn                                       *
00003B12                          4367      *1 - An                                       *
00003B12                          4368      *2 - (An)                                     *
00003B12                          4369      *3 - (An)+                                    *
00003B12                          4370      *4 - -(An)                                    *
00003B12                          4371      *5 - (XXX).W                                  *
00003B12                          4372      *6 - (XXX).L                                  *
00003B12                          4373      *7 - #<data>                                  *
00003B12                          4374      ***********************************************
00003B12                          4375      
00003B12                          4376      *** Check if source ...  <ea> = Dn
00003B12                          4377  DEST_CHECK0    
00003B12  41F9 000048FA           4378            LEA     TEMP_REGISTER_FORMAT,A0
00003B18  1439 000048F8           4379            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B1E  1082                    4380            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B20  0239 0001 000048FA      4381            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003B28  0C39 0001 000048FA      4382            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003B30  6700 006A               4383            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003B34  0CB9 00000000 0000490A  4384            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B3E  6600 005C               4385            BNE     DEST_CHECK1
00003B42                          4386            
00003B42                          4387            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B42  163C 0020               4388            MOVE.B    #' ',D3
00003B46  6100 0426               4389            BSR       PUSH_STACK
00003B4A  163C 0044               4390            MOVE.B    #'D',D3
00003B4E  6100 041E               4391            BSR       PUSH_STACK
00003B52                          4392  
00003B52                          4393            *FIND REGISTER NUMBER END LOCATION*  
00003B52  13F9 000048FB 00004902  4394            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B5C  0239 000F 00004902      4395            AND.B   #$0F,VAR_BYTE_END
00003B64                          4396            
00003B64                          4397            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B64  23C5 00004906           4398            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B6A  1439 00004902           4399            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003B70                          4400            
00003B70                          4401            *INTITIALIZE FOR BIT SHIFTING
00003B70  41F9 00004906           4402            LEA     VAR_TEMP_CLEANCOPY,A0
00003B76  2639 00004906           4403            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B7C                          4404  DEST_LOOP_SHIFTING
00003B7C  0C02 0000               4405            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B80  6700 0008               4406            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003B84  E24B                    4407            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B86  5302                    4408            SUB.B   #1,D2                     *DECREMENT COUNTER
00003B88  60F2                    4409            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003B8A                          4410  DEST_MASKING_NEXT
00003B8A  C6BC 00000007           4411            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B90  0603 0030               4412            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003B94  6100 03D8               4413            BSR     PUSH_STACK                *PUSH TO STACK
00003B98                          4414            
00003B98  6000 0394               4415            BRA     GET_DST_SUCCESS           *RETURN          
00003B9C                          4416            
00003B9C                          4417            
00003B9C                          4418            *** Check if source ...  <ea> = An
00003B9C                          4419  DEST_CHECK1    
00003B9C  41F9 000048FA           4420            LEA     TEMP_REGISTER_FORMAT,A0
00003BA2  1439 000048F8           4421            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003BA8  1082                    4422            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003BAA  0239 0002 000048FA      4423            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003BB2  0C39 0002 000048FA      4424            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003BBA  6700 006A               4425            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003BBE  0CB9 00000001 0000490A  4426            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003BC8  6600 005C               4427            BNE     DEST_CHECK2
00003BCC                          4428            
00003BCC                          4429            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003BCC  163C 0020               4430            MOVE.B    #' ',D3
00003BD0  6100 039C               4431            BSR       PUSH_STACK
00003BD4  163C 0041               4432            MOVE.B    #'A',D3
00003BD8  6100 0394               4433            BSR       PUSH_STACK
00003BDC                          4434  
00003BDC                          4435            
00003BDC                          4436            *FIND REGISTER NUMBER END LOCATION*  
00003BDC  13F9 000048FB 00004902  4437            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BE6  0239 000F 00004902      4438            AND.B   #$0F,VAR_BYTE_END
00003BEE                          4439            
00003BEE                          4440            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BEE  23C5 00004906           4441            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BF4  1439 00004902           4442            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003BFA                          4443            
00003BFA                          4444            *INTITIALIZE FOR BIT SHIFTING
00003BFA  41F9 00004906           4445            LEA     VAR_TEMP_CLEANCOPY,A0
00003C00  2639 00004906           4446            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C06                          4447  DEST_LOOP_SHIFTING1
00003C06  0C02 0000               4448            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C0A  6700 0008               4449            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C0E  E24B                    4450            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C10  5302                    4451            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C12  60F2                    4452            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003C14                          4453  DEST_MASKING_NEXT1
00003C14  C6BC 00000007           4454            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C1A  0603 0030               4455            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003C1E  6100 034E               4456            BSR     PUSH_STACK                *PUSH TO STACK
00003C22                          4457            
00003C22  6000 030A               4458            BRA     GET_DST_SUCCESS                   *RETURN 
00003C26                          4459            
00003C26                          4460            
00003C26                          4461            
00003C26                          4462            
00003C26                          4463            *** Check if source ...  <ea> = (An)       
00003C26                          4464  DEST_CHECK2    
00003C26  41F9 000048FA           4465            LEA     TEMP_REGISTER_FORMAT,A0
00003C2C  1439 000048F8           4466            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C32  1082                    4467            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C34  0239 0004 000048FA      4468            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003C3C  0C39 0004 000048FA      4469            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003C44  6700 007A               4470            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003C48  0CB9 00000002 0000490A  4471            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003C52  6600 006C               4472            BNE     DEST_CHECK3
00003C56                          4473            
00003C56                          4474            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003C56  163C 0020               4475            MOVE.B    #' ',D3
00003C5A  6100 0312               4476            BSR       PUSH_STACK
00003C5E  163C 0028               4477            MOVE.B    #'(',D3
00003C62  6100 030A               4478            BSR       PUSH_STACK
00003C66  163C 0041               4479            MOVE.B    #'A',D3
00003C6A  6100 0302               4480            BSR       PUSH_STACK
00003C6E                          4481  
00003C6E                          4482            
00003C6E                          4483            *FIND REGISTER NUMBER END LOCATION*  
00003C6E  13F9 000048FB 00004902  4484            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C78  0239 000F 00004902      4485            AND.B   #$0F,VAR_BYTE_END
00003C80                          4486            
00003C80                          4487            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C80  23C5 00004906           4488            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C86  1439 00004902           4489            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C8C                          4490            
00003C8C                          4491            *INTITIALIZE FOR BIT SHIFTING
00003C8C  41F9 00004906           4492            LEA     VAR_TEMP_CLEANCOPY,A0
00003C92  2639 00004906           4493            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C98                          4494  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003C98  0C02 0000               4495            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C9C  6700 0008               4496            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003CA0  E24B                    4497            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003CA2  5302                    4498            SUB.B   #1,D2                     *DECREMENT COUNTER
00003CA4  60F2                    4499            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003CA6                          4500  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003CA6  0283 00000007           4501            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003CAC  0603 0030               4502            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003CB0  6100 02BC               4503            BSR     PUSH_STACK                *PUSH TO STACK
00003CB4                          4504            
00003CB4  163C 0029               4505            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003CB8  6100 02B4               4506            BSR       PUSH_STACK
00003CBC                          4507            
00003CBC  6000 0270               4508            BRA     GET_DST_SUCCESS                   *RETURN 
00003CC0                          4509  
00003CC0                          4510            
00003CC0                          4511            
00003CC0                          4512                      
00003CC0                          4513  *** Check if source ...  <ea> = (An)+       
00003CC0  41F9 000048FA           4514  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003CC6  1439 000048F8           4515            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CCC  1082                    4516            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CCE  0239 0008 000048FA      4517            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003CD6  0C39 0008 000048FA      4518            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CDE  6700 0082               4519            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CE2  0CB9 00000003 0000490A  4520            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003CEC  6600 0074               4521            BNE     DEST_CHECK4
00003CF0                          4522            
00003CF0                          4523            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CF0  163C 0020               4524            MOVE.B    #' ',D3
00003CF4  6100 0278               4525            BSR       PUSH_STACK
00003CF8  163C 0028               4526            MOVE.B    #'(',D3
00003CFC  6100 0270               4527            BSR       PUSH_STACK
00003D00  163C 0041               4528            MOVE.B    #'A',D3
00003D04  6100 0268               4529            BSR       PUSH_STACK
00003D08                          4530  
00003D08                          4531            
00003D08                          4532            *FIND REGISTER NUMBER END LOCATION*  
00003D08  13F9 000048FB 00004902  4533            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D12  0239 000F 00004902      4534            ANDI.B   #$0F,VAR_BYTE_END
00003D1A                          4535            
00003D1A                          4536            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D1A  23C5 00004906           4537            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D20  1439 00004902           4538            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D26                          4539            
00003D26                          4540            *INTITIALIZE FOR BIT SHIFTING
00003D26  41F9 00004906           4541            LEA     VAR_TEMP_CLEANCOPY,A0
00003D2C  2639 00004906           4542            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D32                          4543            
00003D32                          4544  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003D32  0C02 0000               4545            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D36  6700 0008               4546            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D3A  E24B                    4547            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D3C  5302                    4548            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003D3E  60F2                    4549            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003D40                          4550                                               *change: NAME OF LABEL*
00003D40                          4551  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003D40  0283 00000007           4552            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D46  0603 0030               4553            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D4A  6100 0222               4554            BSR     PUSH_STACK                *PUSH TO STACK
00003D4E                          4555            
00003D4E  163C 0029               4556            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D52  6100 021A               4557            BSR       PUSH_STACK
00003D56  163C 002B               4558            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D5A  6100 0212               4559            BSR       PUSH_STACK
00003D5E                          4560            
00003D5E  6000 01CE               4561            BRA       GET_DST_SUCCESS                   *RETURN 
00003D62                          4562  
00003D62                          4563            
00003D62                          4564            
00003D62                          4565                      
00003D62                          4566            *** Check if source ...  <ea> = -(An)       
00003D62                          4567  DEST_CHECK4    
00003D62  41F9 000048FA           4568            LEA     TEMP_REGISTER_FORMAT,A0
00003D68  1439 000048F8           4569            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D6E  1082                    4570            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D70  0239 0010 000048FA      4571            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003D78  0C39 0010 000048FA      4572            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D80  6700 0082               4573            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003D84  0CB9 00000004 0000490A  4574            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003D8E  6600 0074               4575            BNE     DEST_CHECK7
00003D92                          4576            
00003D92                          4577            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003D92  163C 0020               4578            MOVE.B    #' ',D3
00003D96  6100 01D6               4579            BSR       PUSH_STACK
00003D9A  163C 002D               4580            MOVE.B    #'-',D3
00003D9E  6100 01CE               4581            BSR       PUSH_STACK
00003DA2  163C 0028               4582            MOVE.B    #'(',D3
00003DA6  6100 01C6               4583            BSR       PUSH_STACK
00003DAA  163C 0041               4584            MOVE.B    #'A',D3
00003DAE  6100 01BE               4585            BSR       PUSH_STACK
00003DB2                          4586  
00003DB2                          4587            
00003DB2                          4588            *FIND REGISTER NUMBER END LOCATION*  
00003DB2  13F9 000048FB 00004902  4589            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003DBC  0239 000F 00004902      4590            AND.B   #$0F,VAR_BYTE_END
00003DC4                          4591            
00003DC4                          4592            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003DC4  23C5 00004906           4593            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003DCA  1439 00004902           4594            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003DD0                          4595            
00003DD0                          4596            *INTITIALIZE FOR BIT SHIFTING
00003DD0  41F9 00004906           4597            LEA     VAR_TEMP_CLEANCOPY,A0
00003DD6  2639 00004906           4598            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003DDC                          4599            
00003DDC                          4600  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003DDC  0C02 0000               4601            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DE0  6700 0008               4602            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003DE4  E24B                    4603            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DE6  5302                    4604            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003DE8  60F2                    4605            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003DEA                          4606                                               *change: NAME OF LABEL*
00003DEA                          4607  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003DEA  0283 00000007           4608            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003DF0  0603 0030               4609            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003DF4  6100 0178               4610            BSR     PUSH_STACK                *PUSH TO STACK
00003DF8                          4611            
00003DF8  163C 0029               4612            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DFC  6100 0170               4613            BSR       PUSH_STACK
00003E00                          4614            
00003E00  6000 012C               4615            BRA     GET_DST_SUCCESS                   *RETURN
00003E04                          4616            
00003E04                          4617                      
00003E04                          4618            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003E04                          4619  DEST_CHECK7    
00003E04  0CB9 00000007 0000490A  4620            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003E0E  6600 011A               4621            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003E12                          4622                   
00003E12                          4623            *NEXT: (MODE == 111) 
00003E12                          4624            *NOW: CHECK FOR SRC REGISTER 
00003E12                          4625                  *(000 = (xxx).W)
00003E12                          4626                  *(001 = (xxx).L)
00003E12                          4627                  *(010 = #<data>)
00003E12                          4628                  
00003E12                          4629            *FIND REGISTER NUMBER END LOCATION*  
00003E12  13F9 000048FB 00004902  4630            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E1C  0239 000F 00004902      4631            AND.B   #$0F,VAR_BYTE_END
00003E24                          4632            
00003E24                          4633            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E24  23C5 00004906           4634            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E2A  1439 00004902           4635            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003E30                          4636            
00003E30                          4637            *INTITIALIZE FOR BIT SHIFTING
00003E30  41F9 00004906           4638            LEA     VAR_TEMP_CLEANCOPY,A0
00003E36  2C39 00004906           4639            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003E3C                          4640  DEST_LOOP_SHIFTING7
00003E3C  0C02 0000               4641            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E40  6700 0008               4642            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003E44  E24E                    4643            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E46  5302                    4644            SUB.B   #1,D2                     *DECREMENT COUNTER
00003E48  60F2                    4645            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003E4A                          4646  DEST_MASKING_NEXT7
00003E4A  CCBC 00000007           4647            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003E50                          4648           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003E50                          4649            
00003E50                          4650  DEST_CHECK_WORD  
00003E50  41F9 000048FA           4651            LEA     TEMP_REGISTER_FORMAT,A0
00003E56  1439 000048F8           4652            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E5C  1082                    4653            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E5E  0239 0020 000048FA      4654            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003E66  0C39 0020 000048FA      4655            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E6E  6700 0026               4656            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E72  0C06 0000               4657            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003E76  6600 001E               4658            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003E7A                          4659            *IT IS A WORD AT THIS POINT*
00003E7A                          4660            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E7A  163C 0020               4661            MOVE.B    #' ',D3
00003E7E  6100 00EE               4662            BSR       PUSH_STACK
00003E82  163C 0024               4663            MOVE.B    #'$',D3
00003E86  6100 00E6               4664            BSR       PUSH_STACK
00003E8A  321D                    4665            MOVE.W    (A5)+,D1
00003E8C  7404                    4666            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003E8E  6100 D3D0               4667            BSR       HEX2ASCII2STACK
00003E92  6000 009A               4668            BRA       GET_DST_SUCCESS
00003E96                          4669  
00003E96                          4670  DEST_CHECK_LONG
00003E96  41F9 000048FA           4671            LEA     TEMP_REGISTER_FORMAT,A0
00003E9C  1439 000048F8           4672            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EA2  1082                    4673            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EA4  0239 0040 000048FA      4674            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003EAC  0C39 0040 000048FA      4675            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003EB4  6700 002E               4676            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003EB8  0C06 0001               4677            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003EBC  6600 0026               4678            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003EC0                          4679            *IT IS A WORD AT THIS POINT*
00003EC0                          4680            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003EC0  163C 0020               4681            MOVE.B    #' ',D3
00003EC4  6100 00A8               4682            BSR       PUSH_STACK
00003EC8  163C 0024               4683            MOVE.B    #'$',D3
00003ECC  6100 00A0               4684            BSR       PUSH_STACK
00003ED0  321D                    4685            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003ED2  7404                    4686            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003ED4  6100 D38A               4687            BSR       HEX2ASCII2STACK
00003ED8  321D                    4688            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003EDA  7404                    4689            MOVE.L    #4,D2          
00003EDC  6100 D382               4690            BSR       HEX2ASCII2STACK
00003EE0  6000 004C               4691            BRA     GET_DST_SUCCESS
00003EE4                          4692            
00003EE4                          4693  DEST_CHECK_IMMEDIATE
00003EE4  41F9 000048FA           4694            LEA     TEMP_REGISTER_FORMAT,A0
00003EEA  1439 000048F8           4695            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EF0  1082                    4696            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EF2  0239 0080 000048FA      4697            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003EFA  0C39 0080 000048FA      4698            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F02  6700 0026               4699            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F06  0C06 0004               4700            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003F0A  6600 001E               4701            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003F0E                          4702            
00003F0E                          4703            *IT IS A WORD AT THIS POINT*
00003F0E                          4704            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F0E  163C 0020               4705            MOVE.B    #' ',D3
00003F12  6100 005A               4706            BSR       PUSH_STACK
00003F16  163C 0023               4707            MOVE.B    #'#',D3
00003F1A  6100 0052               4708            BSR       PUSH_STACK
00003F1E  321D                    4709            MOVE.W    (A5)+,D1
00003F20  7404                    4710            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003F22  6100 D33C               4711            BSR       HEX2ASCII2STACK
00003F26  6000 0006               4712            BRA       GET_DST_SUCCESS
00003F2A                          4713            
00003F2A                          4714  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003F2A  7801                    4715            MOVE.L #1,D4
00003F2C  4E75                    4716            RTS
00003F2E                          4717  GET_DST_SUCCESS 
00003F2E  4E75                    4718            RTS
00003F30                          4719  
00003F30                          4720  
00003F30                          4721  *---------------------------------------------------------------------------*
00003F30                          4722  * STACK/QUEUE INTERFACE
00003F30                          4723  *---------------------------------------------------------------------------*
00003F30                          4724  PRINT_STACK
00003F30  0C39 0000 000048F4      4725            CMP.B     #0,COUNTER
00003F38  6700 000E               4726            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003F3C                          4727            
00003F3C                          4728  PRINT_STACK_HELPER
00003F3C  6100 0038               4729            BSR      POP_STACK          *PRINTS ADDRESS
00003F40  103C 0006               4730            MOVE.B   #6,D0              *Display single character in D1.B. 
00003F44  4E4F                    4731            TRAP     #15             *ACTIVATES PRINT
00003F46                          4732  
00003F46  60E8                    4733            BRA       PRINT_STACK
00003F48                          4734  PRINT_STACK_RETURN
00003F48  4E75                    4735            RTS
00003F4A                          4736            
00003F4A                          4737            
00003F4A                          4738  PRINT_QUEUE
00003F4A  0C39 0000 000048F4      4739            CMP.B     #0,COUNTER
00003F52  6700 0018               4740            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003F56                          4741            
00003F56                          4742  PRINT_QUEUE_HELPER
00003F56  33F9 000048F4 000048F6  4743            MOVE.W   COUNTER,QUEUE_COUNTER
00003F60  6100 0022               4744            BSR      POP_FRONT          *PRINTS ADDRESS
00003F64  103C 0006               4745            MOVE.B   #6,D0              *Display single character in D1.B. 
00003F68  4E4F                    4746            TRAP     #15             *ACTIVATES PRINT
00003F6A                          4747  
00003F6A  60DE                    4748            BRA       PRINT_QUEUE
00003F6C                          4749  PRINT_QUEUE_RETURN
00003F6C  4E75                    4750            RTS
00003F6E                          4751            
00003F6E                          4752  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003F6E                          4753  PUSH_STACK
00003F6E  1503                    4754              MOVE.B  D3,-(A2)
00003F70  6100 0058               4755              BSR     INCREMENT
00003F74  4E75                    4756              RTS
00003F76                          4757  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003F76                          4758  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003F76                          4759  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003F76                          4760  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003F76                          4761  *         TRAP        #15             *ACTIVATES PRINT
00003F76                          4762  POP_STACK
00003F76  BECA                    4763              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003F78  6700 0008               4764              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003F7C  121A                    4765              MOVE.B  (A2)+,D1 
00003F7E  6100 0052               4766              BSR     DECREMENT
00003F82                          4767  POP_RETURN
00003F82  4E75                    4768              RTS 
00003F84                          4769        
00003F84                          4770  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003F84  0C39 0000 000048F6      4771  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003F8C  6700 0030               4772              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003F90                          4773              
00003F90                          4774              
00003F90                          4775              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003F90  347C 7000               4776              MOVEA.W #STACK,A2   *START A2 AT STACK
00003F94  0622 0000               4777              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003F98  384A                    4778              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003F9A  0624 0000               4779              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003F9E  1212                    4780              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003FA0                          4781  POP_SHIFT_LOOP
00003FA0  0C39 0000 000048F6      4782              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003FA8  6700 0014               4783              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003FAC  1494                    4784              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003FAE  0624 0000               4785              ADD.B   #0,-(A4)
00003FB2  0622 0000               4786              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003FB6  5339 000048F6           4787              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003FBC                          4788              
00003FBC  60E2                    4789              BRA     POP_SHIFT_LOOP
00003FBE                          4790                          
00003FBE                          4791  POP_FRONT_RETURN 
00003FBE                          4792              *RESET A2 BACK TO SP
00003FBE  347C 7000               4793              MOVEA.W #STACK,A2    
00003FC2  5339 000048F4           4794              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003FC8  4E75                    4795              RTS   
00003FCA                          4796  
00003FCA                          4797  INCREMENT
00003FCA  5239 000048F4           4798              ADD.B   #1, COUNTER
00003FD0  4E75                    4799              RTS           
00003FD2                          4800  DECREMENT
00003FD2  5339 000048F4           4801              SUB.B   #1, COUNTER
00003FD8  4E75                    4802              RTS           
00003FDA                          4803  CLEAR_STACK
00003FDA  0C39 0000 000048F4      4804              CMP.B     #0,COUNTER
00003FE2  6700 0006               4805              BEQ       CLEAR_RETURN
00003FE6  618E                    4806              BSR       POP_STACK
00003FE8  60F0                    4807              BRA       CLEAR_STACK
00003FEA                          4808   
00003FEA                          4809  CLEAR_RETURN
00003FEA  4E75                    4810              RTS    
00003FEC                          4811              
00003FEC                          4812  *---------------------------------------------------------------------------*
00003FEC                          4813  * 8/16/32-bit Address getter
00003FEC                          4814  *---------------------------------------------------------------------------*
00003FEC                          4815  *get displacement value from bits 0 to 8
00003FEC                          4816  *if displacement is not $00, than it is 8 otherwise check for word
00003FEC                          4817  *if displacement is not $FF, than it is a long
00003FEC                          4818  *add the displacement to the current address being processed + a word
00003FEC                          4819  *place results into D3, so that it can be pushed to stack
00003FEC                          4820  GET_DISPLACEMENT_ADDRESS
00003FEC  2805                    4821              MOVE.L  D5,D4                   * COPIES DATA INTO D6
00003FEE  0286 000000FF           4822              ANDI.L  #$00FF,D6               * MASKS DATA
00003FF4  0C84 00000000           4823              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
00003FFA  6700 0022               4824              BEQ     GET_DISPLACEMENT_WORD
00003FFE  0C84 000000FF           4825              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00004004  6700 0030               4826              BEQ     GET_DISPLACEMENT_LONG
00004008                          4827              
00004008  2E3C 00000100           4828              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
0000400E  9E04                    4829              SUB.B   D4,D7
00004010                          4830              
00004010  280D                    4831              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004012  9807                    4832              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00004014  7404                    4833              MOVE.L  #4,D2
00004016  2204                    4834              MOVE.L  D4,D1  
00004018  6100 D246               4835              BSR     HEX2ASCII2STACK
0000401C  4E75                    4836              RTS
0000401E                          4837              
0000401E                          4838  GET_DISPLACEMENT_WORD
0000401E  2E3C 000000FF           4839              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00004024  9E04                    4840              SUB.B   D4,D7
00004026                          4841              
00004026  280D                    4842              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004028  9807                    4843              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
0000402A  7404                    4844              MOVE.L  #4,D2
0000402C  2604                    4845              MOVE.L  D4,D3
0000402E  2204                    4846              MOVE.L  D4,D1
00004030  6100 D22E               4847              BSR     HEX2ASCII2STACK
00004034  4E75                    4848              RTS     
00004036                          4849  GET_DISPLACEMENT_LONG   
00004036  2E3C 000000FF           4850              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
0000403C  9E04                    4851              SUB.B   D4,D7
0000403E                          4852              
0000403E  280D                    4853              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004040  9807                    4854              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00004042  7408                    4855              MOVE.L  #8,D2
00004044  2604                    4856              MOVE.L  D4,D3                   * PREPARE TO PUSH
00004046  2204                    4857              MOVE.L  D4,D1
00004048  6100 D216               4858              BSR     HEX2ASCII2STACK
0000404C                          4859  
0000404C  4284                    4860              CLR.L   D4
0000404E  4E75                    4861              RTS
00004050                          4862  
00004050                          4863  *---------------------------------------------------------------------------*
00004050                          4864  * TERMINATE
00004050                          4865  *---------------------------------------------------------------------------*
00004050                          4866  TERMINATE   
00004050  43F9 00004400           4867              LEA     FINMSG,A1
00004056  103C 000E               4868              MOVE.B  #14,D0
0000405A  4E4F                    4869              TRAP    #15
0000405C                          4870  
0000405C  103C 0009               4871              MOVE.B  #9,D0
00004060  4E4F                    4872              TRAP    #15
00004062                          4873  
00004062                          4874  *---------------------------------------------------------------------------*
00004062                          4875  * Data storage                                                 
00004062                          4876  *---------------------------------------------------------------------------*  
00004062                          4877  WELCOME
00004062= 20 20 20 20 20 20 ...   4878              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
000040B2= 3D 3D 3D 3D 3D 20 ...   4879              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004102= 3D 3D 3D 3D 3D 20 ...   4880              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00004152                          4881      
00004152= 20 20 20 20 20 20 ...   4882              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
000041A2= 20 20 20 20 20 20 ...   4883              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
000041F2= 20 20 20 20 20 20 ...   4884              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00004242                          4885      
00004242= 20 20 20 20 20 20 ...   4886              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00004292= 3D 3D 3D 3D 3D 20 ...   4887              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
000042E2= 3D 3D 3D 3D 3D 20 ...   4888              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00004337                          4889  
00004337                          4890  PROMPT_START
00004337= 50 6C 65 61 73 65 ...   4891              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
00004366                          4892      
00004366                          4893  PROMPT_END
00004366= 50 6C 65 61 73 65 ...   4894              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00004393= 0D 0A 48 69 74 20 ...   4895  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
000043BD= 57 6F 75 6C 64 20 ...   4896  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004400= 54 68 61 6E 6B 20 ...   4897  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
0000442B= 45 72 72 6F 72 3A ...   4898  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
0000444A= 45 72 72 6F 72 3A ...   4899  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
0000446F= 45 72 72 6F 72 3A ...   4900  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
0000449C                          4901  
0000449C                          4902  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
000044EC                          4903  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
0000453C                          4904  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00004540                          4905  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
00004544= 0D 0A 00                4906  ENDLINE_M   DC.B    CR,LF,0
00004547                          4907  TMPINPUT    DS.B    80                      * temp store user input
00004597                          4908  TMPOUTPUT   DS.B    80                      * temp store prog output
000045E7= 20 20 20 4F 52 49 ...   4909  DISP_ORI_B  DC.B    '   ORI.B',0
000045F0= 20 20 20 4F 52 49 ...   4910  DISP_ORI_W  DC.B    '   ORI.W',0
000045F9= 20 20 20 4F 52 49 ...   4911  DISP_ORI_L  DC.B    '   ORI.L',0
00004602= 20 20 20 45 4F 52 ...   4912  DISP_EORI_B  DC.B    '   EORI.B',0
0000460C= 20 20 20 45 4F 52 ...   4913  DISP_EORI_W  DC.B    '   EORI.W',0
00004616= 20 20 20 45 4F 52 ...   4914  DISP_EORI_L  DC.B    '   EORI.L',0
00004620= 20 20 20 42 54 53 ...   4915  DISP_BTST   DC.B    '   BTST',0
00004628= 20 20 20 43 4D 50 ...   4916  DISP_CMPI_B  DC.B    '   CMPI.B',0
00004632= 20 20 20 43 4D 50 ...   4917  DISP_CMPI_W  DC.B    '   CMPI.W',0
0000463C= 20 20 20 43 4D 50 ...   4918  DISP_CMPI_L  DC.B    '   CMPI.L',0
00004646= 20 20 20 44 41 54 ...   4919  DISP_DATA   DC.B    '   DATA',0
0000464E= 20 20 20 4D 4F 56 ...   4920  DISP_MOVE_B DC.B    '   MOVE.B',0
00004658= 20 20 20 4D 4F 56 ...   4921  DISP_MOVE_W DC.B    '   MOVE.W',0
00004662= 20 20 20 4D 4F 56 ...   4922  DISP_MOVE_L DC.B    '   MOVE.L',0
0000466C= 20 20 20 52 54 53 00    4923  DISP_RTS    DC.B    '   RTS',0
00004673= 20 20 20 4A 53 52 00    4924  DISP_JSR    DC.B    '   JSR',0
0000467A= 20 20 20 4E 45 47 ...   4925  DISP_NEG_B    DC.B    '   NEG.B',0
00004683= 20 20 20 4E 45 47 ...   4926  DISP_NEG_W    DC.B    '   NEG.W',0
0000468C= 20 20 20 4E 45 47 ...   4927  DISP_NEG_L    DC.B    '   NEG.L',0
00004695= 20 20 20 4E 4F 54 ...   4928  DISP_NOT_B  DC.B    '   NOT.B',0
0000469E= 20 20 20 4E 4F 54 ...   4929  DISP_NOT_W  DC.B    '   NOT.W',0
000046A7= 20 20 20 4E 4F 54 ...   4930  DISP_NOT_L  DC.B    '   NOT.L',0
000046B0= 20 20 20 4C 45 41 00    4931  DISP_LEA    DC.B    '   LEA',0
000046B7= 20 20 20 4D 4F 56 ...   4932  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
000046C2= 20 20 20 4D 4F 56 ...   4933  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
000046CD= 20 20 20 41 44 44 ...   4934  DISP_ADDQ_B DC.B    '   ADDQ.B',0
000046D7= 20 20 20 41 44 44 ...   4935  DISP_ADDQ_W DC.B    '   ADDQ.W',0
000046E1= 20 20 20 41 44 44 ...   4936  DISP_ADDQ_L DC.B    '   ADDQ.L',0
000046EB= 20 20 20 44 49 56 ...   4937  DISP_DIVS   DC.B    '   DIVS',0
000046F3= 20 20 20 53 55 42 ...   4938  DISP_SUB_B  DC.B    '   SUB.B',0
000046FC= 20 20 20 53 55 42 ...   4939  DISP_SUB_W  DC.B    '   SUB.W',0
00004705= 20 20 20 53 55 42 ...   4940  DISP_SUB_L  DC.B    '   SUB.L',0
0000470E= 20 20 20 53 55 42 ...   4941  DISP_SUBI_B  DC.B    '   SUBI.B',0
00004718= 20 20 20 53 55 42 ...   4942  DISP_SUBI_W  DC.B    '   SUBI.W',0
00004722= 20 20 20 53 55 42 ...   4943  DISP_SUBI_L  DC.B    '   SUBI.L',0
0000472C= 20 20 20 53 55 42 ...   4944  DISP_SUBA_W  DC.B    '   SUBA.W',0
00004736= 20 20 20 53 55 42 ...   4945  DISP_SUBA_L  DC.B    '   SUBA.L',0
00004740= 20 20 20 45 4F 52 ...   4946  DISP_EOR_B  DC.B    '   EOR.B',0
00004749= 20 20 20 45 4F 52 ...   4947  DISP_EOR_W  DC.B    '   EOR.W',0
00004752= 20 20 20 45 4F 52 ...   4948  DISP_EOR_L  DC.B    '   EOR.L',0
0000475B= 20 20 20 43 4D 50 ...   4949  DISP_CMP_B  DC.B    '   CMP.B',0
00004764= 20 20 20 43 4D 50 ...   4950  DISP_CMP_W  DC.B    '   CMP.W',0
0000476D= 20 20 20 43 4D 50 ...   4951  DISP_CMP_L  DC.B    '   CMP.L',0
00004776= 20 20 20 43 4D 50 ...   4952  DISP_CMPA_W  DC.B    '   CMPA.W',0
00004780= 20 20 20 43 4D 50 ...   4953  DISP_CMPA_L  DC.B    '   CMPA.L',0
0000478A= 20 20 20 4D 55 4C ...   4954  DISP_MULS_W DC.B    '   MULS.W',0
00004794= 20 20 20 41 4E 44 ...   4955  DISP_AND_B  DC.B    '   AND.B',0
0000479D= 20 20 20 41 4E 44 ...   4956  DISP_AND_W  DC.B    '   AND.W',0
000047A6= 20 20 20 41 4E 44 ...   4957  DISP_AND_L  DC.B    '   AND.L',0
000047AF= 20 20 20 41 44 44 ...   4958  DISP_ADD_B  DC.B    '   ADD.B',0
000047B8= 20 20 20 41 44 44 ...   4959  DISP_ADD_W  DC.B    '   ADD.W',0
000047C1= 20 20 20 41 44 44 ...   4960  DISP_ADD_L  DC.B    '   ADD.L',0
000047CA= 20 20 20 41 44 44 ...   4961  DISP_ADDA_W DC.B    '   ADDA.W',0
000047D4= 20 20 20 41 44 44 ...   4962  DISP_ADDA_L DC.B    '   ADDA.L',0
000047DE= 20 20 20 4C 53 52 ...   4963  DISP_LSR_B  DC.B    '   LSR.B',0
000047E7= 20 20 20 4C 53 4C ...   4964  DISP_LSL_B  DC.B    '   LSL.B',0
000047F0= 20 20 20 4C 53 52 ...   4965  DISP_LSR_W  DC.B    '   LSR.W',0
000047F9= 20 20 20 4C 53 4C ...   4966  DISP_LSL_W  DC.B    '   LSL.W',0
00004802= 20 20 20 4C 53 52 ...   4967  DISP_LSR_L  DC.B    '   LSR.L',0
0000480B= 20 20 20 4C 53 4C ...   4968  DISP_LSL_L  DC.B    '   LSL.L',0
00004814= 20 20 20 41 53 52 ...   4969  DISP_ASR_B  DC.B    '   ASR.B',0
0000481D= 20 20 20 41 53 4C ...   4970  DISP_ASL_B  DC.B    '   ASL.B',0
00004826= 20 20 20 41 53 52 ...   4971  DISP_ASR_W  DC.B    '   ASR.W',0
0000482F= 20 20 20 41 53 4C ...   4972  DISP_ASL_W  DC.B    '   ASL.W',0
00004838= 20 20 20 41 53 52 ...   4973  DISP_ASR_L  DC.B    '   ASR.L',0
00004841= 20 20 20 41 53 4C ...   4974  DISP_ASL_L  DC.B    '   ASL.L',0
0000484A= 20 20 20 52 4F 52 ...   4975  DISP_ROR_B  DC.B    '   ROR.B',0
00004853= 20 20 20 52 4F 4C ...   4976  DISP_ROL_B  DC.B    '   ROL.B',0
0000485C= 20 20 20 52 4F 52 ...   4977  DISP_ROR_W  DC.B    '   ROR.W',0
00004865= 20 20 20 52 4F 4C ...   4978  DISP_ROL_W  DC.B    '   ROL.W',0
0000486E= 20 20 20 52 4F 52 ...   4979  DISP_ROR_L  DC.B    '   ROR.L',0
00004877= 20 20 20 52 4F 4C ...   4980  DISP_ROL_L  DC.B    '   ROL.L',0
00004880= 20 20 20 42 52 41 00    4981  DISP_BRA    DC.B    '   BRA',0
00004887= 20 20 20 42 4C 54 00    4982  DISP_BLT    DC.B    '   BLT',0
0000488E= 20 20 20 42 45 51 00    4983  DISP_BEQ    DC.B    '   BEQ',0
00004895= 20 20 20 42 4E 45 00    4984  DISP_BNE    DC.B    '   BNE',0
0000489C= 20 20 20 42 48 49 00    4985  DISP_BHI    DC.B    '   BHI',0
000048A3= 20 20 20 4D 4F 56 ...   4986  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
000048AE= 20 20 20 4D 4F 56 ...   4987  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
000048B9                          4988  
000048B9= 20 20 20 24 00          4989  DISP_HEX     DC.B    '   $',0
000048BE= 20 20 20 44 00          4990  DISP_D  DC.B    '   D',0
000048C3= 20 20 20 41 00          4991  DISP_A  DC.B    '   A',0
000048C8= 20 20 20 28 00          4992  DISP_OP  DC.B    '   (',0
000048CD= 29 00                   4993  DISP_CP  DC.B   ')',0
000048CF= 20 20 20 28 41 00       4994  DISP_AOP  DC.B    '   (A',0
000048D5                          4995  
000048D5= 20 20 20 2D 28 41 00    4996  DISP_PRE    DC.B    '   -(A',0
000048DC= 29 2B 00                4997  DISP_POST   DC.B    ')+',0
000048DF= 20 20 20 23 00          4998  DISP_LB DC.B    '   #',0
000048E4= 30 00                   4999  DISP_0  DC.B    '0',0
000048E6= 31 00                   5000  DISP_1  DC.B    '1',0
000048E8= 32 00                   5001  DISP_2  DC.B    '2',0
000048EA= 33 00                   5002  DISP_3  DC.B    '3',0
000048EC= 34 00                   5003  DISP_4  DC.B    '4',0
000048EE= 35 00                   5004  DISP_5  DC.B    '5',0
000048F0= 36 00                   5005  DISP_6  DC.B    '6',0
000048F2= 37 00                   5006  DISP_7  DC.B    '7',0
000048F4                          5007  
000048F4                          5008  *STACK INTERFACE VARIABLES*
000048F4                          5009  COUNTER         DS.W    1
000048F6                          5010  QUEUE_COUNTER   DS.W    1
000048F8                          5011  
000048F8                          5012  *EA DECODING INTERFACE VARIABLES* 
000048F8                          5013  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
000048F9                          5014  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
000048FA                          5015  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
000048FB                          5016  
000048FB                          5017  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
000048FB                          5018  * WORD + WORD = LONG
000048FB                          5019  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
000048FB                          5020  * A              + F            = AF         <= EXAMPLE
000048FB                          5021  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
000048FB                          5022  GET_DST_START_END    DS.B    1
000048FC                          5023  GET_SRC_START_END    DS.B    1
000048FD                          5024  
000048FD                          5025  *STORES THE START + END BITS HERE (FROM ABOVE)
000048FE                          5026  VAR_BYTE_START      DS.L    1
00004902                          5027  VAR_BYTE_END        DS.L    1
00004906                          5028  VAR_TEMP_CLEANCOPY  DS.L    1
0000490A                          5029  
0000490A                          5030  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
0000490E                          5031  
0000490E                          5032  *MORE FOR STACK USAGE*
0000490E= 2C 00                   5033  DISP_COMMA  DC.B    ',',0
00004910= 20 20 20 00             5034  DISP_INDENT  DC.B    '   ',0
00004914                          5035  
00004914                          5036  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004914                          5037  POINTER_WORD    DS.W       1
00004916                          5038  
00004916                          5039  
00004916                          5040  
00004916                          5041  *---------------------------------------------------------------------------*
00004916                          5042  * Ends program
00004916                          5043  *---------------------------------------------------------------------------*
00004916                          5044              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1154
ASC2HXLP2STACK      11BC
ASCII2HEX           114E
ASCII2HEX2STACK     11B6
ASC_ERR             11B0
ASC_ERR2STACK       1218
ASC_LOW             1192
ASC_LOW2STACK       11FA
ASC_NUM             11A2
ASC_NUM2STACK       120A
ASC_SFT             11AA
ASC_SFT2STACK       1212
ASC_UPP             119A
ASC_UPP2STACK       1202
CHECK0              36E2
CHECK1              376C
CHECK2              37F6
CHECK3              3890
CHECK4              3932
CHECK7              39D4
CHECK_IMMEDIATE     3AB4
CHECK_LONG          3A66
CHECK_WORD          3A20
CLEAR_RETURN        3FEA
CLEAR_STACK         3FDA
COUNTER             48F4
CR                  D
DECREMENT           3FD2
DEST_CHECK0         3B12
DEST_CHECK1         3B9C
DEST_CHECK2         3C26
DEST_CHECK3         3CC0
DEST_CHECK4         3D62
DEST_CHECK7         3E04
DEST_CHECK_IMMEDIATE  3EE4
DEST_CHECK_LONG     3E96
DEST_CHECK_WORD     3E50
DEST_LOOP_SHIFTING  3B7C
DEST_LOOP_SHIFTING1  3C06
DEST_LOOP_SHIFTING2  3C98
DEST_LOOP_SHIFTING3  3D32
DEST_LOOP_SHIFTING4  3DDC
DEST_LOOP_SHIFTING7  3E3C
DEST_MASKING_NEXT   3B8A
DEST_MASKING_NEXT1  3C14
DEST_MASKING_NEXT2  3CA6
DEST_MASKING_NEXT3  3D40
DEST_MASKING_NEXT4  3DEA
DEST_MASKING_NEXT7  3E4A
DEST_MODE           329A
DEST_REGISTER       356A
DEST_REGISTER_FORMAT  48F8
DISPLAY_30_LINES    1364
DISP_0              48E4
DISP_1              48E6
DISP_2              48E8
DISP_3              48EA
DISP_4              48EC
DISP_5              48EE
DISP_6              48F0
DISP_7              48F2
DISP_A              48C3
DISP_ADDA_L         47D4
DISP_ADDA_W         47CA
DISP_ADDQ_B         46CD
DISP_ADDQ_L         46E1
DISP_ADDQ_W         46D7
DISP_ADD_B          47AF
DISP_ADD_L          47C1
DISP_ADD_W          47B8
DISP_AND_B          4794
DISP_AND_L          47A6
DISP_AND_W          479D
DISP_AOP            48CF
DISP_ASL_B          481D
DISP_ASL_L          4841
DISP_ASL_W          482F
DISP_ASR_B          4814
DISP_ASR_L          4838
DISP_ASR_W          4826
DISP_BEQ            488E
DISP_BHI            489C
DISP_BLT            4887
DISP_BNE            4895
DISP_BRA            4880
DISP_BTST           4620
DISP_CMPA_L         4780
DISP_CMPA_W         4776
DISP_CMPI_B         4628
DISP_CMPI_L         463C
DISP_CMPI_W         4632
DISP_CMP_B          475B
DISP_CMP_L          476D
DISP_CMP_W          4764
DISP_COMMA          490E
DISP_CP             48CD
DISP_D              48BE
DISP_DATA           4646
DISP_DIVS           46EB
DISP_EORI_B         4602
DISP_EORI_L         4616
DISP_EORI_W         460C
DISP_EOR_B          4740
DISP_EOR_L          4752
DISP_EOR_W          4749
DISP_HEX            48B9
DISP_INDENT         4910
DISP_JSR            4673
DISP_LB             48DF
DISP_LEA            46B0
DISP_LSL_B          47E7
DISP_LSL_L          480B
DISP_LSL_W          47F9
DISP_LSR_B          47DE
DISP_LSR_L          4802
DISP_LSR_W          47F0
DISP_MOVEA_L        48AE
DISP_MOVEA_W        48A3
DISP_MOVEM_L        46C2
DISP_MOVEM_W        46B7
DISP_MOVE_B         464E
DISP_MOVE_L         4662
DISP_MOVE_W         4658
DISP_MULS_W         478A
DISP_NEG_B          467A
DISP_NEG_L          468C
DISP_NEG_W          4683
DISP_NEXT           4393
DISP_NOT_B          4695
DISP_NOT_L          46A7
DISP_NOT_W          469E
DISP_OP             48C8
DISP_ORI_B          45E7
DISP_ORI_L          45F9
DISP_ORI_W          45F0
DISP_POST           48DC
DISP_PRE            48D5
DISP_ROL_B          4853
DISP_ROL_L          4877
DISP_ROL_W          4865
DISP_ROR_B          484A
DISP_ROR_L          486E
DISP_ROR_W          485C
DISP_RTS            466C
DISP_SUBA_L         4736
DISP_SUBA_W         472C
DISP_SUBI_B         470E
DISP_SUBI_L         4722
DISP_SUBI_W         4718
DISP_SUB_B          46F3
DISP_SUB_L          4705
DISP_SUB_W          46FC
D_MODE000           333C
D_MODE010           3384
D_MODE011           33E4
D_MODE100           3404
D_MODE111           3456
EA_ARITH            3234
EA_DATA             1774
EA_GEN              3280
EA_MOVEA            325A
EA_NOSRC            3220
ENDLINE_M           4544
END_ADDR            109A
ERRMSG_1            442B
ERRMSG_3            444A
ERRMSG_5            446F
ERROR_1             10FE
ERROR_2             110E
ERROR_3             111E
ERROR_4             112E
ERROR_5             113E
E_ADDR_HX           4540
FINMSG              4400
GET_DISPLACEMENT_ADDRESS  3FEC
GET_DISPLACEMENT_LONG  4036
GET_DISPLACEMENT_WORD  401E
GET_DST_FAILED      3F2A
GET_DST_START_END   48FB
GET_DST_SUCCESS     3F2E
GET_EA_EA_DEST      3B00
GET_EA_EA_SRC       36D0
GET_SRC_FAILED      3AFA
GET_SRC_START_END   48FC
GET_SRC_SUCCESS     3AFE
HEX2ASCII           121E
HEX2ASCII2STACK     1260
HEX_CHAR            124C
HEX_CONT            1250
HEX_LOOP            1232
IMMD_B              350A
IMMD_L              354A
IMMD_W              352A
IMMEDIATE           34DA
INCREMENT           3FCA
INTRO               1028
IS_ODD              12A4
IS_ODD_ERR          12BA
JMPTABLE            1390
LF                  A
LONGMODE            34AE
LOOP_SHIFTING       374C
LOOP_SHIFTING1      37D6
LOOP_SHIFTING2      3868
LOOP_SHIFTING3      3902
LOOP_SHIFTING4      39AC
MAIN                12C0
MASKING_NEXT        375A
MASKING_NEXT1       37E4
MASKING_NEXT2       3876
MASKING_NEXT3       3910
MASKING_NEXT4       39BA
MODE000             3328
MODE001             3350
MODE010             3364
MODE011             33A4
MODE100             33C4
MODE111             3424
NEXTLINES           1372
OP0000              13F0
OP0000_BTST_B       155A
OP0000_CMPI         179C
OP0000_CMPI_B       1812
OP0000_CMPI_L       1862
OP0000_CMPI_W       183A
OP0000_EOR_B        1608
OP0000_EOR_L        1638
OP0000_EOR_W        1620
OP0000_ORI_B        18F6
OP0000_ORI_L        1946
OP0000_ORI_W        191E
OP0000_RETURN_BTST  158A
OP0000_RETURN_CMPI  1886
OP0000_RETURN_EOR   164C
OP0000_RETURN_ORI   196A
OP0000_RETURN_SUBI  172E
OP0000_SUB_B        16EA
OP0000_SUB_L        171A
OP0000_SUB_W        1702
OP0001              196C
OP0010              19DA
OP0011              1AD8
OP0100              1BD4
OP0101              1E2A
OP0101_ADDQ_B       1EA6
OP0101_ADDQ_B_0     1F22
OP0101_ADDQ_B_1     1F2E
OP0101_ADDQ_B_2     1F3A
OP0101_ADDQ_B_3     1F46
OP0101_ADDQ_B_4     1F52
OP0101_ADDQ_B_5     1F5E
OP0101_ADDQ_B_6     1F6A
OP0101_ADDQ_B_7     1F76
OP0101_ADDQ_B_8     1F82
OP0101_ADDQ_L       1EBE
OP0101_ADDQ_W       1EB2
OP0101_RETURN       1EC6
OP0101_RETURN2      1F8A
OP0110              1FCE
OP0111              2074
OP1000              2078
OP1000_DIVS_DN_EA_OR_EA_DN  2086
OP1000_DIVS_RETURN  216A
OP1000_EA_DN_DIVS   20B4
OP1000_PRINT_L_DIVS  2122
OP1000_PRINT_W_DIVS  20DA
OP1001              2180
OP1001_ADD_RETURN   24CE
OP1001_DETERMINE_DN_EA_OR_EA_DN  2296
OP1001_DN_EA        22CE
OP1001_EA_DN        23CE
OP1001_PRINT_B      23F6
OP1001_PRINT_B2     22F6
OP1001_PRINT_L      2486
OP1001_PRINT_L2     2386
OP1001_PRINT_W      243E
OP1001_PRINT_W2     233E
OP1001_SUBA_L       21B2
OP1001_SUBA_W       2224
OP1010              253C
OP1011              2540
OP1011_CMP          259A
OP1011_CMPA         264C
OP1011_CMPA_L       26C6
OP1011_CMPA_W       26BA
OP1011_CMP_B        260E
OP1011_CMP_L        2626
OP1011_CMP_W        261A
OP1011_EOR          26EC
OP1011_EOR_B        2760
OP1011_EOR_L        2778
OP1011_EOR_W        276C
OP1011_RETURN       2780
OP1011_RETURN_CMP   262E
OP1011_RETURN_CMPA  26CE
OP1100              2840
OP1100_AND_RETURN   2B90
OP1100_DETERMINE_DN_EA_OR_EA_DN  2956
OP1100_DN_EA        2990
OP1100_EA_DN        2A90
OP1100_EA_DN_MULS   289E
OP1100_MULS_DN_EA_OR_EA_DN  2870
OP1100_MULS_RETURN  2954
OP1100_PRINT_B      2AB8
OP1100_PRINT_B2     29B8
OP1100_PRINT_L      2B48
OP1100_PRINT_L2     2A48
OP1100_PRINT_L_MULS  290C
OP1100_PRINT_W      2B00
OP1100_PRINT_W2     2A00
OP1100_PRINT_W_MULS  28C4
OP1101              2B92
OP1101_ADDA_L       2BC4
OP1101_ADDA_W       2C36
OP1101_ADD_RETURN   2EE0
OP1101_DETERMINE_DN_EA_OR_EA_DN  2CA8
OP1101_DN_EA        2CE0
OP1101_EA_DN        2DE0
OP1101_PRINT_B      2E08
OP1101_PRINT_B2     2D08
OP1101_PRINT_L      2E98
OP1101_PRINT_L2     2D98
OP1101_PRINT_W      2E50
OP1101_PRINT_W2     2D50
OP1110              2F6E
OP1111              321C
OP_ADDA_L           2F56
OP_ADDA_W           2F3E
OP_ADDQ_B           1F98
OP_ADDQ_L           1FBC
OP_ADDQ_W           1FAA
OP_ADD_B            2EF6
OP_ADD_L            2F26
OP_ADD_W            2F0E
OP_ASL              310E
OP_ASL_B            3132
OP_ASL_L            3144
OP_ASL_W            3156
OP_ASR              30B4
OP_ASR_B            30D8
OP_ASR_L            30EA
OP_ASR_W            30FC
OP_ASX              2FD0
OP_BEQ              2032
OP_BHI              2016
OP_BLT              2066
OP_BNE              2024
OP_BRA              2040
OP_BTST             147A
OP_BTST_IMMEDIATE   1504
OP_CMPA_L           27B0
OP_CMPA_W           279E
OP_CMP_B            27C2
OP_CMP_L            27F2
OP_CMP_W            27DA
OP_DATA             1750
OP_DIVS             216C
OP_EORI             158C
OP_EOR_B            280A
OP_EOR_L            282E
OP_EOR_W            281C
OP_JSR              1DFC
OP_LEA              1C82
OP_LEA_DN_EA_OR_EA_DN  1C90
OP_LEA_RETURN       1CEE
OP_LSL              305A
OP_LSL_B            307E
OP_LSL_L            3090
OP_LSL_W            30A2
OP_LSR              3000
OP_LSR_B            3024
OP_LSR_L            3036
OP_LSR_W            3048
OP_LSX              2FB8
OP_MOVEA_L          1A68
OP_MOVEA_W          1B64
OP_MOVEM_L          1C70
OP_MOVEM_W          1C5E
OP_MOVE_B           1972
OP_MOVE_L           1A00
OP_MOVE_W           1AFC
OP_MULS             2862
OP_NEG              1CF0
OP_NEG_B            1D3C
OP_NEG_L            1D54
OP_NEG_PRINT_EA     1D60
OP_NEG_W            1D48
OP_NOT              1D76
OP_NOT_B            1DC2
OP_NOT_L            1DDA
OP_NOT_PRINT_EA     1DE6
OP_NOT_W            1DCE
OP_ORI              1888
OP_PRINT_L_LEA      1CAE
OP_ROL              31C2
OP_ROL_B            31E6
OP_ROL_L            31F8
OP_ROL_W            320A
OP_ROR              3168
OP_ROR_B            318C
OP_ROR_L            319E
OP_ROR_W            31B0
OP_ROX              2FE8
OP_RTS              1E10
OP_SUBA_L           252A
OP_SUBA_W           2518
OP_SUBI             166E
OP_SUB_B            24D0
OP_SUB_L            2500
OP_SUB_W            24E8
OUTPUT_PROCESSED_DATA  1344
POINTER_WORD        4914
POP_FRONT           3F84
POP_FRONT_RETURN    3FBE
POP_RETURN          3F82
POP_SHIFT_LOOP      3FA0
POP_STACK           3F76
PRINT_QUEUE         3F4A
PRINT_QUEUE_HELPER  3F56
PRINT_QUEUE_RETURN  3F6C
PRINT_STACK         3F30
PRINT_STACK_HELPER  3F3C
PRINT_STACK_RETURN  3F48
PROGLP              100A
PROMPT_END          4366
PROMPT_START        4337
PUSH_STACK          3F6E
QUEUE_COUNTER       48F6
REG_0               361E
REG_1               362C
REG_2               363A
REG_3               3648
REG_4               3656
REG_5               3664
REG_6               3672
REG_7               3680
REPEAT              368E
REPEATMSG           43BD
RETURN              11B4
RETURN2STACK        121C
SRC_LOOP_SHIFTING   3A0C
SRC_MASKING_NEXT    3A1A
SRC_MODE            32DE
SRC_REGISTER        35C6
SRC_REGISTER_FORMAT  48F9
STACK               7000
STACK_HEX_CHAR      128E
STACK_HEX_CONT      1292
STACK_HEX_LOOP      1274
START               1004
START_ADDR          1048
S_ADDR_HX           453C
TEMP_REGISTER_FORMAT  48FA
TERMINATE           4050
TESTING             1036
TMPINPUT            4547
TMPOUTPUT           4597
VAR_BYTE_END        4902
VAR_BYTE_START      48FE
VAR_LONG_ADDRESS_MODE_CHECK  490A
VAR_TEMP_CLEANCOPY  4906
VR_E_ADDR           44EC
VR_S_ADDR           449C
WELCOME             4062
WORDMODE            3482
