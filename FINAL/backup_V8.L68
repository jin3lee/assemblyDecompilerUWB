00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 6:03:19 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001052             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010A4             38              JSR     END_ADDR
00001016  43F9 000045D6             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012CA             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 000040F4             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  E228                      53              LSR.B   D1,D0
00001038  EA08                      54              LSR.B   #5,D0
0000103A  EA48                      55              LSR.W   #5,D0
0000103C  E2D1                      56              LSR.W   (A1)
0000103E  E2DA                      57              LSR.W   (A2)+
00001040  E2E3                      58              LSR.W   -(A3)
00001042  E2F8 1234                 59              LSR.W   $1234
00001046  E2F9 12345678             60              LSR.W   $12345678   
0000104C  E2A8                      61              LSR.L   D1,D0
0000104E  EA88                      62              LSR.L   #5,D0
00001050                            63  
00001050                            64  
00001050                            65  
00001050  4E75                      66              RTS
00001052                            67  *---------------------------------------------------------------------------*
00001052                            68  * START_ADDR: Compute the starting address
00001052                            69  *---------------------------------------------------------------------------*
00001052                            70  START_ADDR
00001052                            71              * Output
00001052  43F9 000043C9             72              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001058  103C 000E                 73              MOVE.B  #14,D0                  * Display PROMPT_START
0000105C  4E4F                      74              TRAP    #15
0000105E                            75      
0000105E                            76              * Input
0000105E  43F9 0000452E             77              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
00001064  103C 0002                 78              MOVE.B  #2,D0                   * Ask user for input
00001068  4E4F                      79              TRAP    #15
0000106A                            80              
0000106A                            81              * Error Checking (length)
0000106A  0C01 0000                 82              CMPI.B  #0, D1                  * Check if input length <= 0
0000106E  6F00 0098                 83              BLE     ERROR_1
00001072  0C01 0008                 84              CMPI.B  #8, D1                  * Check if input length > 8
00001076  6E00 0090                 85              BGT     ERROR_1
0000107A                            86              
0000107A                            87              * Conversion & Storage
0000107A  4EB9 00001158             88              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001080  0C07 0001                 89              CMPI.B  #1, D7                  * Check for error
00001084  6700 0082                 90              BEQ     ERROR_1                 
00001088  23C1 000045CE             91              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
0000108E                            92              
0000108E                            93              * Error Checking (Odd)
0000108E  43F9 000045CE             94              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
00001094  4EB9 000012AE             95              JSR     IS_ODD                  * Check if the input address is odd
0000109A  0C07 0001                 96              CMPI.B  #1, D7                  * Check for error
0000109E  6700 0088                 97              BEQ     ERROR_3
000010A2                            98              
000010A2                            99              * Return
000010A2  4E75                     100              RTS     
000010A4                           101  *---------------------------------------------------------------------------*
000010A4                           102  * END_ADDR: Compute the ending address
000010A4                           103  *---------------------------------------------------------------------------*
000010A4                           104  END_ADDR
000010A4                           105              * Output
000010A4  43F9 000043F8            106              LEA     PROMPT_END,A1           * Load PROMPT_END
000010AA  103C 000E                107              MOVE.B  #14,D0                  * Display PROMPT_END
000010AE  4E4F                     108              TRAP    #15
000010B0                           109  
000010B0                           110              * Input
000010B0  43F9 0000457E            111              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010B6  103C 0002                112              MOVE.B  #2,D0                   * Ask user for input
000010BA  4E4F                     113              TRAP    #15
000010BC                           114              
000010BC                           115              * Error Checking (length)
000010BC  0C01 0000                116              CMPI.B  #0, D1                  * Check if input length <= 0
000010C0  6F00 0056                117              BLE     ERROR_2
000010C4  0C01 0008                118              CMPI.B  #8, D1                  * Check if input length > 8
000010C8  6E00 004E                119              BGT     ERROR_2
000010CC                           120              
000010CC                           121              * Conversion & Storage
000010CC  4EB9 00001158            122              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010D2  0C07 0001                123              CMPI.B  #1, D7                  * Check for error
000010D6  6700 0040                124              BEQ     ERROR_2
000010DA  23C1 000045D2            125              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010E0                           126              
000010E0                           127              * Error Checking (start > end case)
000010E0  2439 000045CE            128              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010E6  B282                     129              CMP.L   D2, D1                  * Compare starting and ending address
000010E8  6300 005E                130              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010EC                           131              
000010EC                           132              * Error Checking (Odd case)
000010EC  43F9 000045D2            133              LEA     E_ADDR_HX, A1           * Move the ending address
000010F2  4EB9 000012AE            134              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010F8  0C07 0001                135              CMPI.B  #1, D7                  * Check for an error flag
000010FC  6700 003A                136              BEQ     ERROR_4
00001100                           137              
00001100                           138              * Inputs are valid
00001100  2A79 000045CE            139              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
00001106                           140              
00001106  4E75                     141              RTS
00001108                           142              
00001108                           143  *---------------------------------------------------------------------------*
00001108                           144  * ERROR_1: Address error (Invalid starting address)
00001108                           145  *---------------------------------------------------------------------------*
00001108                           146  ERROR_1
00001108  43F9 000044BD            147              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000110E  103C 000E                148              MOVE.B  #14, D0                 * Display ERRMSG_1
00001112  4E4F                     149              TRAP    #15
00001114  4EF8 1052                150              JMP     START_ADDR              * Jump to START_ADDR
00001118                           151      
00001118                           152  *---------------------------------------------------------------------------*
00001118                           153  * ERROR_2: Address error (Invalid ending address)
00001118                           154  *---------------------------------------------------------------------------*
00001118                           155  ERROR_2
00001118  43F9 000044BD            156              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000111E  103C 000E                157              MOVE.B  #14, D0                 * Display ERRMSG_1
00001122  4E4F                     158              TRAP    #15
00001124  4EF8 10A4                159              JMP     END_ADDR                * Jump to END_ADDR
00001128                           160  
00001128                           161  *---------------------------------------------------------------------------*
00001128                           162  * ERROR_3: Address error (Odd starting address)
00001128                           163  *---------------------------------------------------------------------------*
00001128                           164  ERROR_3
00001128  43F9 000044DC            165              LEA     ERRMSG_3, A1
0000112E  103C 000E                166              MOVE.B  #14, D0
00001132  4E4F                     167              TRAP    #15
00001134  4EF8 1052                168              JMP     START_ADDR
00001138                           169     
00001138                           170  *---------------------------------------------------------------------------*
00001138                           171  * ERROR_4: Address error (Odd ending address)
00001138                           172  *---------------------------------------------------------------------------*         
00001138                           173  ERROR_4
00001138  43F9 000044DC            174              LEA     ERRMSG_3, A1
0000113E  103C 000E                175              MOVE.B  #14, D0
00001142  4E4F                     176              TRAP    #15
00001144  4EF8 10A4                177              JMP     END_ADDR
00001148                           178            
00001148                           179  *---------------------------------------------------------------------------*
00001148                           180  * ERROR_3: Address error (Ending address is less than starting address)
00001148                           181  *---------------------------------------------------------------------------*
00001148                           182  ERROR_5
00001148  43F9 00004501            183              LEA     ERRMSG_5, A1
0000114E  103C 000E                184              MOVE.B  #14, D0
00001152  4E4F                     185              TRAP    #15
00001154  4EF8 10A4                186              JMP     END_ADDR
00001158                           187    
00001158                           188  *---------------------------------------------------------------------------*
00001158                           189  * ASCII2HEX: Convert ASCii to Hexadecimal
00001158                           190  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001158                           191  *---------------------------------------------------------------------------*
00001158  4281                     192  ASCII2HEX   CLR.L   D1                      * Clear the destination 
0000115A  4287                     193              CLR.L   D7                      * Set the error flag to 0
0000115C  4282                     194              CLR.L   D2                      * Clear D2 for temp storage
0000115E                           195              
0000115E  1419                     196  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001160  0C02 0000                197              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
00001164  6700 0058                198              BEQ     RETURN                  * If it's NULL, go to return
00001168  0C02 0066                199              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
0000116C  6E00 004C                200              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001170  0C02 0061                201              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
00001174  6C00 0026                202              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001178  0C02 0046                203              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
0000117C  6E00 003C                204              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001180  0C02 0041                205              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
00001184  6C00 001E                206              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001188  0C02 0039                207              CMPI.B  #57, D2                 * Decimal value of 9 is 57
0000118C  6E00 002C                208              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001190  0C02 0030                209              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
00001194  6C00 0016                210              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
00001198  6000 0020                211              BRA     ASC_ERR                 * Invalid input
0000119C                           212  
0000119C  0442 0057                213  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011A0  6000 0012                214              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A4                           215              
000011A4  0442 0037                216  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011A8  6000 000A                217              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AC                           218              
000011AC  0442 0030                219  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011B0  6000 0002                220              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011B4                           221              
000011B4  E981                     222  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011B6  D202                     223              ADD.B   D2, D1                  * Add the converted input to D1
000011B8  60A4                     224              BRA     ASC2HXLP                * Loop
000011BA                           225  
000011BA  1E3C 0001                226  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011BE  4E75                     227  RETURN      RTS     
000011C0                           228  
000011C0                           229  *---------------------------------------------------------------------------*
000011C0                           230  * ASCII2HEX: Convert ASCii to Hexadecimal
000011C0                           231  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011C0                           232  *---------------------------------------------------------------------------*
000011C0                           233  ASCII2HEX2STACK
000011C0  4283                     234              CLR.L   D3                      * Clear the destination 
000011C2  4287                     235              CLR.L   D7                      * Set the error flag to 0
000011C4  4282                     236              CLR.L   D2                      * Clear D2 for temp storage
000011C6                           237              
000011C6                           238  ASC2HXLP2STACK
000011C6  1419                     239              MOVE.B  (A1)+, D2               * Read a byte to D2
000011C8  0C02 0000                240              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011CC  6700 0058                241              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011D0  0C02 0066                242              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011D4  6E00 004C                243              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011D8  0C02 0061                244              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011DC  6C00 0026                245              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011E0  0C02 0046                246              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011E4  6E00 003C                247              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011E8  0C02 0041                248              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011EC  6C00 001E                249              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011F0  0C02 0039                250              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011F4  6E00 002C                251              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
000011F8  0C02 0030                252              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011FC  6C00 0016                253              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
00001200  6000 0020                254              BRA     ASC_ERR2STACK                 * Invalid input
00001204                           255  
00001204                           256  ASC_LOW2STACK
00001204  0442 0057                257              SUBI    #87, D2                 * Convert the ASCII input to Hex
00001208  6000 0012                258              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
0000120C                           259              
0000120C                           260  ASC_UPP2STACK
0000120C  0442 0037                261              SUBI    #55, D2                 * Convert the ASCII input to Hex
00001210  6000 000A                262              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
00001214                           263              
00001214                           264  ASC_NUM2STACK
00001214  0442 0030                265              SUBI    #48, D2                 * Convert the ASCII input to Hex
00001218  6000 0002                266              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
0000121C                           267              
0000121C                           268  ASC_SFT2STACK
0000121C  E983                     269              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
0000121E  D602                     270              ADD.B   D2, D3                  * Add the converted input to D1
00001220  60A4                     271              BRA     ASC2HXLP2STACK                * Loop
00001222                           272  
00001222                           273  ASC_ERR2STACK
00001222  1E3C 0001                274              MOVE.B  #1, D7                  * Set the error flag to 1            
00001226                           275  RETURN2STACK
00001226  4E75                     276              RTS  
00001228                           277  *---------------------------------------------------------------------------*
00001228                           278  * HEX2ASCII: Convert Hexadecimal to ASCii 
00001228                           279  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001228                           280  *---------------------------------------------------------------------------*
00001228  0C02 0008                281  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
0000122C  6700 000E                282              BEQ     HEX_LOOP
00001230  4841                     283              SWAP    D1
00001232  0C02 0002                284              CMPI.B  #2,D2
00001236  6600 0004                285              BNE     HEX_LOOP
0000123A  E189                     286              LSL.L   #8,D1
0000123C                           287             
0000123C  E999                     288  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
0000123E  2601                     289              MOVE.L  D1, D3                  * Move D1 to D3
00001240  0283 0000000F            290              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001246  0C03 0009                291              CMPI.B  #9, D3                  * Compare te digit
0000124A  6E00 000A                292              BGT     HEX_CHAR              
0000124E  0603 0030                293              ADDI.B  #48,D3                  * Add 48 for numerical output
00001252  6000 0006                294              BRA     HEX_CONT
00001256                           295              
00001256  0603 0037                296  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
0000125A                           297  
0000125A  12C3                     298  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
0000125C  5342                     299              SUBI    #1, D2                  * Decrement the size
0000125E  0C02 0000                300              CMPI.B  #0, D2                  * Check if D2 is 0
00001262  66D8                     301              BNE     HEX_LOOP                * Loop
00001264  12BC 0000                302              MOVE.B  #$0,(A1)                * Null terminator
00001268  4E75                     303              RTS
0000126A                           304  *---------------------------------------------------------------------------*
0000126A                           305  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
0000126A                           306  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
0000126A                           307  *---------------------------------------------------------------------------*
0000126A                           308  HEX2ASCII2STACK
0000126A  0C02 0008                309              CMPI.B  #8, D2                  * Check to see if the size is long
0000126E  6700 000E                310              BEQ     STACK_HEX_LOOP
00001272  4841                     311              SWAP    D1
00001274  0C02 0002                312              CMPI.B  #2,D2
00001278  6600 0004                313              BNE     STACK_HEX_LOOP
0000127C  E189                     314              LSL.L   #8,D1
0000127E                           315             
0000127E                           316  STACK_HEX_LOOP    
0000127E  E999                     317              ROL.L   #4, D1                  * Roll D1 to left
00001280  2601                     318              MOVE.L  D1, D3                  * Move D1 to D3
00001282  0283 0000000F            319              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001288  0C03 0009                320              CMPI.B  #9, D3                  * Compare te digit
0000128C  6E00 000A                321              BGT     STACK_HEX_CHAR              
00001290  0603 0030                322              ADDI.B  #48,D3                  * Add 48 for numerical output
00001294  6000 0006                323              BRA     STACK_HEX_CONT
00001298                           324              
00001298                           325  STACK_HEX_CHAR    
00001298  0603 0037                326              ADDI.B  #55,D3                  * Add 55 for character output
0000129C                           327  
0000129C                           328  STACK_HEX_CONT    
0000129C  6100 2D62                329              BSR     PUSH_STACK              *PLACE INTO STACK
000012A0  5342                     330              SUBI    #1, D2                  * Decrement the size
000012A2  0C02 0000                331              CMPI.B  #0, D2                  * Check if D2 is 0
000012A6  66D6                     332              BNE     STACK_HEX_LOOP                * Loop
000012A8  12BC 0000                333              MOVE.B  #$0,(A1)                * Null terminator
000012AC  4E75                     334              RTS
000012AE                           335  
000012AE                           336  
000012AE                           337  *---------------------------------------------------------------------------*
000012AE                           338  * IS_ODD: Check whether the source address is odd
000012AE                           339  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
000012AE                           340  *---------------------------------------------------------------------------*
000012AE  4281                     341  IS_ODD      CLR.L   D1                      * Clear the result
000012B0  4287                     342              CLR.L   D7                      * Set the error flag to 0
000012B2  2211                     343              MOVE.L  (A1),D1                * Temp store the checking address to D1
000012B4  82FC 0002                344              DIVU    #2, D1                  * Divide the result by 2
000012B8  4841                     345              SWAP    D1                      * Swap remainder with quotient
000012BA  0C01 0001                346              CMPI.B  #1, D1                  * Check for error
000012BE  6700 0004                347              BEQ     IS_ODD_ERR
000012C2  4E75                     348              RTS
000012C4                           349              
000012C4  1E3C 0001                350  IS_ODD_ERR  MOVE.B  #1, D7
000012C8  4E75                     351              RTS
000012CA                           352  
000012CA                           353  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012CA                           354  * MAINDEBUG                    
000012CA                           355  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012CA                           356  * A5: Processing address
000012CA                           357  *
000012CA                           358  * D3: USED FOR PUSHING INTO STACK
000012CA                           359  *     To push into stack => MOVE.W #DATA,D3 
000012CA                           360  *                           BSR    PUSH_STACK
000012CA                           361  *     To print stack     => BSR    PRINT_STACK 
000012CA                           362  *     To clear stack     => BSR    CLEAR_STACK
000012CA                           363  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012CA                           364  MAIN        
000012CA                           365              *initialize stack pointer
000012CA  33FC 0000 00004986       366              MOVE.W  #0,COUNTER
000012D2  347C 7000                367              MOVEA.W #STACK,A2
000012D6  163C 0020                368              MOVE.B  #' ',D3
000012DA  6100 2D24                369              BSR     PUSH_STACK
000012DE  6100 2D20                370              BSR     PUSH_STACK
000012E2  6100 2D1C                371              BSR     PUSH_STACK
000012E6                           372              
000012E6                           373              * clear registers for temp storage
000012E6  4280                     374              CLR.L   D0                   
000012E8  4281                     375              CLR.L   D1                   
000012EA  227C 00000000            376              MOVEA.L #0, A1                
000012F0                           377              
000012F0  220D                     378              MOVE.L  A5,D1                   * check to see if the address is fully read
000012F2  23CD 000045CE            379              MOVE.L  A5,S_ADDR_HX
000012F8  B2B9 000045D2            380              CMP.L   E_ADDR_HX,D1
000012FE  6C00 2420                381              BGE     REPEAT                  * go to repeat for user action
00001302                           382  
00001302  43F9 00004629            383              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001308  143C 0008                384              MOVE.B  #8,D2                   * set the output size
0000130C  4EB8 1228                385              JSR     HEX2ASCII               
00001310  43F9 00004629            386              LEA     TMPOUTPUT,A1
00001316  103C 000E                387              MOVE.B  #14,D0
0000131A  4E4F                     388              TRAP    #15
0000131C                           389              
0000131C  4285                     390              CLR.L    D5                      * clear the processing data
0000131E  3A1D                     391              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
00001320                           392                                               * advance the current instruction pointer to the next
00001320                           393                                               * instruction in memory
00001320                           394  *----------------------------------------*
00001320                           395  * Registers          
00001320                           396  * [D1] - COPY OF D5
00001320                           397  * [D5] - DATA TO BE PROCESSED
00001320                           398  * [D6] - COUNTER FOR LINES PROCESSED
00001320                           399  *
00001320                           400  * [D4]      - ERROR FLAG BEFORE PRINTING
00001320                           401  * [STACK]   - PRINTS PROCESS DATA
00001320                           402  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
00001320                           403  *
00001320                           404  * [A1] - USED FOR JUMPING/PRINTING
00001320                           405  *
00001320                           406  *----------------------------------------*
00001320                           407  
00001320                           408              
00001320                           409              *Processing the first 4 most significant bits 
00001320  2205                     410              MOVE.L  D5,D1                    * copy the current processing data to D1
00001322  143C 000C                411              MOVE.B  #12,D2                   * shift to right by 12 bits
00001326  E469                     412              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
00001328  C2FC 0006                413              MULU    #6,D1                    * form offset
0000132C  43F9 0000139A            414              LEA     JMPTABLE,A1              * index into table
00001332  4EB1 1000                415              JSR     0(A1,D1)                 * jump indirect with index
00001336                           416              
00001336                           417              *SECURED EA*
00001336  B83C 0001                418              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
0000133A  6600 0012                419              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
0000133E  6100 041A                420              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001342  6100 2D28                421              BSR     CLEAR_STACK              * CLEARS THE STACK 
00001346  183C 0000                422              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000134A  6000 0022                423              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
0000134E                           424             
0000134E                           425  OUTPUT_PROCESSED_DATA       
0000134E  163C 000D                426              MOVE.B  #$D,D3                  *carriage return
00001352  6100 2CAC                427              BSR     PUSH_STACK
00001356  163C 000A                428              MOVE.B  #$A,D3                  *new line feed
0000135A  6100 2CA4                429              BSR     PUSH_STACK
0000135E  163C 0000                430              MOVE.B  #$0,D3                  *null
00001362  6100 2C9C                431              BSR     PUSH_STACK
00001366                           432       
00001366  6100 2C74                433              BSR     PRINT_QUEUE
0000136A  183C 0000                434              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000136E                           435  DISPLAY_30_LINES
0000136E                           436              * display 30 lines per page
0000136E  5206                     437              ADDI.B  #1,D6
00001370  0C06 001E                438              CMPI.B  #30,D6
00001374  6C00 0006                439              BGE     NEXTLINES
00001378  6000 FF50                440              BRA     MAIN
0000137C                           441            
0000137C                           442  *---------------------------------------------------------------------------*
0000137C                           443  * NEXTLINES: receive input from user to print the next 30 lines
0000137C                           444  *---------------------------------------------------------------------------*  
0000137C  4206                     445  NEXTLINES   CLR.B   D6
0000137E  43F9 00004425            446              LEA     DISP_NEXT,A1
00001384  103C 000E                447              MOVE.B  #14,D0
00001388  4E4F                     448              TRAP    #15
0000138A  43F9 000045D9            449              LEA     TMPINPUT,A1
00001390  103C 0002                450              MOVE.B  #2,D0
00001394  4E4F                     451              TRAP    #15
00001396  4EF8 12CA                452              JMP     MAIN
0000139A                           453    
0000139A                           454  *---------------------------------------------------------------------------*
0000139A                           455  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
0000139A                           456  *---------------------------------------------------------------------------*  
0000139A  4EF9 000013FA            457  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - 
000013A0  4EF9 00001976            458              JMP     OP0001  * MOVE.B                                        *FINISHED - 
000013A6  4EF9 000019E4            459              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - 
000013AC  4EF9 00001AE2            460              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - 
000013B2  4EF9 00001BDE            461              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - 
000013B8  4EF9 00001E34            462              JMP     OP0101  * ADDQ                                          *FINISHED - 
000013BE  4EF9 00001FD8            463              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *FINISHED - 
000013C4  4EF9 000020DE            464              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013CA  4EF9 000020E2            465              JMP     OP1000  * DIVS                                          *FINISHED - 
000013D0  4EF9 000021EA            466              JMP     OP1001  * SUB/SUBA                                      *FINISHED - 
000013D6  4EF9 000025A6            467              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013DC  4EF9 000025AA            468              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - 
000013E2  4EF9 000028AA            469              JMP     OP1100  * MULS/AND                                      *FINISHED - 
000013E8  4EF9 00002BFC            470              JMP     OP1101  * ADD/ADDA                                      *FINISHED - 
000013EE  4EF9 00002FD8            471              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
000013F4  4EF9 000032AE            472              JMP     OP1111  * Special/Reserved
000013FA                           473              
000013FA                           474  *---------------------------------------------------------------------------*
000013FA                           475  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013FA                           476  *---------------------------------------------------------------------------*           
000013FA                           477  OP0000                                                                                  
000013FA  4281                     478              CLR.L   D1          * to temporarily store the address to process
000013FC  4280                     479              CLR.L   D0  
000013FE  4284                     480              CLR.L   D4                 
00001400  227C 00000000            481              MOVEA.L #0, A1                
00001406                           482              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001406                           483              * Check if bit 11,10,9,8 are 0000)
00001406  2205                     484              MOVE.L  D5,D1
00001408  0281 00000F00            485              ANDI.L  #$0F00,D1
0000140E  0C81 00000000            486              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
00001414  6700 047C                487              BEQ     OP_ORI
00001418                           488  
00001418                           489              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
00001418                           490              * check if bit 11,10,9,8 are 1100
00001418  4281                     491              CLR.L   D1
0000141A  2205                     492              MOVE.L  D5,D1
0000141C  0281 00000F00            493              ANDI.L  #$0F00,D1
00001422  0C81 00000C00            494              CMPI.L  #$0C00,D1
00001428  6700 037C                495              BEQ     OP0000_CMPI
0000142C                           496              
0000142C                           497              * check for SUBI
0000142C  4281                     498              CLR.L   D1
0000142E  2205                     499              MOVE.L  D5,D1
00001430  0281 00000F00            500              ANDI.L  #$0F00,D1
00001436  0C81 00000400            501              CMPI.L  #$0400,D1
0000143C  6700 023A                502              BEQ     OP_SUBI
00001440                           503              
00001440                           504              * check for EORI
00001440  4281                     505              CLR.L   D1
00001442  2205                     506              MOVE.L  D5,D1
00001444  0281 00000F00            507              ANDI.L  #$0F00,D1
0000144A  0C81 00000A00            508              CMPI.L  #$0A00,D1
00001450  6700 0144                509              BEQ     OP_EORI
00001454                           510              
00001454                           511              * check for BTST
00001454  4281                     512              CLR.L   D1
00001456  2205                     513              MOVE.L  D5,D1
00001458  E099                     514              ROR.L   #8,D1
0000145A  0281 00000001            515              ANDI.L  #$1,D1
00001460  0C01 0001                516              CMPI.B  #$1,D1
00001464  6700 001E                517              BEQ     OP_BTST
00001468  4281                     518              CLR.L   D1
0000146A  2205                     519              MOVE.L  D5,D1
0000146C  EC99                     520              ROR.L   #6,D1
0000146E  0281 000003FF            521              ANDI.L  #$03FF,D1
00001474  0C81 00000020            522              CMPI.L  #%000100000,D1
0000147A  6700 0008                523              BEQ     OP_BTST
0000147E                           524  
0000147E                           525  
0000147E                           526              * OP0000 series other than ORI/CMPI/BTST/EORI
0000147E  4EF9 0000175A            527              JMP     OP_DATA
00001484                           528              
00001484                           529  *---------------------------------------------------------------------------*
00001484                           530  * OP_BTST: display BTST
00001484                           531  *---------------------------------------------------------------------------* 
00001484                           532  OP_BTST       
00001484                           533              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
00001484                           534              *bits #8 indicates which
00001484                           535              *0 - #immediate format
00001484                           536              *1 - Dn format
00001484  4281                     537              CLR.L   D1
00001486  2205                     538              MOVE.L  D5,D1
00001488  E099                     539              ROR.L   #8,D1
0000148A  0281 00000001            540              ANDI.L  #1,D1
00001490  0C01 0001                541              CMPI.B  #1,D1
00001494  6600 0078                542              BNE     OP_BTST_IMMEDIATE
00001498                           543  
00001498                           544             
00001498                           545             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001498  13FC 0000 0000498A       546             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014A0  13FC 0002 0000498B       547             MOVE.B   #$02,SRC_REGISTER_FORMAT
000014A8                           548             
000014A8                           549             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014A8  13FC 00B9 0000498D       550             MOVE.B   #$B9,GET_DST_START_END
000014B0  13FC 0020 0000498E       551             MOVE.B   #$20,GET_SRC_START_END
000014B8                           552             
000014B8  0285 0000FE3F            553             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014BE  0685 00000000            554             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014C4                           555              
000014C4                           556              *CLEAR D3
000014C4  4283                     557              CLR.L   D3
000014C6                           558              *LOAD STACK WITH THIS OPMODE
000014C6  6100 2B38                559              BSR     PUSH_STACK
000014CA  163C 0042                560              MOVE.B  #'B',D3
000014CE  6100 2B30                561              BSR     PUSH_STACK
000014D2  163C 0054                562              MOVE.B  #'T',D3
000014D6  6100 2B28                563              BSR     PUSH_STACK
000014DA  163C 0053                564              MOVE.B  #'S',D3
000014DE  6100 2B20                565              BSR     PUSH_STACK
000014E2  163C 0054                566              MOVE.B  #'T',D3
000014E6  6100 2B18                567              BSR     PUSH_STACK
000014EA  163C 002E                568              MOVE.B  #'.',D3
000014EE  6100 2B10                569              BSR     PUSH_STACK
000014F2  163C 0042                570              MOVE.B  #'B',D3
000014F6  6100 2B08                571              BSR     PUSH_STACK
000014FA                           572              
000014FA  6100 2696                573              BSR     GET_EA_EA_DEST
000014FE  163C 002C                574              MOVE.B  #',',D3
00001502  6100 2AFC                575              BSR     PUSH_STACK
00001506  6100 225A                576              BSR     GET_EA_EA_SRC
0000150A                           577              
0000150A  6000 0088                578              BRA     OP0000_RETURN_BTST
0000150E                           579              
0000150E                           580              
0000150E                           581              *MOVE **** OR **** CMPI
0000150E                           582              
0000150E                           583  OP_BTST_IMMEDIATE              
0000150E                           584   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000150E  13FC 0000 0000498A       585             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001516  13FC 0082 0000498B       586             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000151E                           587             
0000151E                           588             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000151E  13FC 00B9 0000498D       589             MOVE.B   #$B9,GET_DST_START_END
00001526  13FC 0020 0000498E       590             MOVE.B   #$20,GET_SRC_START_END
0000152E                           591             
0000152E                           592              *CLEAR D3
0000152E  4283                     593              CLR.L   D3
00001530                           594              *LOAD STACK WITH THIS OPMODE
00001530  6100 2ACE                595              BSR     PUSH_STACK
00001534  163C 0042                596              MOVE.B  #'B',D3
00001538  6100 2AC6                597              BSR     PUSH_STACK
0000153C  163C 0054                598              MOVE.B  #'T',D3
00001540  6100 2ABE                599              BSR     PUSH_STACK
00001544  163C 0053                600              MOVE.B  #'S',D3
00001548  6100 2AB6                601              BSR     PUSH_STACK
0000154C  163C 0054                602              MOVE.B  #'T',D3
00001550  6100 2AAE                603              BSR     PUSH_STACK
00001554  163C 002E                604              MOVE.B  #'.',D3
00001558  6100 2AA6                605              BSR     PUSH_STACK
0000155C  163C 0042                606              MOVE.B  #'B',D3
00001560  6100 2A9E                607              BSR     PUSH_STACK
00001564                           608  
00001564                           609  OP0000_BTST_B
00001564                           610              *GET DATA FROM ADDQ AND PRINT #0-8
00001564                           611              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001564  0285 0000F03F            612              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000156A  0685 000001C0            613              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001570                           614  
00001570                           615              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001570                           616             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001570                           617             * MOVE.W    (A5)+,D1
00001570                           618             * MOVE.B  #' ',D3
00001570                           619             * BSR     PUSH_STACK
00001570                           620             * MOVE.B  #'#',D3
00001570                           621             * BSR     PUSH_STACK
00001570                           622             * BSR     HEX2ASCII2STACK
00001570                           623             * BSR     PUSH_STACK
00001570                           624              
00001570  163C 0020                625              MOVE.B  #' ',D3
00001574  6100 2A8A                626              BSR     PUSH_STACK
00001578  163C 0023                627              MOVE.B  #'#',D3
0000157C  6100 2A82                628              BSR     PUSH_STACK
00001580  6100 2610                629              BSR     GET_EA_EA_DEST
00001584  163C 002C                630              MOVE.B  #',',D3
00001588  6100 2A76                631              BSR     PUSH_STACK
0000158C  6100 21D4                632              BSR     GET_EA_EA_SRC
00001590  6000 0002                633              BRA     OP0000_RETURN_BTST
00001594                           634  OP0000_RETURN_BTST
00001594                           635              
00001594  4E75                     636              RTS
00001596                           637  
00001596                           638  
00001596                           639  *---------------------------------------------------------------------------*
00001596                           640  * OP_EORI: decode and display EORI
00001596                           641  *---------------------------------------------------------------------------* 
00001596                           642  OP_EORI
00001596                           643                         
00001596                           644  
00001596                           645   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001596  13FC 0000 0000498A       646             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000159E  13FC 0080 0000498B       647             MOVE.B   #$80,SRC_REGISTER_FORMAT
000015A6                           648             
000015A6                           649             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015A6  13FC 00B9 0000498D       650             MOVE.B   #$B9,GET_DST_START_END
000015AE  13FC 0020 0000498E       651             MOVE.B   #$20,GET_SRC_START_END
000015B6                           652             
000015B6                           653              *CLEAR D3
000015B6  4283                     654              CLR.L   D3
000015B8                           655              *LOAD STACK WITH THIS OPMODE
000015B8  6100 2A46                656              BSR     PUSH_STACK
000015BC  163C 0045                657              MOVE.B  #'E',D3
000015C0  6100 2A3E                658              BSR     PUSH_STACK
000015C4  163C 004F                659              MOVE.B  #'O',D3
000015C8  6100 2A36                660              BSR     PUSH_STACK
000015CC  163C 0052                661              MOVE.B  #'R',D3
000015D0  6100 2A2E                662              BSR     PUSH_STACK
000015D4  163C 0049                663              MOVE.B  #'I',D3
000015D8  6100 2A26                664              BSR     PUSH_STACK
000015DC  163C 002E                665              MOVE.B  #'.',D3
000015E0  6100 2A1E                666              BSR     PUSH_STACK
000015E4                           667              
000015E4                           668              *FIGURE OUT SIZE*
000015E4                           669              *00 = BYTE
000015E4                           670              *01 = WORD
000015E4                           671              *10 = LONG
000015E4                           672              * BITS 7&6
000015E4                           673              
000015E4                           674              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015E4  2205                     675              MOVE.L  D5,D1
000015E6  EC99                     676              ROR.L   #6,D1
000015E8  0281 00000003            677              ANDI.L  #$03,D1
000015EE  0C01 0000                678              CMPI.B  #%00,D1
000015F2  6700 001E                679              BEQ     OP0000_EOR_B
000015F6  0281 00000003            680              ANDI.L  #$03,D1
000015FC  0C01 0001                681              CMPI.B  #%01,D1
00001600  6700 0028                682              BEQ     OP0000_EOR_W
00001604  0281 00000003            683              ANDI.L  #$03,D1
0000160A  0C01 0002                684              CMPI.B  #%10,D1
0000160E  6700 0032                685              BEQ     OP0000_EOR_L
00001612                           686            
00001612                           687  OP0000_EOR_B
00001612                           688              
00001612  163C 0042                689              MOVE.B  #'B',D3
00001616  6100 29E8                690              BSR     PUSH_STACK
0000161A                           691              
0000161A                           692              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000161A  0285 0000F03F            693              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001620  0685 000001C0            694              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001626                           695  
00001626                           696              
00001626  6000 002E                697              BRA     OP0000_RETURN_EOR
0000162A                           698  OP0000_EOR_W
0000162A                           699              
0000162A  163C 0057                700              MOVE.B  #'W',D3
0000162E  6100 29D0                701              BSR     PUSH_STACK
00001632                           702              
00001632                           703              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001632  0285 0000F03F            704              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001638  0685 000001C0            705              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000163E                           706  
0000163E                           707              
0000163E  6000 0016                708              BRA     OP0000_RETURN_EOR
00001642                           709  OP0000_EOR_L
00001642                           710              
00001642  163C 004C                711              MOVE.B  #'L',D3
00001646  6100 29B8                712              BSR     PUSH_STACK
0000164A                           713              
0000164A                           714              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000164A  0285 0000FE3F            715              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001650  0685 000009C0            716              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001656                           717  
00001656                           718  
00001656                           719  OP0000_RETURN_EOR       
00001656  163C 0020                720              MOVE.B  #' ',D3
0000165A  6100 29A4                721              BSR     PUSH_STACK
0000165E  163C 0023                722              MOVE.B  #'#',D3
00001662  6100 299C                723              BSR     PUSH_STACK
00001666  6100 252A                724              BSR     GET_EA_EA_DEST
0000166A  163C 002C                725              MOVE.B  #',',D3
0000166E  6100 2990                726              BSR     PUSH_STACK
00001672  6100 20EE                727              BSR     GET_EA_EA_SRC
00001676                           728              
00001676  4E75                     729              RTS
00001678                           730  
00001678                           731  *---------------------------------------------------------------------------*
00001678                           732  * OP_SUBI: decode SUBI.B/.W/.L
00001678                           733  *---------------------------------------------------------------------------* 
00001678                           734  OP_SUBI
00001678                           735             
00001678                           736   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001678  13FC 0000 0000498A       737             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001680  13FC 0080 0000498B       738             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001688                           739             
00001688                           740             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001688  13FC 00B9 0000498D       741             MOVE.B   #$B9,GET_DST_START_END
00001690  13FC 0020 0000498E       742             MOVE.B   #$20,GET_SRC_START_END
00001698                           743             
00001698                           744              *CLEAR D3
00001698  4283                     745              CLR.L   D3
0000169A                           746              *LOAD STACK WITH THIS OPMODE
0000169A  6100 2964                747              BSR     PUSH_STACK
0000169E  163C 0053                748              MOVE.B  #'S',D3
000016A2  6100 295C                749              BSR     PUSH_STACK
000016A6  163C 0055                750              MOVE.B  #'U',D3
000016AA  6100 2954                751              BSR     PUSH_STACK
000016AE  163C 0042                752              MOVE.B  #'B',D3
000016B2  6100 294C                753              BSR     PUSH_STACK
000016B6  163C 0049                754              MOVE.B  #'I',D3
000016BA  6100 2944                755              BSR     PUSH_STACK
000016BE  163C 002E                756              MOVE.B  #'.',D3
000016C2  6100 293C                757              BSR     PUSH_STACK
000016C6                           758              
000016C6                           759              *FIGURE OUT SIZE*
000016C6                           760              *00 = BYTE
000016C6                           761              *01 = WORD
000016C6                           762              *10 = LONG
000016C6                           763              * BITS 7&6
000016C6                           764              
000016C6                           765              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016C6  2205                     766              MOVE.L  D5,D1
000016C8  EC99                     767              ROR.L   #6,D1
000016CA  0281 00000003            768              ANDI.L  #$03,D1
000016D0  0C01 0000                769              CMPI.B  #%00,D1
000016D4  6700 001E                770              BEQ     OP0000_SUB_B
000016D8  0281 00000003            771              ANDI.L  #$03,D1
000016DE  0C01 0001                772              CMPI.B  #%01,D1
000016E2  6700 0028                773              BEQ     OP0000_SUB_W
000016E6  0281 00000003            774              ANDI.L  #$03,D1
000016EC  0C01 0002                775              CMPI.B  #%10,D1
000016F0  6700 0032                776              BEQ     OP0000_SUB_L
000016F4                           777            
000016F4                           778  OP0000_SUB_B
000016F4                           779              
000016F4  163C 0042                780              MOVE.B  #'B',D3
000016F8  6100 2906                781              BSR     PUSH_STACK
000016FC                           782              
000016FC                           783              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016FC  0285 0000F03F            784              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001702  0685 000001C0            785              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001708                           786  
00001708                           787              
00001708  6000 002E                788              BRA     OP0000_RETURN_SUBI
0000170C                           789  OP0000_SUB_W
0000170C                           790              
0000170C  163C 0057                791              MOVE.B  #'W',D3
00001710  6100 28EE                792              BSR     PUSH_STACK
00001714                           793              
00001714                           794              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001714  0285 0000F03F            795              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000171A  0685 000001C0            796              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001720                           797  
00001720                           798              
00001720  6000 0016                799              BRA     OP0000_RETURN_SUBI
00001724                           800  OP0000_SUB_L
00001724                           801              
00001724  163C 004C                802              MOVE.B  #'L',D3
00001728  6100 28D6                803              BSR     PUSH_STACK
0000172C                           804              
0000172C                           805              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000172C  0285 0000F03F            806              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001732  0685 000003C0            807              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001738                           808                      
00001738                           809  OP0000_RETURN_SUBI            
00001738  163C 0020                810              MOVE.B  #' ',D3
0000173C  6100 28C2                811              BSR     PUSH_STACK
00001740  163C 0023                812              MOVE.B  #'#',D3
00001744  6100 28BA                813              BSR     PUSH_STACK
00001748  6100 2448                814              BSR     GET_EA_EA_DEST
0000174C  163C 002C                815              MOVE.B  #',',D3
00001750  6100 28AE                816              BSR     PUSH_STACK
00001754  6100 200C                817              BSR     GET_EA_EA_SRC
00001758                           818              
00001758  4E75                     819              RTS
0000175A                           820  
0000175A                           821              
0000175A                           822  *---------------------------------------------------------------------------*
0000175A                           823  * OP_DATA : unidentified opcode
0000175A                           824  *---------------------------------------------------------------------------* 
0000175A                           825  OP_DATA
0000175A  4280                     826              CLR.L   D0                   
0000175C  4281                     827              CLR.L   D1     
0000175E  4284                     828              CLR.L   D4                    
00001760  227C 00000000            829              MOVEA.L #0, A1             
00001766  4287                     830              CLR.L   D7
00001768  1E3C 0001                831              MOVE.B  #1,D7                   * error flag is true
0000176C                           832              
0000176C  43F9 000046D8            833              LEA     DISP_DATA,A1
00001772  103C 000E                834              MOVE.B  #14,D0
00001776  4E4F                     835              TRAP    #15
00001778                           836              
00001778  4EF9 0000177E            837              JMP     EA_DATA
0000177E                           838             
0000177E                           839             
0000177E                           840  *---------------------------------------------------------------------------*
0000177E                           841  * EA_DATA
0000177E                           842  *---------------------------------------------------------------------------*       
0000177E  43F9 00004629            843  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
00001784  2205                     844              MOVE.L  D5,D1           * transfer the processing data to D1
00001786  7404                     845              MOVE.L  #4,D2           * set to word size
00001788  4EB8 1228                846              JSR     HEX2ASCII       * prepare output in ascii
0000178C  43F9 0000494B            847              LEA     DISP_HEX,A1     * display $ symbol
00001792  103C 000E                848              MOVE.B  #14,D0      
00001796  4E4F                     849              TRAP    #15
00001798  43F9 00004629            850              LEA     TMPOUTPUT,A1    * display with a new line
0000179E  103C 000D                851              MOVE.B  #13,D0
000017A2  4E4F                     852              TRAP    #15
000017A4                           853  
000017A4  4E75                     854              RTS
000017A6                           855              
000017A6                           856  *---------------------------------------------------------------------------*
000017A6                           857  * OP_CMPI : decode CMPI and its size
000017A6                           858  *---------------------------------------------------------------------------*          
000017A6                           859  OP0000_CMPI
000017A6                           860  
000017A6                           861              
000017A6                           862   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017A6  13FC 0000 0000498A       863             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017AE  13FC 0082 0000498B       864             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017B6                           865             
000017B6                           866             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017B6  13FC 00B9 0000498D       867             MOVE.B   #$B9,GET_DST_START_END
000017BE  13FC 0020 0000498E       868             MOVE.B   #$20,GET_SRC_START_END
000017C6                           869             
000017C6                           870              *CLEAR D3
000017C6  4283                     871              CLR.L   D3
000017C8                           872              *LOAD STACK WITH THIS OPMODE
000017C8  6100 2836                873              BSR     PUSH_STACK
000017CC  163C 0043                874              MOVE.B  #'C',D3
000017D0  6100 282E                875              BSR     PUSH_STACK
000017D4  163C 004D                876              MOVE.B  #'M',D3
000017D8  6100 2826                877              BSR     PUSH_STACK
000017DC  163C 0050                878              MOVE.B  #'P',D3
000017E0  6100 281E                879              BSR     PUSH_STACK
000017E4  163C 0049                880              MOVE.B  #'I',D3
000017E8  6100 2816                881              BSR     PUSH_STACK
000017EC  163C 002E                882              MOVE.B  #'.',D3
000017F0  6100 280E                883              BSR     PUSH_STACK
000017F4                           884              
000017F4                           885              *FIGURE OUT SIZE*
000017F4                           886              *00 = BYTE
000017F4                           887              *01 = WORD
000017F4                           888              *10 = LONG
000017F4                           889              * BITS 7&6
000017F4                           890              
000017F4                           891              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017F4  2205                     892              MOVE.L  D5,D1
000017F6  EC99                     893              ROR.L   #6,D1
000017F8  0281 00000003            894              ANDI.L  #$03,D1
000017FE  0C01 0000                895              CMPI.B  #%00,D1
00001802  6700 0018                896              BEQ     OP0000_CMPI_B
00001806  0C01 0001                897              CMPI.B  #%01,D1
0000180A  6700 0038                898              BEQ     OP0000_CMPI_W
0000180E  0281 00000003            899              ANDI.L  #$03,D1
00001814  0C01 0002                900              CMPI.B  #%10,D1
00001818  6700 0052                901              BEQ     OP0000_CMPI_L
0000181C                           902  
0000181C                           903  OP0000_CMPI_B
0000181C  163C 0042                904              MOVE.B  #'B',D3
00001820  6100 27DE                905              BSR     PUSH_STACK
00001824                           906  *GET DATA FROM ADDQ AND PRINT #0-8
00001824                           907              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001824  0285 0000F03F            908              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000182A  0685 000001C0            909              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001830  6100 2360                910              BSR     GET_EA_EA_DEST
00001834  163C 002C                911              MOVE.B  #',',D3
00001838  6100 27C6                912              BSR     PUSH_STACK
0000183C  6100 1F24                913              BSR     GET_EA_EA_SRC
00001840  6000 004E                914              BRA     OP0000_RETURN_CMPI
00001844                           915  
00001844                           916  OP0000_CMPI_W
00001844  163C 0057                917              MOVE.B  #'W',D3
00001848  6100 27B6                918              BSR     PUSH_STACK
0000184C                           919  *GET DATA FROM ADDQ AND PRINT #0-8
0000184C                           920              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000184C  0285 0000F03F            921              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001852  0685 000001C0            922              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001858  6100 2338                923              BSR     GET_EA_EA_DEST
0000185C  163C 002C                924              MOVE.B  #',',D3
00001860  6100 279E                925              BSR     PUSH_STACK
00001864  6100 1EFC                926              BSR     GET_EA_EA_SRC
00001868  6000 0026                927              BRA     OP0000_RETURN_CMPI
0000186C                           928  
0000186C                           929  OP0000_CMPI_L
0000186C  163C 004C                930              MOVE.B  #'L',D3
00001870  6100 278E                931              BSR     PUSH_STACK
00001874                           932              *GET DATA FROM ADDQ AND PRINT #0-8
00001874                           933              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001874  0285 0000F03F            934              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000187A  0685 000003C0            935              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001880  6100 2310                936              BSR     GET_EA_EA_DEST
00001884  163C 002C                937              MOVE.B  #',',D3
00001888  6100 2776                938              BSR     PUSH_STACK
0000188C  6100 1ED4                939              BSR     GET_EA_EA_SRC
00001890                           940              
00001890                           941  OP0000_RETURN_CMPI
00001890                           942  
00001890                           943  
00001890                           944              
00001890  4E75                     945              RTS
00001892                           946   
00001892                           947  *---------------------------------------------------------------------------*
00001892                           948  * OP_ORI : decode ORI and its size
00001892                           949  *---------------------------------------------------------------------------* 
00001892                           950  OP_ORI      
00001892                           951           
00001892                           952   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001892  13FC 0000 0000498A       953             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000189A  13FC 0082 0000498B       954             MOVE.B   #$82,SRC_REGISTER_FORMAT
000018A2                           955             
000018A2                           956             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000018A2  13FC 00B9 0000498D       957             MOVE.B   #$B9,GET_DST_START_END
000018AA  13FC 0020 0000498E       958             MOVE.B   #$20,GET_SRC_START_END
000018B2                           959             
000018B2                           960              *CLEAR D3
000018B2  4283                     961              CLR.L   D3
000018B4                           962              *LOAD STACK WITH THIS OPMODE
000018B4  6100 274A                963              BSR     PUSH_STACK
000018B8  163C 004F                964              MOVE.B  #'O',D3
000018BC  6100 2742                965              BSR     PUSH_STACK
000018C0  163C 0052                966              MOVE.B  #'R',D3
000018C4  6100 273A                967              BSR     PUSH_STACK
000018C8  163C 0049                968              MOVE.B  #'I',D3
000018CC  6100 2732                969              BSR     PUSH_STACK
000018D0  163C 002E                970              MOVE.B  #'.',D3
000018D4  6100 272A                971              BSR     PUSH_STACK
000018D8                           972              
000018D8                           973              *FIGURE OUT SIZE*
000018D8                           974              *00 = BYTE
000018D8                           975              *01 = WORD
000018D8                           976              *10 = LONG
000018D8                           977              * BITS 7&6
000018D8                           978              
000018D8                           979              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018D8  2205                     980              MOVE.L  D5,D1
000018DA  EC99                     981              ROR.L   #6,D1
000018DC  0281 00000003            982              ANDI.L  #$03,D1
000018E2  0C01 0000                983              CMPI.B  #%00,D1
000018E6  6700 0018                984              BEQ     OP0000_ORI_B
000018EA  0C01 0001                985              CMPI.B  #%01,D1
000018EE  6700 0038                986              BEQ     OP0000_ORI_W
000018F2  0281 00000003            987              ANDI.L  #$03,D1
000018F8  0C01 0002                988              CMPI.B  #%10,D1
000018FC  6700 0052                989              BEQ     OP0000_ORI_L
00001900                           990  
00001900                           991  OP0000_ORI_B
00001900  163C 0042                992              MOVE.B  #'B',D3
00001904  6100 26FA                993              BSR     PUSH_STACK
00001908                           994  *GET DATA FROM ADDQ AND PRINT #0-8
00001908                           995              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001908  0285 0000F03F            996              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000190E  0685 000001C0            997              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001914  6100 227C                998              BSR     GET_EA_EA_DEST
00001918  163C 002C                999              MOVE.B  #',',D3
0000191C  6100 26E2               1000              BSR     PUSH_STACK
00001920  6100 1E40               1001              BSR     GET_EA_EA_SRC
00001924  6000 004E               1002              BRA     OP0000_RETURN_ORI
00001928                          1003  
00001928                          1004  OP0000_ORI_W
00001928  163C 0057               1005              MOVE.B  #'W',D3
0000192C  6100 26D2               1006              BSR     PUSH_STACK
00001930                          1007  *GET DATA FROM ADDQ AND PRINT #0-8
00001930                          1008              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001930  0285 0000F03F           1009              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001936  0685 000001C0           1010              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000193C  6100 2254               1011              BSR     GET_EA_EA_DEST
00001940  163C 002C               1012              MOVE.B  #',',D3
00001944  6100 26BA               1013              BSR     PUSH_STACK
00001948  6100 1E18               1014              BSR     GET_EA_EA_SRC
0000194C  6000 0026               1015              BRA     OP0000_RETURN_ORI
00001950                          1016  
00001950                          1017  OP0000_ORI_L
00001950  163C 004C               1018              MOVE.B  #'L',D3
00001954  6100 26AA               1019              BSR     PUSH_STACK
00001958                          1020              *GET DATA FROM ADDQ AND PRINT #0-8
00001958                          1021              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001958  0285 0000F03F           1022              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000195E  0685 000003C0           1023              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001964  6100 222C               1024              BSR     GET_EA_EA_DEST
00001968  163C 002C               1025              MOVE.B  #',',D3
0000196C  6100 2692               1026              BSR     PUSH_STACK
00001970  6100 1DF0               1027              BSR     GET_EA_EA_SRC
00001974                          1028              
00001974                          1029  OP0000_RETURN_ORI
00001974                          1030  
00001974                          1031  
00001974                          1032              
00001974  4E75                    1033              RTS
00001976                          1034  
00001976                          1035          
00001976                          1036  *---------------------------------------------------------------------------*
00001976                          1037  * OP0001: MOVE.B
00001976                          1038  *---------------------------------------------------------------------------*
00001976                          1039  OP0001      
00001976  4EF9 0000197C           1040              JMP     OP_MOVE_B   * display MOVE.B
0000197C                          1041              
0000197C                          1042  *---------------------------------------------------------------------------*
0000197C                          1043  * OP_MOVE_B: display MOVE_B and proceed to EA
0000197C                          1044  *---------------------------------------------------------------------------*
0000197C                          1045  OP_MOVE_B                                                                       
0000197C                          1046             
0000197C                          1047             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000197C  13FC 0082 0000498A      1048             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001984  13FC 0000 0000498B      1049             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000198C                          1050             
0000198C                          1051             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000198C  13FC 00B9 0000498D      1052             MOVE.B   #$B9,GET_DST_START_END
00001994  13FC 0020 0000498E      1053             MOVE.B   #$20,GET_SRC_START_END
0000199C                          1054             
0000199C                          1055              *CLEAR D3
0000199C  4283                    1056              CLR.L   D3
0000199E                          1057              *LOAD STACK WITH THIS OPMODE
0000199E  6100 2660               1058              BSR     PUSH_STACK
000019A2  163C 004D               1059              MOVE.B  #'M',D3
000019A6  6100 2658               1060              BSR     PUSH_STACK
000019AA  163C 004F               1061              MOVE.B  #'O',D3
000019AE  6100 2650               1062              BSR     PUSH_STACK
000019B2  163C 0056               1063              MOVE.B  #'V',D3
000019B6  6100 2648               1064              BSR     PUSH_STACK
000019BA  163C 0045               1065              MOVE.B  #'E',D3
000019BE  6100 2640               1066              BSR     PUSH_STACK
000019C2  163C 002E               1067              MOVE.B  #'.',D3
000019C6  6100 2638               1068              BSR     PUSH_STACK
000019CA  163C 0042               1069              MOVE.B  #'B',D3
000019CE  6100 2630               1070              BSR     PUSH_STACK
000019D2                          1071              
000019D2  6100 1D8E               1072              BSR     GET_EA_EA_SRC
000019D6  163C 002C               1073              MOVE.B  #',',D3
000019DA  6100 2624               1074              BSR     PUSH_STACK
000019DE  6100 21B2               1075              BSR     GET_EA_EA_DEST
000019E2                          1076              
000019E2  4E75                    1077              RTS
000019E4                          1078              
000019E4                          1079             
000019E4                          1080  *---------------------------------------------------------------------------*
000019E4                          1081  * OP0010: decode MOVE.L/MOVEA.L
000019E4                          1082  *---------------------------------------------------------------------------*
000019E4                          1083  OP0010      
000019E4  183C 0002               1084              MOVE.B  #2,D4
000019E8  4280                    1085              CLR.L   D0                     
000019EA  4281                    1086              CLR.L   D1                      
000019EC  227C 00000000           1087              MOVEA.L #0, A1                 
000019F2                          1088              
000019F2  2205                    1089              MOVE.L  D5,D1
000019F4  EA99                    1090              ROR.L   #5,D1
000019F6  0281 0000000E           1091              ANDI.L  #$E,D1
000019FC  0C01 0002               1092              CMPI.B  #2,D1
00001A00  6700 0070               1093              BEQ     OP_MOVEA_L
00001A04                          1094  
00001A04  4EF9 00001A0A           1095              JMP     OP_MOVE_L
00001A0A                          1096             
00001A0A                          1097  
00001A0A                          1098  *---------------------------------------------------------------------------*
00001A0A                          1099  * OP_MOVE_L: display MOVE_L and proceed to EA
00001A0A                          1100  *---------------------------------------------------------------------------*
00001A0A                          1101  OP_MOVE_L   
00001A0A                          1102             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A0A  13FC 0082 0000498A      1103             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A12  13FC 0000 0000498B      1104             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A1A                          1105             
00001A1A                          1106             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A1A  13FC 00B9 0000498D      1107             MOVE.B   #$B9,GET_DST_START_END
00001A22  13FC 0020 0000498E      1108             MOVE.B   #$20,GET_SRC_START_END
00001A2A                          1109             
00001A2A                          1110              *CLEAR D3
00001A2A  4283                    1111              CLR.L   D3
00001A2C                          1112              *LOAD STACK WITH THIS OPMODE
00001A2C  6100 25D2               1113              BSR     PUSH_STACK
00001A30  163C 004D               1114              MOVE.B  #'M',D3
00001A34  6100 25CA               1115              BSR     PUSH_STACK
00001A38  163C 004F               1116              MOVE.B  #'O',D3
00001A3C  6100 25C2               1117              BSR     PUSH_STACK
00001A40  163C 0056               1118              MOVE.B  #'V',D3
00001A44  6100 25BA               1119              BSR     PUSH_STACK
00001A48  163C 0045               1120              MOVE.B  #'E',D3
00001A4C  6100 25B2               1121              BSR     PUSH_STACK
00001A50  163C 002E               1122              MOVE.B  #'.',D3
00001A54  6100 25AA               1123              BSR     PUSH_STACK
00001A58  163C 004C               1124              MOVE.B  #'L',D3
00001A5C  6100 25A2               1125              BSR     PUSH_STACK
00001A60                          1126              
00001A60  6100 1D00               1127              BSR     GET_EA_EA_SRC
00001A64  163C 002C               1128              MOVE.B  #',',D3
00001A68  6100 2596               1129              BSR     PUSH_STACK
00001A6C  6100 2124               1130              BSR     GET_EA_EA_DEST
00001A70                          1131              
00001A70  4E75                    1132              RTS
00001A72                          1133  
00001A72                          1134  
00001A72                          1135  *---------------------------------------------------------------------------*
00001A72                          1136  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A72                          1137  *---------------------------------------------------------------------------*
00001A72                          1138  OP_MOVEA_L 
00001A72                          1139             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A72  13FC 00FD 0000498A      1140             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A7A  13FC 0000 0000498B      1141             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A82                          1142             
00001A82                          1143             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A82  13FC 00B9 0000498D      1144             MOVE.B   #$B9,GET_DST_START_END
00001A8A  13FC 0020 0000498E      1145             MOVE.B   #$20,GET_SRC_START_END
00001A92                          1146             
00001A92                          1147              *CLEAR D3
00001A92  4283                    1148              CLR.L   D3
00001A94                          1149              *LOAD STACK WITH THIS OPMODE
00001A94  6100 256A               1150              BSR     PUSH_STACK
00001A98  163C 004D               1151              MOVE.B  #'M',D3
00001A9C  6100 2562               1152              BSR     PUSH_STACK
00001AA0  163C 004F               1153              MOVE.B  #'O',D3
00001AA4  6100 255A               1154              BSR     PUSH_STACK
00001AA8  163C 0056               1155              MOVE.B  #'V',D3
00001AAC  6100 2552               1156              BSR     PUSH_STACK
00001AB0  163C 0045               1157              MOVE.B  #'E',D3
00001AB4  6100 254A               1158              BSR     PUSH_STACK           
00001AB8  163C 0041               1159              MOVE.B  #'A',D3
00001ABC  6100 2542               1160              BSR     PUSH_STACK
00001AC0  163C 002E               1161              MOVE.B  #'.',D3
00001AC4  6100 253A               1162              BSR     PUSH_STACK
00001AC8  163C 004C               1163              MOVE.B  #'L',D3
00001ACC  6100 2532               1164              BSR     PUSH_STACK
00001AD0                          1165              
00001AD0  6100 1C90               1166              BSR     GET_EA_EA_SRC
00001AD4  163C 002C               1167              MOVE.B  #',',D3
00001AD8  6100 2526               1168              BSR     PUSH_STACK
00001ADC  6100 20B4               1169              BSR     GET_EA_EA_DEST
00001AE0                          1170              
00001AE0  4E75                    1171              RTS
00001AE2                          1172  
00001AE2                          1173              
00001AE2                          1174  *---------------------------------------------------------------------------*
00001AE2                          1175  * OP0011: decode MOVE.W/MOVEA.W
00001AE2                          1176  *---------------------------------------------------------------------------*
00001AE2                          1177  OP0011      
00001AE2  4280                    1178              CLR.L   D0                      
00001AE4  4281                    1179              CLR.L   D1  
00001AE6  4284                    1180              CLR.L   D4                   
00001AE8  227C 00000000           1181              MOVEA.L #0, A1 
00001AEE                          1182                
00001AEE  2205                    1183              MOVE.L  D5,D1
00001AF0  EC99                    1184              ROR.L   #6,D1
00001AF2  0281 00000007           1185              ANDI.L  #$07,D1
00001AF8  0C01 0001               1186              CMPI.B  #1,D1
00001AFC  6700 0070               1187              BEQ     OP_MOVEA_W
00001B00                          1188              
00001B00  4EF9 00001B06           1189              JMP     OP_MOVE_W
00001B06                          1190            
00001B06                          1191  *---------------------------------------------------------------------------*
00001B06                          1192  * OP_MOVE_W: display MOVE_W and proceed to EA
00001B06                          1193  *---------------------------------------------------------------------------*
00001B06                          1194  OP_MOVE_W   
00001B06                          1195             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B06  13FC 0082 0000498A      1196             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001B0E  13FC 0000 0000498B      1197             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B16                          1198             
00001B16                          1199             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B16  13FC 00B9 0000498D      1200             MOVE.B   #$B9,GET_DST_START_END
00001B1E  13FC 0020 0000498E      1201             MOVE.B   #$20,GET_SRC_START_END
00001B26                          1202             
00001B26                          1203              *CLEAR D3
00001B26  4283                    1204              CLR.L   D3
00001B28                          1205              *LOAD STACK WITH THIS OPMODE
00001B28  6100 24D6               1206              BSR     PUSH_STACK
00001B2C  163C 004D               1207              MOVE.B  #'M',D3
00001B30  6100 24CE               1208              BSR     PUSH_STACK
00001B34  163C 004F               1209              MOVE.B  #'O',D3
00001B38  6100 24C6               1210              BSR     PUSH_STACK
00001B3C  163C 0056               1211              MOVE.B  #'V',D3
00001B40  6100 24BE               1212              BSR     PUSH_STACK
00001B44  163C 0045               1213              MOVE.B  #'E',D3
00001B48  6100 24B6               1214              BSR     PUSH_STACK
00001B4C  163C 002E               1215              MOVE.B  #'.',D3
00001B50  6100 24AE               1216              BSR     PUSH_STACK
00001B54  163C 0057               1217              MOVE.B  #'W',D3
00001B58  6100 24A6               1218              BSR     PUSH_STACK
00001B5C                          1219              
00001B5C  6100 1C04               1220              BSR     GET_EA_EA_SRC
00001B60  163C 002C               1221              MOVE.B  #',',D3
00001B64  6100 249A               1222              BSR     PUSH_STACK
00001B68  6100 2028               1223              BSR     GET_EA_EA_DEST
00001B6C                          1224              
00001B6C  4E75                    1225              RTS
00001B6E                          1226  
00001B6E                          1227  *---------------------------------------------------------------------------*
00001B6E                          1228  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B6E                          1229  *---------------------------------------------------------------------------*
00001B6E                          1230  OP_MOVEA_W 
00001B6E                          1231             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B6E  13FC 00FD 0000498A      1232             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B76  13FC 0000 0000498B      1233             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B7E                          1234             
00001B7E                          1235             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B7E  13FC 00B9 0000498D      1236             MOVE.B   #$B9,GET_DST_START_END
00001B86  13FC 0020 0000498E      1237             MOVE.B   #$20,GET_SRC_START_END
00001B8E                          1238             
00001B8E                          1239              *CLEAR D3
00001B8E  4283                    1240              CLR.L   D3
00001B90                          1241              *LOAD STACK WITH THIS OPMODE
00001B90  6100 246E               1242              BSR     PUSH_STACK
00001B94  163C 004D               1243              MOVE.B  #'M',D3
00001B98  6100 2466               1244              BSR     PUSH_STACK
00001B9C  163C 004F               1245              MOVE.B  #'O',D3
00001BA0  6100 245E               1246              BSR     PUSH_STACK
00001BA4  163C 0056               1247              MOVE.B  #'V',D3
00001BA8  6100 2456               1248              BSR     PUSH_STACK
00001BAC  163C 0045               1249              MOVE.B  #'E',D3
00001BB0  6100 244E               1250              BSR     PUSH_STACK           
00001BB4  163C 0041               1251              MOVE.B  #'A',D3
00001BB8  6100 2446               1252              BSR     PUSH_STACK
00001BBC  163C 002E               1253              MOVE.B  #'.',D3
00001BC0  6100 243E               1254              BSR     PUSH_STACK
00001BC4  163C 0057               1255              MOVE.B  #'W',D3
00001BC8  6100 2436               1256              BSR     PUSH_STACK
00001BCC                          1257              
00001BCC  6100 1B94               1258              BSR     GET_EA_EA_SRC
00001BD0  163C 002C               1259              MOVE.B  #',',D3
00001BD4  6100 242A               1260              BSR     PUSH_STACK
00001BD8  6100 1FB8               1261              BSR     GET_EA_EA_DEST
00001BDC                          1262            
00001BDC  4E75                    1263              RTS
00001BDE                          1264  *---------------------------------------------------------------------------*
00001BDE                          1265  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BDE                          1266  *---------------------------------------------------------------------------*
00001BDE                          1267  OP0100
00001BDE  4280                    1268              CLR.L   D0                      
00001BE0  4281                    1269              CLR.L   D1  
00001BE2  4284                    1270              CLR.L   D4                      
00001BE4  227C 00000000           1271              MOVEA.L #0, A1                  
00001BEA  2205                    1272              MOVE.L  D5,D1  
00001BEC                          1273              
00001BEC                          1274              * check for RTS
00001BEC  0C41 4E75               1275              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BF0  6700 0228               1276              BEQ     OP_RTS
00001BF4                          1277              
00001BF4                          1278              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BF4  4281                    1279              CLR.L   D1 
00001BF6  2205                    1280              MOVE.L  D5,D1  
00001BF8  0241 0F00               1281              ANDI.W  #$0F00,D1
00001BFC  0C41 0E00               1282              CMPI.W  #$0E00,D1
00001C00  6700 0204               1283              BEQ     OP_JSR
00001C04                          1284  
00001C04                          1285              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001C04  4281                    1286              CLR.L   D1 
00001C06  2205                    1287              MOVE.L  D5,D1  
00001C08  0241 0F00               1288              ANDI.W  #$0F00,D1
00001C0C  0C41 0400               1289              CMPI.W  #$0400,D1
00001C10  6700 00E8               1290              BEQ     OP_NEG
00001C14                          1291              
00001C14                          1292              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001C14  4281                    1293              CLR.L   D1 
00001C16  2205                    1294              MOVE.L  D5,D1  
00001C18  0241 0F00               1295              ANDI.W  #$0F00,D1
00001C1C  0C41 0600               1296              CMPI.W  #$0600,D1
00001C20  6700 015E               1297              BEQ     OP_NOT
00001C24                          1298              
00001C24                          1299              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C24  4281                    1300              CLR.L   D1 
00001C26  2205                    1301              MOVE.L  D5,D1  
00001C28  EC99                    1302              ROR.L   #6,D1
00001C2A  0281 00000007           1303              ANDI.L  #7,D1
00001C30  0C81 00000007           1304              CMPI.L  #7,D1
00001C36  6700 0054               1305              BEQ     OP_LEA
00001C3A                          1306              
00001C3A                          1307              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C3A  4281                    1308              CLR.L   D1 
00001C3C  2205                    1309              MOVE.L  D5,D1  
00001C3E  EB59                    1310              ROL.W   #5,D1
00001C40  0C01 0001               1311              CMPI.B  #1,D1
00001C44  6600 FB14               1312              BNE     OP_DATA
00001C48  E959                    1313              ROL.W   #4,D1
00001C4A  0C01 0001               1314              CMPI.B  #1,D1
00001C4E  6600 FB0A               1315              BNE     OP_DATA
00001C52  E359                    1316              ROL.W   #1,D1
00001C54  0C01 0000               1317              CMPI.B  #0,D1
00001C58  6700 000E               1318              BEQ     OP_MOVEM_W
00001C5C  0C01 0001               1319              CMPI.B  #1,D1
00001C60  6700 0018               1320              BEQ     OP_MOVEM_L
00001C64  4EF8 175A               1321              JMP     OP_DATA
00001C68                          1322  
00001C68                          1323  *---------------------------------------------------------------------------*
00001C68                          1324  * OP_MOVEM_W: display MOVEM_W
00001C68                          1325  *---------------------------------------------------------------------------*    
00001C68                          1326  OP_MOVEM_W  
00001C68  183C 0001               1327              MOVE.B  #1,D4
00001C6C  43F9 00004749           1328              LEA     DISP_MOVEM_W,A1
00001C72  103C 000E               1329              MOVE.B  #14,D0
00001C76  4E4F                    1330              TRAP    #15
00001C78  4E75                    1331              RTS
00001C7A                          1332  
00001C7A                          1333  *---------------------------------------------------------------------------*
00001C7A                          1334  * OP_MOVEM_L: display MOVEM_L
00001C7A                          1335  *---------------------------------------------------------------------------*
00001C7A                          1336  OP_MOVEM_L  
00001C7A  183C 0002               1337              MOVE.B  #2,D4
00001C7E  43F9 00004754           1338              LEA     DISP_MOVEM_L,A1
00001C84  103C 000E               1339              MOVE.B  #14,D0
00001C88  4E4F                    1340              TRAP    #15
00001C8A  4E75                    1341              RTS
00001C8C                          1342     
00001C8C                          1343  *---------------------------------------------------------------------------*
00001C8C                          1344  * OP_LEA: decode and display LEA
00001C8C                          1345  *---------------------------------------------------------------------------*
00001C8C                          1346  OP_LEA      
00001C8C  4281                    1347               CLR.L   D1       
00001C8E  4284                    1348              CLR.L   D4                   
00001C90  227C 00000000           1349              MOVEA.L #0, A1              
00001C96  2205                    1350              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C98                          1351              *CLEAR D3
00001C98  4283                    1352              CLR.L   D3
00001C9A                          1353  
00001C9A                          1354  OP_LEA_DN_EA_OR_EA_DN 
00001C9A                          1355              *LOAD STACK WITH THIS OPMODE
00001C9A  6100 2364               1356              BSR     PUSH_STACK
00001C9E  163C 004C               1357              MOVE.B  #'L',D3
00001CA2  6100 235C               1358              BSR     PUSH_STACK
00001CA6  163C 0045               1359              MOVE.B  #'E',D3
00001CAA  6100 2354               1360              BSR     PUSH_STACK
00001CAE  163C 0041               1361              MOVE.B  #'A',D3
00001CB2  6100 234C               1362              BSR     PUSH_STACK
00001CB6  2205                    1363              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CB8                          1364          
00001CB8                          1365  
00001CB8                          1366  OP_PRINT_L_LEA
00001CB8                          1367                          
00001CB8                          1368              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CB8  13FC 0000 0000498A      1369              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CC0  13FC 009B 0000498B      1370              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CC8                          1371             
00001CC8                          1372              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CC8  13FC 00B9 0000498D      1373              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CD0  13FC 0020 0000498E      1374              MOVE.B   #$20,GET_SRC_START_END
00001CD8                          1375  
00001CD8                          1376              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CD8  0285 0000FE3F           1377              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CDE  0685 00000040           1378              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CE4                          1379  
00001CE4  6100 1A7C               1380              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CE8  163C 002C               1381              MOVE.B  #',',D3
00001CEC  6100 2312               1382              BSR     PUSH_STACK           
00001CF0  6100 1EA0               1383              BSR     GET_EA_EA_DEST       *GETS Dn    
00001CF4                          1384  
00001CF4                          1385              
00001CF4  6000 0002               1386              BRA     OP_LEA_RETURN
00001CF8                          1387              
00001CF8                          1388  OP_LEA_RETURN
00001CF8  4E75                    1389              RTS
00001CFA                          1390              
00001CFA                          1391  
00001CFA                          1392  
00001CFA                          1393  *---------------------------------------------------------------------------*
00001CFA                          1394  * OP_NEG: decode and display NEG 
00001CFA                          1395  *---------------------------------------------------------------------------*
00001CFA                          1396  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001CFA  4281                    1397              CLR.L   D1
00001CFC  4284                    1398              CLR.L   D4
00001CFE  2205                    1399              MOVE.L  D5,D1
00001D00                          1400              
00001D00                          1401              *CLEAR D3
00001D00  4283                    1402              CLR.L   D3
00001D02                          1403              *LOAD STACK WITH THIS OPMODE
00001D02  6100 22FC               1404              BSR     PUSH_STACK
00001D06  163C 004E               1405              MOVE.B  #'N',D3
00001D0A  6100 22F4               1406              BSR     PUSH_STACK
00001D0E  163C 0045               1407              MOVE.B  #'E',D3
00001D12  6100 22EC               1408              BSR     PUSH_STACK
00001D16  163C 0047               1409              MOVE.B  #'G',D3
00001D1A  6100 22E4               1410              BSR     PUSH_STACK
00001D1E  163C 002E               1411              MOVE.B  #'.',D3
00001D22  6100 22DC               1412              BSR     PUSH_STACK
00001D26                          1413              
00001D26                          1414              
00001D26  EC99                    1415              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D28  0281 00000007           1416              ANDI.L  #$07,D1
00001D2E                          1417              
00001D2E  0C01 0000               1418              CMPI.B  #0,D1
00001D32  6700 0012               1419              BEQ     OP_NEG_B    * size is byte
00001D36  0C01 0001               1420              CMPI.B  #1,D1
00001D3A  6700 0016               1421              BEQ     OP_NEG_W    * size is word
00001D3E  0C01 0002               1422              CMPI.B  #2,D1
00001D42  6700 001A               1423              BEQ     OP_NEG_L    * size is long
00001D46                          1424                         
00001D46                          1425  
00001D46                          1426  OP_NEG_B    * size is byte   
00001D46  163C 0042               1427              MOVE.B  #'B',D3
00001D4A  6100 22B4               1428              BSR     PUSH_STACK
00001D4E  6000 001A               1429              BRA     OP_NEG_PRINT_EA
00001D52                          1430  
00001D52                          1431              
00001D52                          1432  OP_NEG_W    * size is word
00001D52  163C 0057               1433              MOVE.B  #'W',D3
00001D56  6100 22A8               1434              BSR     PUSH_STACK
00001D5A  6000 000E               1435              BRA     OP_NEG_PRINT_EA
00001D5E                          1436  
00001D5E                          1437              
00001D5E                          1438  OP_NEG_L    * size is long
00001D5E  163C 004C               1439              MOVE.B  #'L',D3
00001D62  6100 229C               1440              BSR     PUSH_STACK
00001D66  6000 0002               1441              BRA     OP_NEG_PRINT_EA
00001D6A                          1442  
00001D6A                          1443  
00001D6A                          1444  OP_NEG_PRINT_EA
00001D6A                          1445   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D6A  13FC 0082 0000498B      1446             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D72                          1447             
00001D72                          1448             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D72  13FC 0020 0000498E      1449             MOVE.B   #$20,GET_SRC_START_END
00001D7A                          1450                         
00001D7A                          1451  
00001D7A  6100 19E6               1452              BSR     GET_EA_EA_SRC
00001D7E                          1453              
00001D7E  4E75                    1454              RTS
00001D80                          1455  
00001D80                          1456  *---------------------------------------------------------------------------*
00001D80                          1457  * OP_NOT: decode and display NOT 
00001D80                          1458  *---------------------------------------------------------------------------*
00001D80                          1459  OP_NOT
00001D80  4281                    1460              CLR.L   D1
00001D82  4284                    1461              CLR.L   D4
00001D84  2205                    1462              MOVE.L  D5,D1
00001D86                          1463              
00001D86                          1464              *CLEAR D3
00001D86  4283                    1465              CLR.L   D3
00001D88                          1466              *LOAD STACK WITH THIS OPMODE
00001D88  6100 2276               1467              BSR     PUSH_STACK
00001D8C  163C 004E               1468              MOVE.B  #'N',D3
00001D90  6100 226E               1469              BSR     PUSH_STACK
00001D94  163C 004F               1470              MOVE.B  #'O',D3
00001D98  6100 2266               1471              BSR     PUSH_STACK
00001D9C  163C 0054               1472              MOVE.B  #'T',D3
00001DA0  6100 225E               1473              BSR     PUSH_STACK
00001DA4  163C 002E               1474              MOVE.B  #'.',D3
00001DA8  6100 2256               1475              BSR     PUSH_STACK
00001DAC                          1476              
00001DAC                          1477              
00001DAC  EC99                    1478              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DAE  0281 00000007           1479              ANDI.L  #$07,D1
00001DB4                          1480              
00001DB4  0C01 0000               1481              CMPI.B  #0,D1
00001DB8  6700 0012               1482              BEQ     OP_NOT_B    * size is byte
00001DBC  0C01 0001               1483              CMPI.B  #1,D1
00001DC0  6700 0016               1484              BEQ     OP_NOT_W    * size is word
00001DC4  0C01 0002               1485              CMPI.B  #2,D1
00001DC8  6700 001A               1486              BEQ     OP_NOT_L    * size is long
00001DCC                          1487                         
00001DCC                          1488  
00001DCC                          1489  OP_NOT_B    * size is byte   
00001DCC  163C 0042               1490              MOVE.B  #'B',D3
00001DD0  6100 222E               1491              BSR     PUSH_STACK
00001DD4  6000 001A               1492              BRA     OP_NOT_PRINT_EA
00001DD8                          1493  
00001DD8                          1494              
00001DD8                          1495  OP_NOT_W    * size is word
00001DD8  163C 0057               1496              MOVE.B  #'W',D3
00001DDC  6100 2222               1497              BSR     PUSH_STACK
00001DE0  6000 000E               1498              BRA     OP_NOT_PRINT_EA
00001DE4                          1499  
00001DE4                          1500              
00001DE4                          1501  OP_NOT_L    * size is long
00001DE4  163C 004C               1502              MOVE.B  #'L',D3
00001DE8  6100 2216               1503              BSR     PUSH_STACK
00001DEC  6000 0002               1504              BRA     OP_NOT_PRINT_EA
00001DF0                          1505  
00001DF0                          1506  
00001DF0                          1507  OP_NOT_PRINT_EA
00001DF0                          1508   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DF0  13FC 0082 0000498B      1509             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001DF8                          1510             
00001DF8                          1511             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DF8  13FC 0020 0000498E      1512             MOVE.B   #$20,GET_SRC_START_END
00001E00  6100 1960               1513              BSR     GET_EA_EA_SRC
00001E04                          1514              
00001E04  4E75                    1515              RTS
00001E06                          1516  
00001E06                          1517  
00001E06                          1518  *---------------------------------------------------------------------------*
00001E06                          1519  * OP_JSR: display JSR     
00001E06                          1520  *---------------------------------------------------------------------------*
00001E06  43F9 00004705           1521  OP_JSR      LEA     DISP_JSR,A1
00001E0C  103C 000E               1522              MOVE.B  #14,D0
00001E10  4E4F                    1523              TRAP    #15
00001E12  4EB9 000032B2           1524              JSR     EA_NOSRC
00001E18                          1525  
00001E18  4E75                    1526              RTS
00001E1A                          1527  
00001E1A                          1528  *---------------------------------------------------------------------------*
00001E1A                          1529  * OP_RTS: display RTS     
00001E1A                          1530  *---------------------------------------------------------------------------* 
00001E1A                          1531  OP_RTS      
00001E1A  163C 0052               1532              MOVE.B #'R',D3
00001E1E  6100 21E0               1533              BSR     PUSH_STACK
00001E22  163C 0054               1534              MOVE.B #'T',D3
00001E26  6100 21D8               1535              BSR     PUSH_STACK
00001E2A  163C 0053               1536              MOVE.B #'S',D3
00001E2E  6100 21D0               1537              BSR     PUSH_STACK
00001E32  4E75                    1538              RTS
00001E34                          1539  
00001E34                          1540  *---------------------------------------------------------------------------*
00001E34                          1541  * OP0101: decode ADDQ
00001E34                          1542  *---------------------------------------------------------------------------* 
00001E34                          1543  OP0101      
00001E34                          1544             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E34  13FC 0082 0000498A      1545             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E3C  13FC 0080 0000498B      1546             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E44                          1547             
00001E44                          1548             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E44  13FC 00B9 0000498D      1549             MOVE.B   #$B9,GET_DST_START_END
00001E4C  13FC 0020 0000498E      1550             MOVE.B   #$20,GET_SRC_START_END
00001E54                          1551             
00001E54                          1552              *CLEAR D3
00001E54  4283                    1553              CLR.L   D3
00001E56                          1554              *LOAD STACK WITH THIS OPMODE
00001E56  6100 21A8               1555              BSR     PUSH_STACK
00001E5A  163C 0041               1556              MOVE.B  #'A',D3
00001E5E  6100 21A0               1557              BSR     PUSH_STACK
00001E62  163C 0044               1558              MOVE.B  #'D',D3
00001E66  6100 2198               1559              BSR     PUSH_STACK
00001E6A  163C 0044               1560              MOVE.B  #'D',D3
00001E6E  6100 2190               1561              BSR     PUSH_STACK
00001E72  163C 0051               1562              MOVE.B  #'Q',D3
00001E76  6100 2188               1563              BSR     PUSH_STACK
00001E7A  163C 002E               1564              MOVE.B  #'.',D3
00001E7E  6100 2180               1565              BSR     PUSH_STACK
00001E82                          1566              
00001E82                          1567              *FIGURE OUT SIZE*
00001E82                          1568              *00 = BYTE
00001E82                          1569              *01 = WORD
00001E82                          1570              *10 = LONG
00001E82                          1571              * BITS 7&6
00001E82                          1572              
00001E82                          1573              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E82  2205                    1574              MOVE.L  D5,D1
00001E84  EC99                    1575              ROR.L   #6,D1
00001E86  0281 00000003           1576              ANDI.L  #$03,D1
00001E8C  0C01 0000               1577              CMPI.B  #%00,D1
00001E90  6700 001E               1578              BEQ     OP0101_ADDQ_B
00001E94  0281 00000003           1579              ANDI.L  #$03,D1
00001E9A  0C01 0001               1580              CMPI.B  #%01,D1
00001E9E  6700 001C               1581              BEQ     OP0101_ADDQ_W
00001EA2  0281 00000003           1582              ANDI.L  #$03,D1
00001EA8  0C01 0002               1583              CMPI.B  #%10,D1
00001EAC  6700 001A               1584              BEQ     OP0101_ADDQ_L
00001EB0                          1585            
00001EB0                          1586  OP0101_ADDQ_B
00001EB0                          1587              
00001EB0  163C 0042               1588              MOVE.B  #'B',D3
00001EB4  6100 214A               1589              BSR     PUSH_STACK
00001EB8  6000 0016               1590              BRA     OP0101_RETURN
00001EBC                          1591  OP0101_ADDQ_W
00001EBC                          1592              
00001EBC  163C 0057               1593              MOVE.B  #'W',D3
00001EC0  6100 213E               1594              BSR     PUSH_STACK
00001EC4  6000 000A               1595              BRA     OP0101_RETURN
00001EC8                          1596  OP0101_ADDQ_L
00001EC8                          1597              
00001EC8  163C 004C               1598              MOVE.B  #'L',D3
00001ECC  6100 2132               1599              BSR     PUSH_STACK
00001ED0                          1600  OP0101_RETURN            
00001ED0                          1601  
00001ED0                          1602              
00001ED0                          1603  *GET DATA FROM ADDQ AND PRINT #0-8
00001ED0  163C 0020               1604              MOVE.B  #' ',D3
00001ED4  6100 212A               1605              BSR     PUSH_STACK
00001ED8  163C 0023               1606              MOVE.B  #'#',D3
00001EDC  6100 2122               1607              BSR     PUSH_STACK 
00001EE0                          1608  
00001EE0                          1609                       
00001EE0                          1610              *GET DATA #   
00001EE0  2205                    1611              MOVE.L  D5,D1
00001EE2  EC99                    1612              ROR.L   #6,D1            
00001EE4  E699                    1613              ROR.L   #3,D1
00001EE6  0281 00000007           1614              ANDI.L  #$07,D1
00001EEC                          1615              
00001EEC  0C01 0000               1616              CMPI.B  #%000,D1
00001EF0  6700 009A               1617              BEQ     OP0101_ADDQ_B_8
00001EF4  0C01 0001               1618              CMPI.B  #%001,D1
00001EF8  6700 003E               1619              BEQ     OP0101_ADDQ_B_1
00001EFC  0C01 0002               1620              CMPI.B  #%010,D1
00001F00  6700 0042               1621              BEQ     OP0101_ADDQ_B_2
00001F04  0C01 0003               1622              CMPI.B  #%011,D1
00001F08  6700 0046               1623              BEQ     OP0101_ADDQ_B_3
00001F0C  0C01 0004               1624              CMPI.B  #%100,D1
00001F10  6700 004A               1625              BEQ     OP0101_ADDQ_B_4
00001F14  0C01 0005               1626              CMPI.B  #%101,D1
00001F18  6700 004E               1627              BEQ     OP0101_ADDQ_B_5
00001F1C  0C01 0006               1628              CMPI.B  #%110,D1
00001F20  6700 0052               1629              BEQ     OP0101_ADDQ_B_6
00001F24  0C01 0007               1630              CMPI.B  #%111,D1
00001F28  6700 0056               1631              BEQ     OP0101_ADDQ_B_7
00001F2C                          1632              
00001F2C                          1633  OP0101_ADDQ_B_0
00001F2C  163C 0030               1634              MOVE.B  #'0',D3
00001F30  6100 20CE               1635              BSR     PUSH_STACK
00001F34  6000 005E               1636              BRA     OP0101_RETURN2            
00001F38                          1637  OP0101_ADDQ_B_1
00001F38  163C 0031               1638              MOVE.B  #'1',D3
00001F3C  6100 20C2               1639              BSR     PUSH_STACK
00001F40  6000 0052               1640              BRA     OP0101_RETURN2            
00001F44                          1641  OP0101_ADDQ_B_2
00001F44  163C 0032               1642              MOVE.B  #'2',D3
00001F48  6100 20B6               1643              BSR     PUSH_STACK
00001F4C  6000 0046               1644              BRA     OP0101_RETURN2            
00001F50                          1645  OP0101_ADDQ_B_3
00001F50  163C 0033               1646              MOVE.B  #'3',D3
00001F54  6100 20AA               1647              BSR     PUSH_STACK
00001F58  6000 003A               1648              BRA     OP0101_RETURN2            
00001F5C                          1649  OP0101_ADDQ_B_4
00001F5C  163C 0034               1650              MOVE.B  #'4',D3
00001F60  6100 209E               1651              BSR     PUSH_STACK
00001F64  6000 002E               1652              BRA     OP0101_RETURN2            
00001F68                          1653  OP0101_ADDQ_B_5
00001F68  163C 0035               1654              MOVE.B  #'5',D3
00001F6C  6100 2092               1655              BSR     PUSH_STACK
00001F70  6000 0022               1656              BRA     OP0101_RETURN2
00001F74                          1657  OP0101_ADDQ_B_6
00001F74  163C 0036               1658              MOVE.B  #'6',D3
00001F78  6100 2086               1659              BSR     PUSH_STACK
00001F7C  6000 0016               1660              BRA     OP0101_RETURN2
00001F80                          1661  OP0101_ADDQ_B_7
00001F80  163C 0037               1662              MOVE.B  #'7',D3
00001F84  6100 207A               1663              BSR     PUSH_STACK
00001F88  6000 000A               1664              BRA     OP0101_RETURN2
00001F8C                          1665  
00001F8C                          1666  OP0101_ADDQ_B_8
00001F8C  163C 0038               1667              MOVE.B  #'8',D3
00001F90  6100 206E               1668              BSR     PUSH_STACK
00001F94                          1669              
00001F94                          1670  OP0101_RETURN2            
00001F94  163C 002C               1671              MOVE.B  #',',D3
00001F98  6100 2066               1672              BSR     PUSH_STACK
00001F9C  6100 17C4               1673              BSR     GET_EA_EA_SRC
00001FA0                          1674              
00001FA0  4E75                    1675              RTS
00001FA2                          1676  
00001FA2                          1677  
00001FA2                          1678              
00001FA2                          1679  *---------------------------------------------------------------------------*
00001FA2                          1680  * OP_ADDQ: display ADDQ
00001FA2                          1681  *---------------------------------------------------------------------------*              
00001FA2                          1682  OP_ADDQ_B    * size is byte   
00001FA2  183C 0000               1683              MOVE.B  #0,D4 
00001FA6  43F9 0000475F           1684              LEA     DISP_ADDQ_B,A1
00001FAC  103C 000E               1685              MOVE.B  #14,D0
00001FB0  4E4F                    1686              TRAP    #15
00001FB2  4E75                    1687              RTS
00001FB4                          1688              
00001FB4                          1689  OP_ADDQ_W    * size is word
00001FB4  183C 0001               1690              MOVE.B  #1,D4
00001FB8  43F9 00004769           1691              LEA     DISP_ADDQ_W,A1
00001FBE  103C 000E               1692              MOVE.B  #14,D0
00001FC2  4E4F                    1693              TRAP    #15
00001FC4  4E75                    1694              RTS
00001FC6                          1695              
00001FC6                          1696  OP_ADDQ_L    * size is long
00001FC6  183C 0002               1697              MOVE.B  #2,D4
00001FCA  43F9 00004773           1698              LEA     DISP_ADDQ_L,A1
00001FD0  103C 000E               1699              MOVE.B  #14,D0
00001FD4  4E4F                    1700              TRAP    #15
00001FD6  4E75                    1701              RTS
00001FD8                          1702  
00001FD8                          1703  *---------------------------------------------------------------------------*
00001FD8                          1704  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FD8                          1705  *---------------------------------------------------------------------------*              
00001FD8  4280                    1706  OP0110      CLR.L   D0                  
00001FDA  4281                    1707              CLR.L   D1   
00001FDC  4284                    1708              CLR.L   D4                 
00001FDE  227C 00000000           1709              MOVEA.L #0,A1
00001FE4  2205                    1710              MOVE.L  D5, D1                
00001FE6  0281 000000FF           1711              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FEC  2205                    1712              MOVE.L  D5,D1                  
00001FEE  0281 00000F00           1713              ANDI.L  #$0F00,D1
00001FF4                          1714                 
00001FF4  0C41 0000               1715              CMPI.W  #$0000,D1               * Check for BRA
00001FF8  6700 0098               1716              BEQ     OP_BRA                  
00001FFC                          1717                          
00001FFC  0C41 0D00               1718              CMPI.W  #$0D00,D1               * Check for BLT
00002000  6700 00B6               1719              BEQ     OP_BLT      
00002004                          1720  
00002004  0C41 0700               1721              CMPI.W  #$0700,D1               * Check for BEQ
00002008  6700 0062               1722              BEQ     OP_BEQ      
0000200C                          1723  
0000200C  0C41 0600               1724              CMPI.W  #$0600,D1               * Check for BNE
00002010  6700 0034               1725              BEQ     OP_BNE  
00002014                          1726              
00002014  0C41 0200               1727              CMPI.W  #$0200,D1               * Check for BHI
00002018  6700 0006               1728              BEQ     OP_BHI
0000201C                          1729  
0000201C  4EF8 175A               1730              JMP     OP_DATA
00002020                          1731              
00002020  163C 0042               1732  OP_BHI      MOVE.B  #'B',D3
00002024  6100 1FDA               1733              BSR     PUSH_STACK
00002028  163C 0048               1734              MOVE.B  #'H',D3
0000202C  6100 1FD2               1735              BSR     PUSH_STACK
00002030  163C 0049               1736              MOVE.B  #'I',D3
00002034  6100 1FCA               1737              BSR     PUSH_STACK
00002038  163C 0009               1738              MOVE.B  #$9,D3
0000203C  6100 1FC2               1739              BSR     PUSH_STACK
00002040  6100 203C               1740              BSR     GET_DISPLACEMENT_ADDRESS
00002044  4E75                    1741              RTS
00002046                          1742  
00002046  163C 0042               1743  OP_BNE      MOVE.B  #'B',D3
0000204A  6100 1FB4               1744              BSR     PUSH_STACK
0000204E  163C 004E               1745              MOVE.B  #'N',D3
00002052  6100 1FAC               1746              BSR     PUSH_STACK
00002056  163C 0045               1747              MOVE.B  #'E',D3
0000205A  6100 1FA4               1748              BSR     PUSH_STACK
0000205E  163C 0009               1749              MOVE.B  #$9,D3
00002062  6100 1F9C               1750              BSR     PUSH_STACK
00002066  6100 2016               1751              BSR     GET_DISPLACEMENT_ADDRESS
0000206A  4E75                    1752              RTS
0000206C                          1753  
0000206C  163C 0042               1754  OP_BEQ      MOVE.B  #'B',D3
00002070  6100 1F8E               1755              BSR     PUSH_STACK
00002074  163C 0045               1756              MOVE.B  #'E',D3
00002078  6100 1F86               1757              BSR     PUSH_STACK
0000207C  163C 0051               1758              MOVE.B  #'Q',D3
00002080  6100 1F7E               1759              BSR     PUSH_STACK
00002084  163C 0009               1760              MOVE.B  #$9,D3
00002088  6100 1F76               1761              BSR     PUSH_STACK
0000208C  6100 1FF0               1762              BSR     GET_DISPLACEMENT_ADDRESS
00002090  4E75                    1763              RTS          
00002092                          1764                          
00002092                          1765  OP_BRA      
00002092  163C 0042               1766              MOVE.B  #'B',D3
00002096  6100 1F68               1767              BSR     PUSH_STACK
0000209A  163C 0052               1768              MOVE.B  #'R',D3
0000209E  6100 1F60               1769              BSR     PUSH_STACK
000020A2  163C 0041               1770              MOVE.B  #'A',D3
000020A6  6100 1F58               1771              BSR     PUSH_STACK
000020AA  163C 0009               1772              MOVE.B  #$9,D3
000020AE  6100 1F50               1773              BSR     PUSH_STACK
000020B2  6100 1FCA               1774              BSR     GET_DISPLACEMENT_ADDRESS
000020B6                          1775              
000020B6  4E75                    1776              RTS
000020B8                          1777              
000020B8  163C 0042               1778  OP_BLT      MOVE.B  #'B',D3
000020BC  6100 1F42               1779              BSR     PUSH_STACK
000020C0  163C 004C               1780              MOVE.B  #'L',D3
000020C4  6100 1F3A               1781              BSR     PUSH_STACK
000020C8  163C 0054               1782              MOVE.B  #'T',D3
000020CC  6100 1F32               1783              BSR     PUSH_STACK
000020D0  163C 0009               1784              MOVE.B  #$9,D3
000020D4  6100 1F2A               1785              BSR     PUSH_STACK
000020D8  6100 1FA4               1786              BSR     GET_DISPLACEMENT_ADDRESS
000020DC  4E75                    1787              RTS
000020DE                          1788     
000020DE                          1789  *---------------------------------------------------------------------------*
000020DE                          1790  * OP0111 : MOVEQ not required
000020DE                          1791  *---------------------------------------------------------------------------*           
000020DE  4EF8 175A               1792  OP0111      JMP     OP_DATA
000020E2                          1793             
000020E2                          1794  *---------------------------------------------------------------------------*
000020E2                          1795  * OP1000 : decode DIVS
000020E2                          1796  *---------------------------------------------------------------------------*           
000020E2                          1797  OP1000                           
000020E2  4281                    1798              CLR.L   D1       
000020E4  4284                    1799              CLR.L   D4                   
000020E6  227C 00000000           1800              MOVEA.L #0, A1              
000020EC  2205                    1801              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020EE                          1802              *CLEAR D3
000020EE  4283                    1803              CLR.L   D3
000020F0                          1804  
000020F0                          1805  OP1000_DIVS_DN_EA_OR_EA_DN 
000020F0                          1806              *LOAD STACK WITH THIS OPMODE
000020F0  6100 1F0E               1807              BSR     PUSH_STACK
000020F4  163C 0044               1808              MOVE.B  #'D',D3
000020F8  6100 1F06               1809              BSR     PUSH_STACK
000020FC  163C 0049               1810              MOVE.B  #'I',D3
00002100  6100 1EFE               1811              BSR     PUSH_STACK
00002104  163C 0056               1812              MOVE.B  #'V',D3
00002108  6100 1EF6               1813              BSR     PUSH_STACK
0000210C  163C 0053               1814              MOVE.B  #'S',D3
00002110  6100 1EEE               1815              BSR     PUSH_STACK
00002114  163C 002E               1816              MOVE.B  #'.',D3
00002118  6100 1EE6               1817              BSR     PUSH_STACK
0000211C                          1818              
0000211C  2205                    1819              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000211E                          1820              
0000211E                          1821  OP1000_EA_DN_DIVS
0000211E                          1822              *BITS (7 TO 6) 
0000211E                          1823              *00 = .B
0000211E                          1824              *01 = .W
0000211E                          1825              *10 = .L 
0000211E  2205                    1826              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002120  EC99                    1827              ROR.L   #6,D1
00002122  0281 00000003           1828              ANDI.L  #$03,D1
00002128  0C81 00000003           1829              CMPI.L  #%11,D1 *EQUALS .W
0000212E  6700 0014               1830              BEQ     OP1000_PRINT_W_DIVS
00002132  0C81 00000000           1831              CMPI.L  #%00,D1 *EQUALS .L
00002138  6700 0052               1832              BEQ     OP1000_PRINT_L_DIVS
0000213C                          1833              
0000213C  183C 0001               1834              MOVE.B  #1,D4               *ERROR READ
00002140  6000 0092               1835              BRA     OP1000_DIVS_RETURN
00002144                          1836  OP1000_PRINT_W_DIVS
00002144  163C 0057               1837              MOVE.B  #'W',D3
00002148  6100 1EB6               1838              BSR     PUSH_STACK
0000214C                          1839  
0000214C                          1840              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000214C  13FC 0000 0000498A      1841              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002154  13FC 0000 0000498B      1842              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000215C                          1843             
0000215C                          1844              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000215C  13FC 00B9 0000498D      1845              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002164  13FC 0020 0000498E      1846              MOVE.B   #$20,GET_SRC_START_END
0000216C                          1847  
0000216C                          1848             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000216C  0285 0000FE3F           1849              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002172  0685 00000000           1850              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002178                          1851  
00002178                          1852              
00002178  6100 15E8               1853              BSR     GET_EA_EA_SRC      *GETS <ea>
0000217C  163C 002C               1854              MOVE.B  #',',D3
00002180  6100 1E7E               1855              BSR     PUSH_STACK
00002184  6100 1A0C               1856              BSR     GET_EA_EA_DEST       *GETS Dn    
00002188                          1857              
00002188  6000 004A               1858              BRA     OP1000_DIVS_RETURN
0000218C                          1859  OP1000_PRINT_L_DIVS
0000218C  163C 004C               1860              MOVE.B  #'L',D3
00002190  6100 1E6E               1861              BSR     PUSH_STACK
00002194                          1862              
00002194                          1863              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002194  13FC 0000 0000498A      1864              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000219C  13FC 0000 0000498B      1865              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021A4                          1866             
000021A4                          1867              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021A4  13FC 00B9 0000498D      1868              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021AC  13FC 0020 0000498E      1869              MOVE.B   #$20,GET_SRC_START_END
000021B4                          1870  
000021B4                          1871              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021B4  0285 0000FE3F           1872              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021BA  0685 00000000           1873              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021C0                          1874  
000021C0                          1875                     
000021C0  6100 15A0               1876              BSR     GET_EA_EA_SRC      *GETS <ea>
000021C4  163C 002C               1877              MOVE.B  #',',D3
000021C8  6100 1E36               1878              BSR     PUSH_STACK                  
000021CC  6100 19C4               1879              BSR     GET_EA_EA_DEST       *GETS Dn    
000021D0                          1880  
000021D0                          1881              
000021D0  6000 0002               1882              BRA     OP1000_DIVS_RETURN
000021D4                          1883              
000021D4                          1884  OP1000_DIVS_RETURN
000021D4  4E75                    1885              RTS
000021D6                          1886              
000021D6                          1887  
000021D6                          1888  
000021D6                          1889  *---------------------------------------------------------------------------*
000021D6                          1890  * OP_DIVS: display DIVS and proceed to EA
000021D6                          1891  *---------------------------------------------------------------------------*  
000021D6  43F9 0000477D           1892  OP_DIVS     LEA     DISP_DIVS,A1
000021DC  103C 000E               1893              MOVE.B  #14,D0
000021E0  4E4F                    1894              TRAP    #15
000021E2  4EF9 000032C6           1895              JMP     EA_ARITH
000021E8                          1896  
000021E8  4E75                    1897              RTS
000021EA                          1898              
000021EA                          1899  *---------------------------------------------------------------------------*
000021EA                          1900  * OP1001: decode SUB/SUBA
000021EA                          1901  *---------------------------------------------------------------------------*      
000021EA                          1902  OP1001      
000021EA  4280                    1903              CLR.L   D0                  
000021EC  4281                    1904              CLR.L   D1       
000021EE  4284                    1905              CLR.L   D4                   
000021F0  227C 00000000           1906              MOVEA.L #0, A1              
000021F6  2205                    1907              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000021F8                          1908              
000021F8                          1909              *CLEAR D3
000021F8  4283                    1910              CLR.L   D3
000021FA                          1911              
000021FA                          1912              
000021FA                          1913              
000021FA                          1914              **INTEGRATING SUB.W/.L INTO THIS CODE**
000021FA  2205                    1915              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021FC                          1916              *BITS (INDEX 8) 
000021FC                          1917              *0 = ADD.B/W/L <EA>,Dn
000021FC                          1918              *1 = ADD.B/W/L Dn,<EA> 
000021FC  EC99                    1919              ROR.L   #6,D1
000021FE  0281 00000007           1920              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002204  0C81 00000007           1921              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
0000220A  6700 0010               1922              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
0000220E  0C81 00000003           1923              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002214  6700 0078               1924              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00002218  6000 00E6               1925              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000221C                          1926              
0000221C                          1927  OP1001_SUBA_L
0000221C                          1928              *LOAD STACK WITH THIS OPMODE
0000221C  6100 1DE2               1929              BSR     PUSH_STACK
00002220  163C 0053               1930              MOVE.B  #'S',D3
00002224  6100 1DDA               1931              BSR     PUSH_STACK
00002228  163C 0055               1932              MOVE.B  #'U',D3
0000222C  6100 1DD2               1933              BSR     PUSH_STACK
00002230  163C 0042               1934              MOVE.B  #'B',D3
00002234  6100 1DCA               1935              BSR     PUSH_STACK
00002238  163C 0041               1936              MOVE.B  #'A',D3
0000223C  6100 1DC2               1937              BSR     PUSH_STACK
00002240  163C 002E               1938              MOVE.B  #'.',D3
00002244  6100 1DBA               1939              BSR     PUSH_STACK
00002248  163C 004C               1940              MOVE.B  #'L',D3
0000224C  6100 1DB2               1941              BSR     PUSH_STACK
00002250                          1942              
00002250                          1943             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002250  13FC 0000 0000498A      1944             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002258  13FC 0000 0000498B      1945             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002260                          1946             
00002260                          1947             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002260  13FC 00B9 0000498D      1948             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002268  13FC 0020 0000498E      1949             MOVE.B   #$20,GET_SRC_START_END
00002270                          1950  
00002270                          1951              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002270  0285 0000FE3F           1952              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002276  0685 00000040           1953              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000227C                          1954       
0000227C                          1955              *PRINT <EA>,AN
0000227C  6100 14E4               1956              BSR     GET_EA_EA_SRC       *GETS <ea>
00002280  163C 002C               1957              MOVE.B  #',',D3
00002284  6100 1D7A               1958              BSR     PUSH_STACK                     
00002288  6100 1908               1959              BSR     GET_EA_EA_DEST      *GETS Dn
0000228C                          1960  
0000228C                          1961              
0000228C                          1962              
0000228C  4E75                    1963              RTS
0000228E                          1964  OP1001_SUBA_W
0000228E                          1965              *LOAD STACK WITH THIS OPMODE
0000228E  6100 1D70               1966              BSR     PUSH_STACK
00002292  163C 0053               1967              MOVE.B  #'S',D3
00002296  6100 1D68               1968              BSR     PUSH_STACK
0000229A  163C 0055               1969              MOVE.B  #'U',D3
0000229E  6100 1D60               1970              BSR     PUSH_STACK
000022A2  163C 0042               1971              MOVE.B  #'B',D3
000022A6  6100 1D58               1972              BSR     PUSH_STACK
000022AA  163C 0041               1973              MOVE.B  #'A',D3
000022AE  6100 1D50               1974              BSR     PUSH_STACK
000022B2  163C 002E               1975              MOVE.B  #'.',D3
000022B6  6100 1D48               1976              BSR     PUSH_STACK
000022BA  163C 0057               1977              MOVE.B  #'W',D3
000022BE  6100 1D40               1978              BSR     PUSH_STACK
000022C2                          1979              
000022C2                          1980             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022C2  13FC 0000 0000498A      1981             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022CA  13FC 0000 0000498B      1982             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022D2                          1983             
000022D2                          1984             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022D2  13FC 00B9 0000498D      1985             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022DA  13FC 0020 0000498E      1986             MOVE.B   #$20,GET_SRC_START_END
000022E2                          1987  
000022E2                          1988              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022E2  0285 0000FE3F           1989              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022E8  0685 00000040           1990              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022EE                          1991       
000022EE                          1992              *PRINT <EA>,AN
000022EE  6100 1472               1993              BSR     GET_EA_EA_SRC       *GETS <ea>
000022F2  163C 002C               1994              MOVE.B  #',',D3
000022F6  6100 1D08               1995              BSR     PUSH_STACK                     
000022FA  6100 1896               1996              BSR     GET_EA_EA_DEST      *GETS Dn
000022FE                          1997  
000022FE  4E75                    1998              RTS
00002300                          1999  
00002300                          2000  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00002300                          2001              *LOAD STACK WITH THIS OPMODE
00002300  6100 1CFE               2002              BSR     PUSH_STACK
00002304  163C 0053               2003              MOVE.B  #'S',D3
00002308  6100 1CF6               2004              BSR     PUSH_STACK
0000230C  163C 0055               2005              MOVE.B  #'U',D3
00002310  6100 1CEE               2006              BSR     PUSH_STACK
00002314  163C 0042               2007              MOVE.B  #'B',D3
00002318  6100 1CE6               2008              BSR     PUSH_STACK
0000231C  163C 002E               2009              MOVE.B  #'.',D3
00002320  6100 1CDE               2010              BSR     PUSH_STACK
00002324                          2011              
00002324  2205                    2012              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002326                          2013              
00002326                          2014              *BITS (INDEX 8) 
00002326                          2015              *0 = ADD.B/W/L <EA>,Dn
00002326                          2016              *1 = ADD.B/W/L Dn,<EA> 
00002326  E099                    2017              ROR.L   #8,D1
00002328  0281 00000001           2018              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000232E  0C81 00000000           2019              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002334  6700 0102               2020              BEQ     OP1001_EA_DN
00002338                          2021              *else procede to Dn_EA
00002338                          2022              
00002338                          2023  OP1001_DN_EA
00002338                          2024              *BITS (7 TO 6) 
00002338                          2025              *00 = .B
00002338                          2026              *01 = .W
00002338                          2027              *10 = .L 
00002338  2205                    2028              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000233A  EC99                    2029              ROR.L   #6,D1
0000233C  0281 00000003           2030              ANDI.L  #$03,D1
00002342  0C81 00000000           2031              CMPI.L  #$00,D1 *EQUALS .B
00002348  6700 0016               2032              BEQ     OP1001_PRINT_B2
0000234C  0C81 00000001           2033              CMPI.L  #$01,D1 *EQUALS .W
00002352  6700 0054               2034              BEQ     OP1001_PRINT_W2
00002356  0C81 00000002           2035              CMPI.L  #$02,D1 *EQUALS .L
0000235C  6700 0092               2036              BEQ     OP1001_PRINT_L2
00002360                          2037  OP1001_PRINT_B2
00002360                          2038              *PUSH 'B'
00002360  163C 0042               2039              MOVE.B  #'B',D3
00002364  6100 1C9A               2040              BSR     PUSH_STACK
00002368                          2041             
00002368                          2042              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002368  13FC 0000 0000498A      2043             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002370  13FC 0083 0000498B      2044             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002378                          2045             
00002378                          2046             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002378  13FC 00B9 0000498D      2047             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002380  13FC 0020 0000498E      2048             MOVE.B   #$20,GET_SRC_START_END
00002388                          2049  
00002388                          2050              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002388  0285 0000FE3F           2051              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000238E  0685 00000040           2052              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002394                          2053       
00002394  6100 17FC               2054              BSR     GET_EA_EA_DEST      *GETS Dn
00002398  163C 002C               2055              MOVE.B  #',',D3
0000239C  6100 1C62               2056              BSR     PUSH_STACK                     
000023A0  6100 13C0               2057              BSR     GET_EA_EA_SRC       *GETS <ea>
000023A4                          2058  
000023A4                          2059              
000023A4  6000 0BA4               2060              BRA     OP1101_ADD_RETURN
000023A8                          2061  OP1001_PRINT_W2
000023A8  163C 0057               2062              MOVE.B  #'W',D3
000023AC  6100 1C52               2063              BSR     PUSH_STACK
000023B0                          2064  
000023B0                          2065              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023B0  13FC 0000 0000498A      2066              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023B8  13FC 0083 0000498B      2067              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023C0                          2068             
000023C0                          2069              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023C0  13FC 00B9 0000498D      2070              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023C8  13FC 0020 0000498E      2071              MOVE.B   #$20,GET_SRC_START_END
000023D0                          2072  
000023D0                          2073              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023D0  0285 0000FE3F           2074              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023D6  0685 00000040           2075              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000023DC                          2076  
000023DC                          2077        
000023DC  6100 17B4               2078              BSR     GET_EA_EA_DEST      *GETS Dn
000023E0  163C 002C               2079              MOVE.B  #',',D3
000023E4  6100 1C1A               2080              BSR     PUSH_STACK               
000023E8  6100 1378               2081              BSR     GET_EA_EA_SRC       *GETS <ea>       
000023EC                          2082  
000023EC                          2083  
000023EC                          2084  
000023EC  6000 0B5C               2085              BRA     OP1101_ADD_RETURN
000023F0                          2086  OP1001_PRINT_L2 
000023F0  163C 004C               2087              MOVE.B  #'L',D3
000023F4  6100 1C0A               2088              BSR     PUSH_STACK
000023F8                          2089              
000023F8                          2090              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023F8  13FC 0000 0000498A      2091              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002400  13FC 0083 0000498B      2092              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002408                          2093             
00002408                          2094              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002408  13FC 00B9 0000498D      2095              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002410  13FC 0020 0000498E      2096              MOVE.B   #$20,GET_SRC_START_END
00002418                          2097  
00002418                          2098             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002418  0285 0000FE3F           2099              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000241E  0685 00000040           2100              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002424                          2101  
00002424                          2102               
00002424  6100 176C               2103              BSR     GET_EA_EA_DEST       *GETS Dn
00002428  163C 002C               2104              MOVE.B  #',',D3
0000242C  6100 1BD2               2105              BSR     PUSH_STACK          
00002430  6100 1330               2106              BSR     GET_EA_EA_SRC        *GETS <ea>
00002434                          2107  
00002434  6000 0B14               2108              BRA     OP1101_ADD_RETURN
00002438                          2109              
00002438                          2110  OP1001_EA_DN           
00002438                          2111              *BITS (7 TO 6) 
00002438                          2112              *00 = .B
00002438                          2113              *01 = .W
00002438                          2114              *10 = .L 
00002438  2205                    2115              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000243A  EC99                    2116              ROR.L   #6,D1
0000243C  0281 00000003           2117              ANDI.L  #$03,D1
00002442  0C81 00000000           2118              CMPI.L  #$00,D1 *EQUALS .B
00002448  6700 0016               2119              BEQ     OP1001_PRINT_B
0000244C  0C81 00000001           2120              CMPI.L  #$01,D1 *EQUALS .W
00002452  6700 0054               2121              BEQ     OP1001_PRINT_W
00002456  0C81 00000002           2122              CMPI.L  #$02,D1 *EQUALS .L
0000245C  6700 0092               2123              BEQ     OP1001_PRINT_L
00002460                          2124  OP1001_PRINT_B
00002460  163C 0042               2125              MOVE.B  #'B',D3
00002464  6100 1B9A               2126              BSR     PUSH_STACK
00002468                          2127                
00002468                          2128              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002468  13FC 0000 0000498A      2129              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002470  13FC 0002 0000498B      2130              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002478                          2131             
00002478                          2132              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002478  13FC 00B9 0000498D      2133              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002480  13FC 0020 0000498E      2134              MOVE.B   #$20,GET_SRC_START_END
00002488                          2135  
00002488                          2136             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002488  0285 0000FE3F           2137              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000248E  0685 00000040           2138              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002494                          2139  
00002494                          2140              
00002494  6100 12CC               2141              BSR     GET_EA_EA_SRC      *GETS <ea>
00002498  163C 002C               2142              MOVE.B  #',',D3
0000249C  6100 1B62               2143              BSR     PUSH_STACK          
000024A0  6100 16F0               2144              BSR     GET_EA_EA_DEST       *GETS Dn
000024A4                          2145              
000024A4  6000 0AA4               2146              BRA     OP1101_ADD_RETURN
000024A8                          2147  OP1001_PRINT_W
000024A8  163C 0057               2148              MOVE.B  #'W',D3
000024AC  6100 1B52               2149              BSR     PUSH_STACK
000024B0                          2150  
000024B0                          2151              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024B0  13FC 0000 0000498A      2152              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024B8  13FC 0000 0000498B      2153              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024C0                          2154             
000024C0                          2155              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024C0  13FC 00B9 0000498D      2156              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024C8  13FC 0020 0000498E      2157              MOVE.B   #$20,GET_SRC_START_END
000024D0                          2158  
000024D0                          2159             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024D0  0285 0000FE3F           2160              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024D6  0685 00000040           2161              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024DC                          2162  
000024DC                          2163              
000024DC  6100 1284               2164              BSR     GET_EA_EA_SRC      *GETS <ea>
000024E0  163C 002C               2165              MOVE.B  #',',D3
000024E4  6100 1B1A               2166              BSR     PUSH_STACK
000024E8  6100 16A8               2167              BSR     GET_EA_EA_DEST       *GETS Dn    
000024EC                          2168              
000024EC  6000 004A               2169              BRA     OP1001_ADD_RETURN
000024F0                          2170  OP1001_PRINT_L 
000024F0  163C 004C               2171              MOVE.B  #'L',D3
000024F4  6100 1B0A               2172              BSR     PUSH_STACK
000024F8                          2173              
000024F8                          2174              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024F8  13FC 0000 0000498A      2175              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002500  13FC 0000 0000498B      2176              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002508                          2177             
00002508                          2178              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002508  13FC 00B9 0000498D      2179              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002510  13FC 0020 0000498E      2180              MOVE.B   #$20,GET_SRC_START_END
00002518                          2181  
00002518                          2182              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002518  0285 0000FE3F           2183              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000251E  0685 00000040           2184              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002524                          2185  
00002524                          2186                     
00002524  6100 123C               2187              BSR     GET_EA_EA_SRC      *GETS <ea>
00002528  163C 002C               2188              MOVE.B  #',',D3
0000252C  6100 1AD2               2189              BSR     PUSH_STACK                  
00002530  6100 1660               2190              BSR     GET_EA_EA_DEST       *GETS Dn    
00002534                          2191  
00002534                          2192              
00002534  6000 0002               2193              BRA     OP1001_ADD_RETURN
00002538                          2194              
00002538                          2195  OP1001_ADD_RETURN
00002538  4E75                    2196              RTS
0000253A                          2197  
0000253A                          2198    
0000253A                          2199  *---------------------------------------------------------------------------*
0000253A                          2200  * OP_SUB: display SUB and proceed to EA
0000253A                          2201  *---------------------------------------------------------------------------*            
0000253A  43F9 00004785           2202  OP_SUB_B    LEA     DISP_SUB_B,A1
00002540  103C 000E               2203              MOVE.B  #14,D0
00002544  4E4F                    2204              TRAP    #15
00002546  183C 0000               2205              MOVE.B  #0,D4
0000254A  4EF9 00003312           2206              JMP     EA_GEN
00002550                          2207  
00002550  4E75                    2208              RTS
00002552                          2209  
00002552  43F9 0000478E           2210  OP_SUB_W    LEA     DISP_SUB_W,A1
00002558  103C 000E               2211              MOVE.B  #14,D0
0000255C  4E4F                    2212              TRAP    #15
0000255E  183C 0001               2213              MOVE.B  #1,D4
00002562  4EF9 00003312           2214              JMP     EA_GEN
00002568                          2215  
00002568  4E75                    2216              RTS
0000256A                          2217  
0000256A  43F9 00004797           2218  OP_SUB_L    LEA     DISP_SUB_L,A1
00002570  103C 000E               2219              MOVE.B  #14,D0
00002574  4E4F                    2220              TRAP    #15
00002576  183C 0002               2221              MOVE.B  #2,D4
0000257A  4EF9 00003312           2222              JMP     EA_GEN
00002580                          2223  
00002580  4E75                    2224              RTS
00002582                          2225  
00002582                          2226  *---------------------------------------------------------------------------*
00002582                          2227  * OP_SUBA: display SUBA
00002582                          2228  *---------------------------------------------------------------------------*  
00002582  43F9 000047BE           2229  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00002588  103C 000E               2230              MOVE.B  #14,D0
0000258C  4E4F                    2231              TRAP    #15
0000258E  183C 0001               2232              MOVE.B  #1,D4
00002592  4E75                    2233              RTS
00002594                          2234  
00002594  43F9 000047C8           2235  OP_SUBA_L   LEA     DISP_SUBA_L,A1
0000259A  103C 000E               2236              MOVE.B  #14,D0
0000259E  4E4F                    2237              TRAP    #15
000025A0  183C 0002               2238              MOVE.B  #2,D4
000025A4  4E75                    2239              RTS         
000025A6                          2240  *---------------------------------------------------------------------------*
000025A6                          2241  * OP1010 : unassigned
000025A6                          2242  *---------------------------------------------------------------------------*           
000025A6  4EF8 175A               2243  OP1010      JMP     OP_DATA
000025AA                          2244              
000025AA                          2245  *---------------------------------------------------------------------------*
000025AA                          2246  * OP1011 : decode CMP/EOR/CMPA
000025AA                          2247  *---------------------------------------------------------------------------*           
000025AA  4280                    2248  OP1011      CLR.L   D0                
000025AC  4281                    2249              CLR.L   D1            
000025AE  4284                    2250              CLR.L   D4                   
000025B0  227C 00000000           2251              MOVEA.L #0, A1               
000025B6  2205                    2252              MOVE.L  D5,D1
000025B8  EA99                    2253              ROR.L   #5,D1
000025BA  0281 0000000E           2254              ANDI.L  #$E,D1
000025C0  0C01 0000               2255              CMPI.B  #$0,D1
000025C4  6700 003E               2256              BEQ     OP1011_CMP
000025C8  0C01 0002               2257              CMPI.B  #$2,D1
000025CC  6700 0036               2258              BEQ     OP1011_CMP
000025D0  0C01 0004               2259              CMPI.B  #$4,D1
000025D4  6700 002E               2260              BEQ     OP1011_CMP
000025D8  0C01 0008               2261              CMPI.B  #$8,D1
000025DC  6700 0178               2262              BEQ     OP1011_EOR
000025E0  0C01 000A               2263              CMPI.B  #$A,D1
000025E4  6700 0170               2264              BEQ     OP1011_EOR
000025E8  0C01 000C               2265              CMPI.B  #$C,D1
000025EC  6700 0168               2266              BEQ     OP1011_EOR  
000025F0  0C01 0006               2267              CMPI.B  #$6,D1
000025F4  6700 00C0               2268              BEQ     OP1011_CMPA
000025F8  0C01 000E               2269              CMPI.B  #$E,D1
000025FC  6700 00B8               2270              BEQ     OP1011_CMPA 
00002600                          2271  
00002600  4EF8 175A               2272              JMP     OP_DATA          
00002604                          2273  
00002604                          2274  
00002604                          2275  
00002604                          2276  
00002604                          2277  OP1011_CMP
00002604                          2278             
00002604                          2279   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002604  13FC 0082 0000498A      2280             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000260C  13FC 0000 0000498B      2281             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002614                          2282             
00002614                          2283             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002614  13FC 00B9 0000498D      2284             MOVE.B   #$B9,GET_DST_START_END
0000261C  13FC 0020 0000498E      2285             MOVE.B   #$20,GET_SRC_START_END
00002624                          2286             
00002624                          2287              *CLEAR D3
00002624  4283                    2288              CLR.L   D3
00002626                          2289              *LOAD STACK WITH THIS OPMODE
00002626  6100 19D8               2290              BSR     PUSH_STACK
0000262A  163C 0043               2291              MOVE.B  #'C',D3
0000262E  6100 19D0               2292              BSR     PUSH_STACK
00002632  163C 004D               2293              MOVE.B  #'M',D3
00002636  6100 19C8               2294              BSR     PUSH_STACK
0000263A  163C 0050               2295              MOVE.B  #'P',D3
0000263E  6100 19C0               2296              BSR     PUSH_STACK
00002642  163C 002E               2297              MOVE.B  #'.',D3
00002646  6100 19B8               2298              BSR     PUSH_STACK
0000264A                          2299              
0000264A                          2300              *FIGURE OUT SIZE*
0000264A                          2301              *00 = BYTE
0000264A                          2302              *01 = WORD
0000264A                          2303              *10 = LONG
0000264A                          2304              * BITS 7&6
0000264A                          2305              
0000264A                          2306              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000264A  2205                    2307              MOVE.L  D5,D1
0000264C  EC99                    2308              ROR.L   #6,D1
0000264E  0281 00000003           2309              ANDI.L  #$03,D1
00002654  0C01 0000               2310              CMPI.B  #%00,D1
00002658  6700 001E               2311              BEQ     OP1011_CMP_B
0000265C  0281 00000003           2312              ANDI.L  #$03,D1
00002662  0C01 0001               2313              CMPI.B  #%01,D1
00002666  6700 001C               2314              BEQ     OP1011_CMP_W
0000266A  0281 00000003           2315              ANDI.L  #$03,D1
00002670  0C01 0002               2316              CMPI.B  #%10,D1
00002674  6700 001A               2317              BEQ     OP1011_CMP_L
00002678                          2318            
00002678                          2319  OP1011_CMP_B
00002678                          2320              
00002678  163C 0042               2321              MOVE.B  #'B',D3
0000267C  6100 1982               2322              BSR     PUSH_STACK
00002680  6000 0016               2323              BRA     OP1011_RETURN_CMP  
00002684                          2324  OP1011_CMP_W
00002684                          2325              
00002684  163C 0057               2326              MOVE.B  #'W',D3
00002688  6100 1976               2327              BSR     PUSH_STACK
0000268C  6000 000A               2328              BRA     OP1011_RETURN_CMP  
00002690                          2329  OP1011_CMP_L
00002690                          2330              
00002690  163C 004C               2331              MOVE.B  #'L',D3
00002694  6100 196A               2332              BSR     PUSH_STACK
00002698                          2333  OP1011_RETURN_CMP            
00002698                          2334  
00002698                          2335              
00002698                          2336  *GET DATA FROM ADDQ AND PRINT #0-8
00002698                          2337       
00002698                          2338              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002698  0285 0000FE3F           2339              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000269E  0685 00000000           2340              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026A4                          2341  
000026A4  6100 10BC               2342              BSR     GET_EA_EA_SRC
000026A8  163C 002C               2343              MOVE.B  #',',D3
000026AC  6100 1952               2344              BSR     PUSH_STACK
000026B0  6100 14E0               2345              BSR     GET_EA_EA_DEST
000026B4                          2346              
000026B4  4E75                    2347              RTS
000026B6                          2348              
000026B6                          2349  
000026B6                          2350  
000026B6                          2351  OP1011_CMPA
000026B6                          2352              
000026B6                          2353   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026B6  13FC 0080 0000498A      2354             MOVE.B   #$80,DEST_REGISTER_FORMAT
000026BE  13FC 0000 0000498B      2355             MOVE.B   #$00,SRC_REGISTER_FORMAT
000026C6                          2356             
000026C6                          2357             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026C6  13FC 00B9 0000498D      2358             MOVE.B   #$B9,GET_DST_START_END
000026CE  13FC 0020 0000498E      2359             MOVE.B   #$20,GET_SRC_START_END
000026D6                          2360             
000026D6                          2361              *CLEAR D3
000026D6  4283                    2362              CLR.L   D3
000026D8                          2363              *LOAD STACK WITH THIS OPMODE
000026D8  6100 1926               2364              BSR     PUSH_STACK
000026DC  163C 0043               2365              MOVE.B  #'C',D3
000026E0  6100 191E               2366              BSR     PUSH_STACK
000026E4  163C 004D               2367              MOVE.B  #'M',D3
000026E8  6100 1916               2368              BSR     PUSH_STACK
000026EC  163C 0050               2369              MOVE.B  #'P',D3
000026F0  6100 190E               2370              BSR     PUSH_STACK
000026F4  163C 0041               2371              MOVE.B  #'A',D3
000026F8  6100 1906               2372              BSR     PUSH_STACK
000026FC  163C 002E               2373              MOVE.B  #'.',D3
00002700  6100 18FE               2374              BSR     PUSH_STACK
00002704                          2375              
00002704                          2376              *FIGURE OUT SIZE*
00002704                          2377              *00 = BYTE
00002704                          2378              *01 = WORD
00002704                          2379              *10 = LONG
00002704                          2380              * BITS 7&6
00002704                          2381              
00002704                          2382              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002704  2205                    2383              MOVE.L  D5,D1
00002706  EC99                    2384              ROR.L   #6,D1
00002708  0281 00000003           2385              ANDI.L  #$03,D1
0000270E  0C01 0001               2386              CMPI.B  #%01,D1
00002712  6700 0010               2387              BEQ     OP1011_CMPA_W
00002716  0281 00000003           2388              ANDI.L  #$03,D1
0000271C  0C01 0002               2389              CMPI.B  #%10,D1
00002720  6700 000E               2390              BEQ     OP1011_CMPA_L
00002724                          2391  OP1011_CMPA_W
00002724                          2392              
00002724  163C 0057               2393              MOVE.B  #'W',D3
00002728  6100 18D6               2394              BSR     PUSH_STACK
0000272C  6000 000A               2395              BRA     OP1011_RETURN_CMPA 
00002730                          2396  OP1011_CMPA_L
00002730                          2397              
00002730  163C 004C               2398              MOVE.B  #'L',D3
00002734  6100 18CA               2399              BSR     PUSH_STACK
00002738                          2400  OP1011_RETURN_CMPA            
00002738                          2401  
00002738                          2402              
00002738                          2403  *GET DATA FROM ADDQ AND PRINT #0-8
00002738                          2404       
00002738                          2405              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002738  0285 0000FE3F           2406              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000273E  0685 00000040           2407              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00002744                          2408  
00002744  6100 101C               2409              BSR     GET_EA_EA_SRC
00002748  163C 002C               2410              MOVE.B  #',',D3
0000274C  6100 18B2               2411              BSR     PUSH_STACK
00002750  6100 1440               2412              BSR     GET_EA_EA_DEST
00002754                          2413              
00002754  4E75                    2414              RTS
00002756                          2415  
00002756                          2416  OP1011_EOR
00002756                          2417  
00002756                          2418   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002756  13FC 0082 0000498A      2419             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000275E  13FC 0080 0000498B      2420             MOVE.B   #$80,SRC_REGISTER_FORMAT
00002766                          2421             
00002766                          2422             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002766  13FC 00B9 0000498D      2423             MOVE.B   #$B9,GET_DST_START_END
0000276E  13FC 0020 0000498E      2424             MOVE.B   #$20,GET_SRC_START_END
00002776                          2425             
00002776                          2426              *CLEAR D3
00002776  4283                    2427              CLR.L   D3
00002778                          2428              *LOAD STACK WITH THIS OPMODE
00002778  6100 1886               2429              BSR     PUSH_STACK
0000277C  163C 0045               2430              MOVE.B  #'E',D3
00002780  6100 187E               2431              BSR     PUSH_STACK
00002784  163C 004F               2432              MOVE.B  #'O',D3
00002788  6100 1876               2433              BSR     PUSH_STACK
0000278C  163C 0052               2434              MOVE.B  #'R',D3
00002790  6100 186E               2435              BSR     PUSH_STACK
00002794  163C 002E               2436              MOVE.B  #'.',D3
00002798  6100 1866               2437              BSR     PUSH_STACK
0000279C                          2438              
0000279C                          2439              *FIGURE OUT SIZE*
0000279C                          2440              *00 = BYTE
0000279C                          2441              *01 = WORD
0000279C                          2442              *10 = LONG
0000279C                          2443              * BITS 7&6
0000279C                          2444              
0000279C                          2445              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000279C  2205                    2446              MOVE.L  D5,D1
0000279E  EC99                    2447              ROR.L   #6,D1
000027A0  0281 00000003           2448              ANDI.L  #$03,D1
000027A6  0C01 0000               2449              CMPI.B  #%00,D1
000027AA  6700 001E               2450              BEQ     OP1011_EOR_B
000027AE  0281 00000003           2451              ANDI.L  #$03,D1
000027B4  0C01 0001               2452              CMPI.B  #%01,D1
000027B8  6700 001C               2453              BEQ     OP1011_EOR_W
000027BC  0281 00000003           2454              ANDI.L  #$03,D1
000027C2  0C01 0002               2455              CMPI.B  #%10,D1
000027C6  6700 001A               2456              BEQ     OP1011_EOR_L
000027CA                          2457            
000027CA                          2458  OP1011_EOR_B
000027CA                          2459              
000027CA  163C 0042               2460              MOVE.B  #'B',D3
000027CE  6100 1830               2461              BSR     PUSH_STACK
000027D2  6000 0016               2462              BRA     OP1011_RETURN
000027D6                          2463  OP1011_EOR_W
000027D6                          2464              
000027D6  163C 0057               2465              MOVE.B  #'W',D3
000027DA  6100 1824               2466              BSR     PUSH_STACK
000027DE  6000 000A               2467              BRA     OP1011_RETURN
000027E2                          2468  OP1011_EOR_L
000027E2                          2469              
000027E2  163C 004C               2470              MOVE.B  #'L',D3
000027E6  6100 1818               2471              BSR     PUSH_STACK
000027EA                          2472  OP1011_RETURN            
000027EA                          2473  
000027EA                          2474              
000027EA                          2475  *GET DATA FROM ADDQ AND PRINT #0-8
000027EA                          2476       
000027EA                          2477              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027EA  0285 0000FE3F           2478              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027F0  0685 00000000           2479              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027F6                          2480  
000027F6  6100 139A               2481              BSR     GET_EA_EA_DEST
000027FA  163C 002C               2482              MOVE.B  #',',D3
000027FE  6100 1800               2483              BSR     PUSH_STACK
00002802  6100 0F5E               2484              BSR     GET_EA_EA_SRC
00002806                          2485              
00002806  4E75                    2486              RTS
00002808                          2487              
00002808                          2488              
00002808                          2489              
00002808                          2490              
00002808                          2491  
00002808                          2492  *---------------------------------------------------------------------------*
00002808                          2493  * OP_CMPA: display CMPA 
00002808                          2494  *---------------------------------------------------------------------------
00002808  43F9 00004808           2495  OP_CMPA_W   LEA     DISP_CMPA_W,A1
0000280E  103C 000E               2496              MOVE.B  #14,D0
00002812  4E4F                    2497              TRAP    #15
00002814  183C 0001               2498              MOVE.B  #1,D4
00002818  4E75                    2499              RTS
0000281A                          2500  
0000281A  43F9 00004812           2501  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002820  103C 000E               2502              MOVE.B  #14,D0
00002824  4E4F                    2503              TRAP    #15
00002826  183C 0002               2504              MOVE.B  #2,D4
0000282A  4E75                    2505              RTS
0000282C                          2506  
0000282C                          2507  *---------------------------------------------------------------------------*
0000282C                          2508  * OP_CMP: display CMP and proceed to EA
0000282C                          2509  *---------------------------------------------------------------------------*  
0000282C  43F9 000047ED           2510  OP_CMP_B    LEA     DISP_CMP_B,A1
00002832  103C 000E               2511              MOVE.B  #14,D0
00002836  4E4F                    2512              TRAP    #15
00002838  183C 0000               2513              MOVE.B  #0,D4
0000283C  4EF9 00003312           2514              JMP     EA_GEN
00002842                          2515  
00002842  4E75                    2516              RTS
00002844                          2517              
00002844  43F9 000047F6           2518  OP_CMP_W    LEA     DISP_CMP_W,A1
0000284A  103C 000E               2519              MOVE.B  #14,D0
0000284E  4E4F                    2520              TRAP    #15
00002850  183C 0001               2521              MOVE.B  #1,D4
00002854  4EF9 00003312           2522              JMP     EA_GEN
0000285A                          2523  
0000285A  4E75                    2524              RTS
0000285C                          2525              
0000285C  43F9 000047FF           2526  OP_CMP_L    LEA     DISP_CMP_L,A1
00002862  103C 000E               2527              MOVE.B  #14,D0
00002866  4E4F                    2528              TRAP    #15
00002868  183C 0002               2529              MOVE.B  #2,D4
0000286C  4EF9 00003312           2530              JMP     EA_GEN
00002872                          2531  
00002872  4E75                    2532              RTS
00002874                          2533              
00002874                          2534  *---------------------------------------------------------------------------*
00002874                          2535  * OP_EOR: display EOR
00002874                          2536  *---------------------------------------------------------------------------*  
00002874  43F9 000047D2           2537  OP_EOR_B    LEA     DISP_EOR_B,A1
0000287A  103C 000E               2538              MOVE.B  #14,D0
0000287E  4E4F                    2539              TRAP    #15
00002880  183C 0000               2540              MOVE.B  #0,D4
00002884  4E75                    2541              RTS
00002886                          2542              
00002886  43F9 000047DB           2543  OP_EOR_W    LEA     DISP_EOR_W,A1
0000288C  103C 000E               2544              MOVE.B  #14,D0
00002890  4E4F                    2545              TRAP    #15
00002892  183C 0001               2546              MOVE.B  #1,D4
00002896  4E75                    2547              RTS
00002898                          2548              
00002898  43F9 000047E4           2549  OP_EOR_L    LEA     DISP_EOR_L,A1
0000289E  103C 000E               2550              MOVE.B  #14,D0
000028A2  4E4F                    2551              TRAP    #15
000028A4  183C 0002               2552              MOVE.B  #2,D4
000028A8  4E75                    2553              RTS    
000028AA                          2554  
000028AA                          2555  *---------------------------------------------------------------------------*
000028AA                          2556  * OP1100: Decode and display MULS/AND and proceed to EA
000028AA                          2557  *---------------------------------------------------------------------------* 
000028AA  4280                    2558  OP1100      CLR.L   D0                 
000028AC  4281                    2559              CLR.L   D1    
000028AE  4284                    2560              CLR.L   D4                
000028B0  227C 00000000           2561              MOVEA.L #0, A1        
000028B6  2205                    2562              MOVE.L  D5,D1
000028B8  EA89                    2563              LSR.L   #5,D1
000028BA  0281 0000000E           2564              ANDI.L  #$E,D1
000028C0  0C41 000E               2565              CMPI.W  #$E,D1
000028C4  6700 0006               2566              BEQ     OP_MULS
000028C8  6000 00F6               2567              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000028CC                          2568  
000028CC                          2569  OP_MULS                      
000028CC  4281                    2570              CLR.L   D1       
000028CE  4284                    2571              CLR.L   D4                   
000028D0  227C 00000000           2572              MOVEA.L #0, A1              
000028D6  2205                    2573              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000028D8                          2574              *CLEAR D3
000028D8  4283                    2575              CLR.L   D3
000028DA                          2576  
000028DA                          2577  OP1100_MULS_DN_EA_OR_EA_DN 
000028DA                          2578              *LOAD STACK WITH THIS OPMODE
000028DA  6100 1724               2579              BSR     PUSH_STACK
000028DE  163C 004D               2580              MOVE.B  #'M',D3
000028E2  6100 171C               2581              BSR     PUSH_STACK
000028E6  163C 0055               2582              MOVE.B  #'U',D3
000028EA  6100 1714               2583              BSR     PUSH_STACK
000028EE  163C 004C               2584              MOVE.B  #'L',D3
000028F2  6100 170C               2585              BSR     PUSH_STACK
000028F6  163C 0053               2586              MOVE.B  #'S',D3
000028FA  6100 1704               2587              BSR     PUSH_STACK
000028FE  163C 002E               2588              MOVE.B  #'.',D3
00002902  6100 16FC               2589              BSR     PUSH_STACK
00002906                          2590              
00002906  2205                    2591              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002908                          2592              
00002908                          2593  OP1100_EA_DN_MULS           
00002908                          2594              *BITS (7 TO 6) 
00002908                          2595              *00 = .B
00002908                          2596              *01 = .W
00002908                          2597              *10 = .L 
00002908  2205                    2598              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000290A  EC99                    2599              ROR.L   #6,D1
0000290C  0281 00000003           2600              ANDI.L  #$03,D1
00002912  0C81 00000003           2601              CMPI.L  #%11,D1 *EQUALS .W
00002918  6700 0014               2602              BEQ     OP1100_PRINT_W_MULS
0000291C  0C81 00000000           2603              CMPI.L  #%00,D1 *EQUALS .L
00002922  6700 0052               2604              BEQ     OP1100_PRINT_L_MULS
00002926                          2605              
00002926  183C 0001               2606              MOVE.B  #1,D4               *ERROR READ
0000292A  6000 0092               2607              BRA     OP1100_MULS_RETURN
0000292E                          2608  OP1100_PRINT_W_MULS
0000292E  163C 0057               2609              MOVE.B  #'W',D3
00002932  6100 16CC               2610              BSR     PUSH_STACK
00002936                          2611  
00002936                          2612              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002936  13FC 0000 0000498A      2613              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000293E  13FC 0000 0000498B      2614              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002946                          2615             
00002946                          2616              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002946  13FC 00B9 0000498D      2617              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000294E  13FC 0020 0000498E      2618              MOVE.B   #$20,GET_SRC_START_END
00002956                          2619  
00002956                          2620             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002956  0285 0000FE3F           2621              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000295C  0685 00000000           2622              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002962                          2623  
00002962                          2624              
00002962  6100 0DFE               2625              BSR     GET_EA_EA_SRC      *GETS <ea>
00002966  163C 002C               2626              MOVE.B  #',',D3
0000296A  6100 1694               2627              BSR     PUSH_STACK
0000296E  6100 1222               2628              BSR     GET_EA_EA_DEST       *GETS Dn    
00002972                          2629              
00002972  6000 004A               2630              BRA     OP1100_MULS_RETURN
00002976                          2631  OP1100_PRINT_L_MULS 
00002976  163C 004C               2632              MOVE.B  #'L',D3
0000297A  6100 1684               2633              BSR     PUSH_STACK
0000297E                          2634              
0000297E                          2635              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000297E  13FC 0000 0000498A      2636              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002986  13FC 0000 0000498B      2637              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000298E                          2638             
0000298E                          2639              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000298E  13FC 00B9 0000498D      2640              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002996  13FC 0020 0000498E      2641              MOVE.B   #$20,GET_SRC_START_END
0000299E                          2642  
0000299E                          2643              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000299E  0285 0000FE3F           2644              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029A4  0685 00000000           2645              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000029AA                          2646  
000029AA                          2647                     
000029AA  6100 0DB6               2648              BSR     GET_EA_EA_SRC      *GETS <ea>
000029AE  163C 002C               2649              MOVE.B  #',',D3
000029B2  6100 164C               2650              BSR     PUSH_STACK                  
000029B6  6100 11DA               2651              BSR     GET_EA_EA_DEST       *GETS Dn    
000029BA                          2652  
000029BA                          2653              
000029BA  6000 0002               2654              BRA     OP1100_MULS_RETURN
000029BE                          2655              
000029BE                          2656  OP1100_MULS_RETURN
000029BE  4E75                    2657              RTS
000029C0                          2658              
000029C0                          2659  
000029C0                          2660  
000029C0                          2661  
000029C0                          2662  
000029C0                          2663  
000029C0                          2664  
000029C0                          2665  
000029C0                          2666  
000029C0                          2667  
000029C0                          2668  
000029C0                          2669  
000029C0                          2670  
000029C0                          2671  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000029C0                          2672              *LOAD STACK WITH THIS OPMODE
000029C0  4283                    2673              CLR.L   D3
000029C2  6100 163C               2674              BSR     PUSH_STACK
000029C6  163C 0041               2675              MOVE.B  #'A',D3
000029CA  6100 1634               2676              BSR     PUSH_STACK
000029CE  163C 004E               2677              MOVE.B  #'N',D3
000029D2  6100 162C               2678              BSR     PUSH_STACK
000029D6  163C 0044               2679              MOVE.B  #'D',D3
000029DA  6100 1624               2680              BSR     PUSH_STACK
000029DE  163C 002E               2681              MOVE.B  #'.',D3
000029E2  6100 161C               2682              BSR     PUSH_STACK
000029E6                          2683              
000029E6  2205                    2684              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000029E8                          2685              
000029E8                          2686              *BITS (INDEX 8) 
000029E8                          2687              *0 = ADD.B/W/L <EA>,Dn
000029E8                          2688              *1 = ADD.B/W/L Dn,<EA> 
000029E8  E099                    2689              ROR.L   #8,D1
000029EA  0281 00000001           2690              ANDI.L  #$01,D1     *MASKS WITH 00000001
000029F0  0C81 00000000           2691              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000029F6  6700 0102               2692              BEQ     OP1100_EA_DN
000029FA                          2693              *else procede to Dn_EA
000029FA                          2694              
000029FA                          2695  OP1100_DN_EA
000029FA                          2696              *BITS (7 TO 6) 
000029FA                          2697              *00 = .B
000029FA                          2698              *01 = .W
000029FA                          2699              *10 = .L 
000029FA  2205                    2700              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000029FC  EC99                    2701              ROR.L   #6,D1
000029FE  0281 00000003           2702              ANDI.L  #$03,D1
00002A04  0C81 00000000           2703              CMPI.L  #$00,D1 *EQUALS .B
00002A0A  6700 0016               2704              BEQ     OP1100_PRINT_B2
00002A0E  0C81 00000001           2705              CMPI.L  #$01,D1 *EQUALS .W
00002A14  6700 0054               2706              BEQ     OP1100_PRINT_W2
00002A18  0C81 00000002           2707              CMPI.L  #$02,D1 *EQUALS .L
00002A1E  6700 0092               2708              BEQ     OP1100_PRINT_L2
00002A22                          2709  OP1100_PRINT_B2
00002A22                          2710              *PUSH 'B'
00002A22  163C 0042               2711              MOVE.B  #'B',D3
00002A26  6100 15D8               2712              BSR     PUSH_STACK
00002A2A                          2713             
00002A2A                          2714              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A2A  13FC 0000 0000498A      2715             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A32  13FC 0083 0000498B      2716             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A3A                          2717             
00002A3A                          2718             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A3A  13FC 00B9 0000498D      2719             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A42  13FC 0020 0000498E      2720             MOVE.B   #$20,GET_SRC_START_END
00002A4A                          2721  
00002A4A                          2722              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A4A  0285 0000FE3F           2723              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A50  0685 00000000           2724              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A56                          2725       
00002A56  6100 113A               2726              BSR     GET_EA_EA_DEST      *GETS Dn
00002A5A  163C 002C               2727              MOVE.B  #',',D3
00002A5E  6100 15A0               2728              BSR     PUSH_STACK                     
00002A62  6100 0CFE               2729              BSR     GET_EA_EA_SRC       *GETS <ea>
00002A66                          2730  
00002A66                          2731              
00002A66  6000 0192               2732              BRA     OP1100_AND_RETURN
00002A6A                          2733  OP1100_PRINT_W2
00002A6A  163C 0057               2734              MOVE.B  #'W',D3
00002A6E  6100 1590               2735              BSR     PUSH_STACK
00002A72                          2736  
00002A72                          2737              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A72  13FC 0000 0000498A      2738              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A7A  13FC 0083 0000498B      2739              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A82                          2740             
00002A82                          2741              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A82  13FC 00B9 0000498D      2742              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A8A  13FC 0020 0000498E      2743              MOVE.B   #$20,GET_SRC_START_END
00002A92                          2744  
00002A92                          2745              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A92  0285 0000FE3F           2746              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A98  0685 00000000           2747              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002A9E                          2748  
00002A9E                          2749        
00002A9E  6100 10F2               2750              BSR     GET_EA_EA_DEST      *GETS Dn
00002AA2  163C 002C               2751              MOVE.B  #',',D3
00002AA6  6100 1558               2752              BSR     PUSH_STACK               
00002AAA  6100 0CB6               2753              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002AAE                          2754  
00002AAE                          2755  
00002AAE                          2756  
00002AAE  6000 049A               2757              BRA     OP1101_ADD_RETURN
00002AB2                          2758  OP1100_PRINT_L2 
00002AB2  163C 004C               2759              MOVE.B  #'L',D3
00002AB6  6100 1548               2760              BSR     PUSH_STACK
00002ABA                          2761              
00002ABA                          2762              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002ABA  13FC 0000 0000498A      2763              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AC2  13FC 0083 0000498B      2764              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002ACA                          2765             
00002ACA                          2766              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002ACA  13FC 00B9 0000498D      2767              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AD2  13FC 0020 0000498E      2768              MOVE.B   #$20,GET_SRC_START_END
00002ADA                          2769  
00002ADA                          2770             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002ADA  0285 0000FE3F           2771              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AE0  0685 00000000           2772              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002AE6                          2773  
00002AE6                          2774               
00002AE6  6100 10AA               2775              BSR     GET_EA_EA_DEST       *GETS Dn
00002AEA  163C 002C               2776              MOVE.B  #',',D3
00002AEE  6100 1510               2777              BSR     PUSH_STACK          
00002AF2  6100 0C6E               2778              BSR     GET_EA_EA_SRC        *GETS <ea>
00002AF6                          2779  
00002AF6  6000 0102               2780              BRA     OP1100_AND_RETURN
00002AFA                          2781              
00002AFA                          2782  OP1100_EA_DN           
00002AFA                          2783              *BITS (7 TO 6) 
00002AFA                          2784              *00 = .B
00002AFA                          2785              *01 = .W
00002AFA                          2786              *10 = .L 
00002AFA  2205                    2787              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002AFC  EC99                    2788              ROR.L   #6,D1
00002AFE  0281 00000003           2789              ANDI.L  #$03,D1
00002B04  0C81 00000000           2790              CMPI.L  #$00,D1 *EQUALS .B
00002B0A  6700 0016               2791              BEQ     OP1100_PRINT_B
00002B0E  0C81 00000001           2792              CMPI.L  #$01,D1 *EQUALS .W
00002B14  6700 0054               2793              BEQ     OP1100_PRINT_W
00002B18  0C81 00000002           2794              CMPI.L  #$02,D1 *EQUALS .L
00002B1E  6700 0092               2795              BEQ     OP1100_PRINT_L
00002B22                          2796  OP1100_PRINT_B
00002B22  163C 0042               2797              MOVE.B  #'B',D3
00002B26  6100 14D8               2798              BSR     PUSH_STACK
00002B2A                          2799                
00002B2A                          2800              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B2A  13FC 0000 0000498A      2801              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B32  13FC 0002 0000498B      2802              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B3A                          2803             
00002B3A                          2804              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B3A  13FC 00B9 0000498D      2805              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B42  13FC 0020 0000498E      2806              MOVE.B   #$20,GET_SRC_START_END
00002B4A                          2807  
00002B4A                          2808             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B4A  0285 0000FE3F           2809              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B50  0685 00000000           2810              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002B56                          2811  
00002B56                          2812              
00002B56  6100 0C0A               2813              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B5A  163C 002C               2814              MOVE.B  #',',D3
00002B5E  6100 14A0               2815              BSR     PUSH_STACK          
00002B62  6100 102E               2816              BSR     GET_EA_EA_DEST       *GETS Dn
00002B66                          2817              
00002B66  6000 03E2               2818              BRA     OP1101_ADD_RETURN
00002B6A                          2819  OP1100_PRINT_W
00002B6A  163C 0057               2820              MOVE.B  #'W',D3
00002B6E  6100 1490               2821              BSR     PUSH_STACK
00002B72                          2822  
00002B72                          2823              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B72  13FC 0000 0000498A      2824              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B7A  13FC 0002 0000498B      2825              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B82                          2826             
00002B82                          2827              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B82  13FC 00B9 0000498D      2828              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B8A  13FC 0020 0000498E      2829              MOVE.B   #$20,GET_SRC_START_END
00002B92                          2830  
00002B92                          2831             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B92  0285 0000FE3F           2832              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B98  0685 00000000           2833              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B9E                          2834  
00002B9E                          2835              
00002B9E  6100 0BC2               2836              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BA2  163C 002C               2837              MOVE.B  #',',D3
00002BA6  6100 1458               2838              BSR     PUSH_STACK
00002BAA  6100 0FE6               2839              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BAE                          2840              
00002BAE  6000 F988               2841              BRA     OP1001_ADD_RETURN
00002BB2                          2842  OP1100_PRINT_L 
00002BB2  163C 004C               2843              MOVE.B  #'L',D3
00002BB6  6100 1448               2844              BSR     PUSH_STACK
00002BBA                          2845              
00002BBA                          2846              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BBA  13FC 0000 0000498A      2847              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BC2  13FC 0002 0000498B      2848              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BCA                          2849             
00002BCA                          2850              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BCA  13FC 00B9 0000498D      2851              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BD2  13FC 0020 0000498E      2852              MOVE.B   #$20,GET_SRC_START_END
00002BDA                          2853  
00002BDA                          2854              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BDA  0285 0000FE3F           2855              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BE0  0685 00000000           2856              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BE6                          2857  
00002BE6                          2858                     
00002BE6  6100 0B7A               2859              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BEA  163C 002C               2860              MOVE.B  #',',D3
00002BEE  6100 1410               2861              BSR     PUSH_STACK                  
00002BF2  6100 0F9E               2862              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BF6                          2863  
00002BF6                          2864              
00002BF6  6000 0002               2865              BRA     OP1100_AND_RETURN
00002BFA                          2866              
00002BFA                          2867  OP1100_AND_RETURN
00002BFA  4E75                    2868              RTS
00002BFC                          2869  
00002BFC                          2870  
00002BFC                          2871  *---------------------------------------------------------------------------*
00002BFC                          2872  * OP1101: Decode ADD/ADDA
00002BFC                          2873  *---------------------------------------------------------------------------* 
00002BFC  4280                    2874  OP1101      CLR.L   D0                  
00002BFE  4281                    2875              CLR.L   D1       
00002C00  4284                    2876              CLR.L   D4                   
00002C02  227C 00000000           2877              MOVEA.L #0, A1              
00002C08  2205                    2878              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002C0A                          2879              
00002C0A                          2880              *CLEAR D3
00002C0A  4283                    2881              CLR.L   D3
00002C0C                          2882              
00002C0C                          2883              
00002C0C                          2884              
00002C0C                          2885              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002C0C  2205                    2886              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C0E                          2887              *BITS (INDEX 8) 
00002C0E                          2888              *0 = ADD.B/W/L <EA>,Dn
00002C0E                          2889              *1 = ADD.B/W/L Dn,<EA> 
00002C0E  EC99                    2890              ROR.L   #6,D1
00002C10  0281 00000007           2891              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002C16  0C81 00000007           2892              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002C1C  6700 0010               2893              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002C20  0C81 00000003           2894              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002C26  6700 0078               2895              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002C2A  6000 00E6               2896              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002C2E                          2897              
00002C2E                          2898  OP1101_ADDA_L
00002C2E                          2899              *LOAD STACK WITH THIS OPMODE
00002C2E  6100 13D0               2900              BSR     PUSH_STACK
00002C32  163C 0041               2901              MOVE.B  #'A',D3
00002C36  6100 13C8               2902              BSR     PUSH_STACK
00002C3A  163C 0044               2903              MOVE.B  #'D',D3
00002C3E  6100 13C0               2904              BSR     PUSH_STACK
00002C42  163C 0044               2905              MOVE.B  #'D',D3
00002C46  6100 13B8               2906              BSR     PUSH_STACK
00002C4A  163C 0041               2907              MOVE.B  #'A',D3
00002C4E  6100 13B0               2908              BSR     PUSH_STACK
00002C52  163C 002E               2909              MOVE.B  #'.',D3
00002C56  6100 13A8               2910              BSR     PUSH_STACK
00002C5A  163C 004C               2911              MOVE.B  #'L',D3
00002C5E  6100 13A0               2912              BSR     PUSH_STACK
00002C62                          2913              
00002C62                          2914             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C62  13FC 0000 0000498A      2915             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C6A  13FC 0000 0000498B      2916             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C72                          2917             
00002C72                          2918             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C72  13FC 00B9 0000498D      2919             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C7A  13FC 0020 0000498E      2920             MOVE.B   #$20,GET_SRC_START_END
00002C82                          2921  
00002C82                          2922              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C82  0285 0000FE3F           2923              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C88  0685 00000040           2924              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C8E                          2925       
00002C8E                          2926              *PRINT <EA>,AN
00002C8E  6100 0AD2               2927              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C92  163C 002C               2928              MOVE.B  #',',D3
00002C96  6100 1368               2929              BSR     PUSH_STACK                     
00002C9A  6100 0EF6               2930              BSR     GET_EA_EA_DEST      *GETS Dn
00002C9E                          2931  
00002C9E                          2932              
00002C9E                          2933              
00002C9E  4E75                    2934              RTS
00002CA0                          2935  OP1101_ADDA_W
00002CA0                          2936              *LOAD STACK WITH THIS OPMODE
00002CA0  6100 135E               2937              BSR     PUSH_STACK
00002CA4  163C 0041               2938              MOVE.B  #'A',D3
00002CA8  6100 1356               2939              BSR     PUSH_STACK
00002CAC  163C 0044               2940              MOVE.B  #'D',D3
00002CB0  6100 134E               2941              BSR     PUSH_STACK
00002CB4  163C 0044               2942              MOVE.B  #'D',D3
00002CB8  6100 1346               2943              BSR     PUSH_STACK
00002CBC  163C 0041               2944              MOVE.B  #'A',D3
00002CC0  6100 133E               2945              BSR     PUSH_STACK
00002CC4  163C 002E               2946              MOVE.B  #'.',D3
00002CC8  6100 1336               2947              BSR     PUSH_STACK
00002CCC  163C 0057               2948              MOVE.B  #'W',D3
00002CD0  6100 132E               2949              BSR     PUSH_STACK
00002CD4                          2950              
00002CD4                          2951             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CD4  13FC 0000 0000498A      2952             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CDC  13FC 0000 0000498B      2953             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CE4                          2954             
00002CE4                          2955             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CE4  13FC 00B9 0000498D      2956             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CEC  13FC 0020 0000498E      2957             MOVE.B   #$20,GET_SRC_START_END
00002CF4                          2958  
00002CF4                          2959              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CF4  0285 0000FE3F           2960              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CFA  0685 00000040           2961              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002D00                          2962       
00002D00                          2963              *PRINT <EA>,AN
00002D00  6100 0A60               2964              BSR     GET_EA_EA_SRC       *GETS <ea>
00002D04  163C 002C               2965              MOVE.B  #',',D3
00002D08  6100 12F6               2966              BSR     PUSH_STACK                     
00002D0C  6100 0E84               2967              BSR     GET_EA_EA_DEST      *GETS Dn
00002D10                          2968  
00002D10  4E75                    2969              RTS
00002D12                          2970  
00002D12                          2971  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002D12                          2972              *LOAD STACK WITH THIS OPMODE
00002D12  6100 12EC               2973              BSR     PUSH_STACK
00002D16  163C 0041               2974              MOVE.B  #'A',D3
00002D1A  6100 12E4               2975              BSR     PUSH_STACK
00002D1E  163C 0044               2976              MOVE.B  #'D',D3
00002D22  6100 12DC               2977              BSR     PUSH_STACK
00002D26  163C 0044               2978              MOVE.B  #'D',D3
00002D2A  6100 12D4               2979              BSR     PUSH_STACK
00002D2E  163C 002E               2980              MOVE.B  #'.',D3
00002D32  6100 12CC               2981              BSR     PUSH_STACK
00002D36                          2982              
00002D36  2205                    2983              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002D38                          2984              
00002D38                          2985              *BITS (INDEX 8) 
00002D38                          2986              *0 = ADD.B/W/L <EA>,Dn
00002D38                          2987              *1 = ADD.B/W/L Dn,<EA> 
00002D38  E099                    2988              ROR.L   #8,D1
00002D3A  0281 00000001           2989              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002D40  0C81 00000000           2990              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002D46  6700 0102               2991              BEQ     OP1101_EA_DN
00002D4A                          2992              *else procede to Dn_EA
00002D4A                          2993              
00002D4A                          2994  OP1101_DN_EA
00002D4A                          2995              *BITS (7 TO 6) 
00002D4A                          2996              *00 = .B
00002D4A                          2997              *01 = .W
00002D4A                          2998              *10 = .L 
00002D4A  2205                    2999              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002D4C  EC99                    3000              ROR.L   #6,D1
00002D4E  0281 00000003           3001              ANDI.L  #$03,D1
00002D54  0C81 00000000           3002              CMPI.L  #$00,D1 *EQUALS .B
00002D5A  6700 0016               3003              BEQ     OP1101_PRINT_B2
00002D5E  0C81 00000001           3004              CMPI.L  #$01,D1 *EQUALS .W
00002D64  6700 0054               3005              BEQ     OP1101_PRINT_W2
00002D68  0C81 00000002           3006              CMPI.L  #$02,D1 *EQUALS .L
00002D6E  6700 0092               3007              BEQ     OP1101_PRINT_L2
00002D72                          3008  OP1101_PRINT_B2
00002D72                          3009              *PUSH 'B'
00002D72  163C 0042               3010              MOVE.B  #'B',D3
00002D76  6100 1288               3011              BSR     PUSH_STACK
00002D7A                          3012             
00002D7A                          3013              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D7A  13FC 0002 0000498A      3014             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D82  13FC 0083 0000498B      3015             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D8A                          3016             
00002D8A                          3017             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D8A  13FC 00B9 0000498D      3018             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D92  13FC 0020 0000498E      3019             MOVE.B   #$20,GET_SRC_START_END
00002D9A                          3020  
00002D9A                          3021              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D9A  0285 0000FE3F           3022              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DA0  0685 00000000           3023              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DA6                          3024       
00002DA6  6100 0DEA               3025              BSR     GET_EA_EA_DEST      *GETS Dn
00002DAA  163C 002C               3026              MOVE.B  #',',D3
00002DAE  6100 1250               3027              BSR     PUSH_STACK                     
00002DB2  6100 09AE               3028              BSR     GET_EA_EA_SRC       *GETS <ea>
00002DB6                          3029  
00002DB6                          3030              
00002DB6  6000 0192               3031              BRA     OP1101_ADD_RETURN
00002DBA                          3032  OP1101_PRINT_W2
00002DBA  163C 0057               3033              MOVE.B  #'W',D3
00002DBE  6100 1240               3034              BSR     PUSH_STACK
00002DC2                          3035  
00002DC2                          3036              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DC2  13FC 0000 0000498A      3037              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DCA  13FC 0083 0000498B      3038              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DD2                          3039             
00002DD2                          3040              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DD2  13FC 00B9 0000498D      3041              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DDA  13FC 0020 0000498E      3042              MOVE.B   #$20,GET_SRC_START_END
00002DE2                          3043  
00002DE2                          3044              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DE2  0285 0000FE3F           3045              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DE8  0685 00000000           3046              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DEE                          3047  
00002DEE                          3048        
00002DEE  6100 0DA2               3049              BSR     GET_EA_EA_DEST      *GETS Dn
00002DF2  163C 002C               3050              MOVE.B  #',',D3
00002DF6  6100 1208               3051              BSR     PUSH_STACK               
00002DFA  6100 0966               3052              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002DFE                          3053  
00002DFE                          3054  
00002DFE                          3055  
00002DFE  6000 014A               3056              BRA     OP1101_ADD_RETURN
00002E02                          3057  OP1101_PRINT_L2 
00002E02  163C 004C               3058              MOVE.B  #'L',D3
00002E06  6100 11F8               3059              BSR     PUSH_STACK
00002E0A                          3060              
00002E0A                          3061              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E0A  13FC 0000 0000498A      3062              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E12  13FC 0083 0000498B      3063              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E1A                          3064             
00002E1A                          3065              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E1A  13FC 00B9 0000498D      3066              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E22  13FC 0020 0000498E      3067              MOVE.B   #$20,GET_SRC_START_END
00002E2A                          3068  
00002E2A                          3069             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E2A  0285 0000FE3F           3070              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E30  0685 00000000           3071              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E36                          3072  
00002E36                          3073               
00002E36  6100 0D5A               3074              BSR     GET_EA_EA_DEST       *GETS Dn
00002E3A  163C 002C               3075              MOVE.B  #',',D3
00002E3E  6100 11C0               3076              BSR     PUSH_STACK          
00002E42  6100 091E               3077              BSR     GET_EA_EA_SRC        *GETS <ea>
00002E46                          3078  
00002E46  6000 0102               3079              BRA     OP1101_ADD_RETURN
00002E4A                          3080              
00002E4A                          3081  OP1101_EA_DN           
00002E4A                          3082              *BITS (7 TO 6) 
00002E4A                          3083              *00 = .B
00002E4A                          3084              *01 = .W
00002E4A                          3085              *10 = .L 
00002E4A  2205                    3086              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002E4C  EC99                    3087              ROR.L   #6,D1
00002E4E  0281 00000003           3088              ANDI.L  #$03,D1
00002E54  0C81 00000000           3089              CMPI.L  #$00,D1 *EQUALS .B
00002E5A  6700 0016               3090              BEQ     OP1101_PRINT_B
00002E5E  0C81 00000001           3091              CMPI.L  #$01,D1 *EQUALS .W
00002E64  6700 0054               3092              BEQ     OP1101_PRINT_W
00002E68  0C81 00000002           3093              CMPI.L  #$02,D1 *EQUALS .L
00002E6E  6700 0092               3094              BEQ     OP1101_PRINT_L
00002E72                          3095  OP1101_PRINT_B
00002E72  163C 0042               3096              MOVE.B  #'B',D3
00002E76  6100 1188               3097              BSR     PUSH_STACK
00002E7A                          3098                
00002E7A                          3099              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E7A  13FC 0002 0000498A      3100              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E82  13FC 0002 0000498B      3101              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E8A                          3102             
00002E8A                          3103              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E8A  13FC 00B9 0000498D      3104              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E92  13FC 0020 0000498E      3105              MOVE.B   #$20,GET_SRC_START_END
00002E9A                          3106  
00002E9A                          3107             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E9A  0285 0000FE3F           3108              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EA0  0685 00000000           3109              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EA6                          3110  
00002EA6                          3111              
00002EA6  6100 08BA               3112              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EAA  163C 002C               3113              MOVE.B  #',',D3
00002EAE  6100 1150               3114              BSR     PUSH_STACK          
00002EB2  6100 0CDE               3115              BSR     GET_EA_EA_DEST       *GETS Dn
00002EB6                          3116              
00002EB6  6000 0092               3117              BRA     OP1101_ADD_RETURN
00002EBA                          3118  OP1101_PRINT_W
00002EBA  163C 0057               3119              MOVE.B  #'W',D3
00002EBE  6100 1140               3120              BSR     PUSH_STACK
00002EC2                          3121  
00002EC2                          3122              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002EC2  13FC 0000 0000498A      3123              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002ECA  13FC 0000 0000498B      3124              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002ED2                          3125             
00002ED2                          3126              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002ED2  13FC 00B9 0000498D      3127              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002EDA  13FC 0020 0000498E      3128              MOVE.B   #$20,GET_SRC_START_END
00002EE2                          3129  
00002EE2                          3130             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002EE2  0285 0000FE3F           3131              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EE8  0685 00000000           3132              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EEE                          3133  
00002EEE                          3134              
00002EEE  6100 0872               3135              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EF2  163C 002C               3136              MOVE.B  #',',D3
00002EF6  6100 1108               3137              BSR     PUSH_STACK
00002EFA  6100 0C96               3138              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EFE                          3139              
00002EFE  6000 004A               3140              BRA     OP1101_ADD_RETURN
00002F02                          3141  OP1101_PRINT_L 
00002F02  163C 004C               3142              MOVE.B  #'L',D3
00002F06  6100 10F8               3143              BSR     PUSH_STACK
00002F0A                          3144              
00002F0A                          3145              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002F0A  13FC 0000 0000498A      3146              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002F12  13FC 0000 0000498B      3147              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002F1A                          3148             
00002F1A                          3149              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002F1A  13FC 00B9 0000498D      3150              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002F22  13FC 0020 0000498E      3151              MOVE.B   #$20,GET_SRC_START_END
00002F2A                          3152  
00002F2A                          3153              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002F2A  0285 0000FE3F           3154              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002F30  0685 00000000           3155              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002F36                          3156  
00002F36                          3157                     
00002F36  6100 082A               3158              BSR     GET_EA_EA_SRC      *GETS <ea>
00002F3A  163C 002C               3159              MOVE.B  #',',D3
00002F3E  6100 10C0               3160              BSR     PUSH_STACK                  
00002F42  6100 0C4E               3161              BSR     GET_EA_EA_DEST       *GETS Dn    
00002F46                          3162  
00002F46                          3163              
00002F46  6000 0002               3164              BRA     OP1101_ADD_RETURN
00002F4A                          3165              
00002F4A                          3166  OP1101_ADD_RETURN
00002F4A  4E75                    3167              RTS
00002F4C                          3168              
00002F4C                          3169              *ADDW
00002F4C  0C01 0006               3170              CMPI.B  #$6,D1
00002F50  6700 0056               3171              BEQ     OP_ADDA_W
00002F54  0C01 000E               3172              CMPI.B  #$E,D1
00002F58  6700 0066               3173              BEQ     OP_ADDA_L 
00002F5C                          3174  
00002F5C  4EF8 175A               3175              JMP     OP_DATA  
00002F60                          3176            
00002F60                          3177  *---------------------------------------------------------------------------*
00002F60                          3178  * OP_ADD: display ADD and proceed to EA
00002F60                          3179  *---------------------------------------------------------------------------*  
00002F60  43F9 00004841           3180  OP_ADD_B    LEA     DISP_ADD_B,A1
00002F66  103C 000E               3181              MOVE.B  #14,D0
00002F6A  4E4F                    3182              TRAP    #15
00002F6C  183C 0000               3183              MOVE.B  #0,D4
00002F70  4EF9 00003312           3184              JMP     EA_GEN
00002F76                          3185  
00002F76  4E75                    3186              RTS
00002F78                          3187  
00002F78  43F9 0000484A           3188  OP_ADD_W    LEA     DISP_ADD_W,A1
00002F7E  103C 000E               3189              MOVE.B  #14,D0
00002F82  4E4F                    3190              TRAP    #15
00002F84  183C 0001               3191              MOVE.B  #1,D4
00002F88  4EF9 00003312           3192              JMP     EA_GEN
00002F8E                          3193  
00002F8E  4E75                    3194              RTS
00002F90                          3195  
00002F90  43F9 00004853           3196  OP_ADD_L    LEA     DISP_ADD_L,A1
00002F96  103C 000E               3197              MOVE.B  #14,D0
00002F9A  4E4F                    3198              TRAP    #15
00002F9C  183C 0002               3199              MOVE.B  #2,D4
00002FA0  4EF9 00003312           3200              JMP     EA_GEN
00002FA6                          3201  
00002FA6  4E75                    3202              RTS
00002FA8                          3203  
00002FA8                          3204  *---------------------------------------------------------------------------*
00002FA8                          3205  * OP_ADDA: display ADDA and proceed to EA
00002FA8                          3206  *---------------------------------------------------------------------------*  
00002FA8  43F9 0000485C           3207  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002FAE  103C 000E               3208              MOVE.B  #14,D0
00002FB2  4E4F                    3209              TRAP    #15
00002FB4  183C 0001               3210              MOVE.B  #1,D4
00002FB8  4EF9 00003312           3211              JMP     EA_GEN
00002FBE                          3212  
00002FBE  4E75                    3213              RTS
00002FC0                          3214  
00002FC0  43F9 00004866           3215  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002FC6  103C 000E               3216              MOVE.B  #14,D0
00002FCA  4E4F                    3217              TRAP    #15
00002FCC  183C 0002               3218              MOVE.B  #2,D4
00002FD0  4EF9 00003312           3219              JMP     EA_GEN
00002FD6                          3220  
00002FD6  4E75                    3221              RTS
00002FD8                          3222              
00002FD8                          3223  *---------------------------------------------------------------------------*
00002FD8                          3224  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002FD8                          3225  *---------------------------------------------------------------------------* 
00002FD8  4280                    3226  OP1110      CLR.L   D0                  
00002FDA  4281                    3227              CLR.L   D1   
00002FDC  4284                    3228              CLR.L   D4                   
00002FDE  227C 00000000           3229              MOVEA.L #0, A1                 
00002FE4  2205                    3230              MOVE.L  D5,D1
00002FE6                          3231              
00002FE6                          3232              *1)CHECK FOR MEMORY ROTATE/SHIFT FIRST
00002FE6                          3233              * check for LSL 
00002FE6  0281 0000FFC0           3234              ANDI.L  #%1111111111000000,D1
00002FEC  0C81 0000E3C0           3235              CMPI.L  #%1110001111000000,D1
00002FF2  6700 02BA               3236              BEQ     OP_LSL
00002FF6                          3237              
00002FF6                          3238                              
00002FF6  2205                    3239              MOVE.L  D5,D1
00002FF8  0281 0000FFC0           3240              ANDI.L  #%1111111111000000,D1
00002FFE  0C81 0000E2C0           3241              CMPI.L  #%1110001011000000,D1
00003004  6700 011E               3242              BEQ     OP_LSR
00003008                          3243              
00003008                          3244                              
00003008  2205                    3245              MOVE.L  D5,D1
0000300A  0281 0000FFC0           3246              ANDI.L  #%1111111111000000,D1
00003010  0C81 0000E1C0           3247              CMPI.L  #%1110000111000000,D1
00003016  6700 0296               3248              BEQ     OP_ASL
0000301A                          3249              
0000301A                          3250                              
0000301A  2205                    3251              MOVE.L  D5,D1
0000301C  0281 0000FFC0           3252              ANDI.L  #%1111111111000000,D1
00003022  0C81 0000E0C0           3253              CMPI.L  #%1110000011000000,D1
00003028  6700 0284               3254              BEQ     OP_ASR
0000302C                          3255              
0000302C                          3256                              
0000302C  2205                    3257              MOVE.L  D5,D1
0000302E  0281 0000FEC0           3258              ANDI.L  #%1111111011000000,D1
00003034  0C81 0000E7C0           3259              CMPI.L  #%1110011111000000,D1
0000303A  6700 0272               3260              BEQ     OP_ROL
0000303E                          3261              
0000303E                          3262                              
0000303E  2205                    3263              MOVE.L  D5,D1
00003040  0281 0000FFC0           3264              ANDI.L  #%1111111111000000,D1
00003046  0C81 0000E6C0           3265              CMPI.L  #%1110011011000000,D1
0000304C  6700 0260               3266              BEQ     OP_ROR
00003050                          3267  
00003050                          3268              *2)IF NOT THOSE, THAN CHECK FOR IMMEDIATE/REGISTER SHIFTS/ROTATE
00003050  2205                    3269              MOVE.L  D5,D1
00003052  0281 0000F118           3270              ANDI.L  #%1111000100011000,D1
00003058  0C81 0000E108           3271              CMPI.L  #%1110000100001000,D1
0000305E  6700 024E               3272              BEQ     OP_LSL_2
00003062                          3273              
00003062  2205                    3274              MOVE.L  D5,D1
00003064  0281 0000F118           3275              ANDI.L  #%1111000100011000,D1
0000306A  0C81 0000E008           3276              CMPI.L  #%1110000000001000,D1
00003070  6700 00B2               3277              BEQ     OP_LSR_2
00003074                          3278              
00003074  2205                    3279              MOVE.L  D5,D1
00003076  0281 0000F118           3280              ANDI.L  #%1111000100011000,D1
0000307C  0C81 0000E100           3281              CMPI.L  #%1110000100000000,D1
00003082  6700 022A               3282              BEQ     OP_ASL_2   
00003086                          3283           
00003086  2205                    3284              MOVE.L  D5,D1
00003088  0281 0000F118           3285              ANDI.L  #%1111000100011000,D1
0000308E  0C81 0000E000           3286              CMPI.L  #%1110000000000000,D1
00003094  6700 0218               3287              BEQ     OP_ASR_2
00003098                          3288              
00003098  2205                    3289              MOVE.L  D5,D1
0000309A  0281 0000F118           3290              ANDI.L  #%1111000100011000,D1
000030A0  0C81 0000E118           3291              CMPI.L  #%1110000100011000,D1
000030A6  6700 0206               3292              BEQ     OP_ROL_2   
000030AA                          3293           
000030AA  2205                    3294              MOVE.L  D5,D1
000030AC  0281 0000F118           3295              ANDI.L  #%1111000100011000,D1
000030B2  0C81 0000E018           3296              CMPI.L  #%1110000000011000,D1
000030B8  6700 01F4               3297              BEQ     OP_ROR_2
000030BC                          3298  
000030BC                          3299  
000030BC                          3300              
000030BC                          3301             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000030BC  13FC 0082 0000498A      3302             MOVE.B   #$82,DEST_REGISTER_FORMAT
000030C4  13FC 0000 0000498B      3303             MOVE.B   #$00,SRC_REGISTER_FORMAT
000030CC                          3304             
000030CC                          3305             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000030CC  13FC 00B9 0000498D      3306             MOVE.B   #$B9,GET_DST_START_END
000030D4  13FC 0020 0000498E      3307             MOVE.B   #$20,GET_SRC_START_END
000030DC                          3308             
000030DC                          3309              *CLEAR D3
000030DC  4283                    3310              CLR.L   D3
000030DE                          3311              *LOAD STACK WITH THIS OPMODE
000030DE  6100 0F20               3312              BSR     PUSH_STACK
000030E2  163C 004D               3313              MOVE.B  #'M',D3
000030E6  6100 0F18               3314              BSR     PUSH_STACK
000030EA  163C 004F               3315              MOVE.B  #'O',D3
000030EE  6100 0F10               3316              BSR     PUSH_STACK
000030F2  163C 0056               3317              MOVE.B  #'V',D3
000030F6  6100 0F08               3318              BSR     PUSH_STACK
000030FA  163C 0045               3319              MOVE.B  #'E',D3
000030FE  6100 0F00               3320              BSR     PUSH_STACK
00003102  163C 002E               3321              MOVE.B  #'.',D3
00003106  6100 0EF8               3322              BSR     PUSH_STACK
0000310A  163C 0042               3323              MOVE.B  #'B',D3
0000310E  6100 0EF0               3324              BSR     PUSH_STACK
00003112                          3325              
00003112  6100 064E               3326              BSR     GET_EA_EA_SRC
00003116  163C 002C               3327              MOVE.B  #',',D3
0000311A  6100 0EE4               3328              BSR     PUSH_STACK
0000311E  6100 0A72               3329              BSR     GET_EA_EA_DEST
00003122                          3330              
00003122  4E75                    3331              RTS
00003124                          3332  
00003124                          3333  
00003124                          3334  
00003124                          3335  
00003124                          3336  *---------------------------------------------------------------------------*
00003124                          3337  * OP_LSR: decode and display LSR
00003124                          3338  *---------------------------------------------------------------------------*        
00003124                          3339  OP_LSR     
00003124                          3340  
00003124                          3341              
00003124                          3342              
00003124                          3343  *---------------------------------------------------------------------------*
00003124                          3344  * OP_LSR: decode and display LSR IMMEDIATE/REGISTER
00003124                          3345  *---------------------------------------------------------------------------*        
00003124                          3346  OP_LSR_2      
00003124                          3347  
00003124                          3348              *CLEAR D3
00003124  4283                    3349              CLR.L   D3
00003126                          3350              *LOAD STACK WITH THIS OPMODE
00003126  6100 0ED8               3351              BSR     PUSH_STACK
0000312A  163C 004C               3352              MOVE.B  #'L',D3
0000312E  6100 0ED0               3353              BSR     PUSH_STACK
00003132  163C 0053               3354              MOVE.B  #'S',D3
00003136  6100 0EC8               3355              BSR     PUSH_STACK
0000313A  163C 0052               3356              MOVE.B  #'R',D3
0000313E  6100 0EC0               3357              BSR     PUSH_STACK
00003142  163C 002E               3358              MOVE.B  #'.',D3
00003146  6100 0EB8               3359              BSR     PUSH_STACK
0000314A                          3360              
0000314A                          3361              *FIND SIZE
0000314A  2605                    3362              MOVE.L  D5,D3
0000314C  EC9B                    3363              ROR.L   #6,D3
0000314E  0283 00000003           3364              ANDI.L  #3,D3
00003154  0C83 00000000           3365              CMPI.L  #%00,D3     * 00 == BYTE
0000315A  6700 0036               3366              BEQ     OP_LSR_2_B
0000315E  0C83 00000001           3367              CMPI.L  #%01,D3     * 01 == WORD
00003164  6700 0132               3368              BEQ     OP_LSR_2_W
00003168  0C83 00000002           3369              CMPI.L  #%10,D3     * 10 == LONG
0000316E  6700 0134               3370              BEQ     OP_LSR_2_L
00003172                          3371  
00003172                          3372           
00003172                          3373              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003172  13FC 0000 0000498A      3374              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000317A  13FC 0000 0000498B      3375              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00003182                          3376             
00003182                          3377              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003182  13FC 00B9 0000498D      3378              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000318A  13FC 0020 0000498E      3379              MOVE.B   #$20,GET_SRC_START_END
00003192                          3380  
00003192                          3381  OP_LSR_2_B
00003192                          3382  
00003192  163C 0042               3383              MOVE.B  #'B',D3
00003196  6100 0E68               3384              BSR     PUSH_STACK
0000319A  2605                    3385              MOVE.L  D5,D3
0000319C  EA9B                    3386              ROR.L   #5,D3
0000319E  0283 00000001           3387              ANDI.L  #$1,D3
000031A4  0C83 00000000           3388              CMPI.L  #0,D3
000031AA  6700 001E               3389              BEQ     OP_LSR_2_B_I
000031AE                          3390              
000031AE                          3391  OP_LSR_2_B_R           
000031AE                          3392              *IF REGISTER THAN DO THIS
000031AE  0285 0000FE07           3393              ANDI.L  #$FE07,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000031B4  5085                    3394              ADDI.L  #$0008,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000031B6                          3395              
000031B6  6100 09DA               3396              BSR     GET_EA_EA_DEST
000031BA  163C 002C               3397              MOVE.B  #',',D3
000031BE  6100 0E40               3398              BSR     PUSH_STACK
000031C2  6100 059E               3399              BSR     GET_EA_EA_SRC
000031C6                          3400              
000031C6  6000 00E4               3401              BRA     OP_LSR_2_RETURN
000031CA                          3402  
000031CA                          3403  *DEBUG NOT DONE
000031CA                          3404  OP_LSR_2_B_I
000031CA                          3405              *IF IMMEDIATE THAN DO THIS
000031CA  0285 0000FE3F           3406              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000031D0  0685 00000000           3407              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000)
000031D6                          3408              
000031D6                          3409              *GET NUMBER AT REGISTER
000031D6  2605                    3410              MOVE.L  D5,D3
000031D8  EC9B                    3411              ROR.L   #6,D3
000031DA  E69B                    3412              ROR.L   #3,D3
000031DC  0283 00000007           3413              ANDI.L  #7,D3
000031E2  0C01 0000               3414              CMPI.B  #%000,D1
000031E6  6700 003A               3415              BEQ     OP_LSR_2_B_0
000031EA  0C01 0001               3416              CMPI.B  #%001,D1
000031EE  6700 003E               3417              BEQ     OP_LSR_2_B_1
000031F2  0C01 0002               3418              CMPI.B  #%010,D1
000031F6  6700 0042               3419              BEQ     OP_LSR_2_B_2
000031FA  0C01 0003               3420              CMPI.B  #%011,D1
000031FE  6700 0046               3421              BEQ     OP_LSR_2_B_3
00003202  0C01 0004               3422              CMPI.B  #%100,D1
00003206  6700 004A               3423              BEQ     OP_LSR_2_B_4
0000320A  0C01 0005               3424              CMPI.B  #%101,D1
0000320E  6700 004E               3425              BEQ     OP_LSR_2_B_5
00003212  0C01 0006               3426              CMPI.B  #%110,D1
00003216  6700 0052               3427              BEQ     OP_LSR_2_B_6
0000321A  0C01 0007               3428              CMPI.B  #%111,D1
0000321E  6700 0056               3429              BEQ     OP_LSR_2_B_7
00003222                          3430              
00003222                          3431  OP_LSR_2_B_0
00003222  163C 0030               3432              MOVE.B  #'0',D3
00003226  6100 0DD8               3433              BSR     PUSH_STACK
0000322A  6000 005E               3434              BRA     OP_LSR_2_B_RETURN2            
0000322E                          3435  OP_LSR_2_B_1
0000322E  163C 0031               3436              MOVE.B  #'1',D3
00003232  6100 0DCC               3437              BSR     PUSH_STACK
00003236  6000 0052               3438              BRA     OP_LSR_2_B_RETURN2            
0000323A                          3439  OP_LSR_2_B_2
0000323A  163C 0032               3440              MOVE.B  #'2',D3
0000323E  6100 0DC0               3441              BSR     PUSH_STACK
00003242  6000 0046               3442              BRA     OP_LSR_2_B_RETURN2            
00003246                          3443  OP_LSR_2_B_3
00003246  163C 0033               3444              MOVE.B  #'3',D3
0000324A  6100 0DB4               3445              BSR     PUSH_STACK
0000324E  6000 003A               3446              BRA     OP_LSR_2_B_RETURN2            
00003252                          3447  OP_LSR_2_B_4
00003252  163C 0034               3448              MOVE.B  #'4',D3
00003256  6100 0DA8               3449              BSR     PUSH_STACK
0000325A  6000 002E               3450              BRA     OP_LSR_2_B_RETURN2            
0000325E                          3451  OP_LSR_2_B_5
0000325E  163C 0035               3452              MOVE.B  #'5',D3
00003262  6100 0D9C               3453              BSR     PUSH_STACK
00003266  6000 0022               3454              BRA     OP_LSR_2_B_RETURN2
0000326A                          3455  OP_LSR_2_B_6
0000326A  163C 0036               3456              MOVE.B  #'6',D3
0000326E  6100 0D90               3457              BSR     PUSH_STACK
00003272  6000 0016               3458              BRA     OP_LSR_2_B_RETURN2
00003276                          3459  OP_LSR_2_B_7
00003276  163C 0037               3460              MOVE.B  #'7',D3
0000327A  6100 0D84               3461              BSR     PUSH_STACK
0000327E  6000 000A               3462              BRA     OP_LSR_2_B_RETURN2
00003282                          3463  
00003282                          3464  OP_LSR_2_B_8
00003282  163C 0038               3465              MOVE.B  #'8',D3
00003286  6100 0D78               3466              BSR     PUSH_STACK
0000328A                          3467              
0000328A                          3468  OP_LSR_2_B_RETURN2            
0000328A  163C 002C               3469              MOVE.B  #',',D3
0000328E  6100 0D70               3470              BSR     PUSH_STACK
00003292  6100 04CE               3471              BSR     GET_EA_EA_SRC
00003296                          3472              
00003296  4E75                    3473              RTS
00003298                          3474  
00003298                          3475  
00003298                          3476              
00003298                          3477              
00003298                          3478  OP_LSR_2_W
00003298  163C 0057               3479              MOVE.B  #'W',D3
0000329C  6100 0D62               3480              BSR     PUSH_STACK
000032A0                          3481  
000032A0  6000 000A               3482              BRA     OP_LSR_2_RETURN
000032A4                          3483  OP_LSR_2_L
000032A4  163C 004C               3484              MOVE.B  #'L',D3
000032A8  6100 0D56               3485              BSR     PUSH_STACK
000032AC                          3486  
000032AC                          3487  OP_LSR_2_RETURN
000032AC  4E75                    3488          RTS
000032AE                          3489              
000032AE                          3490              *FIGURE OUT SIZE
000032AE                          3491   
000032AE                          3492  *---------------------------------------------------------------------------*
000032AE                          3493  * OP_LSL: decode and display LSL
000032AE                          3494  *---------------------------------------------------------------------------*             
000032AE                          3495  OP_LSL      
000032AE                          3496              
000032AE                          3497   
000032AE                          3498  *---------------------------------------------------------------------------*
000032AE                          3499  * OP_LSL: decode and display LSL
000032AE                          3500  *---------------------------------------------------------------------------*             
000032AE                          3501  OP_LSL_2   
000032AE                          3502              
000032AE                          3503   
000032AE                          3504  *---------------------------------------------------------------------------*
000032AE                          3505  * OP_ASR: decode and display ASR
000032AE                          3506  *---------------------------------------------------------------------------*             
000032AE                          3507  OP_ASR      
000032AE                          3508   
000032AE                          3509  *---------------------------------------------------------------------------*
000032AE                          3510  * OP_ASR: decode and display ASR
000032AE                          3511  *---------------------------------------------------------------------------*             
000032AE                          3512  OP_ASR_2     
000032AE                          3513  
000032AE                          3514       
000032AE                          3515       
000032AE                          3516  *---------------------------------------------------------------------------*
000032AE                          3517  * OP_ASL: decode and display ASL
000032AE                          3518  *---------------------------------------------------------------------------*         
000032AE                          3519  OP_ASL      
000032AE                          3520              
000032AE                          3521  *---------------------------------------------------------------------------*
000032AE                          3522  * OP_ASL: decode and display ASL
000032AE                          3523  *---------------------------------------------------------------------------*         
000032AE                          3524  OP_ASL_2     
000032AE                          3525              
000032AE                          3526  
000032AE                          3527  *---------------------------------------------------------------------------*
000032AE                          3528  * OP_ROR: decode and display ROR
000032AE                          3529  *---------------------------------------------------------------------------*             
000032AE                          3530  OP_ROR      
000032AE                          3531  
000032AE                          3532  
000032AE                          3533  *---------------------------------------------------------------------------*
000032AE                          3534  * OP_ROR: decode and display ROR
000032AE                          3535  *---------------------------------------------------------------------------*             
000032AE                          3536  OP_ROR_2    
000032AE                          3537  
000032AE                          3538  *---------------------------------------------------------------------------*
000032AE                          3539  * OP_ROL: decode and display ROL
000032AE                          3540  *---------------------------------------------------------------------------*             
000032AE                          3541  OP_ROL     
000032AE                          3542              
000032AE                          3543  *---------------------------------------------------------------------------*
000032AE                          3544  * OP_ROL: decode and display ROL
000032AE                          3545  *---------------------------------------------------------------------------*             
000032AE                          3546  OP_ROL_2    
000032AE                          3547              
000032AE                          3548  
000032AE                          3549              
000032AE                          3550  *---------------------------------------------------------------------------*
000032AE                          3551  * OP1111 : Special reserved
000032AE                          3552  *---------------------------------------------------------------------------*           
000032AE  4EF8 175A               3553  OP1111      JMP     OP_DATA
000032B2                          3554  
000032B2                          3555  *---------------------------------------------------------------------------*
000032B2                          3556  * EA_NOSRC: decode and display effective addresses for NEG/JSR
000032B2                          3557  *---------------------------------------------------------------------------*
000032B2                          3558  EA_NOSRC    
000032B2  4EB9 00003370           3559              JSR     SRC_MODE
000032B8  43F9 000045D6           3560              LEA     ENDLINE_M,A1
000032BE  103C 000E               3561              MOVE.B  #14,D0
000032C2  4E4F                    3562              TRAP    #15
000032C4  4E75                    3563              RTS
000032C6                          3564              
000032C6                          3565  *---------------------------------------------------------------------------*
000032C6                          3566  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000032C6                          3567  *---------------------------------------------------------------------------*
000032C6                          3568  EA_ARITH
000032C6  4EB9 00003370           3569              JSR     SRC_MODE
000032CC  43F9 00004950           3570              LEA     DISP_D,A1
000032D2  103C 000E               3571              MOVE.B  #14,D0
000032D6  4E4F                    3572              TRAP    #15
000032D8  4EB9 000035FC           3573              JSR     DEST_REGISTER
000032DE  43F9 000045D6           3574              LEA     ENDLINE_M,A1
000032E4  103C 000E               3575              MOVE.B  #14,D0
000032E8  4E4F                    3576              TRAP    #15
000032EA  4E75                    3577              RTS
000032EC                          3578              
000032EC                          3579  *---------------------------------------------------------------------------*
000032EC                          3580  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000032EC                          3581  *---------------------------------------------------------------------------*
000032EC                          3582  EA_MOVEA
000032EC  4EB9 00003370           3583              JSR     SRC_MODE
000032F2  43F9 00004961           3584              LEA     DISP_AOP,A1
000032F8  103C 000E               3585              MOVE.B  #14,D0
000032FC  4E4F                    3586              TRAP    #15
000032FE  4EB9 000035FC           3587              JSR     DEST_REGISTER
00003304  43F9 0000495F           3588              LEA     DISP_CP,A1
0000330A  103C 000D               3589              MOVE.B  #13,D0
0000330E  4E4F                    3590              TRAP    #15
00003310  4E75                    3591              RTS
00003312                          3592              
00003312                          3593  *---------------------------------------------------------------------------*
00003312                          3594  * EA_GEN: decode and display effective addresses for MOVE
00003312                          3595  *---------------------------------------------------------------------------*
00003312                          3596  EA_GEN          
00003312                          3597              * retrieve/display source mode/register
00003312  4EB9 00003370           3598              JSR     SRC_MODE
00003318                          3599              
00003318                          3600              * retrieve/display destination mode/register
00003318  4EB9 0000332C           3601              JSR     DEST_MODE
0000331E                          3602              
0000331E  43F9 000045D6           3603              LEA     ENDLINE_M,A1
00003324  103C 000E               3604              MOVE.B  #14,D0
00003328  4E4F                    3605              TRAP    #15
0000332A                          3606              
0000332A  4E75                    3607              RTS
0000332C                          3608  
0000332C                          3609  *---------------------------------------------------------------------------*
0000332C                          3610  * DEST_MODE: decode and display destination mode (bit 8 - 6)
0000332C                          3611  *---------------------------------------------------------------------------*           
0000332C                          3612  DEST_MODE   
0000332C                          3613              * clear registers to store temp data
0000332C  4280                    3614              CLR.L   D0                      
0000332E  4281                    3615              CLR.L   D1                      
00003330  207C 00000000           3616              MOVEA.L #0, A0                  
00003336  227C 00000000           3617              MOVEA.L #0, A1                  
0000333C  2205                    3618              MOVE.L  D5,D1
0000333E  EC89                    3619              LSR.L   #6,D1
00003340  0281 00000007           3620              ANDI.L  #$7,D1
00003346  0C01 0000               3621              CMPI.B  #0,D1   * Dn
0000334A  6700 0082               3622              BEQ     D_MODE000
0000334E  0C01 0002               3623              CMPI.B  #2,D1   * (An)
00003352  6700 00C2               3624              BEQ     D_MODE010
00003356  0C01 0003               3625              CMPI.B  #3,D1   * (An)+
0000335A  6700 011A               3626              BEQ     D_MODE011
0000335E  0C01 0004               3627              CMPI.B  #4,D1   * -(An)
00003362  6700 0132               3628              BEQ     D_MODE100
00003366  0C01 0007               3629              CMPI.B  #7,D1  * abs
0000336A  6700 017C               3630              BEQ     D_MODE111 
0000336E  4E75                    3631              RTS
00003370                          3632  
00003370                          3633  *---------------------------------------------------------------------------*
00003370                          3634  * SRC_MODE: decode and display source mode (bit 5 - 3)
00003370                          3635  *---------------------------------------------------------------------------*  
00003370                          3636  SRC_MODE    
00003370                          3637              * clear registers to store temp data
00003370  4280                    3638              CLR.L   D0                      
00003372  4281                    3639              CLR.L   D1                      
00003374  207C 00000000           3640              MOVEA.L #0, A0                  
0000337A  227C 00000000           3641              MOVEA.L #0, A1                  
00003380  2205                    3642              MOVE.L  D5,D1
00003382  E489                    3643              LSR.L   #2,D1
00003384  0281 0000000E           3644              ANDI.L  #$E,D1
0000338A                          3645              
0000338A  0C01 0000               3646              CMPI.B  #0,D1   * Dn
0000338E  6700 002A               3647              BEQ     MODE000
00003392  0C01 0002               3648              CMPI.B  #2,D1   * An 
00003396  6700 004A               3649              BEQ     MODE001
0000339A  0C01 0004               3650              CMPI.B  #4,D1   * (An)
0000339E  6700 0056               3651              BEQ     MODE010
000033A2  0C01 0006               3652              CMPI.B  #6,D1   * (An)+
000033A6  6700 008E               3653              BEQ     MODE011
000033AA  0C01 0008               3654              CMPI.B  #8,D1   * -(An)
000033AE  6700 00A6               3655              BEQ     MODE100
000033B2  0C01 000F               3656              CMPI.B  #15,D1  * abs/immediate
000033B6  6700 00FE               3657              BEQ     MODE111 
000033BA                          3658        
000033BA                          3659  *---------------------------------------------------------------------------*
000033BA                          3660  * MODE000: decode and display source mode Dn
000033BA                          3661  *---------------------------------------------------------------------------*           
000033BA                          3662  MODE000     *Dn
000033BA  43F9 00004950           3663              LEA     DISP_D,A1
000033C0  103C 000E               3664              MOVE.B  #14,D0
000033C4  4E4F                    3665              TRAP    #15
000033C6  4EB9 00003658           3666              JSR     SRC_REGISTER
000033CC  4E75                    3667              RTS
000033CE                          3668  
000033CE                          3669  *---------------------------------------------------------------------------*
000033CE                          3670  * D_MODE000: decode and display dest mode Dn
000033CE                          3671  *---------------------------------------------------------------------------*
000033CE                          3672  D_MODE000     *Dn
000033CE  43F9 00004950           3673              LEA     DISP_D,A1
000033D4  103C 000E               3674              MOVE.B  #14,D0
000033D8  4E4F                    3675              TRAP    #15
000033DA  4EB9 000035FC           3676              JSR     DEST_REGISTER
000033E0  4E75                    3677              RTS
000033E2                          3678  
000033E2                          3679  *---------------------------------------------------------------------------*
000033E2                          3680  * MODE001: decode and display source mode An
000033E2                          3681  *---------------------------------------------------------------------------* 
000033E2                          3682  MODE001 *An
000033E2  43F9 00004955           3683              LEA     DISP_A,A1
000033E8  103C 000E               3684              MOVE.B  #14,D0
000033EC  4E4F                    3685              TRAP    #15
000033EE  4EB9 00003658           3686              JSR     SRC_REGISTER
000033F4                          3687          
000033F4  4E75                    3688              RTS
000033F6                          3689  
000033F6                          3690  *---------------------------------------------------------------------------*
000033F6                          3691  * MODE010: decode and display source mode (An)
000033F6                          3692  *---------------------------------------------------------------------------*    
000033F6                          3693  MODE010 *(An)
000033F6  43F9 00004961           3694              LEA     DISP_AOP,A1  *display (A
000033FC  103C 000E               3695              MOVE.B  #14,D0
00003400  4E4F                    3696              TRAP    #15
00003402                          3697  
00003402  4EB9 00003658           3698              JSR     SRC_REGISTER * display register
00003408                          3699  
00003408  43F9 0000495F           3700              LEA     DISP_CP,A1   *display )
0000340E  103C 000E               3701              MOVE.B  #14,D0
00003412  4E4F                    3702              TRAP    #15
00003414                          3703              
00003414  4E75                    3704              RTS
00003416                          3705  
00003416                          3706  *---------------------------------------------------------------------------*
00003416                          3707  * D_MODE010: decode and display dest mode (An)
00003416                          3708  *---------------------------------------------------------------------------*
00003416                          3709  D_MODE010 *(An)
00003416  43F9 00004961           3710              LEA     DISP_AOP,A1  *display (A
0000341C  103C 000E               3711              MOVE.B  #14,D0
00003420  4E4F                    3712              TRAP    #15
00003422                          3713     
00003422  4EB9 000035FC           3714              JSR     DEST_REGISTER * display register
00003428                          3715  
00003428  43F9 0000495F           3716              LEA     DISP_CP,A1   *display )
0000342E  103C 000E               3717              MOVE.B  #14,D0
00003432  4E4F                    3718              TRAP    #15
00003434                          3719              
00003434  4E75                    3720              RTS
00003436                          3721  
00003436                          3722  *---------------------------------------------------------------------------*
00003436                          3723  * MODE011: decode and display source mode (An)+
00003436                          3724  *---------------------------------------------------------------------------*
00003436                          3725  MODE011 *(An)+
00003436  43F9 00004961           3726              LEA     DISP_AOP,A1      *display (A
0000343C  103C 000E               3727              MOVE.B  #14,D0
00003440  4E4F                    3728              TRAP    #15
00003442                          3729              
00003442  4EB9 00003658           3730              JSR     SRC_REGISTER    * display register
00003448                          3731  
00003448  43F9 0000496E           3732              LEA     DISP_POST,A1    *display )+
0000344E  103C 000E               3733              MOVE.B  #14,D0
00003452  4E4F                    3734              TRAP    #15
00003454                          3735              
00003454  4E75                    3736              RTS
00003456                          3737              
00003456                          3738  *---------------------------------------------------------------------------*
00003456                          3739  * MODE100: decode and display source mode -(An)
00003456                          3740  *---------------------------------------------------------------------------*
00003456                          3741  MODE100 *-(An)
00003456  43F9 00004967           3742              LEA     DISP_PRE,A1    *display -(A
0000345C  103C 000E               3743              MOVE.B  #14,D0
00003460  4E4F                    3744              TRAP    #15
00003462                          3745  
00003462  4EB9 00003658           3746              JSR     SRC_REGISTER    *display register
00003468                          3747  
00003468  43F9 0000495F           3748              LEA     DISP_CP,A1   *display )
0000346E  103C 000E               3749              MOVE.B  #14,D0
00003472  4E4F                    3750              TRAP    #15
00003474                          3751              
00003474  4E75                    3752              RTS
00003476                          3753  
00003476                          3754  *---------------------------------------------------------------------------*
00003476                          3755  * D_MODE011: decode and display dest mode (An)+
00003476                          3756  *---------------------------------------------------------------------------*
00003476                          3757  D_MODE011 *(An)+
00003476  43F9 00004961           3758              LEA     DISP_AOP,A1      *display (A
0000347C  103C 000E               3759              MOVE.B  #14,D0
00003480  4E4F                    3760              TRAP    #15
00003482                          3761  
00003482  4EB9 000035FC           3762              JSR     DEST_REGISTER    * display register
00003488                          3763  
00003488  43F9 0000496E           3764              LEA     DISP_POST,A1    *display )+
0000348E  103C 000E               3765              MOVE.B  #14,D0
00003492  4E4F                    3766              TRAP    #15
00003494                          3767              
00003494  4E75                    3768              RTS
00003496                          3769              
00003496                          3770  *---------------------------------------------------------------------------*
00003496                          3771  * D_MODE100: decode and display dest mode -(An)
00003496                          3772  *---------------------------------------------------------------------------*            
00003496                          3773  D_MODE100 *-(An)
00003496  43F9 00004967           3774              LEA     DISP_PRE,A1    *display -(A
0000349C  103C 000E               3775              MOVE.B  #14,D0
000034A0  4E4F                    3776              TRAP    #15
000034A2                          3777              
000034A2  4EB9 000035FC           3778              JSR     DEST_REGISTER    *display register
000034A8                          3779  
000034A8  43F9 0000495F           3780              LEA     DISP_CP,A1   *display )
000034AE  103C 000E               3781              MOVE.B  #14,D0
000034B2  4E4F                    3782              TRAP    #15
000034B4                          3783              
000034B4  4E75                    3784              RTS
000034B6                          3785  
000034B6                          3786  *---------------------------------------------------------------------------*
000034B6                          3787  * MODE111: decode and display source mode absolute/immediate
000034B6                          3788  *---------------------------------------------------------------------------*
000034B6                          3789  MODE111     * abs/immediate
000034B6                          3790              * clear registers to store temp data
000034B6  4280                    3791              CLR.L   D0                      
000034B8  4281                    3792              CLR.L   D1                      
000034BA  207C 00000000           3793              MOVEA.L #0, A0                  
000034C0  227C 00000000           3794              MOVEA.L #0, A1                  
000034C6  2205                    3795              MOVE.L  D5,D1
000034C8                          3796              
000034C8                          3797              * retrieve source register for MODE 111
000034C8  E389                    3798              LSL.L   #1,D1   * shift the bits to left by 1
000034CA  0281 0000000E           3799              ANDI.L  #$E,D1  * mask the first 4 bits 
000034D0  0C01 0000               3800              CMPI.B  #0, D1  * if it's 0000, absolute word address
000034D4  6700 003E               3801              BEQ     WORDMODE
000034D8  0C01 0002               3802              CMPI.B  #2, D1  * if it's 0010, absolute long address
000034DC  6700 0062               3803              BEQ     LONGMODE
000034E0  0C01 0008               3804              CMPI.B  #8, D1  * if it's 1000, immediate data
000034E4  6700 0086               3805              BEQ     IMMEDIATE
000034E8                          3806       
000034E8                          3807  *---------------------------------------------------------------------------*
000034E8                          3808  * D_MODE111: decode and display dest mode absolute/immediate
000034E8                          3809  *---------------------------------------------------------------------------*           
000034E8                          3810  D_MODE111   * abs
000034E8                          3811              * clear registers to store temp data
000034E8  4280                    3812              CLR.L   D0                      
000034EA  4281                    3813              CLR.L   D1                      
000034EC  207C 00000000           3814              MOVEA.L #0, A0                  
000034F2  227C 00000000           3815              MOVEA.L #0, A1                  
000034F8  2205                    3816              MOVE.L  D5,D1
000034FA                          3817              
000034FA                          3818              * retrieve dest register for MODE 111
000034FA  EC89                    3819              LSR.L   #6,D1   * shift the bits to right by 6
000034FC  E689                    3820              LSR.L   #3,D1   * shift the bits to right by extra 3
000034FE  0201 0001               3821              ANDI.B  #1,D1   * mask the first 2 bits 
00003502  0C01 0000               3822              CMPI.B  #0, D1  * if it's 000, absolute word address
00003506  6700 000C               3823              BEQ     WORDMODE
0000350A  0C01 0001               3824              CMPI.B  #1, D1  * if it's 001, absolute long address
0000350E  6700 0030               3825              BEQ     LONGMODE
00003512                          3826              *JSR     OP_DATA *not sure..
00003512  4E75                    3827              RTS
00003514                          3828  
00003514                          3829  
00003514                          3830  *---------------------------------------------------------------------------*
00003514                          3831  * WORDMODE: absolute word address
00003514                          3832  *---------------------------------------------------------------------------*
00003514  43F9 0000494B           3833  WORDMODE    LEA     DISP_HEX,A1
0000351A  103C 000E               3834              MOVE.B  #14,D0
0000351E  4E4F                    3835              TRAP    #15
00003520                          3836              
00003520  4285                    3837              CLR.L   D5
00003522  3A1D                    3838              MOVE.W  (A5)+,D5
00003524                          3839              
00003524  43F9 00004629           3840              LEA     TMPOUTPUT,A1
0000352A  2205                    3841              MOVE.L  D5,D1
0000352C  7404                    3842              MOVE.L  #4,D2       *move word size 4
0000352E  4EB8 1228               3843              JSR     HEX2ASCII
00003532  43F9 00004629           3844              LEA     TMPOUTPUT,A1
00003538  103C 000E               3845              MOVE.B  #14,D0
0000353C  4E4F                    3846              TRAP    #15
0000353E                          3847              
0000353E  4E75                    3848              RTS
00003540                          3849  
00003540                          3850  *---------------------------------------------------------------------------*
00003540                          3851  * LONGMODE: absolute long address
00003540                          3852  *---------------------------------------------------------------------------*
00003540  43F9 0000494B           3853  LONGMODE    LEA     DISP_HEX,A1
00003546  103C 000E               3854              MOVE.B  #14,D0
0000354A  4E4F                    3855              TRAP    #15
0000354C                          3856              
0000354C  4285                    3857              CLR.L   D5
0000354E  2A1D                    3858              MOVE.L  (A5)+,D5
00003550                          3859              
00003550  43F9 00004629           3860              LEA     TMPOUTPUT,A1
00003556  2205                    3861              MOVE.L  D5,D1
00003558  7408                    3862              MOVE.L  #8,D2           *move longword size 8
0000355A  4EB8 1228               3863              JSR     HEX2ASCII
0000355E  43F9 00004629           3864              LEA     TMPOUTPUT,A1
00003564  103C 000E               3865              MOVE.B  #14,D0
00003568  4E4F                    3866              TRAP    #15
0000356A                          3867              
0000356A  4E75                    3868              RTS
0000356C                          3869  
0000356C                          3870  
0000356C                          3871  *---------------------------------------------------------------------------*
0000356C                          3872  * IMMEDIATE: immediate address
0000356C                          3873  *---------------------------------------------------------------------------*
0000356C  43F9 00004971           3874  IMMEDIATE   LEA     DISP_LB,A1
00003572  103C 000E               3875              MOVE.B  #14,D0
00003576  4E4F                    3876              TRAP    #15
00003578  43F9 0000494B           3877              LEA     DISP_HEX,A1
0000357E  103C 000E               3878              MOVE.B  #14,D0
00003582  4E4F                    3879              TRAP    #15
00003584                          3880              
00003584                          3881              * check for size
00003584  0C04 0000               3882              CMPI.B  #0,D4
00003588  6700 0012               3883              BEQ     IMMD_B
0000358C  0C04 0001               3884              CMPI.B  #1,D4
00003590  6700 002A               3885              BEQ     IMMD_W
00003594  0C04 0002               3886              CMPI.B  #2,D4
00003598  6700 0042               3887              BEQ     IMMD_L
0000359C                          3888  
0000359C                          3889  IMMD_B
0000359C  4285                    3890              CLR.L   D5
0000359E  3A1D                    3891              MOVE.W  (A5)+,D5
000035A0                          3892              
000035A0  43F9 00004629           3893              LEA     TMPOUTPUT,A1
000035A6  2205                    3894              MOVE.L  D5,D1
000035A8  7402                    3895              MOVE.L  #2,D2
000035AA  4EB8 1228               3896              JSR     HEX2ASCII
000035AE  43F9 00004629           3897              LEA     TMPOUTPUT,A1
000035B4  103C 000E               3898              MOVE.B  #14,D0
000035B8  4E4F                    3899              TRAP    #15
000035BA  4E75                    3900              RTS
000035BC                          3901              
000035BC                          3902  IMMD_W
000035BC  4285                    3903              CLR.L   D5
000035BE  3A1D                    3904              MOVE.W  (A5)+,D5
000035C0                          3905              
000035C0  43F9 00004629           3906              LEA     TMPOUTPUT,A1
000035C6  2205                    3907              MOVE.L  D5,D1
000035C8  7404                    3908              MOVE.L  #4,D2
000035CA  4EB8 1228               3909              JSR     HEX2ASCII
000035CE  43F9 00004629           3910              LEA     TMPOUTPUT,A1
000035D4  103C 000E               3911              MOVE.B  #14,D0
000035D8  4E4F                    3912              TRAP    #15
000035DA  4E75                    3913              RTS
000035DC                          3914              
000035DC                          3915  
000035DC                          3916  IMMD_L
000035DC  4285                    3917              CLR.L   D5
000035DE  3A1D                    3918              MOVE.W  (A5)+,D5
000035E0                          3919              
000035E0  43F9 00004629           3920              LEA     TMPOUTPUT,A1
000035E6  2205                    3921              MOVE.L  D5,D1
000035E8  7408                    3922              MOVE.L  #8,D2
000035EA  4EB8 1228               3923              JSR     HEX2ASCII
000035EE  43F9 00004629           3924              LEA     TMPOUTPUT,A1
000035F4  103C 000E               3925              MOVE.B  #14,D0
000035F8  4E4F                    3926              TRAP    #15
000035FA  4E75                    3927              RTS
000035FC                          3928  
000035FC                          3929  
000035FC                          3930  *---------------------------------------------------------------------------*
000035FC                          3931  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000035FC                          3932  *---------------------------------------------------------------------------*
000035FC                          3933  DEST_REGISTER
000035FC                          3934              * clear registers to store temp data
000035FC  4280                    3935              CLR.L   D0                      
000035FE  4281                    3936              CLR.L   D1                      
00003600  207C 00000000           3937              MOVEA.L #0, A0                  
00003606  227C 00000000           3938              MOVEA.L #0, A1 
0000360C                          3939              
0000360C  2205                    3940              MOVE.L  D5,D1
0000360E  EC89                    3941              LSR.L   #6,D1
00003610  E689                    3942              LSR.L   #3,D1
00003612  0281 00000007           3943              ANDI.L  #7,D1
00003618                          3944              
00003618  0C01 0000               3945              CMPI.B  #0,D1
0000361C  6700 0092               3946              BEQ     REG_0
00003620  0C01 0001               3947              CMPI.B  #1,D1
00003624  6700 0098               3948              BEQ     REG_1
00003628  0C01 0002               3949              CMPI.B  #2,D1
0000362C  6700 009E               3950              BEQ     REG_2
00003630  0C01 0003               3951              CMPI.B  #3,D1
00003634  6700 00A4               3952              BEQ     REG_3
00003638  0C01 0004               3953              CMPI.B  #4,D1
0000363C  6700 00AA               3954              BEQ     REG_4
00003640  0C01 0005               3955              CMPI.B  #5,D1
00003644  6700 00B0               3956              BEQ     REG_5
00003648  0C01 0006               3957              CMPI.B  #6,D1
0000364C  6700 00B6               3958              BEQ     REG_6
00003650  0C01 0007               3959              CMPI.B  #7,D1
00003654  6700 00BC               3960              BEQ     REG_7
00003658                          3961  
00003658                          3962  *---------------------------------------------------------------------------*
00003658                          3963  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003658                          3964  *---------------------------------------------------------------------------*           
00003658                          3965  SRC_REGISTER 
00003658                          3966              * clear registers to store temp data
00003658  4280                    3967              CLR.L   D0                      
0000365A  4281                    3968              CLR.L   D1                      
0000365C  207C 00000000           3969              MOVEA.L #0, A0                  
00003662  227C 00000000           3970              MOVEA.L #0, A1                  
00003668                          3971              
00003668  2205                    3972              MOVE.L  D5,D1   * temp store the processing data
0000366A  0281 00000007           3973              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00003670                          3974              
00003670  0C01 0000               3975              CMPI.B  #0,D1
00003674  6700 003A               3976              BEQ     REG_0
00003678  0C01 0001               3977              CMPI.B  #1,D1
0000367C  6700 0040               3978              BEQ     REG_1
00003680  0C01 0002               3979              CMPI.B  #2,D1
00003684  6700 0046               3980              BEQ     REG_2
00003688  0C01 0003               3981              CMPI.B  #3,D1
0000368C  6700 004C               3982              BEQ     REG_3
00003690  0C01 0004               3983              CMPI.B  #4,D1
00003694  6700 0052               3984              BEQ     REG_4
00003698  0C01 0005               3985              CMPI.B  #5,D1
0000369C  6700 0058               3986              BEQ     REG_5
000036A0  0C01 0006               3987              CMPI.B  #6,D1
000036A4  6700 005E               3988              BEQ     REG_6
000036A8  0C01 0007               3989              CMPI.B  #7,D1
000036AC  6700 0064               3990              BEQ     REG_7
000036B0                          3991  
000036B0                          3992  *---------------------------------------------------------------------------*
000036B0                          3993  * REG_0 ~ REG_7: display register 0 to 7
000036B0                          3994  *---------------------------------------------------------------------------*
000036B0  43F9 00004976           3995  REG_0       LEA     DISP_0,A1
000036B6  103C 000E               3996              MOVE.B  #14,D0
000036BA  4E4F                    3997              TRAP    #15
000036BC  4E75                    3998              RTS
000036BE                          3999              
000036BE  43F9 00004978           4000  REG_1       LEA     DISP_1,A1
000036C4  103C 000E               4001              MOVE.B  #14,D0
000036C8  4E4F                    4002              TRAP    #15
000036CA  4E75                    4003              RTS
000036CC                          4004              
000036CC                          4005  
000036CC  43F9 0000497A           4006  REG_2       LEA     DISP_2,A1
000036D2  103C 000E               4007              MOVE.B  #14,D0
000036D6  4E4F                    4008              TRAP    #15
000036D8  4E75                    4009              RTS
000036DA                          4010            
000036DA  43F9 0000497C           4011  REG_3       LEA     DISP_3,A1
000036E0  103C 000E               4012              MOVE.B  #14,D0
000036E4  4E4F                    4013              TRAP    #15
000036E6  4E75                    4014              RTS
000036E8                          4015              
000036E8  43F9 0000497E           4016  REG_4       LEA     DISP_4,A1
000036EE  103C 000E               4017              MOVE.B  #14,D0
000036F2  4E4F                    4018              TRAP    #15
000036F4  4E75                    4019              RTS
000036F6                          4020              
000036F6  43F9 00004980           4021  REG_5       LEA     DISP_5,A1
000036FC  103C 000E               4022              MOVE.B  #14,D0
00003700  4E4F                    4023              TRAP    #15
00003702  4E75                    4024              RTS
00003704                          4025              
00003704  43F9 00004982           4026  REG_6       LEA     DISP_6,A1
0000370A  103C 000E               4027              MOVE.B  #14,D0
0000370E  4E4F                    4028              TRAP    #15
00003710  4E75                    4029              RTS
00003712                          4030              
00003712  43F9 00004984           4031  REG_7       LEA     DISP_7,A1
00003718  103C 000E               4032              MOVE.B  #14,D0
0000371C  4E4F                    4033              TRAP    #15
0000371E  4E75                    4034              RTS
00003720                          4035              
00003720                          4036  *---------------------------------------------------------------------------*
00003720                          4037  * REPEAT : Ask user whether they wish to run the program again
00003720                          4038  *---------------------------------------------------------------------------*           
00003720  4246                    4039  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00003722  43F9 0000444F           4040              LEA     REPEATMSG,A1
00003728  103C 000E               4041              MOVE.B  #14,D0
0000372C  4E4F                    4042              TRAP    #15
0000372E                          4043              
0000372E  43F9 000045D9           4044              LEA     TMPINPUT,A1             * allocate space to temp store user input
00003734  103C 0002               4045              MOVE.B  #2,D0
00003738  4E4F                    4046              TRAP    #15
0000373A                          4047  
0000373A  0C01 0001               4048              CMPI.B  #1,D1                   * check for length of user input
0000373E  66E0                    4049              BNE     REPEAT                  * return to the beginning of the function if unequal
00003740                          4050              
00003740  0C11 0059               4051              CMPI.B  #$59,(A1)               * compare the input with Y    
00003744  6700 D8C4               4052              BEQ     PROGLP                  * repeat the program
00003748                          4053              
00003748  0C11 0079               4054              CMPI.B  #$79,(A1)               * compare the input with y    
0000374C  6700 D8BC               4055              BEQ     PROGLP                  * repeat the program
00003750                          4056              
00003750  0C11 004E               4057              CMPI.B  #$4E,(A1)               * compare the input with N    
00003754  6700 098C               4058              BEQ     TERMINATE               * finish program
00003758                          4059              
00003758  0C11 006E               4060              CMPI.B  #$6E,(A1)               * compare the input with n    
0000375C  6700 0984               4061              BEQ     TERMINATE               * finish program
00003760                          4062              
00003760  60BE                    4063              BRA     REPEAT                  * invalid input/repeat the function
00003762                          4064  
00003762                          4065  *---------------------------------------------------------------------------*
00003762                          4066  * EA DECODING INTERFACE
00003762                          4067  * [A0] - RESERVED FOR USE
00003762                          4068  * [D2] - RESERVED FOR USE
00003762                          4069  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00003762                          4070  *---------------------------------------------------------------------------*
00003762                          4071  GET_EA_EA_SRC
00003762                          4072      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003762                          4073      
00003762                          4074      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003762  2405                    4075      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003764  E68A                    4076      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00003766  23C2 0000499C           4077      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
0000376C  7407                    4078      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
0000376E  C5B9 0000499C           4079      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003774                          4080                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003774                          4081      
00003774                          4082      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003774                          4083      *DESTINATION REGISTER FORMAT STANDARD         *
00003774                          4084      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003774                          4085      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003774                          4086      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003774                          4087      *0 - Dn                                       *
00003774                          4088      *1 - An                                       *
00003774                          4089      *2 - (An)                                     *
00003774                          4090      *3 - (An)+                                    *
00003774                          4091      *4 - -(An)                                    *
00003774                          4092      *5 - (XXX).W                                  *
00003774                          4093      *6 - (XXX).L                                  *
00003774                          4094      *7 - #<data>                                  *
00003774                          4095      ***********************************************
00003774                          4096      
00003774                          4097      *** Check if source ...  <ea> = Dn
00003774                          4098  CHECK0    
00003774  41F9 0000498C           4099            LEA     TEMP_REGISTER_FORMAT,A0
0000377A  1439 0000498B           4100            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003780  1082                    4101            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003782  0239 0001 0000498C      4102            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
0000378A  0C39 0001 0000498C      4103            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003792  6700 006A               4104            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003796  0CB9 00000000 0000499C  4105            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000037A0  6600 005C               4106            BNE     CHECK1
000037A4                          4107            
000037A4                          4108            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000037A4  163C 0020               4109            MOVE.B    #' ',D3
000037A8  6100 0856               4110            BSR       PUSH_STACK
000037AC  163C 0044               4111            MOVE.B    #'D',D3
000037B0  6100 084E               4112            BSR       PUSH_STACK
000037B4                          4113  
000037B4                          4114            *FIND REGISTER NUMBER END LOCATION*  
000037B4  13F9 0000498E 00004994  4115            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000037BE  0239 000F 00004994      4116            AND.B   #$0F,VAR_BYTE_END
000037C6                          4117            
000037C6                          4118            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037C6  23C5 00004998           4119            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037CC  1439 00004994           4120            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000037D2                          4121            
000037D2                          4122            *INTITIALIZE FOR BIT SHIFTING
000037D2  41F9 00004998           4123            LEA     VAR_TEMP_CLEANCOPY,A0
000037D8  2639 00004998           4124            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037DE                          4125  LOOP_SHIFTING
000037DE  0C02 0000               4126            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037E2  6700 0008               4127            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000037E6  E24B                    4128            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037E8  5302                    4129            SUB.B   #1,D2                     *DECREMENT COUNTER
000037EA  60F2                    4130            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000037EC                          4131  MASKING_NEXT
000037EC  C6BC 00000007           4132            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037F2  0603 0030               4133            ADD.B   #$30,D3                   *CONVERT TO CHAR
000037F6  6100 0808               4134            BSR     PUSH_STACK                *PUSH TO STACK
000037FA                          4135            
000037FA  6000 0394               4136            BRA     GET_SRC_SUCCESS           *RETURN          
000037FE                          4137            
000037FE                          4138            
000037FE                          4139            *** Check if source ...  <ea> = An
000037FE  41F9 0000498C           4140  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
00003804  1439 0000498B           4141            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000380A  1082                    4142            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000380C  0239 0002 0000498C      4143            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003814  0C39 0002 0000498C      4144            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
0000381C  6700 006A               4145            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003820  0CB9 00000001 0000499C  4146            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
0000382A  6600 005C               4147            BNE     CHECK2
0000382E                          4148            
0000382E                          4149            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000382E  163C 0020               4150            MOVE.B    #' ',D3
00003832  6100 07CC               4151            BSR       PUSH_STACK
00003836  163C 0041               4152            MOVE.B    #'A',D3
0000383A  6100 07C4               4153            BSR       PUSH_STACK
0000383E                          4154  
0000383E                          4155            
0000383E                          4156            *FIND REGISTER NUMBER END LOCATION*  
0000383E  13F9 0000498E 00004994  4157            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003848  0239 000F 00004994      4158            AND.B   #$0F,VAR_BYTE_END
00003850                          4159            
00003850                          4160            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003850  23C5 00004998           4161            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003856  1439 00004994           4162            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000385C                          4163            
0000385C                          4164            *INTITIALIZE FOR BIT SHIFTING
0000385C  41F9 00004998           4165            LEA     VAR_TEMP_CLEANCOPY,A0
00003862  2639 00004998           4166            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003868                          4167  LOOP_SHIFTING1
00003868  0C02 0000               4168            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000386C  6700 0008               4169            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003870  E24B                    4170            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003872  5302                    4171            SUB.B   #1,D2                     *DECREMENT COUNTER
00003874  60F2                    4172            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003876                          4173  MASKING_NEXT1
00003876  C6BC 00000007           4174            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000387C  0603 0030               4175            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003880  6100 077E               4176            BSR     PUSH_STACK                *PUSH TO STACK
00003884                          4177            
00003884  6000 030A               4178            BRA     GET_SRC_SUCCESS                   *RETURN 
00003888                          4179            
00003888                          4180            
00003888                          4181            
00003888                          4182            
00003888                          4183            *** Check if source ...  <ea> = (An)       
00003888  41F9 0000498C           4184  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
0000388E  1439 0000498B           4185            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003894  1082                    4186            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003896  0239 0004 0000498C      4187            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
0000389E  0C39 0004 0000498C      4188            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000038A6  6700 007A               4189            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000038AA  0CB9 00000002 0000499C  4190            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000038B4  6600 006C               4191            BNE     CHECK3
000038B8                          4192            
000038B8                          4193            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000038B8  163C 0020               4194            MOVE.B    #' ',D3
000038BC  6100 0742               4195            BSR       PUSH_STACK
000038C0  163C 0028               4196            MOVE.B    #'(',D3
000038C4  6100 073A               4197            BSR       PUSH_STACK
000038C8  163C 0041               4198            MOVE.B    #'A',D3
000038CC  6100 0732               4199            BSR       PUSH_STACK
000038D0                          4200  
000038D0                          4201            
000038D0                          4202            *FIND REGISTER NUMBER END LOCATION*  
000038D0  13F9 0000498E 00004994  4203            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038DA  0239 000F 00004994      4204            AND.B   #$0F,VAR_BYTE_END
000038E2                          4205            
000038E2                          4206            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038E2  23C5 00004998           4207            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038E8  1439 00004994           4208            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038EE                          4209            
000038EE                          4210            *INTITIALIZE FOR BIT SHIFTING
000038EE  41F9 00004998           4211            LEA     VAR_TEMP_CLEANCOPY,A0
000038F4  2639 00004998           4212            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038FA                          4213  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000038FA  0C02 0000               4214            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038FE  6700 0008               4215            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003902  E24B                    4216            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003904  5302                    4217            SUB.B   #1,D2                     *DECREMENT COUNTER
00003906  60F2                    4218            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003908                          4219  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003908  0283 00000007           4220            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000390E  0603 0030               4221            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003912  6100 06EC               4222            BSR     PUSH_STACK                *PUSH TO STACK
00003916                          4223            
00003916  163C 0029               4224            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000391A  6100 06E4               4225            BSR       PUSH_STACK
0000391E                          4226            
0000391E  6000 0270               4227            BRA     GET_SRC_SUCCESS                   *RETURN 
00003922                          4228  
00003922                          4229            
00003922                          4230            
00003922                          4231                      
00003922                          4232  *** Check if source ...  <ea> = (An)+       
00003922  41F9 0000498C           4233  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003928  1439 0000498B           4234            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000392E  1082                    4235            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003930  0239 0008 0000498C      4236            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003938  0C39 0008 0000498C      4237            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003940  6700 0082               4238            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003944  0CB9 00000003 0000499C  4239            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000394E  6600 0074               4240            BNE     CHECK4
00003952                          4241            
00003952                          4242            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003952  163C 0020               4243            MOVE.B    #' ',D3
00003956  6100 06A8               4244            BSR       PUSH_STACK
0000395A  163C 0028               4245            MOVE.B    #'(',D3
0000395E  6100 06A0               4246            BSR       PUSH_STACK
00003962  163C 0041               4247            MOVE.B    #'A',D3
00003966  6100 0698               4248            BSR       PUSH_STACK
0000396A                          4249  
0000396A                          4250            
0000396A                          4251            *FIND REGISTER NUMBER END LOCATION*  
0000396A  13F9 0000498E 00004994  4252            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003974  0239 000F 00004994      4253            ANDI.B   #$0F,VAR_BYTE_END
0000397C                          4254            
0000397C                          4255            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000397C  23C5 00004998           4256            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003982  1439 00004994           4257            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003988                          4258            
00003988                          4259            *INTITIALIZE FOR BIT SHIFTING
00003988  41F9 00004998           4260            LEA     VAR_TEMP_CLEANCOPY,A0
0000398E  2639 00004998           4261            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003994                          4262            
00003994                          4263  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003994  0C02 0000               4264            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003998  6700 0008               4265            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000399C  E24B                    4266            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000399E  5302                    4267            SUBI.B   #1,D2                     *DECREMENT COUNTER
000039A0  60F2                    4268            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
000039A2                          4269                                               *change: NAME OF LABEL*
000039A2                          4270  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000039A2  0283 00000007           4271            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000039A8  0603 0030               4272            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000039AC  6100 0652               4273            BSR     PUSH_STACK                *PUSH TO STACK
000039B0                          4274            
000039B0  163C 0029               4275            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000039B4  6100 064A               4276            BSR       PUSH_STACK
000039B8  163C 002B               4277            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000039BC  6100 0642               4278            BSR       PUSH_STACK
000039C0                          4279            
000039C0  6000 01CE               4280            BRA       GET_SRC_SUCCESS                   *RETURN 
000039C4                          4281  
000039C4                          4282            
000039C4                          4283            
000039C4                          4284                      
000039C4                          4285            *** Check if source ...  <ea> = -(An)       
000039C4  41F9 0000498C           4286  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
000039CA  1439 0000498B           4287            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039D0  1082                    4288            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039D2  0239 0010 0000498C      4289            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000039DA  0C39 0010 0000498C      4290            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039E2  6700 0082               4291            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000039E6  0CB9 00000004 0000499C  4292            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000039F0  6600 0074               4293            BNE     CHECK7
000039F4                          4294            
000039F4                          4295            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000039F4  163C 0020               4296            MOVE.B    #' ',D3
000039F8  6100 0606               4297            BSR       PUSH_STACK
000039FC  163C 002D               4298            MOVE.B    #'-',D3
00003A00  6100 05FE               4299            BSR       PUSH_STACK
00003A04  163C 0028               4300            MOVE.B    #'(',D3
00003A08  6100 05F6               4301            BSR       PUSH_STACK
00003A0C  163C 0041               4302            MOVE.B    #'A',D3
00003A10  6100 05EE               4303            BSR       PUSH_STACK
00003A14                          4304  
00003A14                          4305            
00003A14                          4306            *FIND REGISTER NUMBER END LOCATION*  
00003A14  13F9 0000498E 00004994  4307            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A1E  0239 000F 00004994      4308            AND.B   #$0F,VAR_BYTE_END
00003A26                          4309            
00003A26                          4310            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A26  23C5 00004998           4311            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A2C  1439 00004994           4312            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A32                          4313            
00003A32                          4314            *INTITIALIZE FOR BIT SHIFTING
00003A32  41F9 00004998           4315            LEA     VAR_TEMP_CLEANCOPY,A0
00003A38  2639 00004998           4316            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003A3E                          4317            
00003A3E                          4318  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003A3E  0C02 0000               4319            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A42  6700 0008               4320            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003A46  E24B                    4321            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A48  5302                    4322            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003A4A  60F2                    4323            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003A4C                          4324                                               *change: NAME OF LABEL*
00003A4C                          4325  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003A4C  0283 00000007           4326            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A52  0603 0030               4327            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003A56  6100 05A8               4328            BSR     PUSH_STACK                *PUSH TO STACK
00003A5A                          4329            
00003A5A  163C 0029               4330            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003A5E  6100 05A0               4331            BSR       PUSH_STACK
00003A62                          4332            
00003A62  6000 012C               4333            BRA     GET_SRC_SUCCESS                   *RETURN
00003A66                          4334            
00003A66                          4335                      
00003A66                          4336            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003A66  0CB9 00000007 0000499C  4337  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003A70  6600 011A               4338            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003A74                          4339                   
00003A74                          4340            *NEXT: (MODE == 111) 
00003A74                          4341            *NOW: CHECK FOR SRC REGISTER 
00003A74                          4342                  *(000 = (xxx).W)
00003A74                          4343                  *(001 = (xxx).L)
00003A74                          4344                  *(010 = #<data>)
00003A74                          4345                  
00003A74                          4346            *FIND REGISTER NUMBER END LOCATION*  
00003A74  13F9 0000498E 00004994  4347            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A7E  0239 000F 00004994      4348            AND.B   #$0F,VAR_BYTE_END
00003A86                          4349            
00003A86                          4350            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A86  23C5 00004998           4351            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A8C  1439 00004994           4352            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A92                          4353            
00003A92                          4354            *INTITIALIZE FOR BIT SHIFTING
00003A92  41F9 00004998           4355            LEA     VAR_TEMP_CLEANCOPY,A0
00003A98  2C39 00004998           4356            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003A9E                          4357  SRC_LOOP_SHIFTING
00003A9E  0C02 0000               4358            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003AA2  6700 0008               4359            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003AA6  E24E                    4360            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003AA8  5302                    4361            SUB.B   #1,D2                     *DECREMENT COUNTER
00003AAA  60F2                    4362            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003AAC                          4363  SRC_MASKING_NEXT
00003AAC  CCBC 00000007           4364            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003AB2                          4365           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003AB2                          4366           
00003AB2                          4367  CHECK_WORD  
00003AB2  41F9 0000498C           4368            LEA     TEMP_REGISTER_FORMAT,A0
00003AB8  1439 0000498B           4369            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003ABE  1082                    4370            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AC0  0239 0020 0000498C      4371            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003AC8  0C39 0020 0000498C      4372            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003AD0  6700 0026               4373            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003AD4  0C06 0000               4374            CMPI.B  #0,D6                          
00003AD8  6600 001E               4375            BNE     CHECK_LONG 
00003ADC                          4376            
00003ADC                          4377            *IT IS A WORD AT THIS POINT*
00003ADC                          4378            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003ADC  163C 0020               4379            MOVE.B    #' ',D3
00003AE0  6100 051E               4380            BSR       PUSH_STACK
00003AE4  163C 0024               4381            MOVE.B    #'$',D3
00003AE8  6100 0516               4382            BSR       PUSH_STACK
00003AEC  321D                    4383            MOVE.W    (A5)+,D1
00003AEE  7404                    4384            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003AF0  6100 D778               4385            BSR       HEX2ASCII2STACK
00003AF4  6000 009A               4386            BRA     GET_SRC_SUCCESS
00003AF8                          4387  
00003AF8                          4388  CHECK_LONG
00003AF8  41F9 0000498C           4389            LEA     TEMP_REGISTER_FORMAT,A0
00003AFE  1439 0000498B           4390            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B04  1082                    4391            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B06  0239 0040 0000498C      4392            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003B0E  0C39 0040 0000498C      4393            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B16  6700 002E               4394            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003B1A  0C06 0001               4395            CMPI.B  #1,D6                          
00003B1E  6600 0026               4396            BNE     CHECK_IMMEDIATE  
00003B22                          4397  
00003B22                          4398            *IT IS A WORD AT THIS POINT*
00003B22                          4399            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B22  163C 0020               4400            MOVE.B    #' ',D3
00003B26  6100 04D8               4401            BSR       PUSH_STACK
00003B2A  163C 0024               4402            MOVE.B    #'$',D3
00003B2E  6100 04D0               4403            BSR       PUSH_STACK
00003B32  321D                    4404            MOVE.W    (A5)+,D1
00003B34  7404                    4405            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B36  6100 D732               4406            BSR       HEX2ASCII2STACK
00003B3A  321D                    4407            MOVE.W    (A5)+,D1
00003B3C  7404                    4408            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B3E  6100 D72A               4409            BSR       HEX2ASCII2STACK
00003B42  6000 004C               4410            BRA     GET_SRC_SUCCESS
00003B46                          4411            
00003B46                          4412  CHECK_IMMEDIATE
00003B46  41F9 0000498C           4413            LEA     TEMP_REGISTER_FORMAT,A0
00003B4C  1439 0000498B           4414            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B52  1082                    4415            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B54  0239 0080 0000498C      4416            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003B5C  0C39 0080 0000498C      4417            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B64  6700 0026               4418            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003B68  0C06 0004               4419            CMPI.B  #4,D6                          
00003B6C  6600 001E               4420            BNE     GET_SRC_FAILED 
00003B70                          4421  
00003B70                          4422            *IT IS A WORD AT THIS POINT*
00003B70                          4423            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B70  163C 0020               4424            MOVE.B    #' ',D3
00003B74  6100 048A               4425            BSR       PUSH_STACK
00003B78  163C 0023               4426            MOVE.B    #'#',D3
00003B7C  6100 0482               4427            BSR       PUSH_STACK
00003B80  321D                    4428            MOVE.W    (A5)+,D1
00003B82  7404                    4429            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B84  6100 D6E4               4430            BSR       HEX2ASCII2STACK
00003B88  6000 0006               4431            BRA     GET_SRC_SUCCESS
00003B8C                          4432            
00003B8C                          4433  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003B8C  7801                    4434            MOVE.L #1,D4
00003B8E  4E75                    4435            RTS
00003B90                          4436  GET_SRC_SUCCESS 
00003B90  4E75                    4437            RTS
00003B92                          4438                                 
00003B92                          4439      
00003B92                          4440  
00003B92                          4441  
00003B92                          4442  
00003B92                          4443  
00003B92                          4444  
00003B92                          4445  
00003B92                          4446  GET_EA_EA_DEST
00003B92                          4447  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003B92                          4448      
00003B92                          4449      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003B92  2405                    4450      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003B94  EC8A                    4451      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003B96  23C2 0000499C           4452      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003B9C  7407                    4453      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003B9E  C5B9 0000499C           4454      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003BA4                          4455                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003BA4                          4456      
00003BA4                          4457      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003BA4                          4458      *DESTINATION REGISTER FORMAT STANDARD         *
00003BA4                          4459      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003BA4                          4460      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003BA4                          4461      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003BA4                          4462      *0 - Dn                                       *
00003BA4                          4463      *1 - An                                       *
00003BA4                          4464      *2 - (An)                                     *
00003BA4                          4465      *3 - (An)+                                    *
00003BA4                          4466      *4 - -(An)                                    *
00003BA4                          4467      *5 - (XXX).W                                  *
00003BA4                          4468      *6 - (XXX).L                                  *
00003BA4                          4469      *7 - #<data>                                  *
00003BA4                          4470      ***********************************************
00003BA4                          4471      
00003BA4                          4472      *** Check if source ...  <ea> = Dn
00003BA4                          4473  DEST_CHECK0    
00003BA4  41F9 0000498C           4474            LEA     TEMP_REGISTER_FORMAT,A0
00003BAA  1439 0000498A           4475            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003BB0  1082                    4476            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003BB2  0239 0001 0000498C      4477            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003BBA  0C39 0001 0000498C      4478            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003BC2  6700 006A               4479            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003BC6  0CB9 00000000 0000499C  4480            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003BD0  6600 005C               4481            BNE     DEST_CHECK1
00003BD4                          4482            
00003BD4                          4483            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003BD4  163C 0020               4484            MOVE.B    #' ',D3
00003BD8  6100 0426               4485            BSR       PUSH_STACK
00003BDC  163C 0044               4486            MOVE.B    #'D',D3
00003BE0  6100 041E               4487            BSR       PUSH_STACK
00003BE4                          4488  
00003BE4                          4489            *FIND REGISTER NUMBER END LOCATION*  
00003BE4  13F9 0000498D 00004994  4490            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BEE  0239 000F 00004994      4491            AND.B   #$0F,VAR_BYTE_END
00003BF6                          4492            
00003BF6                          4493            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BF6  23C5 00004998           4494            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BFC  1439 00004994           4495            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C02                          4496            
00003C02                          4497            *INTITIALIZE FOR BIT SHIFTING
00003C02  41F9 00004998           4498            LEA     VAR_TEMP_CLEANCOPY,A0
00003C08  2639 00004998           4499            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C0E                          4500  DEST_LOOP_SHIFTING
00003C0E  0C02 0000               4501            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C12  6700 0008               4502            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C16  E24B                    4503            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C18  5302                    4504            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C1A  60F2                    4505            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003C1C                          4506  DEST_MASKING_NEXT
00003C1C  C6BC 00000007           4507            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C22  0603 0030               4508            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003C26  6100 03D8               4509            BSR     PUSH_STACK                *PUSH TO STACK
00003C2A                          4510            
00003C2A  6000 0394               4511            BRA     GET_DST_SUCCESS           *RETURN          
00003C2E                          4512            
00003C2E                          4513            
00003C2E                          4514            *** Check if source ...  <ea> = An
00003C2E                          4515  DEST_CHECK1    
00003C2E  41F9 0000498C           4516            LEA     TEMP_REGISTER_FORMAT,A0
00003C34  1439 0000498A           4517            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C3A  1082                    4518            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C3C  0239 0002 0000498C      4519            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003C44  0C39 0002 0000498C      4520            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003C4C  6700 006A               4521            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003C50  0CB9 00000001 0000499C  4522            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003C5A  6600 005C               4523            BNE     DEST_CHECK2
00003C5E                          4524            
00003C5E                          4525            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003C5E  163C 0020               4526            MOVE.B    #' ',D3
00003C62  6100 039C               4527            BSR       PUSH_STACK
00003C66  163C 0041               4528            MOVE.B    #'A',D3
00003C6A  6100 0394               4529            BSR       PUSH_STACK
00003C6E                          4530  
00003C6E                          4531            
00003C6E                          4532            *FIND REGISTER NUMBER END LOCATION*  
00003C6E  13F9 0000498D 00004994  4533            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C78  0239 000F 00004994      4534            AND.B   #$0F,VAR_BYTE_END
00003C80                          4535            
00003C80                          4536            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C80  23C5 00004998           4537            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C86  1439 00004994           4538            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003C8C                          4539            
00003C8C                          4540            *INTITIALIZE FOR BIT SHIFTING
00003C8C  41F9 00004998           4541            LEA     VAR_TEMP_CLEANCOPY,A0
00003C92  2639 00004998           4542            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C98                          4543  DEST_LOOP_SHIFTING1
00003C98  0C02 0000               4544            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C9C  6700 0008               4545            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003CA0  E24B                    4546            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003CA2  5302                    4547            SUB.B   #1,D2                     *DECREMENT COUNTER
00003CA4  60F2                    4548            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003CA6                          4549  DEST_MASKING_NEXT1
00003CA6  C6BC 00000007           4550            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003CAC  0603 0030               4551            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003CB0  6100 034E               4552            BSR     PUSH_STACK                *PUSH TO STACK
00003CB4                          4553            
00003CB4  6000 030A               4554            BRA     GET_DST_SUCCESS                   *RETURN 
00003CB8                          4555            
00003CB8                          4556            
00003CB8                          4557            
00003CB8                          4558            
00003CB8                          4559            *** Check if source ...  <ea> = (An)       
00003CB8                          4560  DEST_CHECK2    
00003CB8  41F9 0000498C           4561            LEA     TEMP_REGISTER_FORMAT,A0
00003CBE  1439 0000498A           4562            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CC4  1082                    4563            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CC6  0239 0004 0000498C      4564            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003CCE  0C39 0004 0000498C      4565            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CD6  6700 007A               4566            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CDA  0CB9 00000002 0000499C  4567            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003CE4  6600 006C               4568            BNE     DEST_CHECK3
00003CE8                          4569            
00003CE8                          4570            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CE8  163C 0020               4571            MOVE.B    #' ',D3
00003CEC  6100 0312               4572            BSR       PUSH_STACK
00003CF0  163C 0028               4573            MOVE.B    #'(',D3
00003CF4  6100 030A               4574            BSR       PUSH_STACK
00003CF8  163C 0041               4575            MOVE.B    #'A',D3
00003CFC  6100 0302               4576            BSR       PUSH_STACK
00003D00                          4577  
00003D00                          4578            
00003D00                          4579            *FIND REGISTER NUMBER END LOCATION*  
00003D00  13F9 0000498D 00004994  4580            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D0A  0239 000F 00004994      4581            AND.B   #$0F,VAR_BYTE_END
00003D12                          4582            
00003D12                          4583            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D12  23C5 00004998           4584            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D18  1439 00004994           4585            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D1E                          4586            
00003D1E                          4587            *INTITIALIZE FOR BIT SHIFTING
00003D1E  41F9 00004998           4588            LEA     VAR_TEMP_CLEANCOPY,A0
00003D24  2639 00004998           4589            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D2A                          4590  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003D2A  0C02 0000               4591            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D2E  6700 0008               4592            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D32  E24B                    4593            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D34  5302                    4594            SUB.B   #1,D2                     *DECREMENT COUNTER
00003D36  60F2                    4595            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003D38                          4596  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003D38  0283 00000007           4597            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D3E  0603 0030               4598            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D42  6100 02BC               4599            BSR     PUSH_STACK                *PUSH TO STACK
00003D46                          4600            
00003D46  163C 0029               4601            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D4A  6100 02B4               4602            BSR       PUSH_STACK
00003D4E                          4603            
00003D4E  6000 0270               4604            BRA     GET_DST_SUCCESS                   *RETURN 
00003D52                          4605  
00003D52                          4606            
00003D52                          4607            
00003D52                          4608                      
00003D52                          4609  *** Check if source ...  <ea> = (An)+       
00003D52  41F9 0000498C           4610  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003D58  1439 0000498A           4611            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D5E  1082                    4612            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D60  0239 0008 0000498C      4613            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003D68  0C39 0008 0000498C      4614            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D70  6700 0082               4615            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003D74  0CB9 00000003 0000499C  4616            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003D7E  6600 0074               4617            BNE     DEST_CHECK4
00003D82                          4618            
00003D82                          4619            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003D82  163C 0020               4620            MOVE.B    #' ',D3
00003D86  6100 0278               4621            BSR       PUSH_STACK
00003D8A  163C 0028               4622            MOVE.B    #'(',D3
00003D8E  6100 0270               4623            BSR       PUSH_STACK
00003D92  163C 0041               4624            MOVE.B    #'A',D3
00003D96  6100 0268               4625            BSR       PUSH_STACK
00003D9A                          4626  
00003D9A                          4627            
00003D9A                          4628            *FIND REGISTER NUMBER END LOCATION*  
00003D9A  13F9 0000498D 00004994  4629            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003DA4  0239 000F 00004994      4630            ANDI.B   #$0F,VAR_BYTE_END
00003DAC                          4631            
00003DAC                          4632            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003DAC  23C5 00004998           4633            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003DB2  1439 00004994           4634            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003DB8                          4635            
00003DB8                          4636            *INTITIALIZE FOR BIT SHIFTING
00003DB8  41F9 00004998           4637            LEA     VAR_TEMP_CLEANCOPY,A0
00003DBE  2639 00004998           4638            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003DC4                          4639            
00003DC4                          4640  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003DC4  0C02 0000               4641            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DC8  6700 0008               4642            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003DCC  E24B                    4643            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DCE  5302                    4644            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003DD0  60F2                    4645            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003DD2                          4646                                               *change: NAME OF LABEL*
00003DD2                          4647  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003DD2  0283 00000007           4648            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003DD8  0603 0030               4649            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003DDC  6100 0222               4650            BSR     PUSH_STACK                *PUSH TO STACK
00003DE0                          4651            
00003DE0  163C 0029               4652            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DE4  6100 021A               4653            BSR       PUSH_STACK
00003DE8  163C 002B               4654            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DEC  6100 0212               4655            BSR       PUSH_STACK
00003DF0                          4656            
00003DF0  6000 01CE               4657            BRA       GET_DST_SUCCESS                   *RETURN 
00003DF4                          4658  
00003DF4                          4659            
00003DF4                          4660            
00003DF4                          4661                      
00003DF4                          4662            *** Check if source ...  <ea> = -(An)       
00003DF4                          4663  DEST_CHECK4    
00003DF4  41F9 0000498C           4664            LEA     TEMP_REGISTER_FORMAT,A0
00003DFA  1439 0000498A           4665            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E00  1082                    4666            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E02  0239 0010 0000498C      4667            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003E0A  0C39 0010 0000498C      4668            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E12  6700 0082               4669            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003E16  0CB9 00000004 0000499C  4670            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003E20  6600 0074               4671            BNE     DEST_CHECK7
00003E24                          4672            
00003E24                          4673            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003E24  163C 0020               4674            MOVE.B    #' ',D3
00003E28  6100 01D6               4675            BSR       PUSH_STACK
00003E2C  163C 002D               4676            MOVE.B    #'-',D3
00003E30  6100 01CE               4677            BSR       PUSH_STACK
00003E34  163C 0028               4678            MOVE.B    #'(',D3
00003E38  6100 01C6               4679            BSR       PUSH_STACK
00003E3C  163C 0041               4680            MOVE.B    #'A',D3
00003E40  6100 01BE               4681            BSR       PUSH_STACK
00003E44                          4682  
00003E44                          4683            
00003E44                          4684            *FIND REGISTER NUMBER END LOCATION*  
00003E44  13F9 0000498D 00004994  4685            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E4E  0239 000F 00004994      4686            AND.B   #$0F,VAR_BYTE_END
00003E56                          4687            
00003E56                          4688            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E56  23C5 00004998           4689            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E5C  1439 00004994           4690            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003E62                          4691            
00003E62                          4692            *INTITIALIZE FOR BIT SHIFTING
00003E62  41F9 00004998           4693            LEA     VAR_TEMP_CLEANCOPY,A0
00003E68  2639 00004998           4694            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003E6E                          4695            
00003E6E                          4696  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003E6E  0C02 0000               4697            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E72  6700 0008               4698            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003E76  E24B                    4699            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E78  5302                    4700            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003E7A  60F2                    4701            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003E7C                          4702                                               *change: NAME OF LABEL*
00003E7C                          4703  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003E7C  0283 00000007           4704            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003E82  0603 0030               4705            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003E86  6100 0178               4706            BSR     PUSH_STACK                *PUSH TO STACK
00003E8A                          4707            
00003E8A  163C 0029               4708            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003E8E  6100 0170               4709            BSR       PUSH_STACK
00003E92                          4710            
00003E92  6000 012C               4711            BRA     GET_DST_SUCCESS                   *RETURN
00003E96                          4712            
00003E96                          4713                      
00003E96                          4714            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003E96                          4715  DEST_CHECK7    
00003E96  0CB9 00000007 0000499C  4716            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003EA0  6600 011A               4717            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003EA4                          4718                   
00003EA4                          4719            *NEXT: (MODE == 111) 
00003EA4                          4720            *NOW: CHECK FOR SRC REGISTER 
00003EA4                          4721                  *(000 = (xxx).W)
00003EA4                          4722                  *(001 = (xxx).L)
00003EA4                          4723                  *(010 = #<data>)
00003EA4                          4724                  
00003EA4                          4725            *FIND REGISTER NUMBER END LOCATION*  
00003EA4  13F9 0000498D 00004994  4726            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003EAE  0239 000F 00004994      4727            AND.B   #$0F,VAR_BYTE_END
00003EB6                          4728            
00003EB6                          4729            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003EB6  23C5 00004998           4730            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003EBC  1439 00004994           4731            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003EC2                          4732            
00003EC2                          4733            *INTITIALIZE FOR BIT SHIFTING
00003EC2  41F9 00004998           4734            LEA     VAR_TEMP_CLEANCOPY,A0
00003EC8  2C39 00004998           4735            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003ECE                          4736  DEST_LOOP_SHIFTING7
00003ECE  0C02 0000               4737            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003ED2  6700 0008               4738            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003ED6  E24E                    4739            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003ED8  5302                    4740            SUB.B   #1,D2                     *DECREMENT COUNTER
00003EDA  60F2                    4741            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003EDC                          4742  DEST_MASKING_NEXT7
00003EDC  CCBC 00000007           4743            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003EE2                          4744           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003EE2                          4745            
00003EE2                          4746  DEST_CHECK_WORD  
00003EE2  41F9 0000498C           4747            LEA     TEMP_REGISTER_FORMAT,A0
00003EE8  1439 0000498A           4748            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EEE  1082                    4749            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EF0  0239 0020 0000498C      4750            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003EF8  0C39 0020 0000498C      4751            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F00  6700 0026               4752            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F04  0C06 0000               4753            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003F08  6600 001E               4754            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003F0C                          4755            *IT IS A WORD AT THIS POINT*
00003F0C                          4756            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F0C  163C 0020               4757            MOVE.B    #' ',D3
00003F10  6100 00EE               4758            BSR       PUSH_STACK
00003F14  163C 0024               4759            MOVE.B    #'$',D3
00003F18  6100 00E6               4760            BSR       PUSH_STACK
00003F1C  321D                    4761            MOVE.W    (A5)+,D1
00003F1E  7404                    4762            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003F20  6100 D348               4763            BSR       HEX2ASCII2STACK
00003F24  6000 009A               4764            BRA       GET_DST_SUCCESS
00003F28                          4765  
00003F28                          4766  DEST_CHECK_LONG
00003F28  41F9 0000498C           4767            LEA     TEMP_REGISTER_FORMAT,A0
00003F2E  1439 0000498A           4768            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F34  1082                    4769            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F36  0239 0040 0000498C      4770            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F3E  0C39 0040 0000498C      4771            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F46  6700 002E               4772            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F4A  0C06 0001               4773            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003F4E  6600 0026               4774            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003F52                          4775            *IT IS A WORD AT THIS POINT*
00003F52                          4776            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F52  163C 0020               4777            MOVE.B    #' ',D3
00003F56  6100 00A8               4778            BSR       PUSH_STACK
00003F5A  163C 0024               4779            MOVE.B    #'$',D3
00003F5E  6100 00A0               4780            BSR       PUSH_STACK
00003F62  321D                    4781            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F64  7404                    4782            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003F66  6100 D302               4783            BSR       HEX2ASCII2STACK
00003F6A  321D                    4784            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F6C  7404                    4785            MOVE.L    #4,D2          
00003F6E  6100 D2FA               4786            BSR       HEX2ASCII2STACK
00003F72  6000 004C               4787            BRA     GET_DST_SUCCESS
00003F76                          4788            
00003F76                          4789  DEST_CHECK_IMMEDIATE
00003F76  41F9 0000498C           4790            LEA     TEMP_REGISTER_FORMAT,A0
00003F7C  1439 0000498A           4791            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F82  1082                    4792            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F84  0239 0080 0000498C      4793            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F8C  0C39 0080 0000498C      4794            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F94  6700 0026               4795            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F98  0C06 0004               4796            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003F9C  6600 001E               4797            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003FA0                          4798            
00003FA0                          4799            *IT IS A WORD AT THIS POINT*
00003FA0                          4800            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003FA0  163C 0020               4801            MOVE.B    #' ',D3
00003FA4  6100 005A               4802            BSR       PUSH_STACK
00003FA8  163C 0023               4803            MOVE.B    #'#',D3
00003FAC  6100 0052               4804            BSR       PUSH_STACK
00003FB0  321D                    4805            MOVE.W    (A5)+,D1
00003FB2  7404                    4806            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003FB4  6100 D2B4               4807            BSR       HEX2ASCII2STACK
00003FB8  6000 0006               4808            BRA       GET_DST_SUCCESS
00003FBC                          4809            
00003FBC                          4810  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003FBC  7801                    4811            MOVE.L #1,D4
00003FBE  4E75                    4812            RTS
00003FC0                          4813  GET_DST_SUCCESS 
00003FC0  4E75                    4814            RTS
00003FC2                          4815  
00003FC2                          4816  
00003FC2                          4817  *---------------------------------------------------------------------------*
00003FC2                          4818  * STACK/QUEUE INTERFACE
00003FC2                          4819  *---------------------------------------------------------------------------*
00003FC2                          4820  PRINT_STACK
00003FC2  0C39 0000 00004986      4821            CMP.B     #0,COUNTER
00003FCA  6700 000E               4822            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003FCE                          4823            
00003FCE                          4824  PRINT_STACK_HELPER
00003FCE  6100 0038               4825            BSR      POP_STACK          *PRINTS ADDRESS
00003FD2  103C 0006               4826            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FD6  4E4F                    4827            TRAP     #15             *ACTIVATES PRINT
00003FD8                          4828  
00003FD8  60E8                    4829            BRA       PRINT_STACK
00003FDA                          4830  PRINT_STACK_RETURN
00003FDA  4E75                    4831            RTS
00003FDC                          4832            
00003FDC                          4833            
00003FDC                          4834  PRINT_QUEUE
00003FDC  0C39 0000 00004986      4835            CMP.B     #0,COUNTER
00003FE4  6700 0018               4836            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003FE8                          4837            
00003FE8                          4838  PRINT_QUEUE_HELPER
00003FE8  33F9 00004986 00004988  4839            MOVE.W   COUNTER,QUEUE_COUNTER
00003FF2  6100 0022               4840            BSR      POP_FRONT          *PRINTS ADDRESS
00003FF6  103C 0006               4841            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FFA  4E4F                    4842            TRAP     #15             *ACTIVATES PRINT
00003FFC                          4843  
00003FFC  60DE                    4844            BRA       PRINT_QUEUE
00003FFE                          4845  PRINT_QUEUE_RETURN
00003FFE  4E75                    4846            RTS
00004000                          4847            
00004000                          4848  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00004000                          4849  PUSH_STACK
00004000  1503                    4850              MOVE.B  D3,-(A2)
00004002  6100 0058               4851              BSR     INCREMENT
00004006  4E75                    4852              RTS
00004008                          4853  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00004008                          4854  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00004008                          4855  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00004008                          4856  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00004008                          4857  *         TRAP        #15             *ACTIVATES PRINT
00004008                          4858  POP_STACK
00004008  BECA                    4859              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
0000400A  6700 0008               4860              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
0000400E  121A                    4861              MOVE.B  (A2)+,D1 
00004010  6100 0052               4862              BSR     DECREMENT
00004014                          4863  POP_RETURN
00004014  4E75                    4864              RTS 
00004016                          4865        
00004016                          4866  *USE [A4] AS SECOND POINTER IN SHIFTING      
00004016  0C39 0000 00004988      4867  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000401E  6700 0030               4868              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00004022                          4869              
00004022                          4870              
00004022                          4871              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00004022  347C 7000               4872              MOVEA.W #STACK,A2   *START A2 AT STACK
00004026  0622 0000               4873              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
0000402A  384A                    4874              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
0000402C  0624 0000               4875              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00004030  1212                    4876              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00004032                          4877  POP_SHIFT_LOOP
00004032  0C39 0000 00004988      4878              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000403A  6700 0014               4879              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000403E  1494                    4880              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00004040  0624 0000               4881              ADD.B   #0,-(A4)
00004044  0622 0000               4882              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00004048  5339 00004988           4883              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
0000404E                          4884              
0000404E  60E2                    4885              BRA     POP_SHIFT_LOOP
00004050                          4886                          
00004050                          4887  POP_FRONT_RETURN 
00004050                          4888              *RESET A2 BACK TO SP
00004050  347C 7000               4889              MOVEA.W #STACK,A2    
00004054  5339 00004986           4890              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
0000405A  4E75                    4891              RTS   
0000405C                          4892  
0000405C                          4893  INCREMENT
0000405C  5239 00004986           4894              ADD.B   #1, COUNTER
00004062  4E75                    4895              RTS           
00004064                          4896  DECREMENT
00004064  5339 00004986           4897              SUB.B   #1, COUNTER
0000406A  4E75                    4898              RTS           
0000406C                          4899  CLEAR_STACK
0000406C  0C39 0000 00004986      4900              CMP.B     #0,COUNTER
00004074  6700 0006               4901              BEQ       CLEAR_RETURN
00004078  618E                    4902              BSR       POP_STACK
0000407A  60F0                    4903              BRA       CLEAR_STACK
0000407C                          4904   
0000407C                          4905  CLEAR_RETURN
0000407C  4E75                    4906              RTS    
0000407E                          4907              
0000407E                          4908  *---------------------------------------------------------------------------*
0000407E                          4909  * 8/16/32-bit Address getter
0000407E                          4910  *---------------------------------------------------------------------------*
0000407E                          4911  *get displacement value from bits 0 to 8
0000407E                          4912  *if displacement is not $00, than it is 8 otherwise check for word
0000407E                          4913  *if displacement is not $FF, than it is a long
0000407E                          4914  *add the displacement to the current address being processed + a word
0000407E                          4915  *place results into D3, so that it can be pushed to stack
0000407E                          4916  GET_DISPLACEMENT_ADDRESS
0000407E  2805                    4917              MOVE.L  D5,D4                   * COPIES DATA INTO D6
00004080  0286 000000FF           4918              ANDI.L  #$00FF,D6               * MASKS DATA
00004086  0C84 00000000           4919              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
0000408C  6700 0022               4920              BEQ     GET_DISPLACEMENT_WORD
00004090  0C84 000000FF           4921              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00004096  6700 0030               4922              BEQ     GET_DISPLACEMENT_LONG
0000409A                          4923              
0000409A  2E3C 00000100           4924              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000040A0  9E04                    4925              SUB.B   D4,D7
000040A2                          4926              
000040A2  280D                    4927              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040A4  9807                    4928              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040A6  7404                    4929              MOVE.L  #4,D2
000040A8  2204                    4930              MOVE.L  D4,D1  
000040AA  6100 D1BE               4931              BSR     HEX2ASCII2STACK
000040AE  4E75                    4932              RTS
000040B0                          4933              
000040B0                          4934  GET_DISPLACEMENT_WORD
000040B0  2E3C 000000FF           4935              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000040B6  9E04                    4936              SUB.B   D4,D7
000040B8                          4937              
000040B8  280D                    4938              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040BA  9807                    4939              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040BC  7404                    4940              MOVE.L  #4,D2
000040BE  2604                    4941              MOVE.L  D4,D3
000040C0  2204                    4942              MOVE.L  D4,D1
000040C2  6100 D1A6               4943              BSR     HEX2ASCII2STACK
000040C6  4E75                    4944              RTS     
000040C8                          4945  GET_DISPLACEMENT_LONG   
000040C8  2E3C 000000FF           4946              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000040CE  9E04                    4947              SUB.B   D4,D7
000040D0                          4948              
000040D0  280D                    4949              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040D2  9807                    4950              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040D4  7408                    4951              MOVE.L  #8,D2
000040D6  2604                    4952              MOVE.L  D4,D3                   * PREPARE TO PUSH
000040D8  2204                    4953              MOVE.L  D4,D1
000040DA  6100 D18E               4954              BSR     HEX2ASCII2STACK
000040DE                          4955  
000040DE  4284                    4956              CLR.L   D4
000040E0  4E75                    4957              RTS
000040E2                          4958  
000040E2                          4959  *---------------------------------------------------------------------------*
000040E2                          4960  * TERMINATE
000040E2                          4961  *---------------------------------------------------------------------------*
000040E2                          4962  TERMINATE   
000040E2  43F9 00004492           4963              LEA     FINMSG,A1
000040E8  103C 000E               4964              MOVE.B  #14,D0
000040EC  4E4F                    4965              TRAP    #15
000040EE                          4966  
000040EE  103C 0009               4967              MOVE.B  #9,D0
000040F2  4E4F                    4968              TRAP    #15
000040F4                          4969  
000040F4                          4970  *---------------------------------------------------------------------------*
000040F4                          4971  * Data storage                                                 
000040F4                          4972  *---------------------------------------------------------------------------*  
000040F4                          4973  WELCOME
000040F4= 20 20 20 20 20 20 ...   4974              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00004144= 3D 3D 3D 3D 3D 20 ...   4975              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004194= 3D 3D 3D 3D 3D 20 ...   4976              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000041E4                          4977      
000041E4= 20 20 20 20 20 20 ...   4978              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00004234= 20 20 20 20 20 20 ...   4979              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004284= 20 20 20 20 20 20 ...   4980              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000042D4                          4981      
000042D4= 20 20 20 20 20 20 ...   4982              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00004324= 3D 3D 3D 3D 3D 20 ...   4983              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00004374= 3D 3D 3D 3D 3D 20 ...   4984              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
000043C9                          4985  
000043C9                          4986  PROMPT_START
000043C9= 50 6C 65 61 73 65 ...   4987              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000043F8                          4988      
000043F8                          4989  PROMPT_END
000043F8= 50 6C 65 61 73 65 ...   4990              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00004425= 0D 0A 48 69 74 20 ...   4991  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
0000444F= 57 6F 75 6C 64 20 ...   4992  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004492= 54 68 61 6E 6B 20 ...   4993  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
000044BD= 45 72 72 6F 72 3A ...   4994  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000044DC= 45 72 72 6F 72 3A ...   4995  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00004501= 45 72 72 6F 72 3A ...   4996  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
0000452E                          4997  
0000452E                          4998  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
0000457E                          4999  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
000045CE                          5000  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000045D2                          5001  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000045D6= 0D 0A 00                5002  ENDLINE_M   DC.B    CR,LF,0
000045D9                          5003  TMPINPUT    DS.B    80                      * temp store user input
00004629                          5004  TMPOUTPUT   DS.B    80                      * temp store prog output
00004679= 20 20 20 4F 52 49 ...   5005  DISP_ORI_B  DC.B    '   ORI.B',0
00004682= 20 20 20 4F 52 49 ...   5006  DISP_ORI_W  DC.B    '   ORI.W',0
0000468B= 20 20 20 4F 52 49 ...   5007  DISP_ORI_L  DC.B    '   ORI.L',0
00004694= 20 20 20 45 4F 52 ...   5008  DISP_EORI_B  DC.B    '   EORI.B',0
0000469E= 20 20 20 45 4F 52 ...   5009  DISP_EORI_W  DC.B    '   EORI.W',0
000046A8= 20 20 20 45 4F 52 ...   5010  DISP_EORI_L  DC.B    '   EORI.L',0
000046B2= 20 20 20 42 54 53 ...   5011  DISP_BTST   DC.B    '   BTST',0
000046BA= 20 20 20 43 4D 50 ...   5012  DISP_CMPI_B  DC.B    '   CMPI.B',0
000046C4= 20 20 20 43 4D 50 ...   5013  DISP_CMPI_W  DC.B    '   CMPI.W',0
000046CE= 20 20 20 43 4D 50 ...   5014  DISP_CMPI_L  DC.B    '   CMPI.L',0
000046D8= 20 20 20 44 41 54 ...   5015  DISP_DATA   DC.B    '   DATA',0
000046E0= 20 20 20 4D 4F 56 ...   5016  DISP_MOVE_B DC.B    '   MOVE.B',0
000046EA= 20 20 20 4D 4F 56 ...   5017  DISP_MOVE_W DC.B    '   MOVE.W',0
000046F4= 20 20 20 4D 4F 56 ...   5018  DISP_MOVE_L DC.B    '   MOVE.L',0
000046FE= 20 20 20 52 54 53 00    5019  DISP_RTS    DC.B    '   RTS',0
00004705= 20 20 20 4A 53 52 00    5020  DISP_JSR    DC.B    '   JSR',0
0000470C= 20 20 20 4E 45 47 ...   5021  DISP_NEG_B    DC.B    '   NEG.B',0
00004715= 20 20 20 4E 45 47 ...   5022  DISP_NEG_W    DC.B    '   NEG.W',0
0000471E= 20 20 20 4E 45 47 ...   5023  DISP_NEG_L    DC.B    '   NEG.L',0
00004727= 20 20 20 4E 4F 54 ...   5024  DISP_NOT_B  DC.B    '   NOT.B',0
00004730= 20 20 20 4E 4F 54 ...   5025  DISP_NOT_W  DC.B    '   NOT.W',0
00004739= 20 20 20 4E 4F 54 ...   5026  DISP_NOT_L  DC.B    '   NOT.L',0
00004742= 20 20 20 4C 45 41 00    5027  DISP_LEA    DC.B    '   LEA',0
00004749= 20 20 20 4D 4F 56 ...   5028  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004754= 20 20 20 4D 4F 56 ...   5029  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
0000475F= 20 20 20 41 44 44 ...   5030  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00004769= 20 20 20 41 44 44 ...   5031  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00004773= 20 20 20 41 44 44 ...   5032  DISP_ADDQ_L DC.B    '   ADDQ.L',0
0000477D= 20 20 20 44 49 56 ...   5033  DISP_DIVS   DC.B    '   DIVS',0
00004785= 20 20 20 53 55 42 ...   5034  DISP_SUB_B  DC.B    '   SUB.B',0
0000478E= 20 20 20 53 55 42 ...   5035  DISP_SUB_W  DC.B    '   SUB.W',0
00004797= 20 20 20 53 55 42 ...   5036  DISP_SUB_L  DC.B    '   SUB.L',0
000047A0= 20 20 20 53 55 42 ...   5037  DISP_SUBI_B  DC.B    '   SUBI.B',0
000047AA= 20 20 20 53 55 42 ...   5038  DISP_SUBI_W  DC.B    '   SUBI.W',0
000047B4= 20 20 20 53 55 42 ...   5039  DISP_SUBI_L  DC.B    '   SUBI.L',0
000047BE= 20 20 20 53 55 42 ...   5040  DISP_SUBA_W  DC.B    '   SUBA.W',0
000047C8= 20 20 20 53 55 42 ...   5041  DISP_SUBA_L  DC.B    '   SUBA.L',0
000047D2= 20 20 20 45 4F 52 ...   5042  DISP_EOR_B  DC.B    '   EOR.B',0
000047DB= 20 20 20 45 4F 52 ...   5043  DISP_EOR_W  DC.B    '   EOR.W',0
000047E4= 20 20 20 45 4F 52 ...   5044  DISP_EOR_L  DC.B    '   EOR.L',0
000047ED= 20 20 20 43 4D 50 ...   5045  DISP_CMP_B  DC.B    '   CMP.B',0
000047F6= 20 20 20 43 4D 50 ...   5046  DISP_CMP_W  DC.B    '   CMP.W',0
000047FF= 20 20 20 43 4D 50 ...   5047  DISP_CMP_L  DC.B    '   CMP.L',0
00004808= 20 20 20 43 4D 50 ...   5048  DISP_CMPA_W  DC.B    '   CMPA.W',0
00004812= 20 20 20 43 4D 50 ...   5049  DISP_CMPA_L  DC.B    '   CMPA.L',0
0000481C= 20 20 20 4D 55 4C ...   5050  DISP_MULS_W DC.B    '   MULS.W',0
00004826= 20 20 20 41 4E 44 ...   5051  DISP_AND_B  DC.B    '   AND.B',0
0000482F= 20 20 20 41 4E 44 ...   5052  DISP_AND_W  DC.B    '   AND.W',0
00004838= 20 20 20 41 4E 44 ...   5053  DISP_AND_L  DC.B    '   AND.L',0
00004841= 20 20 20 41 44 44 ...   5054  DISP_ADD_B  DC.B    '   ADD.B',0
0000484A= 20 20 20 41 44 44 ...   5055  DISP_ADD_W  DC.B    '   ADD.W',0
00004853= 20 20 20 41 44 44 ...   5056  DISP_ADD_L  DC.B    '   ADD.L',0
0000485C= 20 20 20 41 44 44 ...   5057  DISP_ADDA_W DC.B    '   ADDA.W',0
00004866= 20 20 20 41 44 44 ...   5058  DISP_ADDA_L DC.B    '   ADDA.L',0
00004870= 20 20 20 4C 53 52 ...   5059  DISP_LSR_B  DC.B    '   LSR.B',0
00004879= 20 20 20 4C 53 4C ...   5060  DISP_LSL_B  DC.B    '   LSL.B',0
00004882= 20 20 20 4C 53 52 ...   5061  DISP_LSR_W  DC.B    '   LSR.W',0
0000488B= 20 20 20 4C 53 4C ...   5062  DISP_LSL_W  DC.B    '   LSL.W',0
00004894= 20 20 20 4C 53 52 ...   5063  DISP_LSR_L  DC.B    '   LSR.L',0
0000489D= 20 20 20 4C 53 4C ...   5064  DISP_LSL_L  DC.B    '   LSL.L',0
000048A6= 20 20 20 41 53 52 ...   5065  DISP_ASR_B  DC.B    '   ASR.B',0
000048AF= 20 20 20 41 53 4C ...   5066  DISP_ASL_B  DC.B    '   ASL.B',0
000048B8= 20 20 20 41 53 52 ...   5067  DISP_ASR_W  DC.B    '   ASR.W',0
000048C1= 20 20 20 41 53 4C ...   5068  DISP_ASL_W  DC.B    '   ASL.W',0
000048CA= 20 20 20 41 53 52 ...   5069  DISP_ASR_L  DC.B    '   ASR.L',0
000048D3= 20 20 20 41 53 4C ...   5070  DISP_ASL_L  DC.B    '   ASL.L',0
000048DC= 20 20 20 52 4F 52 ...   5071  DISP_ROR_B  DC.B    '   ROR.B',0
000048E5= 20 20 20 52 4F 4C ...   5072  DISP_ROL_B  DC.B    '   ROL.B',0
000048EE= 20 20 20 52 4F 52 ...   5073  DISP_ROR_W  DC.B    '   ROR.W',0
000048F7= 20 20 20 52 4F 4C ...   5074  DISP_ROL_W  DC.B    '   ROL.W',0
00004900= 20 20 20 52 4F 52 ...   5075  DISP_ROR_L  DC.B    '   ROR.L',0
00004909= 20 20 20 52 4F 4C ...   5076  DISP_ROL_L  DC.B    '   ROL.L',0
00004912= 20 20 20 42 52 41 00    5077  DISP_BRA    DC.B    '   BRA',0
00004919= 20 20 20 42 4C 54 00    5078  DISP_BLT    DC.B    '   BLT',0
00004920= 20 20 20 42 45 51 00    5079  DISP_BEQ    DC.B    '   BEQ',0
00004927= 20 20 20 42 4E 45 00    5080  DISP_BNE    DC.B    '   BNE',0
0000492E= 20 20 20 42 48 49 00    5081  DISP_BHI    DC.B    '   BHI',0
00004935= 20 20 20 4D 4F 56 ...   5082  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004940= 20 20 20 4D 4F 56 ...   5083  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
0000494B                          5084  
0000494B= 20 20 20 24 00          5085  DISP_HEX     DC.B    '   $',0
00004950= 20 20 20 44 00          5086  DISP_D  DC.B    '   D',0
00004955= 20 20 20 41 00          5087  DISP_A  DC.B    '   A',0
0000495A= 20 20 20 28 00          5088  DISP_OP  DC.B    '   (',0
0000495F= 29 00                   5089  DISP_CP  DC.B   ')',0
00004961= 20 20 20 28 41 00       5090  DISP_AOP  DC.B    '   (A',0
00004967                          5091  
00004967= 20 20 20 2D 28 41 00    5092  DISP_PRE    DC.B    '   -(A',0
0000496E= 29 2B 00                5093  DISP_POST   DC.B    ')+',0
00004971= 20 20 20 23 00          5094  DISP_LB DC.B    '   #',0
00004976= 30 00                   5095  DISP_0  DC.B    '0',0
00004978= 31 00                   5096  DISP_1  DC.B    '1',0
0000497A= 32 00                   5097  DISP_2  DC.B    '2',0
0000497C= 33 00                   5098  DISP_3  DC.B    '3',0
0000497E= 34 00                   5099  DISP_4  DC.B    '4',0
00004980= 35 00                   5100  DISP_5  DC.B    '5',0
00004982= 36 00                   5101  DISP_6  DC.B    '6',0
00004984= 37 00                   5102  DISP_7  DC.B    '7',0
00004986                          5103  
00004986                          5104  *STACK INTERFACE VARIABLES*
00004986                          5105  COUNTER         DS.W    1
00004988                          5106  QUEUE_COUNTER   DS.W    1
0000498A                          5107  
0000498A                          5108  *EA DECODING INTERFACE VARIABLES* 
0000498A                          5109  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
0000498B                          5110  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
0000498C                          5111  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
0000498D                          5112  
0000498D                          5113  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
0000498D                          5114  * WORD + WORD = LONG
0000498D                          5115  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
0000498D                          5116  * A              + F            = AF         <= EXAMPLE
0000498D                          5117  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
0000498D                          5118  GET_DST_START_END    DS.B    1
0000498E                          5119  GET_SRC_START_END    DS.B    1
0000498F                          5120  
0000498F                          5121  *STORES THE START + END BITS HERE (FROM ABOVE)
00004990                          5122  VAR_BYTE_START      DS.L    1
00004994                          5123  VAR_BYTE_END        DS.L    1
00004998                          5124  VAR_TEMP_CLEANCOPY  DS.L    1
0000499C                          5125  
0000499C                          5126  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
000049A0                          5127  
000049A0                          5128  *MORE FOR STACK USAGE*
000049A0= 2C 00                   5129  DISP_COMMA  DC.B    ',',0
000049A2= 20 20 20 00             5130  DISP_INDENT  DC.B    '   ',0
000049A6                          5131  
000049A6                          5132  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
000049A6                          5133  POINTER_WORD    DS.W       1
000049A8                          5134  
000049A8                          5135  
000049A8                          5136  
000049A8                          5137  *---------------------------------------------------------------------------*
000049A8                          5138  * Ends program
000049A8                          5139  *---------------------------------------------------------------------------*
000049A8                          5140              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            115E
ASC2HXLP2STACK      11C6
ASCII2HEX           1158
ASCII2HEX2STACK     11C0
ASC_ERR             11BA
ASC_ERR2STACK       1222
ASC_LOW             119C
ASC_LOW2STACK       1204
ASC_NUM             11AC
ASC_NUM2STACK       1214
ASC_SFT             11B4
ASC_SFT2STACK       121C
ASC_UPP             11A4
ASC_UPP2STACK       120C
CHECK0              3774
CHECK1              37FE
CHECK2              3888
CHECK3              3922
CHECK4              39C4
CHECK7              3A66
CHECK_IMMEDIATE     3B46
CHECK_LONG          3AF8
CHECK_WORD          3AB2
CLEAR_RETURN        407C
CLEAR_STACK         406C
COUNTER             4986
CR                  D
DECREMENT           4064
DEST_CHECK0         3BA4
DEST_CHECK1         3C2E
DEST_CHECK2         3CB8
DEST_CHECK3         3D52
DEST_CHECK4         3DF4
DEST_CHECK7         3E96
DEST_CHECK_IMMEDIATE  3F76
DEST_CHECK_LONG     3F28
DEST_CHECK_WORD     3EE2
DEST_LOOP_SHIFTING  3C0E
DEST_LOOP_SHIFTING1  3C98
DEST_LOOP_SHIFTING2  3D2A
DEST_LOOP_SHIFTING3  3DC4
DEST_LOOP_SHIFTING4  3E6E
DEST_LOOP_SHIFTING7  3ECE
DEST_MASKING_NEXT   3C1C
DEST_MASKING_NEXT1  3CA6
DEST_MASKING_NEXT2  3D38
DEST_MASKING_NEXT3  3DD2
DEST_MASKING_NEXT4  3E7C
DEST_MASKING_NEXT7  3EDC
DEST_MODE           332C
DEST_REGISTER       35FC
DEST_REGISTER_FORMAT  498A
DISPLAY_30_LINES    136E
DISP_0              4976
DISP_1              4978
DISP_2              497A
DISP_3              497C
DISP_4              497E
DISP_5              4980
DISP_6              4982
DISP_7              4984
DISP_A              4955
DISP_ADDA_L         4866
DISP_ADDA_W         485C
DISP_ADDQ_B         475F
DISP_ADDQ_L         4773
DISP_ADDQ_W         4769
DISP_ADD_B          4841
DISP_ADD_L          4853
DISP_ADD_W          484A
DISP_AND_B          4826
DISP_AND_L          4838
DISP_AND_W          482F
DISP_AOP            4961
DISP_ASL_B          48AF
DISP_ASL_L          48D3
DISP_ASL_W          48C1
DISP_ASR_B          48A6
DISP_ASR_L          48CA
DISP_ASR_W          48B8
DISP_BEQ            4920
DISP_BHI            492E
DISP_BLT            4919
DISP_BNE            4927
DISP_BRA            4912
DISP_BTST           46B2
DISP_CMPA_L         4812
DISP_CMPA_W         4808
DISP_CMPI_B         46BA
DISP_CMPI_L         46CE
DISP_CMPI_W         46C4
DISP_CMP_B          47ED
DISP_CMP_L          47FF
DISP_CMP_W          47F6
DISP_COMMA          49A0
DISP_CP             495F
DISP_D              4950
DISP_DATA           46D8
DISP_DIVS           477D
DISP_EORI_B         4694
DISP_EORI_L         46A8
DISP_EORI_W         469E
DISP_EOR_B          47D2
DISP_EOR_L          47E4
DISP_EOR_W          47DB
DISP_HEX            494B
DISP_INDENT         49A2
DISP_JSR            4705
DISP_LB             4971
DISP_LEA            4742
DISP_LSL_B          4879
DISP_LSL_L          489D
DISP_LSL_W          488B
DISP_LSR_B          4870
DISP_LSR_L          4894
DISP_LSR_W          4882
DISP_MOVEA_L        4940
DISP_MOVEA_W        4935
DISP_MOVEM_L        4754
DISP_MOVEM_W        4749
DISP_MOVE_B         46E0
DISP_MOVE_L         46F4
DISP_MOVE_W         46EA
DISP_MULS_W         481C
DISP_NEG_B          470C
DISP_NEG_L          471E
DISP_NEG_W          4715
DISP_NEXT           4425
DISP_NOT_B          4727
DISP_NOT_L          4739
DISP_NOT_W          4730
DISP_OP             495A
DISP_ORI_B          4679
DISP_ORI_L          468B
DISP_ORI_W          4682
DISP_POST           496E
DISP_PRE            4967
DISP_ROL_B          48E5
DISP_ROL_L          4909
DISP_ROL_W          48F7
DISP_ROR_B          48DC
DISP_ROR_L          4900
DISP_ROR_W          48EE
DISP_RTS            46FE
DISP_SUBA_L         47C8
DISP_SUBA_W         47BE
DISP_SUBI_B         47A0
DISP_SUBI_L         47B4
DISP_SUBI_W         47AA
DISP_SUB_B          4785
DISP_SUB_L          4797
DISP_SUB_W          478E
D_MODE000           33CE
D_MODE010           3416
D_MODE011           3476
D_MODE100           3496
D_MODE111           34E8
EA_ARITH            32C6
EA_DATA             177E
EA_GEN              3312
EA_MOVEA            32EC
EA_NOSRC            32B2
ENDLINE_M           45D6
END_ADDR            10A4
ERRMSG_1            44BD
ERRMSG_3            44DC
ERRMSG_5            4501
ERROR_1             1108
ERROR_2             1118
ERROR_3             1128
ERROR_4             1138
ERROR_5             1148
E_ADDR_HX           45D2
FINMSG              4492
GET_DISPLACEMENT_ADDRESS  407E
GET_DISPLACEMENT_LONG  40C8
GET_DISPLACEMENT_WORD  40B0
GET_DST_FAILED      3FBC
GET_DST_START_END   498D
GET_DST_SUCCESS     3FC0
GET_EA_EA_DEST      3B92
GET_EA_EA_SRC       3762
GET_SRC_FAILED      3B8C
GET_SRC_START_END   498E
GET_SRC_SUCCESS     3B90
HEX2ASCII           1228
HEX2ASCII2STACK     126A
HEX_CHAR            1256
HEX_CONT            125A
HEX_LOOP            123C
IMMD_B              359C
IMMD_L              35DC
IMMD_W              35BC
IMMEDIATE           356C
INCREMENT           405C
INTRO               1028
IS_ODD              12AE
IS_ODD_ERR          12C4
JMPTABLE            139A
LF                  A
LONGMODE            3540
LOOP_SHIFTING       37DE
LOOP_SHIFTING1      3868
LOOP_SHIFTING2      38FA
LOOP_SHIFTING3      3994
LOOP_SHIFTING4      3A3E
MAIN                12CA
MASKING_NEXT        37EC
MASKING_NEXT1       3876
MASKING_NEXT2       3908
MASKING_NEXT3       39A2
MASKING_NEXT4       3A4C
MODE000             33BA
MODE001             33E2
MODE010             33F6
MODE011             3436
MODE100             3456
MODE111             34B6
NEXTLINES           137C
OP0000              13FA
OP0000_BTST_B       1564
OP0000_CMPI         17A6
OP0000_CMPI_B       181C
OP0000_CMPI_L       186C
OP0000_CMPI_W       1844
OP0000_EOR_B        1612
OP0000_EOR_L        1642
OP0000_EOR_W        162A
OP0000_ORI_B        1900
OP0000_ORI_L        1950
OP0000_ORI_W        1928
OP0000_RETURN_BTST  1594
OP0000_RETURN_CMPI  1890
OP0000_RETURN_EOR   1656
OP0000_RETURN_ORI   1974
OP0000_RETURN_SUBI  1738
OP0000_SUB_B        16F4
OP0000_SUB_L        1724
OP0000_SUB_W        170C
OP0001              1976
OP0010              19E4
OP0011              1AE2
OP0100              1BDE
OP0101              1E34
OP0101_ADDQ_B       1EB0
OP0101_ADDQ_B_0     1F2C
OP0101_ADDQ_B_1     1F38
OP0101_ADDQ_B_2     1F44
OP0101_ADDQ_B_3     1F50
OP0101_ADDQ_B_4     1F5C
OP0101_ADDQ_B_5     1F68
OP0101_ADDQ_B_6     1F74
OP0101_ADDQ_B_7     1F80
OP0101_ADDQ_B_8     1F8C
OP0101_ADDQ_L       1EC8
OP0101_ADDQ_W       1EBC
OP0101_RETURN       1ED0
OP0101_RETURN2      1F94
OP0110              1FD8
OP0111              20DE
OP1000              20E2
OP1000_DIVS_DN_EA_OR_EA_DN  20F0
OP1000_DIVS_RETURN  21D4
OP1000_EA_DN_DIVS   211E
OP1000_PRINT_L_DIVS  218C
OP1000_PRINT_W_DIVS  2144
OP1001              21EA
OP1001_ADD_RETURN   2538
OP1001_DETERMINE_DN_EA_OR_EA_DN  2300
OP1001_DN_EA        2338
OP1001_EA_DN        2438
OP1001_PRINT_B      2460
OP1001_PRINT_B2     2360
OP1001_PRINT_L      24F0
OP1001_PRINT_L2     23F0
OP1001_PRINT_W      24A8
OP1001_PRINT_W2     23A8
OP1001_SUBA_L       221C
OP1001_SUBA_W       228E
OP1010              25A6
OP1011              25AA
OP1011_CMP          2604
OP1011_CMPA         26B6
OP1011_CMPA_L       2730
OP1011_CMPA_W       2724
OP1011_CMP_B        2678
OP1011_CMP_L        2690
OP1011_CMP_W        2684
OP1011_EOR          2756
OP1011_EOR_B        27CA
OP1011_EOR_L        27E2
OP1011_EOR_W        27D6
OP1011_RETURN       27EA
OP1011_RETURN_CMP   2698
OP1011_RETURN_CMPA  2738
OP1100              28AA
OP1100_AND_RETURN   2BFA
OP1100_DETERMINE_DN_EA_OR_EA_DN  29C0
OP1100_DN_EA        29FA
OP1100_EA_DN        2AFA
OP1100_EA_DN_MULS   2908
OP1100_MULS_DN_EA_OR_EA_DN  28DA
OP1100_MULS_RETURN  29BE
OP1100_PRINT_B      2B22
OP1100_PRINT_B2     2A22
OP1100_PRINT_L      2BB2
OP1100_PRINT_L2     2AB2
OP1100_PRINT_L_MULS  2976
OP1100_PRINT_W      2B6A
OP1100_PRINT_W2     2A6A
OP1100_PRINT_W_MULS  292E
OP1101              2BFC
OP1101_ADDA_L       2C2E
OP1101_ADDA_W       2CA0
OP1101_ADD_RETURN   2F4A
OP1101_DETERMINE_DN_EA_OR_EA_DN  2D12
OP1101_DN_EA        2D4A
OP1101_EA_DN        2E4A
OP1101_PRINT_B      2E72
OP1101_PRINT_B2     2D72
OP1101_PRINT_L      2F02
OP1101_PRINT_L2     2E02
OP1101_PRINT_W      2EBA
OP1101_PRINT_W2     2DBA
OP1110              2FD8
OP1111              32AE
OP_ADDA_L           2FC0
OP_ADDA_W           2FA8
OP_ADDQ_B           1FA2
OP_ADDQ_L           1FC6
OP_ADDQ_W           1FB4
OP_ADD_B            2F60
OP_ADD_L            2F90
OP_ADD_W            2F78
OP_ASL              32AE
OP_ASL_2            32AE
OP_ASR              32AE
OP_ASR_2            32AE
OP_BEQ              206C
OP_BHI              2020
OP_BLT              20B8
OP_BNE              2046
OP_BRA              2092
OP_BTST             1484
OP_BTST_IMMEDIATE   150E
OP_CMPA_L           281A
OP_CMPA_W           2808
OP_CMP_B            282C
OP_CMP_L            285C
OP_CMP_W            2844
OP_DATA             175A
OP_DIVS             21D6
OP_EORI             1596
OP_EOR_B            2874
OP_EOR_L            2898
OP_EOR_W            2886
OP_JSR              1E06
OP_LEA              1C8C
OP_LEA_DN_EA_OR_EA_DN  1C9A
OP_LEA_RETURN       1CF8
OP_LSL              32AE
OP_LSL_2            32AE
OP_LSR              3124
OP_LSR_2            3124
OP_LSR_2_B          3192
OP_LSR_2_B_0        3222
OP_LSR_2_B_1        322E
OP_LSR_2_B_2        323A
OP_LSR_2_B_3        3246
OP_LSR_2_B_4        3252
OP_LSR_2_B_5        325E
OP_LSR_2_B_6        326A
OP_LSR_2_B_7        3276
OP_LSR_2_B_8        3282
OP_LSR_2_B_I        31CA
OP_LSR_2_B_R        31AE
OP_LSR_2_B_RETURN2  328A
OP_LSR_2_L          32A4
OP_LSR_2_RETURN     32AC
OP_LSR_2_W          3298
OP_MOVEA_L          1A72
OP_MOVEA_W          1B6E
OP_MOVEM_L          1C7A
OP_MOVEM_W          1C68
OP_MOVE_B           197C
OP_MOVE_L           1A0A
OP_MOVE_W           1B06
OP_MULS             28CC
OP_NEG              1CFA
OP_NEG_B            1D46
OP_NEG_L            1D5E
OP_NEG_PRINT_EA     1D6A
OP_NEG_W            1D52
OP_NOT              1D80
OP_NOT_B            1DCC
OP_NOT_L            1DE4
OP_NOT_PRINT_EA     1DF0
OP_NOT_W            1DD8
OP_ORI              1892
OP_PRINT_L_LEA      1CB8
OP_ROL              32AE
OP_ROL_2            32AE
OP_ROR              32AE
OP_ROR_2            32AE
OP_RTS              1E1A
OP_SUBA_L           2594
OP_SUBA_W           2582
OP_SUBI             1678
OP_SUB_B            253A
OP_SUB_L            256A
OP_SUB_W            2552
OUTPUT_PROCESSED_DATA  134E
POINTER_WORD        49A6
POP_FRONT           4016
POP_FRONT_RETURN    4050
POP_RETURN          4014
POP_SHIFT_LOOP      4032
POP_STACK           4008
PRINT_QUEUE         3FDC
PRINT_QUEUE_HELPER  3FE8
PRINT_QUEUE_RETURN  3FFE
PRINT_STACK         3FC2
PRINT_STACK_HELPER  3FCE
PRINT_STACK_RETURN  3FDA
PROGLP              100A
PROMPT_END          43F8
PROMPT_START        43C9
PUSH_STACK          4000
QUEUE_COUNTER       4988
REG_0               36B0
REG_1               36BE
REG_2               36CC
REG_3               36DA
REG_4               36E8
REG_5               36F6
REG_6               3704
REG_7               3712
REPEAT              3720
REPEATMSG           444F
RETURN              11BE
RETURN2STACK        1226
SRC_LOOP_SHIFTING   3A9E
SRC_MASKING_NEXT    3AAC
SRC_MODE            3370
SRC_REGISTER        3658
SRC_REGISTER_FORMAT  498B
STACK               7000
STACK_HEX_CHAR      1298
STACK_HEX_CONT      129C
STACK_HEX_LOOP      127E
START               1004
START_ADDR          1052
S_ADDR_HX           45CE
TEMP_REGISTER_FORMAT  498C
TERMINATE           40E2
TESTING             1036
TMPINPUT            45D9
TMPOUTPUT           4629
VAR_BYTE_END        4994
VAR_BYTE_START      4990
VAR_LONG_ADDRESS_MODE_CHECK  499C
VAR_TEMP_CLEANCOPY  4998
VR_E_ADDR           457E
VR_S_ADDR           452E
WELCOME             40F4
WORDMODE            3514
