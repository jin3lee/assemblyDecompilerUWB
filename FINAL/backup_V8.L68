00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 10:48:27 AM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001090             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010E2             38              JSR     END_ADDR
00001016  43F9 000044A8             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012A0             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003FC6             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  0413 00FF                 53              SUBI.B  #255,(A3)
0000103A  041C 0025                 54              SUBI.B  #$25,(A4)+
0000103E  0425 00AA                 55              SUBI.B  #%10101010,-(A5)
00001042  0438 0080 3331            56              SUBI.B  #128,$3331
00001048  0439 0040 44444441        57              SUBI.B  #64,$44444441
00001050                            58               
00001050  0453 00FF                 59              SUBI.W  #255,(A3)
00001054  045C 0025                 60              SUBI.W  #$25,(A4)+
00001058  0465 00AA                 61              SUBI.W  #%10101010,-(A5)
0000105C  0478 0080 3331            62              SUBI.W  #128,$3331
00001062  0479 0040 44444441        63              SUBI.W  #64,$44444441
0000106A                            64              
0000106A  0493 000000FF             65              SUBI.L  #255,(A3)
00001070  049C 00000025             66              SUBI.L  #$25,(A4)+
00001076  04A5 000000AA             67              SUBI.L  #%10101010,-(A5)
0000107C  04B8 00000080 3331        68              SUBI.L  #128,$3331
00001084  04B9 00000040 44444441    69              SUBI.L  #64,$44444441
0000108E                            70  
0000108E                            71  
0000108E                            72  
0000108E  4E75                      73              RTS
00001090                            74  *---------------------------------------------------------------------------*
00001090                            75  * START_ADDR: Compute the starting address
00001090                            76  *---------------------------------------------------------------------------*
00001090                            77  START_ADDR
00001090                            78              * Output
00001090  43F9 0000429B             79              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001096  103C 000E                 80              MOVE.B  #14,D0                  * Display PROMPT_START
0000109A  4E4F                      81              TRAP    #15
0000109C                            82      
0000109C                            83              * Input
0000109C  43F9 00004400             84              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
000010A2  103C 0002                 85              MOVE.B  #2,D0                   * Ask user for input
000010A6  4E4F                      86              TRAP    #15
000010A8                            87              
000010A8                            88              * Error Checking (length)
000010A8  0C01 0000                 89              CMPI.B  #0, D1                  * Check if input length <= 0
000010AC  6F00 0098                 90              BLE     ERROR_1
000010B0  0C01 0008                 91              CMPI.B  #8, D1                  * Check if input length > 8
000010B4  6E00 0090                 92              BGT     ERROR_1
000010B8                            93              
000010B8                            94              * Conversion & Storage
000010B8  4EB9 00001196             95              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010BE  0C07 0001                 96              CMPI.B  #1, D7                  * Check for error
000010C2  6700 0082                 97              BEQ     ERROR_1                 
000010C6  23C1 000044A0             98              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
000010CC                            99              
000010CC                           100              * Error Checking (Odd)
000010CC  43F9 000044A0            101              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
000010D2  4EB9 00001284            102              JSR     IS_ODD                  * Check if the input address is odd
000010D8  0C07 0001                103              CMPI.B  #1, D7                  * Check for error
000010DC  6700 0088                104              BEQ     ERROR_3
000010E0                           105              
000010E0                           106              * Return
000010E0  4E75                     107              RTS     
000010E2                           108  *---------------------------------------------------------------------------*
000010E2                           109  * END_ADDR: Compute the ending address
000010E2                           110  *---------------------------------------------------------------------------*
000010E2                           111  END_ADDR
000010E2                           112              * Output
000010E2  43F9 000042CA            113              LEA     PROMPT_END,A1           * Load PROMPT_END
000010E8  103C 000E                114              MOVE.B  #14,D0                  * Display PROMPT_END
000010EC  4E4F                     115              TRAP    #15
000010EE                           116  
000010EE                           117              * Input
000010EE  43F9 00004450            118              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010F4  103C 0002                119              MOVE.B  #2,D0                   * Ask user for input
000010F8  4E4F                     120              TRAP    #15
000010FA                           121              
000010FA                           122              * Error Checking (length)
000010FA  0C01 0000                123              CMPI.B  #0, D1                  * Check if input length <= 0
000010FE  6F00 0056                124              BLE     ERROR_2
00001102  0C01 0008                125              CMPI.B  #8, D1                  * Check if input length > 8
00001106  6E00 004E                126              BGT     ERROR_2
0000110A                           127              
0000110A                           128              * Conversion & Storage
0000110A  4EB9 00001196            129              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001110  0C07 0001                130              CMPI.B  #1, D7                  * Check for error
00001114  6700 0040                131              BEQ     ERROR_2
00001118  23C1 000044A4            132              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
0000111E                           133              
0000111E                           134              * Error Checking (start > end case)
0000111E  2439 000044A0            135              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
00001124  B282                     136              CMP.L   D2, D1                  * Compare starting and ending address
00001126  6300 005E                137              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
0000112A                           138              
0000112A                           139              * Error Checking (Odd case)
0000112A  43F9 000044A4            140              LEA     E_ADDR_HX, A1           * Move the ending address
00001130  4EB9 00001284            141              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
00001136  0C07 0001                142              CMPI.B  #1, D7                  * Check for an error flag
0000113A  6700 003A                143              BEQ     ERROR_4
0000113E                           144              
0000113E                           145              * Inputs are valid
0000113E  2A79 000044A0            146              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
00001144                           147              
00001144  4E75                     148              RTS
00001146                           149              
00001146                           150  *---------------------------------------------------------------------------*
00001146                           151  * ERROR_1: Address error (Invalid starting address)
00001146                           152  *---------------------------------------------------------------------------*
00001146                           153  ERROR_1
00001146  43F9 0000438F            154              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000114C  103C 000E                155              MOVE.B  #14, D0                 * Display ERRMSG_1
00001150  4E4F                     156              TRAP    #15
00001152  4EF8 1090                157              JMP     START_ADDR              * Jump to START_ADDR
00001156                           158      
00001156                           159  *---------------------------------------------------------------------------*
00001156                           160  * ERROR_2: Address error (Invalid ending address)
00001156                           161  *---------------------------------------------------------------------------*
00001156                           162  ERROR_2
00001156  43F9 0000438F            163              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000115C  103C 000E                164              MOVE.B  #14, D0                 * Display ERRMSG_1
00001160  4E4F                     165              TRAP    #15
00001162  4EF8 10E2                166              JMP     END_ADDR                * Jump to END_ADDR
00001166                           167  
00001166                           168  *---------------------------------------------------------------------------*
00001166                           169  * ERROR_3: Address error (Odd starting address)
00001166                           170  *---------------------------------------------------------------------------*
00001166                           171  ERROR_3
00001166  43F9 000043AE            172              LEA     ERRMSG_3, A1
0000116C  103C 000E                173              MOVE.B  #14, D0
00001170  4E4F                     174              TRAP    #15
00001172  4EF8 1090                175              JMP     START_ADDR
00001176                           176     
00001176                           177  *---------------------------------------------------------------------------*
00001176                           178  * ERROR_4: Address error (Odd ending address)
00001176                           179  *---------------------------------------------------------------------------*         
00001176                           180  ERROR_4
00001176  43F9 000043AE            181              LEA     ERRMSG_3, A1
0000117C  103C 000E                182              MOVE.B  #14, D0
00001180  4E4F                     183              TRAP    #15
00001182  4EF8 10E2                184              JMP     END_ADDR
00001186                           185            
00001186                           186  *---------------------------------------------------------------------------*
00001186                           187  * ERROR_3: Address error (Ending address is less than starting address)
00001186                           188  *---------------------------------------------------------------------------*
00001186                           189  ERROR_5
00001186  43F9 000043D3            190              LEA     ERRMSG_5, A1
0000118C  103C 000E                191              MOVE.B  #14, D0
00001190  4E4F                     192              TRAP    #15
00001192  4EF8 10E2                193              JMP     END_ADDR
00001196                           194    
00001196                           195  *---------------------------------------------------------------------------*
00001196                           196  * ASCII2HEX: Convert ASCii to Hexadecimal
00001196                           197  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001196                           198  *---------------------------------------------------------------------------*
00001196  4281                     199  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001198  4287                     200              CLR.L   D7                      * Set the error flag to 0
0000119A  4282                     201              CLR.L   D2                      * Clear D2 for temp storage
0000119C                           202              
0000119C  1419                     203  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
0000119E  0C02 0000                204              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011A2  6700 0058                205              BEQ     RETURN                  * If it's NULL, go to return
000011A6  0C02 0066                206              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011AA  6E00 004C                207              BGT     ASC_ERR                 * ASCII > f (invalid input) 
000011AE  0C02 0061                208              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011B2  6C00 0026                209              BGE     ASC_LOW                 * ASCII >= a (valid input)
000011B6  0C02 0046                210              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011BA  6E00 003C                211              BGT     ASC_ERR                 * ASCII > F (invalid input)
000011BE  0C02 0041                212              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011C2  6C00 001E                213              BGE     ASC_UPP                 * ASCII >= A (valid input)
000011C6  0C02 0039                214              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011CA  6E00 002C                215              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
000011CE  0C02 0030                216              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011D2  6C00 0016                217              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
000011D6  6000 0020                218              BRA     ASC_ERR                 * Invalid input
000011DA                           219  
000011DA  0442 0057                220  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011DE  6000 0012                221              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011E2                           222              
000011E2  0442 0037                223  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011E6  6000 000A                224              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011EA                           225              
000011EA  0442 0030                226  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011EE  6000 0002                227              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011F2                           228              
000011F2  E981                     229  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011F4  D202                     230              ADD.B   D2, D1                  * Add the converted input to D1
000011F6  60A4                     231              BRA     ASC2HXLP                * Loop
000011F8                           232  
000011F8  1E3C 0001                233  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011FC  4E75                     234  RETURN      RTS     
000011FE                           235  
000011FE                           236  *---------------------------------------------------------------------------*
000011FE                           237  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011FE                           238  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011FE                           239  *---------------------------------------------------------------------------*
000011FE  0C02 0008                240  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001202  6700 000E                241              BEQ     HEX_LOOP
00001206  4841                     242              SWAP    D1
00001208  0C02 0002                243              CMPI.B  #2,D2
0000120C  6600 0004                244              BNE     HEX_LOOP
00001210  E189                     245              LSL.L   #8,D1
00001212                           246             
00001212  E999                     247  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001214  2601                     248              MOVE.L  D1, D3                  * Move D1 to D3
00001216  0283 0000000F            249              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000121C  0C03 0009                250              CMPI.B  #9, D3                  * Compare te digit
00001220  6E00 000A                251              BGT     HEX_CHAR              
00001224  0603 0030                252              ADDI.B  #48,D3                  * Add 48 for numerical output
00001228  6000 0006                253              BRA     HEX_CONT
0000122C                           254              
0000122C  0603 0037                255  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001230                           256  
00001230  12C3                     257  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001232  5342                     258              SUBI    #1, D2                  * Decrement the size
00001234  0C02 0000                259              CMPI.B  #0, D2                  * Check if D2 is 0
00001238  66D8                     260              BNE     HEX_LOOP                * Loop
0000123A  12BC 0000                261              MOVE.B  #$0,(A1)                * Null terminator
0000123E  4E75                     262              RTS
00001240                           263  *---------------------------------------------------------------------------*
00001240                           264  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001240                           265  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001240                           266  *---------------------------------------------------------------------------*
00001240                           267  HEX2ASCII2STACK
00001240  0C02 0008                268              CMPI.B  #8, D2                  * Check to see if the size is long
00001244  6700 000E                269              BEQ     STACK_HEX_LOOP
00001248  4841                     270              SWAP    D1
0000124A  0C02 0002                271              CMPI.B  #2,D2
0000124E  6600 0004                272              BNE     STACK_HEX_LOOP
00001252  E189                     273              LSL.L   #8,D1
00001254                           274             
00001254                           275  STACK_HEX_LOOP    
00001254  E999                     276              ROL.L   #4, D1                  * Roll D1 to left
00001256  2601                     277              MOVE.L  D1, D3                  * Move D1 to D3
00001258  0283 0000000F            278              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000125E  0C03 0009                279              CMPI.B  #9, D3                  * Compare te digit
00001262  6E00 000A                280              BGT     STACK_HEX_CHAR              
00001266  0603 0030                281              ADDI.B  #48,D3                  * Add 48 for numerical output
0000126A  6000 0006                282              BRA     STACK_HEX_CONT
0000126E                           283              
0000126E                           284  STACK_HEX_CHAR    
0000126E  0603 0037                285              ADDI.B  #55,D3                  * Add 55 for character output
00001272                           286  
00001272                           287  STACK_HEX_CONT    
00001272  6100 2CC2                288              BSR     PUSH_STACK              *PLACE INTO STACK
00001276  5342                     289              SUBI    #1, D2                  * Decrement the size
00001278  0C02 0000                290              CMPI.B  #0, D2                  * Check if D2 is 0
0000127C  66D6                     291              BNE     STACK_HEX_LOOP                * Loop
0000127E  12BC 0000                292              MOVE.B  #$0,(A1)                * Null terminator
00001282  4E75                     293              RTS
00001284                           294  
00001284                           295  
00001284                           296  *---------------------------------------------------------------------------*
00001284                           297  * IS_ODD: Check whether the source address is odd
00001284                           298  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
00001284                           299  *---------------------------------------------------------------------------*
00001284  4281                     300  IS_ODD      CLR.L   D1                      * Clear the result
00001286  4287                     301              CLR.L   D7                      * Set the error flag to 0
00001288  2211                     302              MOVE.L  (A1),D1                * Temp store the checking address to D1
0000128A  82FC 0002                303              DIVU    #2, D1                  * Divide the result by 2
0000128E  4841                     304              SWAP    D1                      * Swap remainder with quotient
00001290  0C01 0001                305              CMPI.B  #1, D1                  * Check for error
00001294  6700 0004                306              BEQ     IS_ODD_ERR
00001298  4E75                     307              RTS
0000129A                           308              
0000129A  1E3C 0001                309  IS_ODD_ERR  MOVE.B  #1, D7
0000129E  4E75                     310              RTS
000012A0                           311  
000012A0                           312  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012A0                           313  * MAINDEBUG                    
000012A0                           314  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012A0                           315  * A5: Processing address
000012A0                           316  *
000012A0                           317  * D3: USED FOR PUSHING INTO STACK
000012A0                           318  *     To push into stack => MOVE.W #DATA,D3 
000012A0                           319  *                           BSR    PUSH_STACK
000012A0                           320  *     To print stack     => BSR    PRINT_STACK 
000012A0                           321  *     To clear stack     => BSR    CLEAR_STACK
000012A0                           322  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012A0                           323  MAIN        
000012A0                           324              *initialize stack pointer
000012A0  33FC 0000 00004858       325              MOVE.W  #0,COUNTER
000012A8  347C 7000                326              MOVEA.W #STACK,A2
000012AC  163C 0020                327              MOVE.B  #' ',D3
000012B0  6100 2C84                328              BSR     PUSH_STACK
000012B4  6100 2C80                329              BSR     PUSH_STACK
000012B8  6100 2C7C                330              BSR     PUSH_STACK
000012BC                           331              
000012BC                           332              * clear registers for temp storage
000012BC  4280                     333              CLR.L   D0                   
000012BE  4281                     334              CLR.L   D1                   
000012C0  227C 00000000            335              MOVEA.L #0, A1                
000012C6                           336              
000012C6  220D                     337              MOVE.L  A5,D1                   * check to see if the address is fully read
000012C8  23CD 000044A0            338              MOVE.L  A5,S_ADDR_HX
000012CE  B2B9 000044A4            339              CMP.L   E_ADDR_HX,D1
000012D4  6C00 2380                340              BGE     REPEAT                  * go to repeat for user action
000012D8                           341  
000012D8  43F9 000044FB            342              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012DE  143C 0008                343              MOVE.B  #8,D2                   * set the output size
000012E2  4EB8 11FE                344              JSR     HEX2ASCII               
000012E6  43F9 000044FB            345              LEA     TMPOUTPUT,A1
000012EC  103C 000E                346              MOVE.B  #14,D0
000012F0  4E4F                     347              TRAP    #15
000012F2                           348              
000012F2  4285                     349              CLR.L    D5                      * clear the processing data
000012F4  3A1D                     350              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012F6                           351                                               * advance the current instruction pointer to the next
000012F6                           352                                               * instruction in memory
000012F6                           353  *----------------------------------------*
000012F6                           354  * Registers          
000012F6                           355  * [D1] - COPY OF D5
000012F6                           356  * [D5] - DATA TO BE PROCESSED
000012F6                           357  * [D6] - COUNTER FOR LINES PROCESSED
000012F6                           358  *
000012F6                           359  * [D4]      - ERROR FLAG BEFORE PRINTING
000012F6                           360  * [STACK]   - PRINTS PROCESS DATA
000012F6                           361  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012F6                           362  *
000012F6                           363  * [A1] - USED FOR JUMPING/PRINTING
000012F6                           364  *
000012F6                           365  *----------------------------------------*
000012F6                           366  
000012F6                           367              
000012F6                           368              *Processing the first 4 most significant bits 
000012F6  2205                     369              MOVE.L  D5,D1                    * copy the current processing data to D1
000012F8  143C 000C                370              MOVE.B  #12,D2                   * shift to right by 12 bits
000012FC  E469                     371              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012FE  C2FC 0006                372              MULU    #6,D1                    * form offset
00001302  43F9 00001370            373              LEA     JMPTABLE,A1              * index into table
00001308  4EB1 1000                374              JSR     0(A1,D1)                 * jump indirect with index
0000130C                           375              
0000130C                           376              *SECURED EA*
0000130C  B83C 0001                377              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001310  6600 0012                378              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001314  6100 041A                379              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001318  6100 2C88                380              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000131C  183C 0000                381              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001320  6000 0022                382              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001324                           383             
00001324                           384  OUTPUT_PROCESSED_DATA       
00001324  163C 000D                385              MOVE.B  #$D,D3                  *carriage return
00001328  6100 2C0C                386              BSR     PUSH_STACK
0000132C  163C 000A                387              MOVE.B  #$A,D3                  *new line feed
00001330  6100 2C04                388              BSR     PUSH_STACK
00001334  163C 0000                389              MOVE.B  #$0,D3                  *null
00001338  6100 2BFC                390              BSR     PUSH_STACK
0000133C                           391       
0000133C  6100 2BD4                392              BSR     PRINT_QUEUE
00001340  183C 0000                393              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001344                           394  DISPLAY_30_LINES
00001344                           395              * display 30 lines per page
00001344  5206                     396              ADDI.B  #1,D6
00001346  0C06 001E                397              CMPI.B  #30,D6
0000134A  6C00 0006                398              BGE     NEXTLINES
0000134E  6000 FF50                399              BRA     MAIN
00001352                           400            
00001352                           401  *---------------------------------------------------------------------------*
00001352                           402  * NEXTLINES: receive input from user to print the next 30 lines
00001352                           403  *---------------------------------------------------------------------------*  
00001352  4206                     404  NEXTLINES   CLR.B   D6
00001354  43F9 000042F7            405              LEA     DISP_NEXT,A1
0000135A  103C 000E                406              MOVE.B  #14,D0
0000135E  4E4F                     407              TRAP    #15
00001360  43F9 000044AB            408              LEA     TMPINPUT,A1
00001366  103C 0002                409              MOVE.B  #2,D0
0000136A  4E4F                     410              TRAP    #15
0000136C  4EF8 12A0                411              JMP     MAIN
00001370                           412    
00001370                           413  *---------------------------------------------------------------------------*
00001370                           414  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001370                           415  *---------------------------------------------------------------------------*  
00001370  4EF9 000013D0            416  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *CMPI/ORI/BTST/EORI -
00001376  4EF9 0000194C            417              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
0000137C  4EF9 000019BA            418              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
00001382  4EF9 00001AB8            419              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
00001388  4EF9 00001BB4            420              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
0000138E  4EF9 00001E0A            421              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
00001394  4EF9 00001FAE            422              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *NOT FINISHED - LYN
0000139A  4EF9 0000203C            423              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013A0  4EF9 00002040            424              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
000013A6  4EF9 00002148            425              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
000013AC  4EF9 00002504            426              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013B2  4EF9 00002508            427              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - JOSEPH
000013B8  4EF9 00002808            428              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
000013BE  4EF9 00002B5A            429              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
000013C4  4EF9 00002F36            430              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
000013CA  4EF9 000031E4            431              JMP     OP1111  * Special/Reserved
000013D0                           432              
000013D0                           433  *---------------------------------------------------------------------------*
000013D0                           434  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013D0                           435  *---------------------------------------------------------------------------*           
000013D0                           436  OP0000                                                                                  
000013D0  4281                     437              CLR.L   D1          * to temporarily store the address to process
000013D2  4280                     438              CLR.L   D0  
000013D4  4284                     439              CLR.L   D4                 
000013D6  227C 00000000            440              MOVEA.L #0, A1                
000013DC                           441              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013DC                           442              * Check if bit 11,10,9,8 are 0000)
000013DC  2205                     443              MOVE.L  D5,D1
000013DE  0281 00000F00            444              ANDI.L  #$0F00,D1
000013E4  0C81 00000000            445              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013EA  6700 047C                446              BEQ     OP_ORI
000013EE                           447  
000013EE                           448              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013EE                           449              * check if bit 11,10,9,8 are 1100
000013EE  4281                     450              CLR.L   D1
000013F0  2205                     451              MOVE.L  D5,D1
000013F2  0281 00000F00            452              ANDI.L  #$0F00,D1
000013F8  0C81 00000C00            453              CMPI.L  #$0C00,D1
000013FE  6700 037C                454              BEQ     OP0000_CMPI
00001402                           455              
00001402                           456              * check for SUBI
00001402  4281                     457              CLR.L   D1
00001404  2205                     458              MOVE.L  D5,D1
00001406  0281 00000F00            459              ANDI.L  #$0F00,D1
0000140C  0C81 00000400            460              CMPI.L  #$0400,D1
00001412  6700 023A                461              BEQ     OP_SUBI
00001416                           462              
00001416                           463              * check for EORI
00001416  4281                     464              CLR.L   D1
00001418  2205                     465              MOVE.L  D5,D1
0000141A  0281 00000F00            466              ANDI.L  #$0F00,D1
00001420  0C81 00000A00            467              CMPI.L  #$0A00,D1
00001426  6700 0144                468              BEQ     OP_EORI
0000142A                           469              
0000142A                           470              * check for BTST
0000142A  4281                     471              CLR.L   D1
0000142C  2205                     472              MOVE.L  D5,D1
0000142E  E099                     473              ROR.L   #8,D1
00001430  0281 00000001            474              ANDI.L  #$1,D1
00001436  0C01 0001                475              CMPI.B  #$1,D1
0000143A  6700 001E                476              BEQ     OP_BTST
0000143E  4281                     477              CLR.L   D1
00001440  2205                     478              MOVE.L  D5,D1
00001442  EC99                     479              ROR.L   #6,D1
00001444  0281 000003FF            480              ANDI.L  #$03FF,D1
0000144A  0C81 00000020            481              CMPI.L  #%000100000,D1
00001450  6700 0008                482              BEQ     OP_BTST
00001454                           483  
00001454                           484  
00001454                           485              * OP0000 series other than ORI/CMPI/BTST/EORI
00001454  4EF9 00001730            486              JMP     OP_DATA
0000145A                           487              
0000145A                           488  *---------------------------------------------------------------------------*
0000145A                           489  * OP_BTST: display BTST
0000145A                           490  *---------------------------------------------------------------------------* 
0000145A                           491  OP_BTST       
0000145A                           492              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000145A                           493              *bits #8 indicates which
0000145A                           494              *0 - #immediate format
0000145A                           495              *1 - Dn format
0000145A  4281                     496              CLR.L   D1
0000145C  2205                     497              MOVE.L  D5,D1
0000145E  E099                     498              ROR.L   #8,D1
00001460  0281 00000001            499              ANDI.L  #1,D1
00001466  0C01 0001                500              CMPI.B  #1,D1
0000146A  6600 0078                501              BNE     OP_BTST_IMMEDIATE
0000146E                           502  
0000146E                           503             
0000146E                           504             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000146E  13FC 0000 0000485C       505             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001476  13FC 0002 0000485D       506             MOVE.B   #$02,SRC_REGISTER_FORMAT
0000147E                           507             
0000147E                           508             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000147E  13FC 00B9 0000485F       509             MOVE.B   #$B9,GET_DST_START_END
00001486  13FC 0020 00004860       510             MOVE.B   #$20,GET_SRC_START_END
0000148E                           511             
0000148E  0285 0000FE3F            512             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001494  0685 00000000            513             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000149A                           514              
0000149A                           515              *CLEAR D3
0000149A  4283                     516              CLR.L   D3
0000149C                           517              *LOAD STACK WITH THIS OPMODE
0000149C  6100 2A98                518              BSR     PUSH_STACK
000014A0  163C 0042                519              MOVE.B  #'B',D3
000014A4  6100 2A90                520              BSR     PUSH_STACK
000014A8  163C 0054                521              MOVE.B  #'T',D3
000014AC  6100 2A88                522              BSR     PUSH_STACK
000014B0  163C 0053                523              MOVE.B  #'S',D3
000014B4  6100 2A80                524              BSR     PUSH_STACK
000014B8  163C 0054                525              MOVE.B  #'T',D3
000014BC  6100 2A78                526              BSR     PUSH_STACK
000014C0  163C 002E                527              MOVE.B  #'.',D3
000014C4  6100 2A70                528              BSR     PUSH_STACK
000014C8  163C 0042                529              MOVE.B  #'B',D3
000014CC  6100 2A68                530              BSR     PUSH_STACK
000014D0                           531              
000014D0  6100 25F6                532              BSR     GET_EA_EA_DEST
000014D4  163C 002C                533              MOVE.B  #',',D3
000014D8  6100 2A5C                534              BSR     PUSH_STACK
000014DC  6100 21BA                535              BSR     GET_EA_EA_SRC
000014E0                           536              
000014E0  6000 0088                537              BRA     OP0000_RETURN_BTST
000014E4                           538              
000014E4                           539              
000014E4                           540              *MOVE **** OR **** CMPI
000014E4                           541              
000014E4                           542  OP_BTST_IMMEDIATE              
000014E4                           543   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000014E4  13FC 0000 0000485C       544             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014EC  13FC 0082 0000485D       545             MOVE.B   #$82,SRC_REGISTER_FORMAT
000014F4                           546             
000014F4                           547             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014F4  13FC 00B9 0000485F       548             MOVE.B   #$B9,GET_DST_START_END
000014FC  13FC 0020 00004860       549             MOVE.B   #$20,GET_SRC_START_END
00001504                           550             
00001504                           551              *CLEAR D3
00001504  4283                     552              CLR.L   D3
00001506                           553              *LOAD STACK WITH THIS OPMODE
00001506  6100 2A2E                554              BSR     PUSH_STACK
0000150A  163C 0042                555              MOVE.B  #'B',D3
0000150E  6100 2A26                556              BSR     PUSH_STACK
00001512  163C 0054                557              MOVE.B  #'T',D3
00001516  6100 2A1E                558              BSR     PUSH_STACK
0000151A  163C 0053                559              MOVE.B  #'S',D3
0000151E  6100 2A16                560              BSR     PUSH_STACK
00001522  163C 0054                561              MOVE.B  #'T',D3
00001526  6100 2A0E                562              BSR     PUSH_STACK
0000152A  163C 002E                563              MOVE.B  #'.',D3
0000152E  6100 2A06                564              BSR     PUSH_STACK
00001532  163C 0042                565              MOVE.B  #'B',D3
00001536  6100 29FE                566              BSR     PUSH_STACK
0000153A                           567  
0000153A                           568  OP0000_BTST_B
0000153A                           569              *GET DATA FROM ADDQ AND PRINT #0-8
0000153A                           570              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000153A  0285 0000F03F            571              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001540  0685 000001C0            572              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001546                           573  
00001546                           574              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001546                           575             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001546                           576             * MOVE.W    (A5)+,D1
00001546                           577             * MOVE.B  #' ',D3
00001546                           578             * BSR     PUSH_STACK
00001546                           579             * MOVE.B  #'#',D3
00001546                           580             * BSR     PUSH_STACK
00001546                           581             * BSR     HEX2ASCII2STACK
00001546                           582             * BSR     PUSH_STACK
00001546                           583              
00001546  163C 0020                584              MOVE.B  #' ',D3
0000154A  6100 29EA                585              BSR     PUSH_STACK
0000154E  163C 0023                586              MOVE.B  #'#',D3
00001552  6100 29E2                587              BSR     PUSH_STACK
00001556  6100 2570                588              BSR     GET_EA_EA_DEST
0000155A  163C 002C                589              MOVE.B  #',',D3
0000155E  6100 29D6                590              BSR     PUSH_STACK
00001562  6100 2134                591              BSR     GET_EA_EA_SRC
00001566  6000 0002                592              BRA     OP0000_RETURN_BTST
0000156A                           593  OP0000_RETURN_BTST
0000156A                           594              
0000156A  4E75                     595              RTS
0000156C                           596  
0000156C                           597  
0000156C                           598  *---------------------------------------------------------------------------*
0000156C                           599  * OP_EORI: decode and display EORI
0000156C                           600  *---------------------------------------------------------------------------* 
0000156C                           601  OP_EORI
0000156C                           602                         
0000156C                           603  
0000156C                           604   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000156C  13FC 0000 0000485C       605             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001574  13FC 0080 0000485D       606             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000157C                           607             
0000157C                           608             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000157C  13FC 00B9 0000485F       609             MOVE.B   #$B9,GET_DST_START_END
00001584  13FC 0020 00004860       610             MOVE.B   #$20,GET_SRC_START_END
0000158C                           611             
0000158C                           612              *CLEAR D3
0000158C  4283                     613              CLR.L   D3
0000158E                           614              *LOAD STACK WITH THIS OPMODE
0000158E  6100 29A6                615              BSR     PUSH_STACK
00001592  163C 0045                616              MOVE.B  #'E',D3
00001596  6100 299E                617              BSR     PUSH_STACK
0000159A  163C 004F                618              MOVE.B  #'O',D3
0000159E  6100 2996                619              BSR     PUSH_STACK
000015A2  163C 0052                620              MOVE.B  #'R',D3
000015A6  6100 298E                621              BSR     PUSH_STACK
000015AA  163C 0049                622              MOVE.B  #'I',D3
000015AE  6100 2986                623              BSR     PUSH_STACK
000015B2  163C 002E                624              MOVE.B  #'.',D3
000015B6  6100 297E                625              BSR     PUSH_STACK
000015BA                           626              
000015BA                           627              *FIGURE OUT SIZE*
000015BA                           628              *00 = BYTE
000015BA                           629              *01 = WORD
000015BA                           630              *10 = LONG
000015BA                           631              * BITS 7&6
000015BA                           632              
000015BA                           633              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015BA  2205                     634              MOVE.L  D5,D1
000015BC  EC99                     635              ROR.L   #6,D1
000015BE  0281 00000003            636              ANDI.L  #$03,D1
000015C4  0C01 0000                637              CMPI.B  #%00,D1
000015C8  6700 001E                638              BEQ     OP0000_EOR_B
000015CC  0281 00000003            639              ANDI.L  #$03,D1
000015D2  0C01 0001                640              CMPI.B  #%01,D1
000015D6  6700 0028                641              BEQ     OP0000_EOR_W
000015DA  0281 00000003            642              ANDI.L  #$03,D1
000015E0  0C01 0002                643              CMPI.B  #%10,D1
000015E4  6700 0032                644              BEQ     OP0000_EOR_L
000015E8                           645            
000015E8                           646  OP0000_EOR_B
000015E8                           647              
000015E8  163C 0042                648              MOVE.B  #'B',D3
000015EC  6100 2948                649              BSR     PUSH_STACK
000015F0                           650              
000015F0                           651              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000015F0  0285 0000F03F            652              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000015F6  0685 000001C0            653              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000015FC                           654  
000015FC                           655              
000015FC  6000 002E                656              BRA     OP0000_RETURN_EOR
00001600                           657  OP0000_EOR_W
00001600                           658              
00001600  163C 0057                659              MOVE.B  #'W',D3
00001604  6100 2930                660              BSR     PUSH_STACK
00001608                           661              
00001608                           662              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001608  0285 0000F03F            663              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000160E  0685 000001C0            664              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001614                           665  
00001614                           666              
00001614  6000 0016                667              BRA     OP0000_RETURN_EOR
00001618                           668  OP0000_EOR_L
00001618                           669              
00001618  163C 004C                670              MOVE.B  #'L',D3
0000161C  6100 2918                671              BSR     PUSH_STACK
00001620                           672              
00001620                           673              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001620  0285 0000FE3F            674              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001626  0685 000009C0            675              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000162C                           676  
0000162C                           677  
0000162C                           678  OP0000_RETURN_EOR       
0000162C  163C 0020                679              MOVE.B  #' ',D3
00001630  6100 2904                680              BSR     PUSH_STACK
00001634  163C 0023                681              MOVE.B  #'#',D3
00001638  6100 28FC                682              BSR     PUSH_STACK
0000163C  6100 248A                683              BSR     GET_EA_EA_DEST
00001640  163C 002C                684              MOVE.B  #',',D3
00001644  6100 28F0                685              BSR     PUSH_STACK
00001648  6100 204E                686              BSR     GET_EA_EA_SRC
0000164C                           687              
0000164C  4E75                     688              RTS
0000164E                           689  
0000164E                           690  *---------------------------------------------------------------------------*
0000164E                           691  * OP_SUBI: decode SUBI.B/.W/.L
0000164E                           692  *---------------------------------------------------------------------------* 
0000164E                           693  OP_SUBI
0000164E                           694             
0000164E                           695   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000164E  13FC 0000 0000485C       696             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001656  13FC 0080 0000485D       697             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000165E                           698             
0000165E                           699             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000165E  13FC 00B9 0000485F       700             MOVE.B   #$B9,GET_DST_START_END
00001666  13FC 0020 00004860       701             MOVE.B   #$20,GET_SRC_START_END
0000166E                           702             
0000166E                           703              *CLEAR D3
0000166E  4283                     704              CLR.L   D3
00001670                           705              *LOAD STACK WITH THIS OPMODE
00001670  6100 28C4                706              BSR     PUSH_STACK
00001674  163C 0053                707              MOVE.B  #'S',D3
00001678  6100 28BC                708              BSR     PUSH_STACK
0000167C  163C 0055                709              MOVE.B  #'U',D3
00001680  6100 28B4                710              BSR     PUSH_STACK
00001684  163C 0042                711              MOVE.B  #'B',D3
00001688  6100 28AC                712              BSR     PUSH_STACK
0000168C  163C 0049                713              MOVE.B  #'I',D3
00001690  6100 28A4                714              BSR     PUSH_STACK
00001694  163C 002E                715              MOVE.B  #'.',D3
00001698  6100 289C                716              BSR     PUSH_STACK
0000169C                           717              
0000169C                           718              *FIGURE OUT SIZE*
0000169C                           719              *00 = BYTE
0000169C                           720              *01 = WORD
0000169C                           721              *10 = LONG
0000169C                           722              * BITS 7&6
0000169C                           723              
0000169C                           724              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000169C  2205                     725              MOVE.L  D5,D1
0000169E  EC99                     726              ROR.L   #6,D1
000016A0  0281 00000003            727              ANDI.L  #$03,D1
000016A6  0C01 0000                728              CMPI.B  #%00,D1
000016AA  6700 001E                729              BEQ     OP0000_SUB_B
000016AE  0281 00000003            730              ANDI.L  #$03,D1
000016B4  0C01 0001                731              CMPI.B  #%01,D1
000016B8  6700 0028                732              BEQ     OP0000_SUB_W
000016BC  0281 00000003            733              ANDI.L  #$03,D1
000016C2  0C01 0002                734              CMPI.B  #%10,D1
000016C6  6700 0032                735              BEQ     OP0000_SUB_L
000016CA                           736            
000016CA                           737  OP0000_SUB_B
000016CA                           738              
000016CA  163C 0042                739              MOVE.B  #'B',D3
000016CE  6100 2866                740              BSR     PUSH_STACK
000016D2                           741              
000016D2                           742              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016D2  0285 0000F03F            743              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016D8  0685 000001C0            744              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000016DE                           745  
000016DE                           746              
000016DE  6000 002E                747              BRA     OP0000_RETURN_SUBI
000016E2                           748  OP0000_SUB_W
000016E2                           749              
000016E2  163C 0057                750              MOVE.B  #'W',D3
000016E6  6100 284E                751              BSR     PUSH_STACK
000016EA                           752              
000016EA                           753              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016EA  0285 0000F03F            754              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016F0  0685 000001C0            755              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000016F6                           756  
000016F6                           757              
000016F6  6000 0016                758              BRA     OP0000_RETURN_SUBI
000016FA                           759  OP0000_SUB_L
000016FA                           760              
000016FA  163C 004C                761              MOVE.B  #'L',D3
000016FE  6100 2836                762              BSR     PUSH_STACK
00001702                           763              
00001702                           764              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001702  0285 0000F03F            765              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001708  0685 000003C0            766              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000170E                           767                      
0000170E                           768  OP0000_RETURN_SUBI            
0000170E  163C 0020                769              MOVE.B  #' ',D3
00001712  6100 2822                770              BSR     PUSH_STACK
00001716  163C 0023                771              MOVE.B  #'#',D3
0000171A  6100 281A                772              BSR     PUSH_STACK
0000171E  6100 23A8                773              BSR     GET_EA_EA_DEST
00001722  163C 002C                774              MOVE.B  #',',D3
00001726  6100 280E                775              BSR     PUSH_STACK
0000172A  6100 1F6C                776              BSR     GET_EA_EA_SRC
0000172E                           777              
0000172E  4E75                     778              RTS
00001730                           779  
00001730                           780              
00001730                           781  *---------------------------------------------------------------------------*
00001730                           782  * OP_DATA : unidentified opcode
00001730                           783  *---------------------------------------------------------------------------* 
00001730                           784  OP_DATA
00001730  4280                     785              CLR.L   D0                   
00001732  4281                     786              CLR.L   D1     
00001734  4284                     787              CLR.L   D4                    
00001736  227C 00000000            788              MOVEA.L #0, A1             
0000173C  4287                     789              CLR.L   D7
0000173E  1E3C 0001                790              MOVE.B  #1,D7                   * error flag is true
00001742                           791              
00001742  43F9 000045AA            792              LEA     DISP_DATA,A1
00001748  103C 000E                793              MOVE.B  #14,D0
0000174C  4E4F                     794              TRAP    #15
0000174E                           795              
0000174E  4EF9 00001754            796              JMP     EA_DATA
00001754                           797             
00001754                           798             
00001754                           799  *---------------------------------------------------------------------------*
00001754                           800  * EA_DATA
00001754                           801  *---------------------------------------------------------------------------*       
00001754  43F9 000044FB            802  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000175A  2205                     803              MOVE.L  D5,D1           * transfer the processing data to D1
0000175C  7404                     804              MOVE.L  #4,D2           * set to word size
0000175E  4EB8 11FE                805              JSR     HEX2ASCII       * prepare output in ascii
00001762  43F9 0000481D            806              LEA     DISP_HEX,A1     * display $ symbol
00001768  103C 000E                807              MOVE.B  #14,D0      
0000176C  4E4F                     808              TRAP    #15
0000176E  43F9 000044FB            809              LEA     TMPOUTPUT,A1    * display with a new line
00001774  103C 000D                810              MOVE.B  #13,D0
00001778  4E4F                     811              TRAP    #15
0000177A                           812  
0000177A  4E75                     813              RTS
0000177C                           814              
0000177C                           815  *---------------------------------------------------------------------------*
0000177C                           816  * OP_CMPI : decode CMPI and its size
0000177C                           817  *---------------------------------------------------------------------------*          
0000177C                           818  OP0000_CMPI
0000177C                           819  
0000177C                           820              
0000177C                           821   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000177C  13FC 0000 0000485C       822             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001784  13FC 0082 0000485D       823             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000178C                           824             
0000178C                           825             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000178C  13FC 00B9 0000485F       826             MOVE.B   #$B9,GET_DST_START_END
00001794  13FC 0020 00004860       827             MOVE.B   #$20,GET_SRC_START_END
0000179C                           828             
0000179C                           829              *CLEAR D3
0000179C  4283                     830              CLR.L   D3
0000179E                           831              *LOAD STACK WITH THIS OPMODE
0000179E  6100 2796                832              BSR     PUSH_STACK
000017A2  163C 0043                833              MOVE.B  #'C',D3
000017A6  6100 278E                834              BSR     PUSH_STACK
000017AA  163C 004D                835              MOVE.B  #'M',D3
000017AE  6100 2786                836              BSR     PUSH_STACK
000017B2  163C 0050                837              MOVE.B  #'P',D3
000017B6  6100 277E                838              BSR     PUSH_STACK
000017BA  163C 0049                839              MOVE.B  #'I',D3
000017BE  6100 2776                840              BSR     PUSH_STACK
000017C2  163C 002E                841              MOVE.B  #'.',D3
000017C6  6100 276E                842              BSR     PUSH_STACK
000017CA                           843              
000017CA                           844              *FIGURE OUT SIZE*
000017CA                           845              *00 = BYTE
000017CA                           846              *01 = WORD
000017CA                           847              *10 = LONG
000017CA                           848              * BITS 7&6
000017CA                           849              
000017CA                           850              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017CA  2205                     851              MOVE.L  D5,D1
000017CC  EC99                     852              ROR.L   #6,D1
000017CE  0281 00000003            853              ANDI.L  #$03,D1
000017D4  0C01 0000                854              CMPI.B  #%00,D1
000017D8  6700 0018                855              BEQ     OP0000_CMPI_B
000017DC  0C01 0001                856              CMPI.B  #%01,D1
000017E0  6700 0038                857              BEQ     OP0000_CMPI_W
000017E4  0281 00000003            858              ANDI.L  #$03,D1
000017EA  0C01 0002                859              CMPI.B  #%10,D1
000017EE  6700 0052                860              BEQ     OP0000_CMPI_L
000017F2                           861  
000017F2                           862  OP0000_CMPI_B
000017F2  163C 0042                863              MOVE.B  #'B',D3
000017F6  6100 273E                864              BSR     PUSH_STACK
000017FA                           865  *GET DATA FROM ADDQ AND PRINT #0-8
000017FA                           866              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000017FA  0285 0000F03F            867              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001800  0685 000001C0            868              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001806  6100 22C0                869              BSR     GET_EA_EA_DEST
0000180A  163C 002C                870              MOVE.B  #',',D3
0000180E  6100 2726                871              BSR     PUSH_STACK
00001812  6100 1E84                872              BSR     GET_EA_EA_SRC
00001816  6000 004E                873              BRA     OP0000_RETURN_CMPI
0000181A                           874  
0000181A                           875  OP0000_CMPI_W
0000181A  163C 0057                876              MOVE.B  #'W',D3
0000181E  6100 2716                877              BSR     PUSH_STACK
00001822                           878  *GET DATA FROM ADDQ AND PRINT #0-8
00001822                           879              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001822  0285 0000F03F            880              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001828  0685 000001C0            881              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000182E  6100 2298                882              BSR     GET_EA_EA_DEST
00001832  163C 002C                883              MOVE.B  #',',D3
00001836  6100 26FE                884              BSR     PUSH_STACK
0000183A  6100 1E5C                885              BSR     GET_EA_EA_SRC
0000183E  6000 0026                886              BRA     OP0000_RETURN_CMPI
00001842                           887  
00001842                           888  OP0000_CMPI_L
00001842  163C 004C                889              MOVE.B  #'L',D3
00001846  6100 26EE                890              BSR     PUSH_STACK
0000184A                           891              *GET DATA FROM ADDQ AND PRINT #0-8
0000184A                           892              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000184A  0285 0000F03F            893              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001850  0685 000003C0            894              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001856  6100 2270                895              BSR     GET_EA_EA_DEST
0000185A  163C 002C                896              MOVE.B  #',',D3
0000185E  6100 26D6                897              BSR     PUSH_STACK
00001862  6100 1E34                898              BSR     GET_EA_EA_SRC
00001866                           899              
00001866                           900  OP0000_RETURN_CMPI
00001866                           901  
00001866                           902  
00001866                           903              
00001866  4E75                     904              RTS
00001868                           905   
00001868                           906  *---------------------------------------------------------------------------*
00001868                           907  * OP_ORI : decode ORI and its size
00001868                           908  *---------------------------------------------------------------------------* 
00001868                           909  OP_ORI      
00001868                           910           
00001868                           911   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001868  13FC 0000 0000485C       912             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001870  13FC 0082 0000485D       913             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001878                           914             
00001878                           915             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001878  13FC 00B9 0000485F       916             MOVE.B   #$B9,GET_DST_START_END
00001880  13FC 0020 00004860       917             MOVE.B   #$20,GET_SRC_START_END
00001888                           918             
00001888                           919              *CLEAR D3
00001888  4283                     920              CLR.L   D3
0000188A                           921              *LOAD STACK WITH THIS OPMODE
0000188A  6100 26AA                922              BSR     PUSH_STACK
0000188E  163C 004F                923              MOVE.B  #'O',D3
00001892  6100 26A2                924              BSR     PUSH_STACK
00001896  163C 0052                925              MOVE.B  #'R',D3
0000189A  6100 269A                926              BSR     PUSH_STACK
0000189E  163C 0049                927              MOVE.B  #'I',D3
000018A2  6100 2692                928              BSR     PUSH_STACK
000018A6  163C 002E                929              MOVE.B  #'.',D3
000018AA  6100 268A                930              BSR     PUSH_STACK
000018AE                           931              
000018AE                           932              *FIGURE OUT SIZE*
000018AE                           933              *00 = BYTE
000018AE                           934              *01 = WORD
000018AE                           935              *10 = LONG
000018AE                           936              * BITS 7&6
000018AE                           937              
000018AE                           938              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018AE  2205                     939              MOVE.L  D5,D1
000018B0  EC99                     940              ROR.L   #6,D1
000018B2  0281 00000003            941              ANDI.L  #$03,D1
000018B8  0C01 0000                942              CMPI.B  #%00,D1
000018BC  6700 0018                943              BEQ     OP0000_ORI_B
000018C0  0C01 0001                944              CMPI.B  #%01,D1
000018C4  6700 0038                945              BEQ     OP0000_ORI_W
000018C8  0281 00000003            946              ANDI.L  #$03,D1
000018CE  0C01 0002                947              CMPI.B  #%10,D1
000018D2  6700 0052                948              BEQ     OP0000_ORI_L
000018D6                           949  
000018D6                           950  OP0000_ORI_B
000018D6  163C 0042                951              MOVE.B  #'B',D3
000018DA  6100 265A                952              BSR     PUSH_STACK
000018DE                           953  *GET DATA FROM ADDQ AND PRINT #0-8
000018DE                           954              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000018DE  0285 0000F03F            955              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000018E4  0685 000001C0            956              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000018EA  6100 21DC                957              BSR     GET_EA_EA_DEST
000018EE  163C 002C                958              MOVE.B  #',',D3
000018F2  6100 2642                959              BSR     PUSH_STACK
000018F6  6100 1DA0                960              BSR     GET_EA_EA_SRC
000018FA  6000 004E                961              BRA     OP0000_RETURN_ORI
000018FE                           962  
000018FE                           963  OP0000_ORI_W
000018FE  163C 0057                964              MOVE.B  #'W',D3
00001902  6100 2632                965              BSR     PUSH_STACK
00001906                           966  *GET DATA FROM ADDQ AND PRINT #0-8
00001906                           967              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001906  0285 0000F03F            968              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000190C  0685 000001C0            969              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001912  6100 21B4                970              BSR     GET_EA_EA_DEST
00001916  163C 002C                971              MOVE.B  #',',D3
0000191A  6100 261A                972              BSR     PUSH_STACK
0000191E  6100 1D78                973              BSR     GET_EA_EA_SRC
00001922  6000 0026                974              BRA     OP0000_RETURN_ORI
00001926                           975  
00001926                           976  OP0000_ORI_L
00001926  163C 004C                977              MOVE.B  #'L',D3
0000192A  6100 260A                978              BSR     PUSH_STACK
0000192E                           979              *GET DATA FROM ADDQ AND PRINT #0-8
0000192E                           980              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000192E  0285 0000F03F            981              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001934  0685 000003C0            982              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000193A  6100 218C                983              BSR     GET_EA_EA_DEST
0000193E  163C 002C                984              MOVE.B  #',',D3
00001942  6100 25F2                985              BSR     PUSH_STACK
00001946  6100 1D50                986              BSR     GET_EA_EA_SRC
0000194A                           987              
0000194A                           988  OP0000_RETURN_ORI
0000194A                           989  
0000194A                           990  
0000194A                           991              
0000194A  4E75                     992              RTS
0000194C                           993  
0000194C                           994          
0000194C                           995  *---------------------------------------------------------------------------*
0000194C                           996  * OP0001: MOVE.B
0000194C                           997  *---------------------------------------------------------------------------*
0000194C                           998  OP0001      
0000194C  4EF9 00001952            999              JMP     OP_MOVE_B   * display MOVE.B
00001952                          1000              
00001952                          1001  *---------------------------------------------------------------------------*
00001952                          1002  * OP_MOVE_B: display MOVE_B and proceed to EA
00001952                          1003  *---------------------------------------------------------------------------*
00001952                          1004  OP_MOVE_B                                                                       
00001952                          1005             
00001952                          1006             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001952  13FC 0082 0000485C      1007             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000195A  13FC 0000 0000485D      1008             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001962                          1009             
00001962                          1010             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001962  13FC 00B9 0000485F      1011             MOVE.B   #$B9,GET_DST_START_END
0000196A  13FC 0020 00004860      1012             MOVE.B   #$20,GET_SRC_START_END
00001972                          1013             
00001972                          1014              *CLEAR D3
00001972  4283                    1015              CLR.L   D3
00001974                          1016              *LOAD STACK WITH THIS OPMODE
00001974  6100 25C0               1017              BSR     PUSH_STACK
00001978  163C 004D               1018              MOVE.B  #'M',D3
0000197C  6100 25B8               1019              BSR     PUSH_STACK
00001980  163C 004F               1020              MOVE.B  #'O',D3
00001984  6100 25B0               1021              BSR     PUSH_STACK
00001988  163C 0056               1022              MOVE.B  #'V',D3
0000198C  6100 25A8               1023              BSR     PUSH_STACK
00001990  163C 0045               1024              MOVE.B  #'E',D3
00001994  6100 25A0               1025              BSR     PUSH_STACK
00001998  163C 002E               1026              MOVE.B  #'.',D3
0000199C  6100 2598               1027              BSR     PUSH_STACK
000019A0  163C 0042               1028              MOVE.B  #'B',D3
000019A4  6100 2590               1029              BSR     PUSH_STACK
000019A8                          1030              
000019A8  6100 1CEE               1031              BSR     GET_EA_EA_SRC
000019AC  163C 002C               1032              MOVE.B  #',',D3
000019B0  6100 2584               1033              BSR     PUSH_STACK
000019B4  6100 2112               1034              BSR     GET_EA_EA_DEST
000019B8                          1035              
000019B8  4E75                    1036              RTS
000019BA                          1037              
000019BA                          1038             
000019BA                          1039  *---------------------------------------------------------------------------*
000019BA                          1040  * OP0010: decode MOVE.L/MOVEA.L
000019BA                          1041  *---------------------------------------------------------------------------*
000019BA                          1042  OP0010      
000019BA  183C 0002               1043              MOVE.B  #2,D4
000019BE  4280                    1044              CLR.L   D0                     
000019C0  4281                    1045              CLR.L   D1                      
000019C2  227C 00000000           1046              MOVEA.L #0, A1                 
000019C8                          1047              
000019C8  2205                    1048              MOVE.L  D5,D1
000019CA  EA99                    1049              ROR.L   #5,D1
000019CC  0281 0000000E           1050              ANDI.L  #$E,D1
000019D2  0C01 0002               1051              CMPI.B  #2,D1
000019D6  6700 0070               1052              BEQ     OP_MOVEA_L
000019DA                          1053  
000019DA  4EF9 000019E0           1054              JMP     OP_MOVE_L
000019E0                          1055             
000019E0                          1056  
000019E0                          1057  *---------------------------------------------------------------------------*
000019E0                          1058  * OP_MOVE_L: display MOVE_L and proceed to EA
000019E0                          1059  *---------------------------------------------------------------------------*
000019E0                          1060  OP_MOVE_L   
000019E0                          1061             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019E0  13FC 0082 0000485C      1062             MOVE.B   #$82,DEST_REGISTER_FORMAT
000019E8  13FC 0000 0000485D      1063             MOVE.B   #$00,SRC_REGISTER_FORMAT
000019F0                          1064             
000019F0                          1065             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000019F0  13FC 00B9 0000485F      1066             MOVE.B   #$B9,GET_DST_START_END
000019F8  13FC 0020 00004860      1067             MOVE.B   #$20,GET_SRC_START_END
00001A00                          1068             
00001A00                          1069              *CLEAR D3
00001A00  4283                    1070              CLR.L   D3
00001A02                          1071              *LOAD STACK WITH THIS OPMODE
00001A02  6100 2532               1072              BSR     PUSH_STACK
00001A06  163C 004D               1073              MOVE.B  #'M',D3
00001A0A  6100 252A               1074              BSR     PUSH_STACK
00001A0E  163C 004F               1075              MOVE.B  #'O',D3
00001A12  6100 2522               1076              BSR     PUSH_STACK
00001A16  163C 0056               1077              MOVE.B  #'V',D3
00001A1A  6100 251A               1078              BSR     PUSH_STACK
00001A1E  163C 0045               1079              MOVE.B  #'E',D3
00001A22  6100 2512               1080              BSR     PUSH_STACK
00001A26  163C 002E               1081              MOVE.B  #'.',D3
00001A2A  6100 250A               1082              BSR     PUSH_STACK
00001A2E  163C 004C               1083              MOVE.B  #'L',D3
00001A32  6100 2502               1084              BSR     PUSH_STACK
00001A36                          1085              
00001A36  6100 1C60               1086              BSR     GET_EA_EA_SRC
00001A3A  163C 002C               1087              MOVE.B  #',',D3
00001A3E  6100 24F6               1088              BSR     PUSH_STACK
00001A42  6100 2084               1089              BSR     GET_EA_EA_DEST
00001A46                          1090              
00001A46  4E75                    1091              RTS
00001A48                          1092  
00001A48                          1093  
00001A48                          1094  *---------------------------------------------------------------------------*
00001A48                          1095  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A48                          1096  *---------------------------------------------------------------------------*
00001A48                          1097  OP_MOVEA_L 
00001A48                          1098             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A48  13FC 00FD 0000485C      1099             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A50  13FC 0000 0000485D      1100             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A58                          1101             
00001A58                          1102             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A58  13FC 00B9 0000485F      1103             MOVE.B   #$B9,GET_DST_START_END
00001A60  13FC 0020 00004860      1104             MOVE.B   #$20,GET_SRC_START_END
00001A68                          1105             
00001A68                          1106              *CLEAR D3
00001A68  4283                    1107              CLR.L   D3
00001A6A                          1108              *LOAD STACK WITH THIS OPMODE
00001A6A  6100 24CA               1109              BSR     PUSH_STACK
00001A6E  163C 004D               1110              MOVE.B  #'M',D3
00001A72  6100 24C2               1111              BSR     PUSH_STACK
00001A76  163C 004F               1112              MOVE.B  #'O',D3
00001A7A  6100 24BA               1113              BSR     PUSH_STACK
00001A7E  163C 0056               1114              MOVE.B  #'V',D3
00001A82  6100 24B2               1115              BSR     PUSH_STACK
00001A86  163C 0045               1116              MOVE.B  #'E',D3
00001A8A  6100 24AA               1117              BSR     PUSH_STACK           
00001A8E  163C 0041               1118              MOVE.B  #'A',D3
00001A92  6100 24A2               1119              BSR     PUSH_STACK
00001A96  163C 002E               1120              MOVE.B  #'.',D3
00001A9A  6100 249A               1121              BSR     PUSH_STACK
00001A9E  163C 004C               1122              MOVE.B  #'L',D3
00001AA2  6100 2492               1123              BSR     PUSH_STACK
00001AA6                          1124              
00001AA6  6100 1BF0               1125              BSR     GET_EA_EA_SRC
00001AAA  163C 002C               1126              MOVE.B  #',',D3
00001AAE  6100 2486               1127              BSR     PUSH_STACK
00001AB2  6100 2014               1128              BSR     GET_EA_EA_DEST
00001AB6                          1129              
00001AB6  4E75                    1130              RTS
00001AB8                          1131  
00001AB8                          1132              
00001AB8                          1133  *---------------------------------------------------------------------------*
00001AB8                          1134  * OP0011: decode MOVE.W/MOVEA.W
00001AB8                          1135  *---------------------------------------------------------------------------*
00001AB8                          1136  OP0011      
00001AB8  4280                    1137              CLR.L   D0                      
00001ABA  4281                    1138              CLR.L   D1  
00001ABC  4284                    1139              CLR.L   D4                   
00001ABE  227C 00000000           1140              MOVEA.L #0, A1 
00001AC4                          1141                
00001AC4  2205                    1142              MOVE.L  D5,D1
00001AC6  EC99                    1143              ROR.L   #6,D1
00001AC8  0281 00000007           1144              ANDI.L  #$07,D1
00001ACE  0C01 0001               1145              CMPI.B  #1,D1
00001AD2  6700 0070               1146              BEQ     OP_MOVEA_W
00001AD6                          1147              
00001AD6  4EF9 00001ADC           1148              JMP     OP_MOVE_W
00001ADC                          1149            
00001ADC                          1150  *---------------------------------------------------------------------------*
00001ADC                          1151  * OP_MOVE_W: display MOVE_W and proceed to EA
00001ADC                          1152  *---------------------------------------------------------------------------*
00001ADC                          1153  OP_MOVE_W   
00001ADC                          1154             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001ADC  13FC 0082 0000485C      1155             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001AE4  13FC 0000 0000485D      1156             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001AEC                          1157             
00001AEC                          1158             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001AEC  13FC 00B9 0000485F      1159             MOVE.B   #$B9,GET_DST_START_END
00001AF4  13FC 0020 00004860      1160             MOVE.B   #$20,GET_SRC_START_END
00001AFC                          1161             
00001AFC                          1162              *CLEAR D3
00001AFC  4283                    1163              CLR.L   D3
00001AFE                          1164              *LOAD STACK WITH THIS OPMODE
00001AFE  6100 2436               1165              BSR     PUSH_STACK
00001B02  163C 004D               1166              MOVE.B  #'M',D3
00001B06  6100 242E               1167              BSR     PUSH_STACK
00001B0A  163C 004F               1168              MOVE.B  #'O',D3
00001B0E  6100 2426               1169              BSR     PUSH_STACK
00001B12  163C 0056               1170              MOVE.B  #'V',D3
00001B16  6100 241E               1171              BSR     PUSH_STACK
00001B1A  163C 0045               1172              MOVE.B  #'E',D3
00001B1E  6100 2416               1173              BSR     PUSH_STACK
00001B22  163C 002E               1174              MOVE.B  #'.',D3
00001B26  6100 240E               1175              BSR     PUSH_STACK
00001B2A  163C 0057               1176              MOVE.B  #'W',D3
00001B2E  6100 2406               1177              BSR     PUSH_STACK
00001B32                          1178              
00001B32  6100 1B64               1179              BSR     GET_EA_EA_SRC
00001B36  163C 002C               1180              MOVE.B  #',',D3
00001B3A  6100 23FA               1181              BSR     PUSH_STACK
00001B3E  6100 1F88               1182              BSR     GET_EA_EA_DEST
00001B42                          1183              
00001B42  4E75                    1184              RTS
00001B44                          1185  
00001B44                          1186  *---------------------------------------------------------------------------*
00001B44                          1187  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B44                          1188  *---------------------------------------------------------------------------*
00001B44                          1189  OP_MOVEA_W 
00001B44                          1190             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B44  13FC 00FD 0000485C      1191             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B4C  13FC 0000 0000485D      1192             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B54                          1193             
00001B54                          1194             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B54  13FC 00B9 0000485F      1195             MOVE.B   #$B9,GET_DST_START_END
00001B5C  13FC 0020 00004860      1196             MOVE.B   #$20,GET_SRC_START_END
00001B64                          1197             
00001B64                          1198              *CLEAR D3
00001B64  4283                    1199              CLR.L   D3
00001B66                          1200              *LOAD STACK WITH THIS OPMODE
00001B66  6100 23CE               1201              BSR     PUSH_STACK
00001B6A  163C 004D               1202              MOVE.B  #'M',D3
00001B6E  6100 23C6               1203              BSR     PUSH_STACK
00001B72  163C 004F               1204              MOVE.B  #'O',D3
00001B76  6100 23BE               1205              BSR     PUSH_STACK
00001B7A  163C 0056               1206              MOVE.B  #'V',D3
00001B7E  6100 23B6               1207              BSR     PUSH_STACK
00001B82  163C 0045               1208              MOVE.B  #'E',D3
00001B86  6100 23AE               1209              BSR     PUSH_STACK           
00001B8A  163C 0041               1210              MOVE.B  #'A',D3
00001B8E  6100 23A6               1211              BSR     PUSH_STACK
00001B92  163C 002E               1212              MOVE.B  #'.',D3
00001B96  6100 239E               1213              BSR     PUSH_STACK
00001B9A  163C 0057               1214              MOVE.B  #'W',D3
00001B9E  6100 2396               1215              BSR     PUSH_STACK
00001BA2                          1216              
00001BA2  6100 1AF4               1217              BSR     GET_EA_EA_SRC
00001BA6  163C 002C               1218              MOVE.B  #',',D3
00001BAA  6100 238A               1219              BSR     PUSH_STACK
00001BAE  6100 1F18               1220              BSR     GET_EA_EA_DEST
00001BB2                          1221            
00001BB2  4E75                    1222              RTS
00001BB4                          1223  *---------------------------------------------------------------------------*
00001BB4                          1224  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BB4                          1225  *---------------------------------------------------------------------------*
00001BB4                          1226  OP0100
00001BB4  4280                    1227              CLR.L   D0                      
00001BB6  4281                    1228              CLR.L   D1  
00001BB8  4284                    1229              CLR.L   D4                      
00001BBA  227C 00000000           1230              MOVEA.L #0, A1                  
00001BC0  2205                    1231              MOVE.L  D5,D1  
00001BC2                          1232              
00001BC2                          1233              * check for RTS
00001BC2  0C41 4E75               1234              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BC6  6700 0228               1235              BEQ     OP_RTS
00001BCA                          1236              
00001BCA                          1237              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BCA  4281                    1238              CLR.L   D1 
00001BCC  2205                    1239              MOVE.L  D5,D1  
00001BCE  0241 0F00               1240              ANDI.W  #$0F00,D1
00001BD2  0C41 0E00               1241              CMPI.W  #$0E00,D1
00001BD6  6700 0204               1242              BEQ     OP_JSR
00001BDA                          1243  
00001BDA                          1244              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001BDA  4281                    1245              CLR.L   D1 
00001BDC  2205                    1246              MOVE.L  D5,D1  
00001BDE  0241 0F00               1247              ANDI.W  #$0F00,D1
00001BE2  0C41 0400               1248              CMPI.W  #$0400,D1
00001BE6  6700 00E8               1249              BEQ     OP_NEG
00001BEA                          1250              
00001BEA                          1251              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001BEA  4281                    1252              CLR.L   D1 
00001BEC  2205                    1253              MOVE.L  D5,D1  
00001BEE  0241 0F00               1254              ANDI.W  #$0F00,D1
00001BF2  0C41 0600               1255              CMPI.W  #$0600,D1
00001BF6  6700 015E               1256              BEQ     OP_NOT
00001BFA                          1257              
00001BFA                          1258              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001BFA  4281                    1259              CLR.L   D1 
00001BFC  2205                    1260              MOVE.L  D5,D1  
00001BFE  EC99                    1261              ROR.L   #6,D1
00001C00  0281 00000007           1262              ANDI.L  #7,D1
00001C06  0C81 00000007           1263              CMPI.L  #7,D1
00001C0C  6700 0054               1264              BEQ     OP_LEA
00001C10                          1265              
00001C10                          1266              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C10  4281                    1267              CLR.L   D1 
00001C12  2205                    1268              MOVE.L  D5,D1  
00001C14  EB59                    1269              ROL.W   #5,D1
00001C16  0C01 0001               1270              CMPI.B  #1,D1
00001C1A  6600 FB14               1271              BNE     OP_DATA
00001C1E  E959                    1272              ROL.W   #4,D1
00001C20  0C01 0001               1273              CMPI.B  #1,D1
00001C24  6600 FB0A               1274              BNE     OP_DATA
00001C28  E359                    1275              ROL.W   #1,D1
00001C2A  0C01 0000               1276              CMPI.B  #0,D1
00001C2E  6700 000E               1277              BEQ     OP_MOVEM_W
00001C32  0C01 0001               1278              CMPI.B  #1,D1
00001C36  6700 0018               1279              BEQ     OP_MOVEM_L
00001C3A  4EF8 1730               1280              JMP     OP_DATA
00001C3E                          1281  
00001C3E                          1282  *---------------------------------------------------------------------------*
00001C3E                          1283  * OP_MOVEM_W: display MOVEM_W
00001C3E                          1284  *---------------------------------------------------------------------------*    
00001C3E                          1285  OP_MOVEM_W  
00001C3E  183C 0001               1286              MOVE.B  #1,D4
00001C42  43F9 0000461B           1287              LEA     DISP_MOVEM_W,A1
00001C48  103C 000E               1288              MOVE.B  #14,D0
00001C4C  4E4F                    1289              TRAP    #15
00001C4E  4E75                    1290              RTS
00001C50                          1291  
00001C50                          1292  *---------------------------------------------------------------------------*
00001C50                          1293  * OP_MOVEM_L: display MOVEM_L
00001C50                          1294  *---------------------------------------------------------------------------*
00001C50                          1295  OP_MOVEM_L  
00001C50  183C 0002               1296              MOVE.B  #2,D4
00001C54  43F9 00004626           1297              LEA     DISP_MOVEM_L,A1
00001C5A  103C 000E               1298              MOVE.B  #14,D0
00001C5E  4E4F                    1299              TRAP    #15
00001C60  4E75                    1300              RTS
00001C62                          1301     
00001C62                          1302  *---------------------------------------------------------------------------*
00001C62                          1303  * OP_LEA: decode and display LEA
00001C62                          1304  *---------------------------------------------------------------------------*
00001C62                          1305  OP_LEA      
00001C62  4281                    1306               CLR.L   D1       
00001C64  4284                    1307              CLR.L   D4                   
00001C66  227C 00000000           1308              MOVEA.L #0, A1              
00001C6C  2205                    1309              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C6E                          1310              *CLEAR D3
00001C6E  4283                    1311              CLR.L   D3
00001C70                          1312  
00001C70                          1313  OP_LEA_DN_EA_OR_EA_DN 
00001C70                          1314              *LOAD STACK WITH THIS OPMODE
00001C70  6100 22C4               1315              BSR     PUSH_STACK
00001C74  163C 004C               1316              MOVE.B  #'L',D3
00001C78  6100 22BC               1317              BSR     PUSH_STACK
00001C7C  163C 0045               1318              MOVE.B  #'E',D3
00001C80  6100 22B4               1319              BSR     PUSH_STACK
00001C84  163C 0041               1320              MOVE.B  #'A',D3
00001C88  6100 22AC               1321              BSR     PUSH_STACK
00001C8C  2205                    1322              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001C8E                          1323          
00001C8E                          1324  
00001C8E                          1325  OP_PRINT_L_LEA
00001C8E                          1326                          
00001C8E                          1327              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C8E  13FC 0000 0000485C      1328              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C96  13FC 009B 0000485D      1329              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C9E                          1330             
00001C9E                          1331              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C9E  13FC 00B9 0000485F      1332              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CA6  13FC 0020 00004860      1333              MOVE.B   #$20,GET_SRC_START_END
00001CAE                          1334  
00001CAE                          1335              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CAE  0285 0000FE3F           1336              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CB4  0685 00000040           1337              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CBA                          1338  
00001CBA  6100 19DC               1339              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CBE  163C 002C               1340              MOVE.B  #',',D3
00001CC2  6100 2272               1341              BSR     PUSH_STACK           
00001CC6  6100 1E00               1342              BSR     GET_EA_EA_DEST       *GETS Dn    
00001CCA                          1343  
00001CCA                          1344              
00001CCA  6000 0002               1345              BRA     OP_LEA_RETURN
00001CCE                          1346              
00001CCE                          1347  OP_LEA_RETURN
00001CCE  4E75                    1348              RTS
00001CD0                          1349              
00001CD0                          1350  
00001CD0                          1351  
00001CD0                          1352  *---------------------------------------------------------------------------*
00001CD0                          1353  * OP_NEG: decode and display NEG 
00001CD0                          1354  *---------------------------------------------------------------------------*
00001CD0                          1355  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001CD0  4281                    1356              CLR.L   D1
00001CD2  4284                    1357              CLR.L   D4
00001CD4  2205                    1358              MOVE.L  D5,D1
00001CD6                          1359              
00001CD6                          1360              *CLEAR D3
00001CD6  4283                    1361              CLR.L   D3
00001CD8                          1362              *LOAD STACK WITH THIS OPMODE
00001CD8  6100 225C               1363              BSR     PUSH_STACK
00001CDC  163C 004E               1364              MOVE.B  #'N',D3
00001CE0  6100 2254               1365              BSR     PUSH_STACK
00001CE4  163C 0045               1366              MOVE.B  #'E',D3
00001CE8  6100 224C               1367              BSR     PUSH_STACK
00001CEC  163C 0047               1368              MOVE.B  #'G',D3
00001CF0  6100 2244               1369              BSR     PUSH_STACK
00001CF4  163C 002E               1370              MOVE.B  #'.',D3
00001CF8  6100 223C               1371              BSR     PUSH_STACK
00001CFC                          1372              
00001CFC                          1373              
00001CFC  EC99                    1374              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001CFE  0281 00000007           1375              ANDI.L  #$07,D1
00001D04                          1376              
00001D04  0C01 0000               1377              CMPI.B  #0,D1
00001D08  6700 0012               1378              BEQ     OP_NEG_B    * size is byte
00001D0C  0C01 0001               1379              CMPI.B  #1,D1
00001D10  6700 0016               1380              BEQ     OP_NEG_W    * size is word
00001D14  0C01 0002               1381              CMPI.B  #2,D1
00001D18  6700 001A               1382              BEQ     OP_NEG_L    * size is long
00001D1C                          1383                         
00001D1C                          1384  
00001D1C                          1385  OP_NEG_B    * size is byte   
00001D1C  163C 0042               1386              MOVE.B  #'B',D3
00001D20  6100 2214               1387              BSR     PUSH_STACK
00001D24  6000 001A               1388              BRA     OP_NEG_PRINT_EA
00001D28                          1389  
00001D28                          1390              
00001D28                          1391  OP_NEG_W    * size is word
00001D28  163C 0057               1392              MOVE.B  #'W',D3
00001D2C  6100 2208               1393              BSR     PUSH_STACK
00001D30  6000 000E               1394              BRA     OP_NEG_PRINT_EA
00001D34                          1395  
00001D34                          1396              
00001D34                          1397  OP_NEG_L    * size is long
00001D34  163C 004C               1398              MOVE.B  #'L',D3
00001D38  6100 21FC               1399              BSR     PUSH_STACK
00001D3C  6000 0002               1400              BRA     OP_NEG_PRINT_EA
00001D40                          1401  
00001D40                          1402  
00001D40                          1403  OP_NEG_PRINT_EA
00001D40                          1404   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D40  13FC 0082 0000485D      1405             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D48                          1406             
00001D48                          1407             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D48  13FC 0020 00004860      1408             MOVE.B   #$20,GET_SRC_START_END
00001D50                          1409                         
00001D50                          1410  
00001D50  6100 1946               1411              BSR     GET_EA_EA_SRC
00001D54                          1412              
00001D54  4E75                    1413              RTS
00001D56                          1414  
00001D56                          1415  *---------------------------------------------------------------------------*
00001D56                          1416  * OP_NOT: decode and display NOT 
00001D56                          1417  *---------------------------------------------------------------------------*
00001D56                          1418  OP_NOT
00001D56  4281                    1419              CLR.L   D1
00001D58  4284                    1420              CLR.L   D4
00001D5A  2205                    1421              MOVE.L  D5,D1
00001D5C                          1422              
00001D5C                          1423              *CLEAR D3
00001D5C  4283                    1424              CLR.L   D3
00001D5E                          1425              *LOAD STACK WITH THIS OPMODE
00001D5E  6100 21D6               1426              BSR     PUSH_STACK
00001D62  163C 004E               1427              MOVE.B  #'N',D3
00001D66  6100 21CE               1428              BSR     PUSH_STACK
00001D6A  163C 004F               1429              MOVE.B  #'O',D3
00001D6E  6100 21C6               1430              BSR     PUSH_STACK
00001D72  163C 0054               1431              MOVE.B  #'T',D3
00001D76  6100 21BE               1432              BSR     PUSH_STACK
00001D7A  163C 002E               1433              MOVE.B  #'.',D3
00001D7E  6100 21B6               1434              BSR     PUSH_STACK
00001D82                          1435              
00001D82                          1436              
00001D82  EC99                    1437              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D84  0281 00000007           1438              ANDI.L  #$07,D1
00001D8A                          1439              
00001D8A  0C01 0000               1440              CMPI.B  #0,D1
00001D8E  6700 0012               1441              BEQ     OP_NOT_B    * size is byte
00001D92  0C01 0001               1442              CMPI.B  #1,D1
00001D96  6700 0016               1443              BEQ     OP_NOT_W    * size is word
00001D9A  0C01 0002               1444              CMPI.B  #2,D1
00001D9E  6700 001A               1445              BEQ     OP_NOT_L    * size is long
00001DA2                          1446                         
00001DA2                          1447  
00001DA2                          1448  OP_NOT_B    * size is byte   
00001DA2  163C 0042               1449              MOVE.B  #'B',D3
00001DA6  6100 218E               1450              BSR     PUSH_STACK
00001DAA  6000 001A               1451              BRA     OP_NOT_PRINT_EA
00001DAE                          1452  
00001DAE                          1453              
00001DAE                          1454  OP_NOT_W    * size is word
00001DAE  163C 0057               1455              MOVE.B  #'W',D3
00001DB2  6100 2182               1456              BSR     PUSH_STACK
00001DB6  6000 000E               1457              BRA     OP_NOT_PRINT_EA
00001DBA                          1458  
00001DBA                          1459              
00001DBA                          1460  OP_NOT_L    * size is long
00001DBA  163C 004C               1461              MOVE.B  #'L',D3
00001DBE  6100 2176               1462              BSR     PUSH_STACK
00001DC2  6000 0002               1463              BRA     OP_NOT_PRINT_EA
00001DC6                          1464  
00001DC6                          1465  
00001DC6                          1466  OP_NOT_PRINT_EA
00001DC6                          1467   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DC6  13FC 0082 0000485D      1468             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001DCE                          1469             
00001DCE                          1470             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DCE  13FC 0020 00004860      1471             MOVE.B   #$20,GET_SRC_START_END
00001DD6  6100 18C0               1472              BSR     GET_EA_EA_SRC
00001DDA                          1473              
00001DDA  4E75                    1474              RTS
00001DDC                          1475  
00001DDC                          1476  
00001DDC                          1477  *---------------------------------------------------------------------------*
00001DDC                          1478  * OP_JSR: display JSR     
00001DDC                          1479  *---------------------------------------------------------------------------*
00001DDC  43F9 000045D7           1480  OP_JSR      LEA     DISP_JSR,A1
00001DE2  103C 000E               1481              MOVE.B  #14,D0
00001DE6  4E4F                    1482              TRAP    #15
00001DE8  4EB9 000031E8           1483              JSR     EA_NOSRC
00001DEE                          1484  
00001DEE  4E75                    1485              RTS
00001DF0                          1486  
00001DF0                          1487  *---------------------------------------------------------------------------*
00001DF0                          1488  * OP_RTS: display RTS     
00001DF0                          1489  *---------------------------------------------------------------------------* 
00001DF0                          1490  OP_RTS      
00001DF0  163C 0052               1491              MOVE.B #'R',D3
00001DF4  6100 2140               1492              BSR     PUSH_STACK
00001DF8  163C 0054               1493              MOVE.B #'T',D3
00001DFC  6100 2138               1494              BSR     PUSH_STACK
00001E00  163C 0053               1495              MOVE.B #'S',D3
00001E04  6100 2130               1496              BSR     PUSH_STACK
00001E08  4E75                    1497              RTS
00001E0A                          1498  
00001E0A                          1499  *---------------------------------------------------------------------------*
00001E0A                          1500  * OP0101: decode ADDQ
00001E0A                          1501  *---------------------------------------------------------------------------* 
00001E0A                          1502  OP0101      
00001E0A                          1503             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E0A  13FC 0082 0000485C      1504             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E12  13FC 0080 0000485D      1505             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E1A                          1506             
00001E1A                          1507             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E1A  13FC 00B9 0000485F      1508             MOVE.B   #$B9,GET_DST_START_END
00001E22  13FC 0020 00004860      1509             MOVE.B   #$20,GET_SRC_START_END
00001E2A                          1510             
00001E2A                          1511              *CLEAR D3
00001E2A  4283                    1512              CLR.L   D3
00001E2C                          1513              *LOAD STACK WITH THIS OPMODE
00001E2C  6100 2108               1514              BSR     PUSH_STACK
00001E30  163C 0041               1515              MOVE.B  #'A',D3
00001E34  6100 2100               1516              BSR     PUSH_STACK
00001E38  163C 0044               1517              MOVE.B  #'D',D3
00001E3C  6100 20F8               1518              BSR     PUSH_STACK
00001E40  163C 0044               1519              MOVE.B  #'D',D3
00001E44  6100 20F0               1520              BSR     PUSH_STACK
00001E48  163C 0051               1521              MOVE.B  #'Q',D3
00001E4C  6100 20E8               1522              BSR     PUSH_STACK
00001E50  163C 002E               1523              MOVE.B  #'.',D3
00001E54  6100 20E0               1524              BSR     PUSH_STACK
00001E58                          1525              
00001E58                          1526              *FIGURE OUT SIZE*
00001E58                          1527              *00 = BYTE
00001E58                          1528              *01 = WORD
00001E58                          1529              *10 = LONG
00001E58                          1530              * BITS 7&6
00001E58                          1531              
00001E58                          1532              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E58  2205                    1533              MOVE.L  D5,D1
00001E5A  EC99                    1534              ROR.L   #6,D1
00001E5C  0281 00000003           1535              ANDI.L  #$03,D1
00001E62  0C01 0000               1536              CMPI.B  #%00,D1
00001E66  6700 001E               1537              BEQ     OP0101_ADDQ_B
00001E6A  0281 00000003           1538              ANDI.L  #$03,D1
00001E70  0C01 0001               1539              CMPI.B  #%01,D1
00001E74  6700 001C               1540              BEQ     OP0101_ADDQ_W
00001E78  0281 00000003           1541              ANDI.L  #$03,D1
00001E7E  0C01 0002               1542              CMPI.B  #%10,D1
00001E82  6700 001A               1543              BEQ     OP0101_ADDQ_L
00001E86                          1544            
00001E86                          1545  OP0101_ADDQ_B
00001E86                          1546              
00001E86  163C 0042               1547              MOVE.B  #'B',D3
00001E8A  6100 20AA               1548              BSR     PUSH_STACK
00001E8E  6000 0016               1549              BRA     OP0101_RETURN
00001E92                          1550  OP0101_ADDQ_W
00001E92                          1551              
00001E92  163C 0057               1552              MOVE.B  #'W',D3
00001E96  6100 209E               1553              BSR     PUSH_STACK
00001E9A  6000 000A               1554              BRA     OP0101_RETURN
00001E9E                          1555  OP0101_ADDQ_L
00001E9E                          1556              
00001E9E  163C 004C               1557              MOVE.B  #'L',D3
00001EA2  6100 2092               1558              BSR     PUSH_STACK
00001EA6                          1559  OP0101_RETURN            
00001EA6                          1560  
00001EA6                          1561              
00001EA6                          1562  *GET DATA FROM ADDQ AND PRINT #0-8
00001EA6  163C 0020               1563              MOVE.B  #' ',D3
00001EAA  6100 208A               1564              BSR     PUSH_STACK
00001EAE  163C 0023               1565              MOVE.B  #'#',D3
00001EB2  6100 2082               1566              BSR     PUSH_STACK 
00001EB6                          1567  
00001EB6                          1568                       
00001EB6                          1569              *GET DATA #   
00001EB6  2205                    1570              MOVE.L  D5,D1
00001EB8  EC99                    1571              ROR.L   #6,D1            
00001EBA  E699                    1572              ROR.L   #3,D1
00001EBC  0281 00000007           1573              ANDI.L  #$07,D1
00001EC2                          1574              
00001EC2  0C01 0000               1575              CMPI.B  #%000,D1
00001EC6  6700 009A               1576              BEQ     OP0101_ADDQ_B_8
00001ECA  0C01 0001               1577              CMPI.B  #%001,D1
00001ECE  6700 003E               1578              BEQ     OP0101_ADDQ_B_1
00001ED2  0C01 0002               1579              CMPI.B  #%010,D1
00001ED6  6700 0042               1580              BEQ     OP0101_ADDQ_B_2
00001EDA  0C01 0003               1581              CMPI.B  #%011,D1
00001EDE  6700 0046               1582              BEQ     OP0101_ADDQ_B_3
00001EE2  0C01 0004               1583              CMPI.B  #%100,D1
00001EE6  6700 004A               1584              BEQ     OP0101_ADDQ_B_4
00001EEA  0C01 0005               1585              CMPI.B  #%101,D1
00001EEE  6700 004E               1586              BEQ     OP0101_ADDQ_B_5
00001EF2  0C01 0006               1587              CMPI.B  #%110,D1
00001EF6  6700 0052               1588              BEQ     OP0101_ADDQ_B_6
00001EFA  0C01 0007               1589              CMPI.B  #%111,D1
00001EFE  6700 0056               1590              BEQ     OP0101_ADDQ_B_7
00001F02                          1591              
00001F02                          1592  OP0101_ADDQ_B_0
00001F02  163C 0030               1593              MOVE.B  #'0',D3
00001F06  6100 202E               1594              BSR     PUSH_STACK
00001F0A  6000 005E               1595              BRA     OP0101_RETURN2            
00001F0E                          1596  OP0101_ADDQ_B_1
00001F0E  163C 0031               1597              MOVE.B  #'1',D3
00001F12  6100 2022               1598              BSR     PUSH_STACK
00001F16  6000 0052               1599              BRA     OP0101_RETURN2            
00001F1A                          1600  OP0101_ADDQ_B_2
00001F1A  163C 0032               1601              MOVE.B  #'2',D3
00001F1E  6100 2016               1602              BSR     PUSH_STACK
00001F22  6000 0046               1603              BRA     OP0101_RETURN2            
00001F26                          1604  OP0101_ADDQ_B_3
00001F26  163C 0033               1605              MOVE.B  #'3',D3
00001F2A  6100 200A               1606              BSR     PUSH_STACK
00001F2E  6000 003A               1607              BRA     OP0101_RETURN2            
00001F32                          1608  OP0101_ADDQ_B_4
00001F32  163C 0034               1609              MOVE.B  #'4',D3
00001F36  6100 1FFE               1610              BSR     PUSH_STACK
00001F3A  6000 002E               1611              BRA     OP0101_RETURN2            
00001F3E                          1612  OP0101_ADDQ_B_5
00001F3E  163C 0035               1613              MOVE.B  #'5',D3
00001F42  6100 1FF2               1614              BSR     PUSH_STACK
00001F46  6000 0022               1615              BRA     OP0101_RETURN2
00001F4A                          1616  OP0101_ADDQ_B_6
00001F4A  163C 0036               1617              MOVE.B  #'6',D3
00001F4E  6100 1FE6               1618              BSR     PUSH_STACK
00001F52  6000 0016               1619              BRA     OP0101_RETURN2
00001F56                          1620  OP0101_ADDQ_B_7
00001F56  163C 0037               1621              MOVE.B  #'7',D3
00001F5A  6100 1FDA               1622              BSR     PUSH_STACK
00001F5E  6000 000A               1623              BRA     OP0101_RETURN2
00001F62                          1624  
00001F62                          1625  OP0101_ADDQ_B_8
00001F62  163C 0038               1626              MOVE.B  #'8',D3
00001F66  6100 1FCE               1627              BSR     PUSH_STACK
00001F6A                          1628              
00001F6A                          1629  OP0101_RETURN2            
00001F6A  163C 002C               1630              MOVE.B  #',',D3
00001F6E  6100 1FC6               1631              BSR     PUSH_STACK
00001F72  6100 1724               1632              BSR     GET_EA_EA_SRC
00001F76                          1633              
00001F76  4E75                    1634              RTS
00001F78                          1635  
00001F78                          1636  
00001F78                          1637              
00001F78                          1638  *---------------------------------------------------------------------------*
00001F78                          1639  * OP_ADDQ: display ADDQ
00001F78                          1640  *---------------------------------------------------------------------------*              
00001F78                          1641  OP_ADDQ_B    * size is byte   
00001F78  183C 0000               1642              MOVE.B  #0,D4 
00001F7C  43F9 00004631           1643              LEA     DISP_ADDQ_B,A1
00001F82  103C 000E               1644              MOVE.B  #14,D0
00001F86  4E4F                    1645              TRAP    #15
00001F88  4E75                    1646              RTS
00001F8A                          1647              
00001F8A                          1648  OP_ADDQ_W    * size is word
00001F8A  183C 0001               1649              MOVE.B  #1,D4
00001F8E  43F9 0000463B           1650              LEA     DISP_ADDQ_W,A1
00001F94  103C 000E               1651              MOVE.B  #14,D0
00001F98  4E4F                    1652              TRAP    #15
00001F9A  4E75                    1653              RTS
00001F9C                          1654              
00001F9C                          1655  OP_ADDQ_L    * size is long
00001F9C  183C 0002               1656              MOVE.B  #2,D4
00001FA0  43F9 00004645           1657              LEA     DISP_ADDQ_L,A1
00001FA6  103C 000E               1658              MOVE.B  #14,D0
00001FAA  4E4F                    1659              TRAP    #15
00001FAC  4E75                    1660              RTS
00001FAE                          1661  
00001FAE                          1662  *---------------------------------------------------------------------------*
00001FAE                          1663  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FAE                          1664  *---------------------------------------------------------------------------*              
00001FAE  4280                    1665  OP0110      CLR.L   D0                  
00001FB0  4281                    1666              CLR.L   D1   
00001FB2  4284                    1667              CLR.L   D4                 
00001FB4  227C 00000000           1668              MOVEA.L #0,A1
00001FBA  2205                    1669              MOVE.L  D5, D1                
00001FBC  0281 000000FF           1670              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FC2  2205                    1671              MOVE.L  D5,D1                  
00001FC4  0281 00000F00           1672              ANDI.L  #$0F00,D1
00001FCA                          1673                 
00001FCA  0C41 0000               1674              CMPI.W  #$0000,D1               * Check for BRA
00001FCE  6700 0050               1675              BEQ     OP_BRA                  
00001FD2                          1676                          
00001FD2  0C41 0D00               1677              CMPI.W  #$0D00,D1               * Check for BLT
00001FD6  6700 0056               1678              BEQ     OP_BLT      
00001FDA                          1679  
00001FDA  0C41 0700               1680              CMPI.W  #$0700,D1               * Check for BEQ
00001FDE  6700 0032               1681              BEQ     OP_BEQ      
00001FE2                          1682  
00001FE2  0C41 0600               1683              CMPI.W  #$0600,D1               * Check for BNE
00001FE6  6700 001C               1684              BEQ     OP_BNE  
00001FEA                          1685              
00001FEA  0C41 0200               1686              CMPI.W  #$0200,D1               * Check for BHI
00001FEE  6700 0006               1687              BEQ     OP_BHI
00001FF2                          1688  
00001FF2  4EF8 1730               1689              JMP     OP_DATA
00001FF6                          1690              
00001FF6  43F9 00004800           1691  OP_BHI      LEA     DISP_BHI,A1             
00001FFC  103C 000E               1692              MOVE.B  #14,D0
00002000  4E4F                    1693              TRAP    #15
00002002  4E75                    1694              RTS
00002004                          1695  
00002004  43F9 000047F9           1696  OP_BNE      LEA     DISP_BNE,A1             
0000200A  103C 000E               1697              MOVE.B  #14,D0
0000200E  4E4F                    1698              TRAP    #15
00002010  4E75                    1699              RTS
00002012                          1700  
00002012  43F9 000047F2           1701  OP_BEQ      LEA     DISP_BEQ,A1             
00002018  103C 000E               1702              MOVE.B  #14,D0
0000201C  4E4F                    1703              TRAP    #15
0000201E  4E75                    1704              RTS          
00002020                          1705                          
00002020  43F9 000047E4           1706  OP_BRA      LEA     DISP_BRA,A1             
00002026  103C 000E               1707              MOVE.B  #14,D0
0000202A  4E4F                    1708              TRAP    #15
0000202C  4E75                    1709              RTS
0000202E                          1710              
0000202E  43F9 000047EB           1711  OP_BLT      LEA     DISP_BLT,A1          
00002034  103C 000E               1712              MOVE.B  #14,D0
00002038  4E4F                    1713              TRAP    #15
0000203A  4E75                    1714              RTS
0000203C                          1715     
0000203C                          1716  *---------------------------------------------------------------------------*
0000203C                          1717  * OP0111 : MOVEQ not required
0000203C                          1718  *---------------------------------------------------------------------------*           
0000203C  4EF8 1730               1719  OP0111      JMP     OP_DATA
00002040                          1720             
00002040                          1721  *---------------------------------------------------------------------------*
00002040                          1722  * OP1000 : decode DIVS
00002040                          1723  *---------------------------------------------------------------------------*           
00002040                          1724  OP1000                           
00002040  4281                    1725              CLR.L   D1       
00002042  4284                    1726              CLR.L   D4                   
00002044  227C 00000000           1727              MOVEA.L #0, A1              
0000204A  2205                    1728              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000204C                          1729              *CLEAR D3
0000204C  4283                    1730              CLR.L   D3
0000204E                          1731  
0000204E                          1732  OP1000_DIVS_DN_EA_OR_EA_DN 
0000204E                          1733              *LOAD STACK WITH THIS OPMODE
0000204E  6100 1EE6               1734              BSR     PUSH_STACK
00002052  163C 0044               1735              MOVE.B  #'D',D3
00002056  6100 1EDE               1736              BSR     PUSH_STACK
0000205A  163C 0049               1737              MOVE.B  #'I',D3
0000205E  6100 1ED6               1738              BSR     PUSH_STACK
00002062  163C 0056               1739              MOVE.B  #'V',D3
00002066  6100 1ECE               1740              BSR     PUSH_STACK
0000206A  163C 0053               1741              MOVE.B  #'S',D3
0000206E  6100 1EC6               1742              BSR     PUSH_STACK
00002072  163C 002E               1743              MOVE.B  #'.',D3
00002076  6100 1EBE               1744              BSR     PUSH_STACK
0000207A                          1745              
0000207A  2205                    1746              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000207C                          1747              
0000207C                          1748  OP1000_EA_DN_DIVS
0000207C                          1749              *BITS (7 TO 6) 
0000207C                          1750              *00 = .B
0000207C                          1751              *01 = .W
0000207C                          1752              *10 = .L 
0000207C  2205                    1753              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000207E  EC99                    1754              ROR.L   #6,D1
00002080  0281 00000003           1755              ANDI.L  #$03,D1
00002086  0C81 00000003           1756              CMPI.L  #%11,D1 *EQUALS .W
0000208C  6700 0014               1757              BEQ     OP1000_PRINT_W_DIVS
00002090  0C81 00000000           1758              CMPI.L  #%00,D1 *EQUALS .L
00002096  6700 0052               1759              BEQ     OP1000_PRINT_L_DIVS
0000209A                          1760              
0000209A  183C 0001               1761              MOVE.B  #1,D4               *ERROR READ
0000209E  6000 0092               1762              BRA     OP1000_DIVS_RETURN
000020A2                          1763  OP1000_PRINT_W_DIVS
000020A2  163C 0057               1764              MOVE.B  #'W',D3
000020A6  6100 1E8E               1765              BSR     PUSH_STACK
000020AA                          1766  
000020AA                          1767              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020AA  13FC 0000 0000485C      1768              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020B2  13FC 0000 0000485D      1769              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020BA                          1770             
000020BA                          1771              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020BA  13FC 00B9 0000485F      1772              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020C2  13FC 0020 00004860      1773              MOVE.B   #$20,GET_SRC_START_END
000020CA                          1774  
000020CA                          1775             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000020CA  0285 0000FE3F           1776              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020D0  0685 00000000           1777              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000020D6                          1778  
000020D6                          1779              
000020D6  6100 15C0               1780              BSR     GET_EA_EA_SRC      *GETS <ea>
000020DA  163C 002C               1781              MOVE.B  #',',D3
000020DE  6100 1E56               1782              BSR     PUSH_STACK
000020E2  6100 19E4               1783              BSR     GET_EA_EA_DEST       *GETS Dn    
000020E6                          1784              
000020E6  6000 004A               1785              BRA     OP1000_DIVS_RETURN
000020EA                          1786  OP1000_PRINT_L_DIVS
000020EA  163C 004C               1787              MOVE.B  #'L',D3
000020EE  6100 1E46               1788              BSR     PUSH_STACK
000020F2                          1789              
000020F2                          1790              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020F2  13FC 0000 0000485C      1791              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020FA  13FC 0000 0000485D      1792              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002102                          1793             
00002102                          1794              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002102  13FC 00B9 0000485F      1795              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000210A  13FC 0020 00004860      1796              MOVE.B   #$20,GET_SRC_START_END
00002112                          1797  
00002112                          1798              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002112  0285 0000FE3F           1799              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002118  0685 00000000           1800              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000211E                          1801  
0000211E                          1802                     
0000211E  6100 1578               1803              BSR     GET_EA_EA_SRC      *GETS <ea>
00002122  163C 002C               1804              MOVE.B  #',',D3
00002126  6100 1E0E               1805              BSR     PUSH_STACK                  
0000212A  6100 199C               1806              BSR     GET_EA_EA_DEST       *GETS Dn    
0000212E                          1807  
0000212E                          1808              
0000212E  6000 0002               1809              BRA     OP1000_DIVS_RETURN
00002132                          1810              
00002132                          1811  OP1000_DIVS_RETURN
00002132  4E75                    1812              RTS
00002134                          1813              
00002134                          1814  
00002134                          1815  
00002134                          1816  *---------------------------------------------------------------------------*
00002134                          1817  * OP_DIVS: display DIVS and proceed to EA
00002134                          1818  *---------------------------------------------------------------------------*  
00002134  43F9 0000464F           1819  OP_DIVS     LEA     DISP_DIVS,A1
0000213A  103C 000E               1820              MOVE.B  #14,D0
0000213E  4E4F                    1821              TRAP    #15
00002140  4EF9 000031FC           1822              JMP     EA_ARITH
00002146                          1823  
00002146  4E75                    1824              RTS
00002148                          1825              
00002148                          1826  *---------------------------------------------------------------------------*
00002148                          1827  * OP1001: decode SUB/SUBA
00002148                          1828  *---------------------------------------------------------------------------*      
00002148                          1829  OP1001      
00002148  4280                    1830              CLR.L   D0                  
0000214A  4281                    1831              CLR.L   D1       
0000214C  4284                    1832              CLR.L   D4                   
0000214E  227C 00000000           1833              MOVEA.L #0, A1              
00002154  2205                    1834              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002156                          1835              
00002156                          1836              *CLEAR D3
00002156  4283                    1837              CLR.L   D3
00002158                          1838              
00002158                          1839              
00002158                          1840              
00002158                          1841              **INTEGRATING SUB.W/.L INTO THIS CODE**
00002158  2205                    1842              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000215A                          1843              *BITS (INDEX 8) 
0000215A                          1844              *0 = ADD.B/W/L <EA>,Dn
0000215A                          1845              *1 = ADD.B/W/L Dn,<EA> 
0000215A  EC99                    1846              ROR.L   #6,D1
0000215C  0281 00000007           1847              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002162  0C81 00000007           1848              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002168  6700 0010               1849              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
0000216C  0C81 00000003           1850              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002172  6700 0078               1851              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00002176  6000 00E6               1852              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000217A                          1853              
0000217A                          1854  OP1001_SUBA_L
0000217A                          1855              *LOAD STACK WITH THIS OPMODE
0000217A  6100 1DBA               1856              BSR     PUSH_STACK
0000217E  163C 0053               1857              MOVE.B  #'S',D3
00002182  6100 1DB2               1858              BSR     PUSH_STACK
00002186  163C 0055               1859              MOVE.B  #'U',D3
0000218A  6100 1DAA               1860              BSR     PUSH_STACK
0000218E  163C 0042               1861              MOVE.B  #'B',D3
00002192  6100 1DA2               1862              BSR     PUSH_STACK
00002196  163C 0041               1863              MOVE.B  #'A',D3
0000219A  6100 1D9A               1864              BSR     PUSH_STACK
0000219E  163C 002E               1865              MOVE.B  #'.',D3
000021A2  6100 1D92               1866              BSR     PUSH_STACK
000021A6  163C 004C               1867              MOVE.B  #'L',D3
000021AA  6100 1D8A               1868              BSR     PUSH_STACK
000021AE                          1869              
000021AE                          1870             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021AE  13FC 0000 0000485C      1871             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021B6  13FC 0000 0000485D      1872             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021BE                          1873             
000021BE                          1874             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021BE  13FC 00B9 0000485F      1875             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021C6  13FC 0020 00004860      1876             MOVE.B   #$20,GET_SRC_START_END
000021CE                          1877  
000021CE                          1878              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021CE  0285 0000FE3F           1879              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021D4  0685 00000040           1880              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000021DA                          1881       
000021DA                          1882              *PRINT <EA>,AN
000021DA  6100 14BC               1883              BSR     GET_EA_EA_SRC       *GETS <ea>
000021DE  163C 002C               1884              MOVE.B  #',',D3
000021E2  6100 1D52               1885              BSR     PUSH_STACK                     
000021E6  6100 18E0               1886              BSR     GET_EA_EA_DEST      *GETS Dn
000021EA                          1887  
000021EA                          1888              
000021EA                          1889              
000021EA  4E75                    1890              RTS
000021EC                          1891  OP1001_SUBA_W
000021EC                          1892              *LOAD STACK WITH THIS OPMODE
000021EC  6100 1D48               1893              BSR     PUSH_STACK
000021F0  163C 0053               1894              MOVE.B  #'S',D3
000021F4  6100 1D40               1895              BSR     PUSH_STACK
000021F8  163C 0055               1896              MOVE.B  #'U',D3
000021FC  6100 1D38               1897              BSR     PUSH_STACK
00002200  163C 0042               1898              MOVE.B  #'B',D3
00002204  6100 1D30               1899              BSR     PUSH_STACK
00002208  163C 0041               1900              MOVE.B  #'A',D3
0000220C  6100 1D28               1901              BSR     PUSH_STACK
00002210  163C 002E               1902              MOVE.B  #'.',D3
00002214  6100 1D20               1903              BSR     PUSH_STACK
00002218  163C 0057               1904              MOVE.B  #'W',D3
0000221C  6100 1D18               1905              BSR     PUSH_STACK
00002220                          1906              
00002220                          1907             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002220  13FC 0000 0000485C      1908             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002228  13FC 0000 0000485D      1909             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002230                          1910             
00002230                          1911             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002230  13FC 00B9 0000485F      1912             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002238  13FC 0020 00004860      1913             MOVE.B   #$20,GET_SRC_START_END
00002240                          1914  
00002240                          1915              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002240  0285 0000FE3F           1916              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002246  0685 00000040           1917              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000224C                          1918       
0000224C                          1919              *PRINT <EA>,AN
0000224C  6100 144A               1920              BSR     GET_EA_EA_SRC       *GETS <ea>
00002250  163C 002C               1921              MOVE.B  #',',D3
00002254  6100 1CE0               1922              BSR     PUSH_STACK                     
00002258  6100 186E               1923              BSR     GET_EA_EA_DEST      *GETS Dn
0000225C                          1924  
0000225C  4E75                    1925              RTS
0000225E                          1926  
0000225E                          1927  OP1001_DETERMINE_DN_EA_OR_EA_DN 
0000225E                          1928              *LOAD STACK WITH THIS OPMODE
0000225E  6100 1CD6               1929              BSR     PUSH_STACK
00002262  163C 0053               1930              MOVE.B  #'S',D3
00002266  6100 1CCE               1931              BSR     PUSH_STACK
0000226A  163C 0055               1932              MOVE.B  #'U',D3
0000226E  6100 1CC6               1933              BSR     PUSH_STACK
00002272  163C 0042               1934              MOVE.B  #'B',D3
00002276  6100 1CBE               1935              BSR     PUSH_STACK
0000227A  163C 002E               1936              MOVE.B  #'.',D3
0000227E  6100 1CB6               1937              BSR     PUSH_STACK
00002282                          1938              
00002282  2205                    1939              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002284                          1940              
00002284                          1941              *BITS (INDEX 8) 
00002284                          1942              *0 = ADD.B/W/L <EA>,Dn
00002284                          1943              *1 = ADD.B/W/L Dn,<EA> 
00002284  E099                    1944              ROR.L   #8,D1
00002286  0281 00000001           1945              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000228C  0C81 00000000           1946              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002292  6700 0102               1947              BEQ     OP1001_EA_DN
00002296                          1948              *else procede to Dn_EA
00002296                          1949              
00002296                          1950  OP1001_DN_EA
00002296                          1951              *BITS (7 TO 6) 
00002296                          1952              *00 = .B
00002296                          1953              *01 = .W
00002296                          1954              *10 = .L 
00002296  2205                    1955              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002298  EC99                    1956              ROR.L   #6,D1
0000229A  0281 00000003           1957              ANDI.L  #$03,D1
000022A0  0C81 00000000           1958              CMPI.L  #$00,D1 *EQUALS .B
000022A6  6700 0016               1959              BEQ     OP1001_PRINT_B2
000022AA  0C81 00000001           1960              CMPI.L  #$01,D1 *EQUALS .W
000022B0  6700 0054               1961              BEQ     OP1001_PRINT_W2
000022B4  0C81 00000002           1962              CMPI.L  #$02,D1 *EQUALS .L
000022BA  6700 0092               1963              BEQ     OP1001_PRINT_L2
000022BE                          1964  OP1001_PRINT_B2
000022BE                          1965              *PUSH 'B'
000022BE  163C 0042               1966              MOVE.B  #'B',D3
000022C2  6100 1C72               1967              BSR     PUSH_STACK
000022C6                          1968             
000022C6                          1969              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022C6  13FC 0000 0000485C      1970             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022CE  13FC 0083 0000485D      1971             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022D6                          1972             
000022D6                          1973             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022D6  13FC 00B9 0000485F      1974             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022DE  13FC 0020 00004860      1975             MOVE.B   #$20,GET_SRC_START_END
000022E6                          1976  
000022E6                          1977              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022E6  0285 0000FE3F           1978              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022EC  0685 00000040           1979              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022F2                          1980       
000022F2  6100 17D4               1981              BSR     GET_EA_EA_DEST      *GETS Dn
000022F6  163C 002C               1982              MOVE.B  #',',D3
000022FA  6100 1C3A               1983              BSR     PUSH_STACK                     
000022FE  6100 1398               1984              BSR     GET_EA_EA_SRC       *GETS <ea>
00002302                          1985  
00002302                          1986              
00002302  6000 0BA4               1987              BRA     OP1101_ADD_RETURN
00002306                          1988  OP1001_PRINT_W2
00002306  163C 0057               1989              MOVE.B  #'W',D3
0000230A  6100 1C2A               1990              BSR     PUSH_STACK
0000230E                          1991  
0000230E                          1992              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000230E  13FC 0000 0000485C      1993              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002316  13FC 0083 0000485D      1994              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000231E                          1995             
0000231E                          1996              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000231E  13FC 00B9 0000485F      1997              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002326  13FC 0020 00004860      1998              MOVE.B   #$20,GET_SRC_START_END
0000232E                          1999  
0000232E                          2000              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000232E  0285 0000FE3F           2001              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002334  0685 00000040           2002              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
0000233A                          2003  
0000233A                          2004        
0000233A  6100 178C               2005              BSR     GET_EA_EA_DEST      *GETS Dn
0000233E  163C 002C               2006              MOVE.B  #',',D3
00002342  6100 1BF2               2007              BSR     PUSH_STACK               
00002346  6100 1350               2008              BSR     GET_EA_EA_SRC       *GETS <ea>       
0000234A                          2009  
0000234A                          2010  
0000234A                          2011  
0000234A  6000 0B5C               2012              BRA     OP1101_ADD_RETURN
0000234E                          2013  OP1001_PRINT_L2 
0000234E  163C 004C               2014              MOVE.B  #'L',D3
00002352  6100 1BE2               2015              BSR     PUSH_STACK
00002356                          2016              
00002356                          2017              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002356  13FC 0000 0000485C      2018              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000235E  13FC 0083 0000485D      2019              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002366                          2020             
00002366                          2021              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002366  13FC 00B9 0000485F      2022              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000236E  13FC 0020 00004860      2023              MOVE.B   #$20,GET_SRC_START_END
00002376                          2024  
00002376                          2025             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002376  0285 0000FE3F           2026              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000237C  0685 00000040           2027              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002382                          2028  
00002382                          2029               
00002382  6100 1744               2030              BSR     GET_EA_EA_DEST       *GETS Dn
00002386  163C 002C               2031              MOVE.B  #',',D3
0000238A  6100 1BAA               2032              BSR     PUSH_STACK          
0000238E  6100 1308               2033              BSR     GET_EA_EA_SRC        *GETS <ea>
00002392                          2034  
00002392  6000 0B14               2035              BRA     OP1101_ADD_RETURN
00002396                          2036              
00002396                          2037  OP1001_EA_DN           
00002396                          2038              *BITS (7 TO 6) 
00002396                          2039              *00 = .B
00002396                          2040              *01 = .W
00002396                          2041              *10 = .L 
00002396  2205                    2042              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002398  EC99                    2043              ROR.L   #6,D1
0000239A  0281 00000003           2044              ANDI.L  #$03,D1
000023A0  0C81 00000000           2045              CMPI.L  #$00,D1 *EQUALS .B
000023A6  6700 0016               2046              BEQ     OP1001_PRINT_B
000023AA  0C81 00000001           2047              CMPI.L  #$01,D1 *EQUALS .W
000023B0  6700 0054               2048              BEQ     OP1001_PRINT_W
000023B4  0C81 00000002           2049              CMPI.L  #$02,D1 *EQUALS .L
000023BA  6700 0092               2050              BEQ     OP1001_PRINT_L
000023BE                          2051  OP1001_PRINT_B
000023BE  163C 0042               2052              MOVE.B  #'B',D3
000023C2  6100 1B72               2053              BSR     PUSH_STACK
000023C6                          2054                
000023C6                          2055              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023C6  13FC 0000 0000485C      2056              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023CE  13FC 0002 0000485D      2057              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023D6                          2058             
000023D6                          2059              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023D6  13FC 00B9 0000485F      2060              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023DE  13FC 0020 00004860      2061              MOVE.B   #$20,GET_SRC_START_END
000023E6                          2062  
000023E6                          2063             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023E6  0285 0000FE3F           2064              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023EC  0685 00000040           2065              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
000023F2                          2066  
000023F2                          2067              
000023F2  6100 12A4               2068              BSR     GET_EA_EA_SRC      *GETS <ea>
000023F6  163C 002C               2069              MOVE.B  #',',D3
000023FA  6100 1B3A               2070              BSR     PUSH_STACK          
000023FE  6100 16C8               2071              BSR     GET_EA_EA_DEST       *GETS Dn
00002402                          2072              
00002402  6000 0AA4               2073              BRA     OP1101_ADD_RETURN
00002406                          2074  OP1001_PRINT_W
00002406  163C 0057               2075              MOVE.B  #'W',D3
0000240A  6100 1B2A               2076              BSR     PUSH_STACK
0000240E                          2077  
0000240E                          2078              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000240E  13FC 0000 0000485C      2079              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002416  13FC 0000 0000485D      2080              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000241E                          2081             
0000241E                          2082              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000241E  13FC 00B9 0000485F      2083              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002426  13FC 0020 00004860      2084              MOVE.B   #$20,GET_SRC_START_END
0000242E                          2085  
0000242E                          2086             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000242E  0285 0000FE3F           2087              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002434  0685 00000040           2088              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000243A                          2089  
0000243A                          2090              
0000243A  6100 125C               2091              BSR     GET_EA_EA_SRC      *GETS <ea>
0000243E  163C 002C               2092              MOVE.B  #',',D3
00002442  6100 1AF2               2093              BSR     PUSH_STACK
00002446  6100 1680               2094              BSR     GET_EA_EA_DEST       *GETS Dn    
0000244A                          2095              
0000244A  6000 004A               2096              BRA     OP1001_ADD_RETURN
0000244E                          2097  OP1001_PRINT_L 
0000244E  163C 004C               2098              MOVE.B  #'L',D3
00002452  6100 1AE2               2099              BSR     PUSH_STACK
00002456                          2100              
00002456                          2101              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002456  13FC 0000 0000485C      2102              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000245E  13FC 0000 0000485D      2103              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002466                          2104             
00002466                          2105              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002466  13FC 00B9 0000485F      2106              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000246E  13FC 0020 00004860      2107              MOVE.B   #$20,GET_SRC_START_END
00002476                          2108  
00002476                          2109              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002476  0285 0000FE3F           2110              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000247C  0685 00000040           2111              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002482                          2112  
00002482                          2113                     
00002482  6100 1214               2114              BSR     GET_EA_EA_SRC      *GETS <ea>
00002486  163C 002C               2115              MOVE.B  #',',D3
0000248A  6100 1AAA               2116              BSR     PUSH_STACK                  
0000248E  6100 1638               2117              BSR     GET_EA_EA_DEST       *GETS Dn    
00002492                          2118  
00002492                          2119              
00002492  6000 0002               2120              BRA     OP1001_ADD_RETURN
00002496                          2121              
00002496                          2122  OP1001_ADD_RETURN
00002496  4E75                    2123              RTS
00002498                          2124  
00002498                          2125    
00002498                          2126  *---------------------------------------------------------------------------*
00002498                          2127  * OP_SUB: display SUB and proceed to EA
00002498                          2128  *---------------------------------------------------------------------------*            
00002498  43F9 00004657           2129  OP_SUB_B    LEA     DISP_SUB_B,A1
0000249E  103C 000E               2130              MOVE.B  #14,D0
000024A2  4E4F                    2131              TRAP    #15
000024A4  183C 0000               2132              MOVE.B  #0,D4
000024A8  4EF9 00003248           2133              JMP     EA_GEN
000024AE                          2134  
000024AE  4E75                    2135              RTS
000024B0                          2136  
000024B0  43F9 00004660           2137  OP_SUB_W    LEA     DISP_SUB_W,A1
000024B6  103C 000E               2138              MOVE.B  #14,D0
000024BA  4E4F                    2139              TRAP    #15
000024BC  183C 0001               2140              MOVE.B  #1,D4
000024C0  4EF9 00003248           2141              JMP     EA_GEN
000024C6                          2142  
000024C6  4E75                    2143              RTS
000024C8                          2144  
000024C8  43F9 00004669           2145  OP_SUB_L    LEA     DISP_SUB_L,A1
000024CE  103C 000E               2146              MOVE.B  #14,D0
000024D2  4E4F                    2147              TRAP    #15
000024D4  183C 0002               2148              MOVE.B  #2,D4
000024D8  4EF9 00003248           2149              JMP     EA_GEN
000024DE                          2150  
000024DE  4E75                    2151              RTS
000024E0                          2152  
000024E0                          2153  *---------------------------------------------------------------------------*
000024E0                          2154  * OP_SUBA: display SUBA
000024E0                          2155  *---------------------------------------------------------------------------*  
000024E0  43F9 00004690           2156  OP_SUBA_W   LEA     DISP_SUBA_W,A1
000024E6  103C 000E               2157              MOVE.B  #14,D0
000024EA  4E4F                    2158              TRAP    #15
000024EC  183C 0001               2159              MOVE.B  #1,D4
000024F0  4E75                    2160              RTS
000024F2                          2161  
000024F2  43F9 0000469A           2162  OP_SUBA_L   LEA     DISP_SUBA_L,A1
000024F8  103C 000E               2163              MOVE.B  #14,D0
000024FC  4E4F                    2164              TRAP    #15
000024FE  183C 0002               2165              MOVE.B  #2,D4
00002502  4E75                    2166              RTS         
00002504                          2167  *---------------------------------------------------------------------------*
00002504                          2168  * OP1010 : unassigned
00002504                          2169  *---------------------------------------------------------------------------*           
00002504  4EF8 1730               2170  OP1010      JMP     OP_DATA
00002508                          2171              
00002508                          2172  *---------------------------------------------------------------------------*
00002508                          2173  * OP1011 : decode CMP/EOR/CMPA
00002508                          2174  *---------------------------------------------------------------------------*           
00002508  4280                    2175  OP1011      CLR.L   D0                
0000250A  4281                    2176              CLR.L   D1            
0000250C  4284                    2177              CLR.L   D4                   
0000250E  227C 00000000           2178              MOVEA.L #0, A1               
00002514  2205                    2179              MOVE.L  D5,D1
00002516  EA99                    2180              ROR.L   #5,D1
00002518  0281 0000000E           2181              ANDI.L  #$E,D1
0000251E  0C01 0000               2182              CMPI.B  #$0,D1
00002522  6700 003E               2183              BEQ     OP1011_CMP
00002526  0C01 0002               2184              CMPI.B  #$2,D1
0000252A  6700 0036               2185              BEQ     OP1011_CMP
0000252E  0C01 0004               2186              CMPI.B  #$4,D1
00002532  6700 002E               2187              BEQ     OP1011_CMP
00002536  0C01 0008               2188              CMPI.B  #$8,D1
0000253A  6700 0178               2189              BEQ     OP1011_EOR
0000253E  0C01 000A               2190              CMPI.B  #$A,D1
00002542  6700 0170               2191              BEQ     OP1011_EOR
00002546  0C01 000C               2192              CMPI.B  #$C,D1
0000254A  6700 0168               2193              BEQ     OP1011_EOR  
0000254E  0C01 0006               2194              CMPI.B  #$6,D1
00002552  6700 00C0               2195              BEQ     OP1011_CMPA
00002556  0C01 000E               2196              CMPI.B  #$E,D1
0000255A  6700 00B8               2197              BEQ     OP1011_CMPA 
0000255E                          2198  
0000255E  4EF8 1730               2199              JMP     OP_DATA          
00002562                          2200  
00002562                          2201  
00002562                          2202  
00002562                          2203  
00002562                          2204  OP1011_CMP
00002562                          2205             
00002562                          2206   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002562  13FC 0082 0000485C      2207             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000256A  13FC 0000 0000485D      2208             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002572                          2209             
00002572                          2210             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002572  13FC 00B9 0000485F      2211             MOVE.B   #$B9,GET_DST_START_END
0000257A  13FC 0020 00004860      2212             MOVE.B   #$20,GET_SRC_START_END
00002582                          2213             
00002582                          2214              *CLEAR D3
00002582  4283                    2215              CLR.L   D3
00002584                          2216              *LOAD STACK WITH THIS OPMODE
00002584  6100 19B0               2217              BSR     PUSH_STACK
00002588  163C 0043               2218              MOVE.B  #'C',D3
0000258C  6100 19A8               2219              BSR     PUSH_STACK
00002590  163C 004D               2220              MOVE.B  #'M',D3
00002594  6100 19A0               2221              BSR     PUSH_STACK
00002598  163C 0050               2222              MOVE.B  #'P',D3
0000259C  6100 1998               2223              BSR     PUSH_STACK
000025A0  163C 002E               2224              MOVE.B  #'.',D3
000025A4  6100 1990               2225              BSR     PUSH_STACK
000025A8                          2226              
000025A8                          2227              *FIGURE OUT SIZE*
000025A8                          2228              *00 = BYTE
000025A8                          2229              *01 = WORD
000025A8                          2230              *10 = LONG
000025A8                          2231              * BITS 7&6
000025A8                          2232              
000025A8                          2233              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000025A8  2205                    2234              MOVE.L  D5,D1
000025AA  EC99                    2235              ROR.L   #6,D1
000025AC  0281 00000003           2236              ANDI.L  #$03,D1
000025B2  0C01 0000               2237              CMPI.B  #%00,D1
000025B6  6700 001E               2238              BEQ     OP1011_CMP_B
000025BA  0281 00000003           2239              ANDI.L  #$03,D1
000025C0  0C01 0001               2240              CMPI.B  #%01,D1
000025C4  6700 001C               2241              BEQ     OP1011_CMP_W
000025C8  0281 00000003           2242              ANDI.L  #$03,D1
000025CE  0C01 0002               2243              CMPI.B  #%10,D1
000025D2  6700 001A               2244              BEQ     OP1011_CMP_L
000025D6                          2245            
000025D6                          2246  OP1011_CMP_B
000025D6                          2247              
000025D6  163C 0042               2248              MOVE.B  #'B',D3
000025DA  6100 195A               2249              BSR     PUSH_STACK
000025DE  6000 0016               2250              BRA     OP1011_RETURN_CMP  
000025E2                          2251  OP1011_CMP_W
000025E2                          2252              
000025E2  163C 0057               2253              MOVE.B  #'W',D3
000025E6  6100 194E               2254              BSR     PUSH_STACK
000025EA  6000 000A               2255              BRA     OP1011_RETURN_CMP  
000025EE                          2256  OP1011_CMP_L
000025EE                          2257              
000025EE  163C 004C               2258              MOVE.B  #'L',D3
000025F2  6100 1942               2259              BSR     PUSH_STACK
000025F6                          2260  OP1011_RETURN_CMP            
000025F6                          2261  
000025F6                          2262              
000025F6                          2263  *GET DATA FROM ADDQ AND PRINT #0-8
000025F6                          2264       
000025F6                          2265              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025F6  0285 0000FE3F           2266              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000025FC  0685 00000000           2267              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002602                          2268  
00002602  6100 1094               2269              BSR     GET_EA_EA_SRC
00002606  163C 002C               2270              MOVE.B  #',',D3
0000260A  6100 192A               2271              BSR     PUSH_STACK
0000260E  6100 14B8               2272              BSR     GET_EA_EA_DEST
00002612                          2273              
00002612  4E75                    2274              RTS
00002614                          2275              
00002614                          2276  
00002614                          2277  
00002614                          2278  OP1011_CMPA
00002614                          2279              
00002614                          2280   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002614  13FC 0080 0000485C      2281             MOVE.B   #$80,DEST_REGISTER_FORMAT
0000261C  13FC 0000 0000485D      2282             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002624                          2283             
00002624                          2284             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002624  13FC 00B9 0000485F      2285             MOVE.B   #$B9,GET_DST_START_END
0000262C  13FC 0020 00004860      2286             MOVE.B   #$20,GET_SRC_START_END
00002634                          2287             
00002634                          2288              *CLEAR D3
00002634  4283                    2289              CLR.L   D3
00002636                          2290              *LOAD STACK WITH THIS OPMODE
00002636  6100 18FE               2291              BSR     PUSH_STACK
0000263A  163C 0043               2292              MOVE.B  #'C',D3
0000263E  6100 18F6               2293              BSR     PUSH_STACK
00002642  163C 004D               2294              MOVE.B  #'M',D3
00002646  6100 18EE               2295              BSR     PUSH_STACK
0000264A  163C 0050               2296              MOVE.B  #'P',D3
0000264E  6100 18E6               2297              BSR     PUSH_STACK
00002652  163C 0041               2298              MOVE.B  #'A',D3
00002656  6100 18DE               2299              BSR     PUSH_STACK
0000265A  163C 002E               2300              MOVE.B  #'.',D3
0000265E  6100 18D6               2301              BSR     PUSH_STACK
00002662                          2302              
00002662                          2303              *FIGURE OUT SIZE*
00002662                          2304              *00 = BYTE
00002662                          2305              *01 = WORD
00002662                          2306              *10 = LONG
00002662                          2307              * BITS 7&6
00002662                          2308              
00002662                          2309              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002662  2205                    2310              MOVE.L  D5,D1
00002664  EC99                    2311              ROR.L   #6,D1
00002666  0281 00000003           2312              ANDI.L  #$03,D1
0000266C  0C01 0001               2313              CMPI.B  #%01,D1
00002670  6700 0010               2314              BEQ     OP1011_CMPA_W
00002674  0281 00000003           2315              ANDI.L  #$03,D1
0000267A  0C01 0002               2316              CMPI.B  #%10,D1
0000267E  6700 000E               2317              BEQ     OP1011_CMPA_L
00002682                          2318  OP1011_CMPA_W
00002682                          2319              
00002682  163C 0057               2320              MOVE.B  #'W',D3
00002686  6100 18AE               2321              BSR     PUSH_STACK
0000268A  6000 000A               2322              BRA     OP1011_RETURN_CMPA 
0000268E                          2323  OP1011_CMPA_L
0000268E                          2324              
0000268E  163C 004C               2325              MOVE.B  #'L',D3
00002692  6100 18A2               2326              BSR     PUSH_STACK
00002696                          2327  OP1011_RETURN_CMPA            
00002696                          2328  
00002696                          2329              
00002696                          2330  *GET DATA FROM ADDQ AND PRINT #0-8
00002696                          2331       
00002696                          2332              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002696  0285 0000FE3F           2333              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000269C  0685 00000040           2334              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000026A2                          2335  
000026A2  6100 0FF4               2336              BSR     GET_EA_EA_SRC
000026A6  163C 002C               2337              MOVE.B  #',',D3
000026AA  6100 188A               2338              BSR     PUSH_STACK
000026AE  6100 1418               2339              BSR     GET_EA_EA_DEST
000026B2                          2340              
000026B2  4E75                    2341              RTS
000026B4                          2342  
000026B4                          2343  OP1011_EOR
000026B4                          2344  
000026B4                          2345   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026B4  13FC 0082 0000485C      2346             MOVE.B   #$82,DEST_REGISTER_FORMAT
000026BC  13FC 0080 0000485D      2347             MOVE.B   #$80,SRC_REGISTER_FORMAT
000026C4                          2348             
000026C4                          2349             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026C4  13FC 00B9 0000485F      2350             MOVE.B   #$B9,GET_DST_START_END
000026CC  13FC 0020 00004860      2351             MOVE.B   #$20,GET_SRC_START_END
000026D4                          2352             
000026D4                          2353              *CLEAR D3
000026D4  4283                    2354              CLR.L   D3
000026D6                          2355              *LOAD STACK WITH THIS OPMODE
000026D6  6100 185E               2356              BSR     PUSH_STACK
000026DA  163C 0045               2357              MOVE.B  #'E',D3
000026DE  6100 1856               2358              BSR     PUSH_STACK
000026E2  163C 004F               2359              MOVE.B  #'O',D3
000026E6  6100 184E               2360              BSR     PUSH_STACK
000026EA  163C 0052               2361              MOVE.B  #'R',D3
000026EE  6100 1846               2362              BSR     PUSH_STACK
000026F2  163C 002E               2363              MOVE.B  #'.',D3
000026F6  6100 183E               2364              BSR     PUSH_STACK
000026FA                          2365              
000026FA                          2366              *FIGURE OUT SIZE*
000026FA                          2367              *00 = BYTE
000026FA                          2368              *01 = WORD
000026FA                          2369              *10 = LONG
000026FA                          2370              * BITS 7&6
000026FA                          2371              
000026FA                          2372              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000026FA  2205                    2373              MOVE.L  D5,D1
000026FC  EC99                    2374              ROR.L   #6,D1
000026FE  0281 00000003           2375              ANDI.L  #$03,D1
00002704  0C01 0000               2376              CMPI.B  #%00,D1
00002708  6700 001E               2377              BEQ     OP1011_EOR_B
0000270C  0281 00000003           2378              ANDI.L  #$03,D1
00002712  0C01 0001               2379              CMPI.B  #%01,D1
00002716  6700 001C               2380              BEQ     OP1011_EOR_W
0000271A  0281 00000003           2381              ANDI.L  #$03,D1
00002720  0C01 0002               2382              CMPI.B  #%10,D1
00002724  6700 001A               2383              BEQ     OP1011_EOR_L
00002728                          2384            
00002728                          2385  OP1011_EOR_B
00002728                          2386              
00002728  163C 0042               2387              MOVE.B  #'B',D3
0000272C  6100 1808               2388              BSR     PUSH_STACK
00002730  6000 0016               2389              BRA     OP1011_RETURN
00002734                          2390  OP1011_EOR_W
00002734                          2391              
00002734  163C 0057               2392              MOVE.B  #'W',D3
00002738  6100 17FC               2393              BSR     PUSH_STACK
0000273C  6000 000A               2394              BRA     OP1011_RETURN
00002740                          2395  OP1011_EOR_L
00002740                          2396              
00002740  163C 004C               2397              MOVE.B  #'L',D3
00002744  6100 17F0               2398              BSR     PUSH_STACK
00002748                          2399  OP1011_RETURN            
00002748                          2400  
00002748                          2401              
00002748                          2402  *GET DATA FROM ADDQ AND PRINT #0-8
00002748                          2403       
00002748                          2404              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002748  0285 0000FE3F           2405              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000274E  0685 00000000           2406              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002754                          2407  
00002754  6100 1372               2408              BSR     GET_EA_EA_DEST
00002758  163C 002C               2409              MOVE.B  #',',D3
0000275C  6100 17D8               2410              BSR     PUSH_STACK
00002760  6100 0F36               2411              BSR     GET_EA_EA_SRC
00002764                          2412              
00002764  4E75                    2413              RTS
00002766                          2414              
00002766                          2415              
00002766                          2416              
00002766                          2417              
00002766                          2418  
00002766                          2419  *---------------------------------------------------------------------------*
00002766                          2420  * OP_CMPA: display CMPA 
00002766                          2421  *---------------------------------------------------------------------------
00002766  43F9 000046DA           2422  OP_CMPA_W   LEA     DISP_CMPA_W,A1
0000276C  103C 000E               2423              MOVE.B  #14,D0
00002770  4E4F                    2424              TRAP    #15
00002772  183C 0001               2425              MOVE.B  #1,D4
00002776  4E75                    2426              RTS
00002778                          2427  
00002778  43F9 000046E4           2428  OP_CMPA_L   LEA     DISP_CMPA_L,A1
0000277E  103C 000E               2429              MOVE.B  #14,D0
00002782  4E4F                    2430              TRAP    #15
00002784  183C 0002               2431              MOVE.B  #2,D4
00002788  4E75                    2432              RTS
0000278A                          2433  
0000278A                          2434  *---------------------------------------------------------------------------*
0000278A                          2435  * OP_CMP: display CMP and proceed to EA
0000278A                          2436  *---------------------------------------------------------------------------*  
0000278A  43F9 000046BF           2437  OP_CMP_B    LEA     DISP_CMP_B,A1
00002790  103C 000E               2438              MOVE.B  #14,D0
00002794  4E4F                    2439              TRAP    #15
00002796  183C 0000               2440              MOVE.B  #0,D4
0000279A  4EF9 00003248           2441              JMP     EA_GEN
000027A0                          2442  
000027A0  4E75                    2443              RTS
000027A2                          2444              
000027A2  43F9 000046C8           2445  OP_CMP_W    LEA     DISP_CMP_W,A1
000027A8  103C 000E               2446              MOVE.B  #14,D0
000027AC  4E4F                    2447              TRAP    #15
000027AE  183C 0001               2448              MOVE.B  #1,D4
000027B2  4EF9 00003248           2449              JMP     EA_GEN
000027B8                          2450  
000027B8  4E75                    2451              RTS
000027BA                          2452              
000027BA  43F9 000046D1           2453  OP_CMP_L    LEA     DISP_CMP_L,A1
000027C0  103C 000E               2454              MOVE.B  #14,D0
000027C4  4E4F                    2455              TRAP    #15
000027C6  183C 0002               2456              MOVE.B  #2,D4
000027CA  4EF9 00003248           2457              JMP     EA_GEN
000027D0                          2458  
000027D0  4E75                    2459              RTS
000027D2                          2460              
000027D2                          2461  *---------------------------------------------------------------------------*
000027D2                          2462  * OP_EOR: display EOR
000027D2                          2463  *---------------------------------------------------------------------------*  
000027D2  43F9 000046A4           2464  OP_EOR_B    LEA     DISP_EOR_B,A1
000027D8  103C 000E               2465              MOVE.B  #14,D0
000027DC  4E4F                    2466              TRAP    #15
000027DE  183C 0000               2467              MOVE.B  #0,D4
000027E2  4E75                    2468              RTS
000027E4                          2469              
000027E4  43F9 000046AD           2470  OP_EOR_W    LEA     DISP_EOR_W,A1
000027EA  103C 000E               2471              MOVE.B  #14,D0
000027EE  4E4F                    2472              TRAP    #15
000027F0  183C 0001               2473              MOVE.B  #1,D4
000027F4  4E75                    2474              RTS
000027F6                          2475              
000027F6  43F9 000046B6           2476  OP_EOR_L    LEA     DISP_EOR_L,A1
000027FC  103C 000E               2477              MOVE.B  #14,D0
00002800  4E4F                    2478              TRAP    #15
00002802  183C 0002               2479              MOVE.B  #2,D4
00002806  4E75                    2480              RTS    
00002808                          2481  
00002808                          2482  *---------------------------------------------------------------------------*
00002808                          2483  * OP1100: Decode and display MULS/AND and proceed to EA
00002808                          2484  *---------------------------------------------------------------------------* 
00002808  4280                    2485  OP1100      CLR.L   D0                 
0000280A  4281                    2486              CLR.L   D1    
0000280C  4284                    2487              CLR.L   D4                
0000280E  227C 00000000           2488              MOVEA.L #0, A1        
00002814  2205                    2489              MOVE.L  D5,D1
00002816  EA89                    2490              LSR.L   #5,D1
00002818  0281 0000000E           2491              ANDI.L  #$E,D1
0000281E  0C41 000E               2492              CMPI.W  #$E,D1
00002822  6700 0006               2493              BEQ     OP_MULS
00002826  6000 00F6               2494              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000282A                          2495  
0000282A                          2496  OP_MULS                      
0000282A  4281                    2497              CLR.L   D1       
0000282C  4284                    2498              CLR.L   D4                   
0000282E  227C 00000000           2499              MOVEA.L #0, A1              
00002834  2205                    2500              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002836                          2501              *CLEAR D3
00002836  4283                    2502              CLR.L   D3
00002838                          2503  
00002838                          2504  OP1100_MULS_DN_EA_OR_EA_DN 
00002838                          2505              *LOAD STACK WITH THIS OPMODE
00002838  6100 16FC               2506              BSR     PUSH_STACK
0000283C  163C 004D               2507              MOVE.B  #'M',D3
00002840  6100 16F4               2508              BSR     PUSH_STACK
00002844  163C 0055               2509              MOVE.B  #'U',D3
00002848  6100 16EC               2510              BSR     PUSH_STACK
0000284C  163C 004C               2511              MOVE.B  #'L',D3
00002850  6100 16E4               2512              BSR     PUSH_STACK
00002854  163C 0053               2513              MOVE.B  #'S',D3
00002858  6100 16DC               2514              BSR     PUSH_STACK
0000285C  163C 002E               2515              MOVE.B  #'.',D3
00002860  6100 16D4               2516              BSR     PUSH_STACK
00002864                          2517              
00002864  2205                    2518              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002866                          2519              
00002866                          2520  OP1100_EA_DN_MULS           
00002866                          2521              *BITS (7 TO 6) 
00002866                          2522              *00 = .B
00002866                          2523              *01 = .W
00002866                          2524              *10 = .L 
00002866  2205                    2525              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002868  EC99                    2526              ROR.L   #6,D1
0000286A  0281 00000003           2527              ANDI.L  #$03,D1
00002870  0C81 00000003           2528              CMPI.L  #%11,D1 *EQUALS .W
00002876  6700 0014               2529              BEQ     OP1100_PRINT_W_MULS
0000287A  0C81 00000000           2530              CMPI.L  #%00,D1 *EQUALS .L
00002880  6700 0052               2531              BEQ     OP1100_PRINT_L_MULS
00002884                          2532              
00002884  183C 0001               2533              MOVE.B  #1,D4               *ERROR READ
00002888  6000 0092               2534              BRA     OP1100_MULS_RETURN
0000288C                          2535  OP1100_PRINT_W_MULS
0000288C  163C 0057               2536              MOVE.B  #'W',D3
00002890  6100 16A4               2537              BSR     PUSH_STACK
00002894                          2538  
00002894                          2539              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002894  13FC 0000 0000485C      2540              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000289C  13FC 0000 0000485D      2541              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028A4                          2542             
000028A4                          2543              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028A4  13FC 00B9 0000485F      2544              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028AC  13FC 0020 00004860      2545              MOVE.B   #$20,GET_SRC_START_END
000028B4                          2546  
000028B4                          2547             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028B4  0285 0000FE3F           2548              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028BA  0685 00000000           2549              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028C0                          2550  
000028C0                          2551              
000028C0  6100 0DD6               2552              BSR     GET_EA_EA_SRC      *GETS <ea>
000028C4  163C 002C               2553              MOVE.B  #',',D3
000028C8  6100 166C               2554              BSR     PUSH_STACK
000028CC  6100 11FA               2555              BSR     GET_EA_EA_DEST       *GETS Dn    
000028D0                          2556              
000028D0  6000 004A               2557              BRA     OP1100_MULS_RETURN
000028D4                          2558  OP1100_PRINT_L_MULS 
000028D4  163C 004C               2559              MOVE.B  #'L',D3
000028D8  6100 165C               2560              BSR     PUSH_STACK
000028DC                          2561              
000028DC                          2562              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028DC  13FC 0000 0000485C      2563              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028E4  13FC 0000 0000485D      2564              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028EC                          2565             
000028EC                          2566              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028EC  13FC 00B9 0000485F      2567              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028F4  13FC 0020 00004860      2568              MOVE.B   #$20,GET_SRC_START_END
000028FC                          2569  
000028FC                          2570              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028FC  0285 0000FE3F           2571              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002902  0685 00000000           2572              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002908                          2573  
00002908                          2574                     
00002908  6100 0D8E               2575              BSR     GET_EA_EA_SRC      *GETS <ea>
0000290C  163C 002C               2576              MOVE.B  #',',D3
00002910  6100 1624               2577              BSR     PUSH_STACK                  
00002914  6100 11B2               2578              BSR     GET_EA_EA_DEST       *GETS Dn    
00002918                          2579  
00002918                          2580              
00002918  6000 0002               2581              BRA     OP1100_MULS_RETURN
0000291C                          2582              
0000291C                          2583  OP1100_MULS_RETURN
0000291C  4E75                    2584              RTS
0000291E                          2585              
0000291E                          2586  
0000291E                          2587  
0000291E                          2588  
0000291E                          2589  
0000291E                          2590  
0000291E                          2591  
0000291E                          2592  
0000291E                          2593  
0000291E                          2594  
0000291E                          2595  
0000291E                          2596  
0000291E                          2597  
0000291E                          2598  OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000291E                          2599              *LOAD STACK WITH THIS OPMODE
0000291E  4283                    2600              CLR.L   D3
00002920  6100 1614               2601              BSR     PUSH_STACK
00002924  163C 0041               2602              MOVE.B  #'A',D3
00002928  6100 160C               2603              BSR     PUSH_STACK
0000292C  163C 004E               2604              MOVE.B  #'N',D3
00002930  6100 1604               2605              BSR     PUSH_STACK
00002934  163C 0044               2606              MOVE.B  #'D',D3
00002938  6100 15FC               2607              BSR     PUSH_STACK
0000293C  163C 002E               2608              MOVE.B  #'.',D3
00002940  6100 15F4               2609              BSR     PUSH_STACK
00002944                          2610              
00002944  2205                    2611              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002946                          2612              
00002946                          2613              *BITS (INDEX 8) 
00002946                          2614              *0 = ADD.B/W/L <EA>,Dn
00002946                          2615              *1 = ADD.B/W/L Dn,<EA> 
00002946  E099                    2616              ROR.L   #8,D1
00002948  0281 00000001           2617              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000294E  0C81 00000000           2618              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002954  6700 0102               2619              BEQ     OP1100_EA_DN
00002958                          2620              *else procede to Dn_EA
00002958                          2621              
00002958                          2622  OP1100_DN_EA
00002958                          2623              *BITS (7 TO 6) 
00002958                          2624              *00 = .B
00002958                          2625              *01 = .W
00002958                          2626              *10 = .L 
00002958  2205                    2627              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000295A  EC99                    2628              ROR.L   #6,D1
0000295C  0281 00000003           2629              ANDI.L  #$03,D1
00002962  0C81 00000000           2630              CMPI.L  #$00,D1 *EQUALS .B
00002968  6700 0016               2631              BEQ     OP1100_PRINT_B2
0000296C  0C81 00000001           2632              CMPI.L  #$01,D1 *EQUALS .W
00002972  6700 0054               2633              BEQ     OP1100_PRINT_W2
00002976  0C81 00000002           2634              CMPI.L  #$02,D1 *EQUALS .L
0000297C  6700 0092               2635              BEQ     OP1100_PRINT_L2
00002980                          2636  OP1100_PRINT_B2
00002980                          2637              *PUSH 'B'
00002980  163C 0042               2638              MOVE.B  #'B',D3
00002984  6100 15B0               2639              BSR     PUSH_STACK
00002988                          2640             
00002988                          2641              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002988  13FC 0000 0000485C      2642             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002990  13FC 0083 0000485D      2643             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002998                          2644             
00002998                          2645             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002998  13FC 00B9 0000485F      2646             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029A0  13FC 0020 00004860      2647             MOVE.B   #$20,GET_SRC_START_END
000029A8                          2648  
000029A8                          2649              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029A8  0285 0000FE3F           2650              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029AE  0685 00000000           2651              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029B4                          2652       
000029B4  6100 1112               2653              BSR     GET_EA_EA_DEST      *GETS Dn
000029B8  163C 002C               2654              MOVE.B  #',',D3
000029BC  6100 1578               2655              BSR     PUSH_STACK                     
000029C0  6100 0CD6               2656              BSR     GET_EA_EA_SRC       *GETS <ea>
000029C4                          2657  
000029C4                          2658              
000029C4  6000 0192               2659              BRA     OP1100_AND_RETURN
000029C8                          2660  OP1100_PRINT_W2
000029C8  163C 0057               2661              MOVE.B  #'W',D3
000029CC  6100 1568               2662              BSR     PUSH_STACK
000029D0                          2663  
000029D0                          2664              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000029D0  13FC 0000 0000485C      2665              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000029D8  13FC 0083 0000485D      2666              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000029E0                          2667             
000029E0                          2668              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000029E0  13FC 00B9 0000485F      2669              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029E8  13FC 0020 00004860      2670              MOVE.B   #$20,GET_SRC_START_END
000029F0                          2671  
000029F0                          2672              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029F0  0285 0000FE3F           2673              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029F6  0685 00000000           2674              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000029FC                          2675  
000029FC                          2676        
000029FC  6100 10CA               2677              BSR     GET_EA_EA_DEST      *GETS Dn
00002A00  163C 002C               2678              MOVE.B  #',',D3
00002A04  6100 1530               2679              BSR     PUSH_STACK               
00002A08  6100 0C8E               2680              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002A0C                          2681  
00002A0C                          2682  
00002A0C                          2683  
00002A0C  6000 049A               2684              BRA     OP1101_ADD_RETURN
00002A10                          2685  OP1100_PRINT_L2 
00002A10  163C 004C               2686              MOVE.B  #'L',D3
00002A14  6100 1520               2687              BSR     PUSH_STACK
00002A18                          2688              
00002A18                          2689              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A18  13FC 0000 0000485C      2690              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A20  13FC 0083 0000485D      2691              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A28                          2692             
00002A28                          2693              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A28  13FC 00B9 0000485F      2694              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A30  13FC 0020 00004860      2695              MOVE.B   #$20,GET_SRC_START_END
00002A38                          2696  
00002A38                          2697             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A38  0285 0000FE3F           2698              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A3E  0685 00000000           2699              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A44                          2700  
00002A44                          2701               
00002A44  6100 1082               2702              BSR     GET_EA_EA_DEST       *GETS Dn
00002A48  163C 002C               2703              MOVE.B  #',',D3
00002A4C  6100 14E8               2704              BSR     PUSH_STACK          
00002A50  6100 0C46               2705              BSR     GET_EA_EA_SRC        *GETS <ea>
00002A54                          2706  
00002A54  6000 0102               2707              BRA     OP1100_AND_RETURN
00002A58                          2708              
00002A58                          2709  OP1100_EA_DN           
00002A58                          2710              *BITS (7 TO 6) 
00002A58                          2711              *00 = .B
00002A58                          2712              *01 = .W
00002A58                          2713              *10 = .L 
00002A58  2205                    2714              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002A5A  EC99                    2715              ROR.L   #6,D1
00002A5C  0281 00000003           2716              ANDI.L  #$03,D1
00002A62  0C81 00000000           2717              CMPI.L  #$00,D1 *EQUALS .B
00002A68  6700 0016               2718              BEQ     OP1100_PRINT_B
00002A6C  0C81 00000001           2719              CMPI.L  #$01,D1 *EQUALS .W
00002A72  6700 0054               2720              BEQ     OP1100_PRINT_W
00002A76  0C81 00000002           2721              CMPI.L  #$02,D1 *EQUALS .L
00002A7C  6700 0092               2722              BEQ     OP1100_PRINT_L
00002A80                          2723  OP1100_PRINT_B
00002A80  163C 0042               2724              MOVE.B  #'B',D3
00002A84  6100 14B0               2725              BSR     PUSH_STACK
00002A88                          2726                
00002A88                          2727              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A88  13FC 0000 0000485C      2728              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A90  13FC 0002 0000485D      2729              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A98                          2730             
00002A98                          2731              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A98  13FC 00B9 0000485F      2732              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AA0  13FC 0020 00004860      2733              MOVE.B   #$20,GET_SRC_START_END
00002AA8                          2734  
00002AA8                          2735             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AA8  0285 0000FE3F           2736              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AAE  0685 00000000           2737              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002AB4                          2738  
00002AB4                          2739              
00002AB4  6100 0BE2               2740              BSR     GET_EA_EA_SRC      *GETS <ea>
00002AB8  163C 002C               2741              MOVE.B  #',',D3
00002ABC  6100 1478               2742              BSR     PUSH_STACK          
00002AC0  6100 1006               2743              BSR     GET_EA_EA_DEST       *GETS Dn
00002AC4                          2744              
00002AC4  6000 03E2               2745              BRA     OP1101_ADD_RETURN
00002AC8                          2746  OP1100_PRINT_W
00002AC8  163C 0057               2747              MOVE.B  #'W',D3
00002ACC  6100 1468               2748              BSR     PUSH_STACK
00002AD0                          2749  
00002AD0                          2750              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AD0  13FC 0000 0000485C      2751              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AD8  13FC 0002 0000485D      2752              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AE0                          2753             
00002AE0                          2754              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AE0  13FC 00B9 0000485F      2755              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AE8  13FC 0020 00004860      2756              MOVE.B   #$20,GET_SRC_START_END
00002AF0                          2757  
00002AF0                          2758             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AF0  0285 0000FE3F           2759              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AF6  0685 00000000           2760              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002AFC                          2761  
00002AFC                          2762              
00002AFC  6100 0B9A               2763              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B00  163C 002C               2764              MOVE.B  #',',D3
00002B04  6100 1430               2765              BSR     PUSH_STACK
00002B08  6100 0FBE               2766              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B0C                          2767              
00002B0C  6000 F988               2768              BRA     OP1001_ADD_RETURN
00002B10                          2769  OP1100_PRINT_L 
00002B10  163C 004C               2770              MOVE.B  #'L',D3
00002B14  6100 1420               2771              BSR     PUSH_STACK
00002B18                          2772              
00002B18                          2773              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B18  13FC 0000 0000485C      2774              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B20  13FC 0002 0000485D      2775              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B28                          2776             
00002B28                          2777              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B28  13FC 00B9 0000485F      2778              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B30  13FC 0020 00004860      2779              MOVE.B   #$20,GET_SRC_START_END
00002B38                          2780  
00002B38                          2781              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B38  0285 0000FE3F           2782              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B3E  0685 00000000           2783              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B44                          2784  
00002B44                          2785                     
00002B44  6100 0B52               2786              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B48  163C 002C               2787              MOVE.B  #',',D3
00002B4C  6100 13E8               2788              BSR     PUSH_STACK                  
00002B50  6100 0F76               2789              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B54                          2790  
00002B54                          2791              
00002B54  6000 0002               2792              BRA     OP1100_AND_RETURN
00002B58                          2793              
00002B58                          2794  OP1100_AND_RETURN
00002B58  4E75                    2795              RTS
00002B5A                          2796  
00002B5A                          2797  
00002B5A                          2798  *---------------------------------------------------------------------------*
00002B5A                          2799  * OP1101: Decode ADD/ADDA
00002B5A                          2800  *---------------------------------------------------------------------------* 
00002B5A  4280                    2801  OP1101      CLR.L   D0                  
00002B5C  4281                    2802              CLR.L   D1       
00002B5E  4284                    2803              CLR.L   D4                   
00002B60  227C 00000000           2804              MOVEA.L #0, A1              
00002B66  2205                    2805              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002B68                          2806              
00002B68                          2807              *CLEAR D3
00002B68  4283                    2808              CLR.L   D3
00002B6A                          2809              
00002B6A                          2810              
00002B6A                          2811              
00002B6A                          2812              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002B6A  2205                    2813              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002B6C                          2814              *BITS (INDEX 8) 
00002B6C                          2815              *0 = ADD.B/W/L <EA>,Dn
00002B6C                          2816              *1 = ADD.B/W/L Dn,<EA> 
00002B6C  EC99                    2817              ROR.L   #6,D1
00002B6E  0281 00000007           2818              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002B74  0C81 00000007           2819              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002B7A  6700 0010               2820              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002B7E  0C81 00000003           2821              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002B84  6700 0078               2822              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002B88  6000 00E6               2823              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002B8C                          2824              
00002B8C                          2825  OP1101_ADDA_L
00002B8C                          2826              *LOAD STACK WITH THIS OPMODE
00002B8C  6100 13A8               2827              BSR     PUSH_STACK
00002B90  163C 0041               2828              MOVE.B  #'A',D3
00002B94  6100 13A0               2829              BSR     PUSH_STACK
00002B98  163C 0044               2830              MOVE.B  #'D',D3
00002B9C  6100 1398               2831              BSR     PUSH_STACK
00002BA0  163C 0044               2832              MOVE.B  #'D',D3
00002BA4  6100 1390               2833              BSR     PUSH_STACK
00002BA8  163C 0041               2834              MOVE.B  #'A',D3
00002BAC  6100 1388               2835              BSR     PUSH_STACK
00002BB0  163C 002E               2836              MOVE.B  #'.',D3
00002BB4  6100 1380               2837              BSR     PUSH_STACK
00002BB8  163C 004C               2838              MOVE.B  #'L',D3
00002BBC  6100 1378               2839              BSR     PUSH_STACK
00002BC0                          2840              
00002BC0                          2841             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BC0  13FC 0000 0000485C      2842             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BC8  13FC 0000 0000485D      2843             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BD0                          2844             
00002BD0                          2845             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BD0  13FC 00B9 0000485F      2846             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BD8  13FC 0020 00004860      2847             MOVE.B   #$20,GET_SRC_START_END
00002BE0                          2848  
00002BE0                          2849              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BE0  0285 0000FE3F           2850              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BE6  0685 00000040           2851              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BEC                          2852       
00002BEC                          2853              *PRINT <EA>,AN
00002BEC  6100 0AAA               2854              BSR     GET_EA_EA_SRC       *GETS <ea>
00002BF0  163C 002C               2855              MOVE.B  #',',D3
00002BF4  6100 1340               2856              BSR     PUSH_STACK                     
00002BF8  6100 0ECE               2857              BSR     GET_EA_EA_DEST      *GETS Dn
00002BFC                          2858  
00002BFC                          2859              
00002BFC                          2860              
00002BFC  4E75                    2861              RTS
00002BFE                          2862  OP1101_ADDA_W
00002BFE                          2863              *LOAD STACK WITH THIS OPMODE
00002BFE  6100 1336               2864              BSR     PUSH_STACK
00002C02  163C 0041               2865              MOVE.B  #'A',D3
00002C06  6100 132E               2866              BSR     PUSH_STACK
00002C0A  163C 0044               2867              MOVE.B  #'D',D3
00002C0E  6100 1326               2868              BSR     PUSH_STACK
00002C12  163C 0044               2869              MOVE.B  #'D',D3
00002C16  6100 131E               2870              BSR     PUSH_STACK
00002C1A  163C 0041               2871              MOVE.B  #'A',D3
00002C1E  6100 1316               2872              BSR     PUSH_STACK
00002C22  163C 002E               2873              MOVE.B  #'.',D3
00002C26  6100 130E               2874              BSR     PUSH_STACK
00002C2A  163C 0057               2875              MOVE.B  #'W',D3
00002C2E  6100 1306               2876              BSR     PUSH_STACK
00002C32                          2877              
00002C32                          2878             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C32  13FC 0000 0000485C      2879             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C3A  13FC 0000 0000485D      2880             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C42                          2881             
00002C42                          2882             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C42  13FC 00B9 0000485F      2883             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C4A  13FC 0020 00004860      2884             MOVE.B   #$20,GET_SRC_START_END
00002C52                          2885  
00002C52                          2886              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C52  0285 0000FE3F           2887              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C58  0685 00000040           2888              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C5E                          2889       
00002C5E                          2890              *PRINT <EA>,AN
00002C5E  6100 0A38               2891              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C62  163C 002C               2892              MOVE.B  #',',D3
00002C66  6100 12CE               2893              BSR     PUSH_STACK                     
00002C6A  6100 0E5C               2894              BSR     GET_EA_EA_DEST      *GETS Dn
00002C6E                          2895  
00002C6E  4E75                    2896              RTS
00002C70                          2897  
00002C70                          2898  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002C70                          2899              *LOAD STACK WITH THIS OPMODE
00002C70  6100 12C4               2900              BSR     PUSH_STACK
00002C74  163C 0041               2901              MOVE.B  #'A',D3
00002C78  6100 12BC               2902              BSR     PUSH_STACK
00002C7C  163C 0044               2903              MOVE.B  #'D',D3
00002C80  6100 12B4               2904              BSR     PUSH_STACK
00002C84  163C 0044               2905              MOVE.B  #'D',D3
00002C88  6100 12AC               2906              BSR     PUSH_STACK
00002C8C  163C 002E               2907              MOVE.B  #'.',D3
00002C90  6100 12A4               2908              BSR     PUSH_STACK
00002C94                          2909              
00002C94  2205                    2910              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C96                          2911              
00002C96                          2912              *BITS (INDEX 8) 
00002C96                          2913              *0 = ADD.B/W/L <EA>,Dn
00002C96                          2914              *1 = ADD.B/W/L Dn,<EA> 
00002C96  E099                    2915              ROR.L   #8,D1
00002C98  0281 00000001           2916              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002C9E  0C81 00000000           2917              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002CA4  6700 0102               2918              BEQ     OP1101_EA_DN
00002CA8                          2919              *else procede to Dn_EA
00002CA8                          2920              
00002CA8                          2921  OP1101_DN_EA
00002CA8                          2922              *BITS (7 TO 6) 
00002CA8                          2923              *00 = .B
00002CA8                          2924              *01 = .W
00002CA8                          2925              *10 = .L 
00002CA8  2205                    2926              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002CAA  EC99                    2927              ROR.L   #6,D1
00002CAC  0281 00000003           2928              ANDI.L  #$03,D1
00002CB2  0C81 00000000           2929              CMPI.L  #$00,D1 *EQUALS .B
00002CB8  6700 0016               2930              BEQ     OP1101_PRINT_B2
00002CBC  0C81 00000001           2931              CMPI.L  #$01,D1 *EQUALS .W
00002CC2  6700 0054               2932              BEQ     OP1101_PRINT_W2
00002CC6  0C81 00000002           2933              CMPI.L  #$02,D1 *EQUALS .L
00002CCC  6700 0092               2934              BEQ     OP1101_PRINT_L2
00002CD0                          2935  OP1101_PRINT_B2
00002CD0                          2936              *PUSH 'B'
00002CD0  163C 0042               2937              MOVE.B  #'B',D3
00002CD4  6100 1260               2938              BSR     PUSH_STACK
00002CD8                          2939             
00002CD8                          2940              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CD8  13FC 0002 0000485C      2941             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CE0  13FC 0083 0000485D      2942             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CE8                          2943             
00002CE8                          2944             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CE8  13FC 00B9 0000485F      2945             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CF0  13FC 0020 00004860      2946             MOVE.B   #$20,GET_SRC_START_END
00002CF8                          2947  
00002CF8                          2948              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CF8  0285 0000FE3F           2949              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CFE  0685 00000000           2950              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D04                          2951       
00002D04  6100 0DC2               2952              BSR     GET_EA_EA_DEST      *GETS Dn
00002D08  163C 002C               2953              MOVE.B  #',',D3
00002D0C  6100 1228               2954              BSR     PUSH_STACK                     
00002D10  6100 0986               2955              BSR     GET_EA_EA_SRC       *GETS <ea>
00002D14                          2956  
00002D14                          2957              
00002D14  6000 0192               2958              BRA     OP1101_ADD_RETURN
00002D18                          2959  OP1101_PRINT_W2
00002D18  163C 0057               2960              MOVE.B  #'W',D3
00002D1C  6100 1218               2961              BSR     PUSH_STACK
00002D20                          2962  
00002D20                          2963              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D20  13FC 0000 0000485C      2964              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D28  13FC 0083 0000485D      2965              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D30                          2966             
00002D30                          2967              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D30  13FC 00B9 0000485F      2968              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D38  13FC 0020 00004860      2969              MOVE.B   #$20,GET_SRC_START_END
00002D40                          2970  
00002D40                          2971              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D40  0285 0000FE3F           2972              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D46  0685 00000000           2973              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D4C                          2974  
00002D4C                          2975        
00002D4C  6100 0D7A               2976              BSR     GET_EA_EA_DEST      *GETS Dn
00002D50  163C 002C               2977              MOVE.B  #',',D3
00002D54  6100 11E0               2978              BSR     PUSH_STACK               
00002D58  6100 093E               2979              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002D5C                          2980  
00002D5C                          2981  
00002D5C                          2982  
00002D5C  6000 014A               2983              BRA     OP1101_ADD_RETURN
00002D60                          2984  OP1101_PRINT_L2 
00002D60  163C 004C               2985              MOVE.B  #'L',D3
00002D64  6100 11D0               2986              BSR     PUSH_STACK
00002D68                          2987              
00002D68                          2988              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D68  13FC 0000 0000485C      2989              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D70  13FC 0083 0000485D      2990              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D78                          2991             
00002D78                          2992              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D78  13FC 00B9 0000485F      2993              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D80  13FC 0020 00004860      2994              MOVE.B   #$20,GET_SRC_START_END
00002D88                          2995  
00002D88                          2996             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D88  0285 0000FE3F           2997              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D8E  0685 00000000           2998              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D94                          2999  
00002D94                          3000               
00002D94  6100 0D32               3001              BSR     GET_EA_EA_DEST       *GETS Dn
00002D98  163C 002C               3002              MOVE.B  #',',D3
00002D9C  6100 1198               3003              BSR     PUSH_STACK          
00002DA0  6100 08F6               3004              BSR     GET_EA_EA_SRC        *GETS <ea>
00002DA4                          3005  
00002DA4  6000 0102               3006              BRA     OP1101_ADD_RETURN
00002DA8                          3007              
00002DA8                          3008  OP1101_EA_DN           
00002DA8                          3009              *BITS (7 TO 6) 
00002DA8                          3010              *00 = .B
00002DA8                          3011              *01 = .W
00002DA8                          3012              *10 = .L 
00002DA8  2205                    3013              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002DAA  EC99                    3014              ROR.L   #6,D1
00002DAC  0281 00000003           3015              ANDI.L  #$03,D1
00002DB2  0C81 00000000           3016              CMPI.L  #$00,D1 *EQUALS .B
00002DB8  6700 0016               3017              BEQ     OP1101_PRINT_B
00002DBC  0C81 00000001           3018              CMPI.L  #$01,D1 *EQUALS .W
00002DC2  6700 0054               3019              BEQ     OP1101_PRINT_W
00002DC6  0C81 00000002           3020              CMPI.L  #$02,D1 *EQUALS .L
00002DCC  6700 0092               3021              BEQ     OP1101_PRINT_L
00002DD0                          3022  OP1101_PRINT_B
00002DD0  163C 0042               3023              MOVE.B  #'B',D3
00002DD4  6100 1160               3024              BSR     PUSH_STACK
00002DD8                          3025                
00002DD8                          3026              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DD8  13FC 0002 0000485C      3027              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DE0  13FC 0002 0000485D      3028              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DE8                          3029             
00002DE8                          3030              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DE8  13FC 00B9 0000485F      3031              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DF0  13FC 0020 00004860      3032              MOVE.B   #$20,GET_SRC_START_END
00002DF8                          3033  
00002DF8                          3034             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DF8  0285 0000FE3F           3035              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DFE  0685 00000000           3036              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E04                          3037  
00002E04                          3038              
00002E04  6100 0892               3039              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E08  163C 002C               3040              MOVE.B  #',',D3
00002E0C  6100 1128               3041              BSR     PUSH_STACK          
00002E10  6100 0CB6               3042              BSR     GET_EA_EA_DEST       *GETS Dn
00002E14                          3043              
00002E14  6000 0092               3044              BRA     OP1101_ADD_RETURN
00002E18                          3045  OP1101_PRINT_W
00002E18  163C 0057               3046              MOVE.B  #'W',D3
00002E1C  6100 1118               3047              BSR     PUSH_STACK
00002E20                          3048  
00002E20                          3049              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E20  13FC 0000 0000485C      3050              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E28  13FC 0000 0000485D      3051              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E30                          3052             
00002E30                          3053              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E30  13FC 00B9 0000485F      3054              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E38  13FC 0020 00004860      3055              MOVE.B   #$20,GET_SRC_START_END
00002E40                          3056  
00002E40                          3057             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E40  0285 0000FE3F           3058              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E46  0685 00000000           3059              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E4C                          3060  
00002E4C                          3061              
00002E4C  6100 084A               3062              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E50  163C 002C               3063              MOVE.B  #',',D3
00002E54  6100 10E0               3064              BSR     PUSH_STACK
00002E58  6100 0C6E               3065              BSR     GET_EA_EA_DEST       *GETS Dn    
00002E5C                          3066              
00002E5C  6000 004A               3067              BRA     OP1101_ADD_RETURN
00002E60                          3068  OP1101_PRINT_L 
00002E60  163C 004C               3069              MOVE.B  #'L',D3
00002E64  6100 10D0               3070              BSR     PUSH_STACK
00002E68                          3071              
00002E68                          3072              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E68  13FC 0000 0000485C      3073              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E70  13FC 0000 0000485D      3074              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E78                          3075             
00002E78                          3076              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E78  13FC 00B9 0000485F      3077              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E80  13FC 0020 00004860      3078              MOVE.B   #$20,GET_SRC_START_END
00002E88                          3079  
00002E88                          3080              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E88  0285 0000FE3F           3081              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E8E  0685 00000000           3082              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E94                          3083  
00002E94                          3084                     
00002E94  6100 0802               3085              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E98  163C 002C               3086              MOVE.B  #',',D3
00002E9C  6100 1098               3087              BSR     PUSH_STACK                  
00002EA0  6100 0C26               3088              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EA4                          3089  
00002EA4                          3090              
00002EA4  6000 0002               3091              BRA     OP1101_ADD_RETURN
00002EA8                          3092              
00002EA8                          3093  OP1101_ADD_RETURN
00002EA8  4E75                    3094              RTS
00002EAA                          3095              
00002EAA                          3096              *ADDW
00002EAA  0C01 0006               3097              CMPI.B  #$6,D1
00002EAE  6700 0056               3098              BEQ     OP_ADDA_W
00002EB2  0C01 000E               3099              CMPI.B  #$E,D1
00002EB6  6700 0066               3100              BEQ     OP_ADDA_L 
00002EBA                          3101  
00002EBA  4EF8 1730               3102              JMP     OP_DATA  
00002EBE                          3103            
00002EBE                          3104  *---------------------------------------------------------------------------*
00002EBE                          3105  * OP_ADD: display ADD and proceed to EA
00002EBE                          3106  *---------------------------------------------------------------------------*  
00002EBE  43F9 00004713           3107  OP_ADD_B    LEA     DISP_ADD_B,A1
00002EC4  103C 000E               3108              MOVE.B  #14,D0
00002EC8  4E4F                    3109              TRAP    #15
00002ECA  183C 0000               3110              MOVE.B  #0,D4
00002ECE  4EF9 00003248           3111              JMP     EA_GEN
00002ED4                          3112  
00002ED4  4E75                    3113              RTS
00002ED6                          3114  
00002ED6  43F9 0000471C           3115  OP_ADD_W    LEA     DISP_ADD_W,A1
00002EDC  103C 000E               3116              MOVE.B  #14,D0
00002EE0  4E4F                    3117              TRAP    #15
00002EE2  183C 0001               3118              MOVE.B  #1,D4
00002EE6  4EF9 00003248           3119              JMP     EA_GEN
00002EEC                          3120  
00002EEC  4E75                    3121              RTS
00002EEE                          3122  
00002EEE  43F9 00004725           3123  OP_ADD_L    LEA     DISP_ADD_L,A1
00002EF4  103C 000E               3124              MOVE.B  #14,D0
00002EF8  4E4F                    3125              TRAP    #15
00002EFA  183C 0002               3126              MOVE.B  #2,D4
00002EFE  4EF9 00003248           3127              JMP     EA_GEN
00002F04                          3128  
00002F04  4E75                    3129              RTS
00002F06                          3130  
00002F06                          3131  *---------------------------------------------------------------------------*
00002F06                          3132  * OP_ADDA: display ADDA and proceed to EA
00002F06                          3133  *---------------------------------------------------------------------------*  
00002F06  43F9 0000472E           3134  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002F0C  103C 000E               3135              MOVE.B  #14,D0
00002F10  4E4F                    3136              TRAP    #15
00002F12  183C 0001               3137              MOVE.B  #1,D4
00002F16  4EF9 00003248           3138              JMP     EA_GEN
00002F1C                          3139  
00002F1C  4E75                    3140              RTS
00002F1E                          3141  
00002F1E  43F9 00004738           3142  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002F24  103C 000E               3143              MOVE.B  #14,D0
00002F28  4E4F                    3144              TRAP    #15
00002F2A  183C 0002               3145              MOVE.B  #2,D4
00002F2E  4EF9 00003248           3146              JMP     EA_GEN
00002F34                          3147  
00002F34  4E75                    3148              RTS
00002F36                          3149              
00002F36                          3150  *---------------------------------------------------------------------------*
00002F36                          3151  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002F36                          3152  *---------------------------------------------------------------------------* 
00002F36  4280                    3153  OP1110      CLR.L   D0                  
00002F38  4281                    3154              CLR.L   D1   
00002F3A  4284                    3155              CLR.L   D4                   
00002F3C  227C 00000000           3156              MOVEA.L #0, A1                 
00002F42  2205                    3157              MOVE.L  D5,D1
00002F44                          3158              
00002F44                          3159              * check for LSX
00002F44  E699                    3160              ROR.L   #3,D1
00002F46  0281 00000001           3161              ANDI.L  #$1,D1
00002F4C  0C01 0001               3162              CMPI.B  #1,D1
00002F50  6700 002E               3163              BEQ     OP_LSX
00002F54                          3164              
00002F54                          3165              * reset D1 and check for ASX
00002F54  4281                    3166              CLR.L   D1
00002F56  2205                    3167              MOVE.L  D5,D1
00002F58  E699                    3168              ROR.L   #3,D1
00002F5A  0281 00000001           3169              ANDI.L  #$1,D1
00002F60  0C01 0000               3170              CMPI.B  #0,D1
00002F64  6700 0032               3171              BEQ     OP_ASX
00002F68                          3172  
00002F68                          3173              * reset D1 and check for ROX
00002F68  4281                    3174              CLR.L   D1
00002F6A  2205                    3175              MOVE.L  D5,D1
00002F6C  E699                    3176              ROR.L   #3,D1
00002F6E  0281 00000001           3177              ANDI.L  #$1,D1
00002F74  0C01 0003               3178              CMPI.B  #3,D1
00002F78  6700 0036               3179              BEQ     OP_ROX
00002F7C                          3180              
00002F7C  4EF8 1730               3181              JMP     OP_DATA
00002F80                          3182  
00002F80                          3183  *---------------------------------------------------------------------------*
00002F80                          3184  * OP_LSX: process LSR/LSL
00002F80                          3185  *---------------------------------------------------------------------------*            
00002F80  EA99                    3186  OP_LSX      ROR.L   #5,D1
00002F82  0281 00000001           3187              ANDI.L  #$1,D1
00002F88  0C01 0000               3188              CMPI.B  #0,D1
00002F8C  6700 003A               3189              BEQ     OP_LSR
00002F90  0C01 0001               3190              CMPI.B  #1,D1
00002F94  6700 008C               3191              BEQ     OP_LSL
00002F98                          3192              
00002F98                          3193  *---------------------------------------------------------------------------*
00002F98                          3194  * OP_ASX: process ASR/ASL
00002F98                          3195  *---------------------------------------------------------------------------*  
00002F98  EA99                    3196  OP_ASX      ROR.L   #5,D1
00002F9A  0281 00000001           3197              ANDI.L  #$1,D1
00002FA0  0C01 0000               3198              CMPI.B  #0,D1
00002FA4  6700 00D6               3199              BEQ     OP_ASR
00002FA8  0C01 0001               3200              CMPI.B  #1,D1
00002FAC  6700 0128               3201              BEQ     OP_ASL
00002FB0                          3202              
00002FB0                          3203  *---------------------------------------------------------------------------*
00002FB0                          3204  * OP_ROX: process ROR/ROL
00002FB0                          3205  *---------------------------------------------------------------------------*  
00002FB0  EA99                    3206  OP_ROX      ROR.L   #5,D1
00002FB2  0281 00000001           3207              ANDI.L  #$1,D1
00002FB8  0C01 0000               3208              CMPI.B  #0,D1
00002FBC  6700 0172               3209              BEQ     OP_ROR
00002FC0  0C01 0001               3210              CMPI.B  #1,D1
00002FC4  6700 01C4               3211              BEQ     OP_ROL
00002FC8                          3212  
00002FC8                          3213  *---------------------------------------------------------------------------*
00002FC8                          3214  * OP_LSR: decode and display LSR
00002FC8                          3215  *---------------------------------------------------------------------------*        
00002FC8  E599                    3216  OP_LSR      ROL.L   #2,D1
00002FCA  0281 00000003           3217              ANDI.L  #$3,D1
00002FD0  0C01 0000               3218              CMPI.B  #0,D1
00002FD4  6700 0016               3219              BEQ     OP_LSR_B
00002FD8  0C01 0001               3220              CMPI.B  #$1,D1
00002FDC  6700 0032               3221              BEQ     OP_LSR_W
00002FE0  0C01 0002               3222              CMPI.B  #$2,D1
00002FE4  6700 0018               3223              BEQ     OP_LSR_L
00002FE8                          3224              
00002FE8  4EF8 1730               3225              JMP     OP_DATA
00002FEC                          3226  
00002FEC  43F9 00004742           3227  OP_LSR_B    LEA     DISP_LSR_B,A1
00002FF2  103C 000E               3228              MOVE.B  #14,D0
00002FF6  4E4F                    3229              TRAP    #15
00002FF8  183C 0000               3230              MOVE.B  #0,D4
00002FFC  4E75                    3231              RTS
00002FFE                          3232  
00002FFE  43F9 00004766           3233  OP_LSR_L    LEA     DISP_LSR_L,A1
00003004  103C 000E               3234              MOVE.B  #14,D0
00003008  4E4F                    3235              TRAP    #15
0000300A  183C 0002               3236              MOVE.B  #2,D4
0000300E  4E75                    3237              RTS
00003010                          3238  
00003010  43F9 00004754           3239  OP_LSR_W    LEA     DISP_LSR_W,A1
00003016  103C 000E               3240              MOVE.B  #14,D0
0000301A  4E4F                    3241              TRAP    #15
0000301C  183C 0001               3242              MOVE.B  #1,D4
00003020  4E75                    3243              RTS
00003022                          3244   
00003022                          3245  *---------------------------------------------------------------------------*
00003022                          3246  * OP_LSL: decode and display LSL
00003022                          3247  *---------------------------------------------------------------------------*             
00003022  E599                    3248  OP_LSL      ROL.L   #2,D1
00003024  0281 00000003           3249              ANDI.L  #$3,D1
0000302A  0C01 0000               3250              CMPI.B  #0,D1
0000302E  6700 0016               3251              BEQ     OP_LSL_B
00003032  0C01 0001               3252              CMPI.B  #$1,D1
00003036  6700 0032               3253              BEQ     OP_LSL_W
0000303A  0C01 0002               3254              CMPI.B  #$2,D1
0000303E  6700 0018               3255              BEQ     OP_LSL_L
00003042                          3256              
00003042  4EF8 1730               3257              JMP OP_DATA
00003046                          3258  
00003046  43F9 0000474B           3259  OP_LSL_B    LEA     DISP_LSL_B,A1
0000304C  103C 000E               3260              MOVE.B  #14,D0
00003050  4E4F                    3261              TRAP    #15
00003052  183C 0000               3262              MOVE.B  #0,D4
00003056  4E75                    3263              RTS
00003058                          3264  
00003058  43F9 0000476F           3265  OP_LSL_L    LEA     DISP_LSL_L,A1
0000305E  103C 000E               3266              MOVE.B  #14,D0
00003062  4E4F                    3267              TRAP    #15
00003064  183C 0002               3268              MOVE.B  #2,D4
00003068  4E75                    3269              RTS
0000306A                          3270  
0000306A  43F9 0000475D           3271  OP_LSL_W    LEA     DISP_LSL_W,A1
00003070  103C 000E               3272              MOVE.B  #14,D0
00003074  4E4F                    3273              TRAP    #15
00003076  183C 0001               3274              MOVE.B  #1,D4
0000307A  4E75                    3275              RTS
0000307C                          3276   
0000307C                          3277  *---------------------------------------------------------------------------*
0000307C                          3278  * OP_ASR: decode and display ASR
0000307C                          3279  *---------------------------------------------------------------------------*             
0000307C  E599                    3280  OP_ASR      ROL.L   #2,D1
0000307E  0281 00000003           3281              ANDI.L  #$3,D1
00003084  0C01 0000               3282              CMPI.B  #0,D1
00003088  6700 0016               3283              BEQ     OP_ASR_B
0000308C  0C01 0001               3284              CMPI.B  #$1,D1
00003090  6700 0032               3285              BEQ     OP_ASR_W
00003094  0C01 0002               3286              CMPI.B  #$2,D1
00003098  6700 0018               3287              BEQ     OP_ASR_L
0000309C                          3288              
0000309C  4EF8 1730               3289              JMP OP_DATA
000030A0                          3290  
000030A0  43F9 00004778           3291  OP_ASR_B    LEA     DISP_ASR_B,A1
000030A6  103C 000E               3292              MOVE.B  #14,D0
000030AA  4E4F                    3293              TRAP    #15
000030AC  183C 0000               3294              MOVE.B  #0,D4
000030B0  4E75                    3295              RTS
000030B2                          3296  
000030B2  43F9 0000479C           3297  OP_ASR_L    LEA     DISP_ASR_L,A1
000030B8  103C 000E               3298              MOVE.B  #14,D0
000030BC  4E4F                    3299              TRAP    #15
000030BE  183C 0002               3300              MOVE.B  #2,D4
000030C2  4E75                    3301              RTS
000030C4                          3302  
000030C4  43F9 0000478A           3303  OP_ASR_W    LEA     DISP_ASR_W,A1
000030CA  103C 000E               3304              MOVE.B  #14,D0
000030CE  4E4F                    3305              TRAP    #15
000030D0  183C 0001               3306              MOVE.B  #1,D4
000030D4  4E75                    3307              RTS
000030D6                          3308       
000030D6                          3309  *---------------------------------------------------------------------------*
000030D6                          3310  * OP_ASL: decode and display ASL
000030D6                          3311  *---------------------------------------------------------------------------*         
000030D6  E599                    3312  OP_ASL      ROL.L   #2,D1
000030D8  0281 00000003           3313              ANDI.L  #$3,D1
000030DE  0C01 0000               3314              CMPI.B  #0,D1
000030E2  6700 0016               3315              BEQ     OP_ASL_B
000030E6  0C01 0001               3316              CMPI.B  #$1,D1
000030EA  6700 0032               3317              BEQ     OP_ASL_W
000030EE  0C01 0002               3318              CMPI.B  #$2,D1
000030F2  6700 0018               3319              BEQ     OP_ASL_L
000030F6                          3320              
000030F6  4EF8 1730               3321              JMP OP_DATA
000030FA                          3322  
000030FA  43F9 00004781           3323  OP_ASL_B    LEA     DISP_ASL_B,A1
00003100  103C 000E               3324              MOVE.B  #14,D0
00003104  4E4F                    3325              TRAP    #15
00003106  183C 0000               3326              MOVE.B  #0,D4
0000310A  4E75                    3327              RTS
0000310C                          3328  
0000310C  43F9 000047A5           3329  OP_ASL_L    LEA     DISP_ASL_L,A1
00003112  103C 000E               3330              MOVE.B  #14,D0
00003116  4E4F                    3331              TRAP    #15
00003118  183C 0002               3332              MOVE.B  #2,D4
0000311C  4E75                    3333              RTS
0000311E                          3334  
0000311E  43F9 00004793           3335  OP_ASL_W    LEA     DISP_ASL_W,A1
00003124  103C 000E               3336              MOVE.B  #14,D0
00003128  4E4F                    3337              TRAP    #15
0000312A  183C 0001               3338              MOVE.B  #1,D4
0000312E  4E75                    3339              RTS
00003130                          3340   
00003130                          3341  *---------------------------------------------------------------------------*
00003130                          3342  * OP_ROR: decode and display ROR
00003130                          3343  *---------------------------------------------------------------------------*             
00003130  E599                    3344  OP_ROR      ROL.L   #2,D1
00003132  0281 00000003           3345              ANDI.L  #$3,D1
00003138  0C01 0000               3346              CMPI.B  #0,D1
0000313C  6700 0016               3347              BEQ     OP_ROR_B
00003140  0C01 0001               3348              CMPI.B  #$1,D1
00003144  6700 0032               3349              BEQ     OP_ROR_W
00003148  0C01 0002               3350              CMPI.B  #$2,D1
0000314C  6700 0018               3351              BEQ     OP_ROR_L
00003150                          3352              
00003150  4EF8 1730               3353              JMP OP_DATA
00003154                          3354  
00003154  43F9 000047AE           3355  OP_ROR_B    LEA     DISP_ROR_B,A1
0000315A  103C 000E               3356              MOVE.B  #14,D0
0000315E  4E4F                    3357              TRAP    #15
00003160  183C 0000               3358              MOVE.B  #0,D4
00003164  4E75                    3359              RTS
00003166                          3360  
00003166  43F9 000047D2           3361  OP_ROR_L    LEA     DISP_ROR_L,A1
0000316C  103C 000E               3362              MOVE.B  #14,D0
00003170  4E4F                    3363              TRAP    #15
00003172  183C 0002               3364              MOVE.B  #2,D4
00003176  4E75                    3365              RTS
00003178                          3366  
00003178  43F9 000047C0           3367  OP_ROR_W    LEA     DISP_ROR_W,A1
0000317E  103C 000E               3368              MOVE.B  #14,D0
00003182  4E4F                    3369              TRAP    #15
00003184  183C 0001               3370              MOVE.B  #1,D4
00003188  4E75                    3371              RTS
0000318A                          3372  
0000318A                          3373  *---------------------------------------------------------------------------*
0000318A                          3374  * OP_ROL: decode and display ROL
0000318A                          3375  *---------------------------------------------------------------------------*             
0000318A  E599                    3376  OP_ROL      ROL.L   #2,D1
0000318C  0281 00000003           3377              ANDI.L  #$3,D1
00003192  0C01 0000               3378              CMPI.B  #0,D1
00003196  6700 0016               3379              BEQ     OP_ROL_B
0000319A  0C01 0001               3380              CMPI.B  #$1,D1
0000319E  6700 0032               3381              BEQ     OP_ROL_W
000031A2  0C01 0002               3382              CMPI.B  #$2,D1
000031A6  6700 0018               3383              BEQ     OP_ROL_L
000031AA                          3384              
000031AA  4EF8 1730               3385              JMP OP_DATA
000031AE                          3386  
000031AE                          3387  
000031AE  43F9 000047B7           3388  OP_ROL_B    LEA     DISP_ROL_B,A1
000031B4  103C 000E               3389              MOVE.B  #14,D0
000031B8  4E4F                    3390              TRAP    #15
000031BA  183C 0000               3391              MOVE.B  #0,D4
000031BE  4E75                    3392              RTS
000031C0                          3393  
000031C0  43F9 000047DB           3394  OP_ROL_L    LEA     DISP_ROL_L,A1
000031C6  103C 000E               3395              MOVE.B  #14,D0
000031CA  4E4F                    3396              TRAP    #15
000031CC  183C 0002               3397              MOVE.B  #2,D4
000031D0  4E75                    3398              RTS
000031D2                          3399  
000031D2  43F9 000047C9           3400  OP_ROL_W    LEA     DISP_ROL_W,A1
000031D8  103C 000E               3401              MOVE.B  #14,D0
000031DC  4E4F                    3402              TRAP    #15
000031DE  183C 0001               3403              MOVE.B  #1,D4
000031E2  4E75                    3404              RTS
000031E4                          3405              
000031E4                          3406  *---------------------------------------------------------------------------*
000031E4                          3407  * OP1111 : Special reserved
000031E4                          3408  *---------------------------------------------------------------------------*           
000031E4  4EF8 1730               3409  OP1111      JMP     OP_DATA
000031E8                          3410  
000031E8                          3411  *---------------------------------------------------------------------------*
000031E8                          3412  * EA_NOSRC: decode and display effective addresses for NEG/JSR
000031E8                          3413  *---------------------------------------------------------------------------*
000031E8                          3414  EA_NOSRC    
000031E8  4EB9 000032A6           3415              JSR     SRC_MODE
000031EE  43F9 000044A8           3416              LEA     ENDLINE_M,A1
000031F4  103C 000E               3417              MOVE.B  #14,D0
000031F8  4E4F                    3418              TRAP    #15
000031FA  4E75                    3419              RTS
000031FC                          3420              
000031FC                          3421  *---------------------------------------------------------------------------*
000031FC                          3422  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000031FC                          3423  *---------------------------------------------------------------------------*
000031FC                          3424  EA_ARITH
000031FC  4EB9 000032A6           3425              JSR     SRC_MODE
00003202  43F9 00004822           3426              LEA     DISP_D,A1
00003208  103C 000E               3427              MOVE.B  #14,D0
0000320C  4E4F                    3428              TRAP    #15
0000320E  4EB9 00003532           3429              JSR     DEST_REGISTER
00003214  43F9 000044A8           3430              LEA     ENDLINE_M,A1
0000321A  103C 000E               3431              MOVE.B  #14,D0
0000321E  4E4F                    3432              TRAP    #15
00003220  4E75                    3433              RTS
00003222                          3434              
00003222                          3435  *---------------------------------------------------------------------------*
00003222                          3436  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00003222                          3437  *---------------------------------------------------------------------------*
00003222                          3438  EA_MOVEA
00003222  4EB9 000032A6           3439              JSR     SRC_MODE
00003228  43F9 00004833           3440              LEA     DISP_AOP,A1
0000322E  103C 000E               3441              MOVE.B  #14,D0
00003232  4E4F                    3442              TRAP    #15
00003234  4EB9 00003532           3443              JSR     DEST_REGISTER
0000323A  43F9 00004831           3444              LEA     DISP_CP,A1
00003240  103C 000D               3445              MOVE.B  #13,D0
00003244  4E4F                    3446              TRAP    #15
00003246  4E75                    3447              RTS
00003248                          3448              
00003248                          3449  *---------------------------------------------------------------------------*
00003248                          3450  * EA_GEN: decode and display effective addresses for MOVE
00003248                          3451  *---------------------------------------------------------------------------*
00003248                          3452  EA_GEN          
00003248                          3453              * retrieve/display source mode/register
00003248  4EB9 000032A6           3454              JSR     SRC_MODE
0000324E                          3455              
0000324E                          3456              * retrieve/display destination mode/register
0000324E  4EB9 00003262           3457              JSR     DEST_MODE
00003254                          3458              
00003254  43F9 000044A8           3459              LEA     ENDLINE_M,A1
0000325A  103C 000E               3460              MOVE.B  #14,D0
0000325E  4E4F                    3461              TRAP    #15
00003260                          3462              
00003260  4E75                    3463              RTS
00003262                          3464  
00003262                          3465  *---------------------------------------------------------------------------*
00003262                          3466  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00003262                          3467  *---------------------------------------------------------------------------*           
00003262                          3468  DEST_MODE   
00003262                          3469              * clear registers to store temp data
00003262  4280                    3470              CLR.L   D0                      
00003264  4281                    3471              CLR.L   D1                      
00003266  207C 00000000           3472              MOVEA.L #0, A0                  
0000326C  227C 00000000           3473              MOVEA.L #0, A1                  
00003272  2205                    3474              MOVE.L  D5,D1
00003274  EC89                    3475              LSR.L   #6,D1
00003276  0281 00000007           3476              ANDI.L  #$7,D1
0000327C  0C01 0000               3477              CMPI.B  #0,D1   * Dn
00003280  6700 0082               3478              BEQ     D_MODE000
00003284  0C01 0002               3479              CMPI.B  #2,D1   * (An)
00003288  6700 00C2               3480              BEQ     D_MODE010
0000328C  0C01 0003               3481              CMPI.B  #3,D1   * (An)+
00003290  6700 011A               3482              BEQ     D_MODE011
00003294  0C01 0004               3483              CMPI.B  #4,D1   * -(An)
00003298  6700 0132               3484              BEQ     D_MODE100
0000329C  0C01 0007               3485              CMPI.B  #7,D1  * abs
000032A0  6700 017C               3486              BEQ     D_MODE111 
000032A4  4E75                    3487              RTS
000032A6                          3488  
000032A6                          3489  *---------------------------------------------------------------------------*
000032A6                          3490  * SRC_MODE: decode and display source mode (bit 5 - 3)
000032A6                          3491  *---------------------------------------------------------------------------*  
000032A6                          3492  SRC_MODE    
000032A6                          3493              * clear registers to store temp data
000032A6  4280                    3494              CLR.L   D0                      
000032A8  4281                    3495              CLR.L   D1                      
000032AA  207C 00000000           3496              MOVEA.L #0, A0                  
000032B0  227C 00000000           3497              MOVEA.L #0, A1                  
000032B6  2205                    3498              MOVE.L  D5,D1
000032B8  E489                    3499              LSR.L   #2,D1
000032BA  0281 0000000E           3500              ANDI.L  #$E,D1
000032C0                          3501              
000032C0  0C01 0000               3502              CMPI.B  #0,D1   * Dn
000032C4  6700 002A               3503              BEQ     MODE000
000032C8  0C01 0002               3504              CMPI.B  #2,D1   * An 
000032CC  6700 004A               3505              BEQ     MODE001
000032D0  0C01 0004               3506              CMPI.B  #4,D1   * (An)
000032D4  6700 0056               3507              BEQ     MODE010
000032D8  0C01 0006               3508              CMPI.B  #6,D1   * (An)+
000032DC  6700 008E               3509              BEQ     MODE011
000032E0  0C01 0008               3510              CMPI.B  #8,D1   * -(An)
000032E4  6700 00A6               3511              BEQ     MODE100
000032E8  0C01 000F               3512              CMPI.B  #15,D1  * abs/immediate
000032EC  6700 00FE               3513              BEQ     MODE111 
000032F0                          3514        
000032F0                          3515  *---------------------------------------------------------------------------*
000032F0                          3516  * MODE000: decode and display source mode Dn
000032F0                          3517  *---------------------------------------------------------------------------*           
000032F0                          3518  MODE000     *Dn
000032F0  43F9 00004822           3519              LEA     DISP_D,A1
000032F6  103C 000E               3520              MOVE.B  #14,D0
000032FA  4E4F                    3521              TRAP    #15
000032FC  4EB9 0000358E           3522              JSR     SRC_REGISTER
00003302  4E75                    3523              RTS
00003304                          3524  
00003304                          3525  *---------------------------------------------------------------------------*
00003304                          3526  * D_MODE000: decode and display dest mode Dn
00003304                          3527  *---------------------------------------------------------------------------*
00003304                          3528  D_MODE000     *Dn
00003304  43F9 00004822           3529              LEA     DISP_D,A1
0000330A  103C 000E               3530              MOVE.B  #14,D0
0000330E  4E4F                    3531              TRAP    #15
00003310  4EB9 00003532           3532              JSR     DEST_REGISTER
00003316  4E75                    3533              RTS
00003318                          3534  
00003318                          3535  *---------------------------------------------------------------------------*
00003318                          3536  * MODE001: decode and display source mode An
00003318                          3537  *---------------------------------------------------------------------------* 
00003318                          3538  MODE001 *An
00003318  43F9 00004827           3539              LEA     DISP_A,A1
0000331E  103C 000E               3540              MOVE.B  #14,D0
00003322  4E4F                    3541              TRAP    #15
00003324  4EB9 0000358E           3542              JSR     SRC_REGISTER
0000332A                          3543          
0000332A  4E75                    3544              RTS
0000332C                          3545  
0000332C                          3546  *---------------------------------------------------------------------------*
0000332C                          3547  * MODE010: decode and display source mode (An)
0000332C                          3548  *---------------------------------------------------------------------------*    
0000332C                          3549  MODE010 *(An)
0000332C  43F9 00004833           3550              LEA     DISP_AOP,A1  *display (A
00003332  103C 000E               3551              MOVE.B  #14,D0
00003336  4E4F                    3552              TRAP    #15
00003338                          3553  
00003338  4EB9 0000358E           3554              JSR     SRC_REGISTER * display register
0000333E                          3555  
0000333E  43F9 00004831           3556              LEA     DISP_CP,A1   *display )
00003344  103C 000E               3557              MOVE.B  #14,D0
00003348  4E4F                    3558              TRAP    #15
0000334A                          3559              
0000334A  4E75                    3560              RTS
0000334C                          3561  
0000334C                          3562  *---------------------------------------------------------------------------*
0000334C                          3563  * D_MODE010: decode and display dest mode (An)
0000334C                          3564  *---------------------------------------------------------------------------*
0000334C                          3565  D_MODE010 *(An)
0000334C  43F9 00004833           3566              LEA     DISP_AOP,A1  *display (A
00003352  103C 000E               3567              MOVE.B  #14,D0
00003356  4E4F                    3568              TRAP    #15
00003358                          3569     
00003358  4EB9 00003532           3570              JSR     DEST_REGISTER * display register
0000335E                          3571  
0000335E  43F9 00004831           3572              LEA     DISP_CP,A1   *display )
00003364  103C 000E               3573              MOVE.B  #14,D0
00003368  4E4F                    3574              TRAP    #15
0000336A                          3575              
0000336A  4E75                    3576              RTS
0000336C                          3577  
0000336C                          3578  *---------------------------------------------------------------------------*
0000336C                          3579  * MODE011: decode and display source mode (An)+
0000336C                          3580  *---------------------------------------------------------------------------*
0000336C                          3581  MODE011 *(An)+
0000336C  43F9 00004833           3582              LEA     DISP_AOP,A1      *display (A
00003372  103C 000E               3583              MOVE.B  #14,D0
00003376  4E4F                    3584              TRAP    #15
00003378                          3585              
00003378  4EB9 0000358E           3586              JSR     SRC_REGISTER    * display register
0000337E                          3587  
0000337E  43F9 00004840           3588              LEA     DISP_POST,A1    *display )+
00003384  103C 000E               3589              MOVE.B  #14,D0
00003388  4E4F                    3590              TRAP    #15
0000338A                          3591              
0000338A  4E75                    3592              RTS
0000338C                          3593              
0000338C                          3594  *---------------------------------------------------------------------------*
0000338C                          3595  * MODE100: decode and display source mode -(An)
0000338C                          3596  *---------------------------------------------------------------------------*
0000338C                          3597  MODE100 *-(An)
0000338C  43F9 00004839           3598              LEA     DISP_PRE,A1    *display -(A
00003392  103C 000E               3599              MOVE.B  #14,D0
00003396  4E4F                    3600              TRAP    #15
00003398                          3601  
00003398  4EB9 0000358E           3602              JSR     SRC_REGISTER    *display register
0000339E                          3603  
0000339E  43F9 00004831           3604              LEA     DISP_CP,A1   *display )
000033A4  103C 000E               3605              MOVE.B  #14,D0
000033A8  4E4F                    3606              TRAP    #15
000033AA                          3607              
000033AA  4E75                    3608              RTS
000033AC                          3609  
000033AC                          3610  *---------------------------------------------------------------------------*
000033AC                          3611  * D_MODE011: decode and display dest mode (An)+
000033AC                          3612  *---------------------------------------------------------------------------*
000033AC                          3613  D_MODE011 *(An)+
000033AC  43F9 00004833           3614              LEA     DISP_AOP,A1      *display (A
000033B2  103C 000E               3615              MOVE.B  #14,D0
000033B6  4E4F                    3616              TRAP    #15
000033B8                          3617  
000033B8  4EB9 00003532           3618              JSR     DEST_REGISTER    * display register
000033BE                          3619  
000033BE  43F9 00004840           3620              LEA     DISP_POST,A1    *display )+
000033C4  103C 000E               3621              MOVE.B  #14,D0
000033C8  4E4F                    3622              TRAP    #15
000033CA                          3623              
000033CA  4E75                    3624              RTS
000033CC                          3625              
000033CC                          3626  *---------------------------------------------------------------------------*
000033CC                          3627  * D_MODE100: decode and display dest mode -(An)
000033CC                          3628  *---------------------------------------------------------------------------*            
000033CC                          3629  D_MODE100 *-(An)
000033CC  43F9 00004839           3630              LEA     DISP_PRE,A1    *display -(A
000033D2  103C 000E               3631              MOVE.B  #14,D0
000033D6  4E4F                    3632              TRAP    #15
000033D8                          3633              
000033D8  4EB9 00003532           3634              JSR     DEST_REGISTER    *display register
000033DE                          3635  
000033DE  43F9 00004831           3636              LEA     DISP_CP,A1   *display )
000033E4  103C 000E               3637              MOVE.B  #14,D0
000033E8  4E4F                    3638              TRAP    #15
000033EA                          3639              
000033EA  4E75                    3640              RTS
000033EC                          3641  
000033EC                          3642  *---------------------------------------------------------------------------*
000033EC                          3643  * MODE111: decode and display source mode absolute/immediate
000033EC                          3644  *---------------------------------------------------------------------------*
000033EC                          3645  MODE111     * abs/immediate
000033EC                          3646              * clear registers to store temp data
000033EC  4280                    3647              CLR.L   D0                      
000033EE  4281                    3648              CLR.L   D1                      
000033F0  207C 00000000           3649              MOVEA.L #0, A0                  
000033F6  227C 00000000           3650              MOVEA.L #0, A1                  
000033FC  2205                    3651              MOVE.L  D5,D1
000033FE                          3652              
000033FE                          3653              * retrieve source register for MODE 111
000033FE  E389                    3654              LSL.L   #1,D1   * shift the bits to left by 1
00003400  0281 0000000E           3655              ANDI.L  #$E,D1  * mask the first 4 bits 
00003406  0C01 0000               3656              CMPI.B  #0, D1  * if it's 0000, absolute word address
0000340A  6700 003E               3657              BEQ     WORDMODE
0000340E  0C01 0002               3658              CMPI.B  #2, D1  * if it's 0010, absolute long address
00003412  6700 0062               3659              BEQ     LONGMODE
00003416  0C01 0008               3660              CMPI.B  #8, D1  * if it's 1000, immediate data
0000341A  6700 0086               3661              BEQ     IMMEDIATE
0000341E                          3662       
0000341E                          3663  *---------------------------------------------------------------------------*
0000341E                          3664  * D_MODE111: decode and display dest mode absolute/immediate
0000341E                          3665  *---------------------------------------------------------------------------*           
0000341E                          3666  D_MODE111   * abs
0000341E                          3667              * clear registers to store temp data
0000341E  4280                    3668              CLR.L   D0                      
00003420  4281                    3669              CLR.L   D1                      
00003422  207C 00000000           3670              MOVEA.L #0, A0                  
00003428  227C 00000000           3671              MOVEA.L #0, A1                  
0000342E  2205                    3672              MOVE.L  D5,D1
00003430                          3673              
00003430                          3674              * retrieve dest register for MODE 111
00003430  EC89                    3675              LSR.L   #6,D1   * shift the bits to right by 6
00003432  E689                    3676              LSR.L   #3,D1   * shift the bits to right by extra 3
00003434  0201 0001               3677              ANDI.B  #1,D1   * mask the first 2 bits 
00003438  0C01 0000               3678              CMPI.B  #0, D1  * if it's 000, absolute word address
0000343C  6700 000C               3679              BEQ     WORDMODE
00003440  0C01 0001               3680              CMPI.B  #1, D1  * if it's 001, absolute long address
00003444  6700 0030               3681              BEQ     LONGMODE
00003448                          3682              *JSR     OP_DATA *not sure..
00003448  4E75                    3683              RTS
0000344A                          3684  
0000344A                          3685  
0000344A                          3686  *---------------------------------------------------------------------------*
0000344A                          3687  * WORDMODE: absolute word address
0000344A                          3688  *---------------------------------------------------------------------------*
0000344A  43F9 0000481D           3689  WORDMODE    LEA     DISP_HEX,A1
00003450  103C 000E               3690              MOVE.B  #14,D0
00003454  4E4F                    3691              TRAP    #15
00003456                          3692              
00003456  4285                    3693              CLR.L   D5
00003458  3A1D                    3694              MOVE.W  (A5)+,D5
0000345A                          3695              
0000345A  43F9 000044FB           3696              LEA     TMPOUTPUT,A1
00003460  2205                    3697              MOVE.L  D5,D1
00003462  7404                    3698              MOVE.L  #4,D2       *move word size 4
00003464  4EB8 11FE               3699              JSR     HEX2ASCII
00003468  43F9 000044FB           3700              LEA     TMPOUTPUT,A1
0000346E  103C 000E               3701              MOVE.B  #14,D0
00003472  4E4F                    3702              TRAP    #15
00003474                          3703              
00003474  4E75                    3704              RTS
00003476                          3705  
00003476                          3706  *---------------------------------------------------------------------------*
00003476                          3707  * LONGMODE: absolute long address
00003476                          3708  *---------------------------------------------------------------------------*
00003476  43F9 0000481D           3709  LONGMODE    LEA     DISP_HEX,A1
0000347C  103C 000E               3710              MOVE.B  #14,D0
00003480  4E4F                    3711              TRAP    #15
00003482                          3712              
00003482  4285                    3713              CLR.L   D5
00003484  2A1D                    3714              MOVE.L  (A5)+,D5
00003486                          3715              
00003486  43F9 000044FB           3716              LEA     TMPOUTPUT,A1
0000348C  2205                    3717              MOVE.L  D5,D1
0000348E  7408                    3718              MOVE.L  #8,D2           *move longword size 8
00003490  4EB8 11FE               3719              JSR     HEX2ASCII
00003494  43F9 000044FB           3720              LEA     TMPOUTPUT,A1
0000349A  103C 000E               3721              MOVE.B  #14,D0
0000349E  4E4F                    3722              TRAP    #15
000034A0                          3723              
000034A0  4E75                    3724              RTS
000034A2                          3725  
000034A2                          3726  
000034A2                          3727  *---------------------------------------------------------------------------*
000034A2                          3728  * IMMEDIATE: immediate address
000034A2                          3729  *---------------------------------------------------------------------------*
000034A2  43F9 00004843           3730  IMMEDIATE   LEA     DISP_LB,A1
000034A8  103C 000E               3731              MOVE.B  #14,D0
000034AC  4E4F                    3732              TRAP    #15
000034AE  43F9 0000481D           3733              LEA     DISP_HEX,A1
000034B4  103C 000E               3734              MOVE.B  #14,D0
000034B8  4E4F                    3735              TRAP    #15
000034BA                          3736              
000034BA                          3737              * check for size
000034BA  0C04 0000               3738              CMPI.B  #0,D4
000034BE  6700 0012               3739              BEQ     IMMD_B
000034C2  0C04 0001               3740              CMPI.B  #1,D4
000034C6  6700 002A               3741              BEQ     IMMD_W
000034CA  0C04 0002               3742              CMPI.B  #2,D4
000034CE  6700 0042               3743              BEQ     IMMD_L
000034D2                          3744  
000034D2                          3745  IMMD_B
000034D2  4285                    3746              CLR.L   D5
000034D4  3A1D                    3747              MOVE.W  (A5)+,D5
000034D6                          3748              
000034D6  43F9 000044FB           3749              LEA     TMPOUTPUT,A1
000034DC  2205                    3750              MOVE.L  D5,D1
000034DE  7402                    3751              MOVE.L  #2,D2
000034E0  4EB8 11FE               3752              JSR     HEX2ASCII
000034E4  43F9 000044FB           3753              LEA     TMPOUTPUT,A1
000034EA  103C 000E               3754              MOVE.B  #14,D0
000034EE  4E4F                    3755              TRAP    #15
000034F0  4E75                    3756              RTS
000034F2                          3757              
000034F2                          3758  IMMD_W
000034F2  4285                    3759              CLR.L   D5
000034F4  3A1D                    3760              MOVE.W  (A5)+,D5
000034F6                          3761              
000034F6  43F9 000044FB           3762              LEA     TMPOUTPUT,A1
000034FC  2205                    3763              MOVE.L  D5,D1
000034FE  7404                    3764              MOVE.L  #4,D2
00003500  4EB8 11FE               3765              JSR     HEX2ASCII
00003504  43F9 000044FB           3766              LEA     TMPOUTPUT,A1
0000350A  103C 000E               3767              MOVE.B  #14,D0
0000350E  4E4F                    3768              TRAP    #15
00003510  4E75                    3769              RTS
00003512                          3770              
00003512                          3771  
00003512                          3772  IMMD_L
00003512  4285                    3773              CLR.L   D5
00003514  3A1D                    3774              MOVE.W  (A5)+,D5
00003516                          3775              
00003516  43F9 000044FB           3776              LEA     TMPOUTPUT,A1
0000351C  2205                    3777              MOVE.L  D5,D1
0000351E  7408                    3778              MOVE.L  #8,D2
00003520  4EB8 11FE               3779              JSR     HEX2ASCII
00003524  43F9 000044FB           3780              LEA     TMPOUTPUT,A1
0000352A  103C 000E               3781              MOVE.B  #14,D0
0000352E  4E4F                    3782              TRAP    #15
00003530  4E75                    3783              RTS
00003532                          3784  
00003532                          3785  
00003532                          3786  *---------------------------------------------------------------------------*
00003532                          3787  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
00003532                          3788  *---------------------------------------------------------------------------*
00003532                          3789  DEST_REGISTER
00003532                          3790              * clear registers to store temp data
00003532  4280                    3791              CLR.L   D0                      
00003534  4281                    3792              CLR.L   D1                      
00003536  207C 00000000           3793              MOVEA.L #0, A0                  
0000353C  227C 00000000           3794              MOVEA.L #0, A1 
00003542                          3795              
00003542  2205                    3796              MOVE.L  D5,D1
00003544  EC89                    3797              LSR.L   #6,D1
00003546  E689                    3798              LSR.L   #3,D1
00003548  0281 00000007           3799              ANDI.L  #7,D1
0000354E                          3800              
0000354E  0C01 0000               3801              CMPI.B  #0,D1
00003552  6700 0092               3802              BEQ     REG_0
00003556  0C01 0001               3803              CMPI.B  #1,D1
0000355A  6700 0098               3804              BEQ     REG_1
0000355E  0C01 0002               3805              CMPI.B  #2,D1
00003562  6700 009E               3806              BEQ     REG_2
00003566  0C01 0003               3807              CMPI.B  #3,D1
0000356A  6700 00A4               3808              BEQ     REG_3
0000356E  0C01 0004               3809              CMPI.B  #4,D1
00003572  6700 00AA               3810              BEQ     REG_4
00003576  0C01 0005               3811              CMPI.B  #5,D1
0000357A  6700 00B0               3812              BEQ     REG_5
0000357E  0C01 0006               3813              CMPI.B  #6,D1
00003582  6700 00B6               3814              BEQ     REG_6
00003586  0C01 0007               3815              CMPI.B  #7,D1
0000358A  6700 00BC               3816              BEQ     REG_7
0000358E                          3817  
0000358E                          3818  *---------------------------------------------------------------------------*
0000358E                          3819  * SRC_REGISTER: decode and display source register (bit 2 - 0)
0000358E                          3820  *---------------------------------------------------------------------------*           
0000358E                          3821  SRC_REGISTER 
0000358E                          3822              * clear registers to store temp data
0000358E  4280                    3823              CLR.L   D0                      
00003590  4281                    3824              CLR.L   D1                      
00003592  207C 00000000           3825              MOVEA.L #0, A0                  
00003598  227C 00000000           3826              MOVEA.L #0, A1                  
0000359E                          3827              
0000359E  2205                    3828              MOVE.L  D5,D1   * temp store the processing data
000035A0  0281 00000007           3829              ANDI.L  #7,D1   * mask the first 4 bits with 0111
000035A6                          3830              
000035A6  0C01 0000               3831              CMPI.B  #0,D1
000035AA  6700 003A               3832              BEQ     REG_0
000035AE  0C01 0001               3833              CMPI.B  #1,D1
000035B2  6700 0040               3834              BEQ     REG_1
000035B6  0C01 0002               3835              CMPI.B  #2,D1
000035BA  6700 0046               3836              BEQ     REG_2
000035BE  0C01 0003               3837              CMPI.B  #3,D1
000035C2  6700 004C               3838              BEQ     REG_3
000035C6  0C01 0004               3839              CMPI.B  #4,D1
000035CA  6700 0052               3840              BEQ     REG_4
000035CE  0C01 0005               3841              CMPI.B  #5,D1
000035D2  6700 0058               3842              BEQ     REG_5
000035D6  0C01 0006               3843              CMPI.B  #6,D1
000035DA  6700 005E               3844              BEQ     REG_6
000035DE  0C01 0007               3845              CMPI.B  #7,D1
000035E2  6700 0064               3846              BEQ     REG_7
000035E6                          3847  
000035E6                          3848  *---------------------------------------------------------------------------*
000035E6                          3849  * REG_0 ~ REG_7: display register 0 to 7
000035E6                          3850  *---------------------------------------------------------------------------*
000035E6  43F9 00004848           3851  REG_0       LEA     DISP_0,A1
000035EC  103C 000E               3852              MOVE.B  #14,D0
000035F0  4E4F                    3853              TRAP    #15
000035F2  4E75                    3854              RTS
000035F4                          3855              
000035F4  43F9 0000484A           3856  REG_1       LEA     DISP_1,A1
000035FA  103C 000E               3857              MOVE.B  #14,D0
000035FE  4E4F                    3858              TRAP    #15
00003600  4E75                    3859              RTS
00003602                          3860              
00003602                          3861  
00003602  43F9 0000484C           3862  REG_2       LEA     DISP_2,A1
00003608  103C 000E               3863              MOVE.B  #14,D0
0000360C  4E4F                    3864              TRAP    #15
0000360E  4E75                    3865              RTS
00003610                          3866            
00003610  43F9 0000484E           3867  REG_3       LEA     DISP_3,A1
00003616  103C 000E               3868              MOVE.B  #14,D0
0000361A  4E4F                    3869              TRAP    #15
0000361C  4E75                    3870              RTS
0000361E                          3871              
0000361E  43F9 00004850           3872  REG_4       LEA     DISP_4,A1
00003624  103C 000E               3873              MOVE.B  #14,D0
00003628  4E4F                    3874              TRAP    #15
0000362A  4E75                    3875              RTS
0000362C                          3876              
0000362C  43F9 00004852           3877  REG_5       LEA     DISP_5,A1
00003632  103C 000E               3878              MOVE.B  #14,D0
00003636  4E4F                    3879              TRAP    #15
00003638  4E75                    3880              RTS
0000363A                          3881              
0000363A  43F9 00004854           3882  REG_6       LEA     DISP_6,A1
00003640  103C 000E               3883              MOVE.B  #14,D0
00003644  4E4F                    3884              TRAP    #15
00003646  4E75                    3885              RTS
00003648                          3886              
00003648  43F9 00004856           3887  REG_7       LEA     DISP_7,A1
0000364E  103C 000E               3888              MOVE.B  #14,D0
00003652  4E4F                    3889              TRAP    #15
00003654  4E75                    3890              RTS
00003656                          3891              
00003656                          3892  *---------------------------------------------------------------------------*
00003656                          3893  * REPEAT : Ask user whether they wish to run the program again
00003656                          3894  *---------------------------------------------------------------------------*           
00003656  4246                    3895  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00003658  43F9 00004321           3896              LEA     REPEATMSG,A1
0000365E  103C 000E               3897              MOVE.B  #14,D0
00003662  4E4F                    3898              TRAP    #15
00003664                          3899              
00003664  43F9 000044AB           3900              LEA     TMPINPUT,A1             * allocate space to temp store user input
0000366A  103C 0002               3901              MOVE.B  #2,D0
0000366E  4E4F                    3902              TRAP    #15
00003670                          3903  
00003670  0C01 0001               3904              CMPI.B  #1,D1                   * check for length of user input
00003674  66E0                    3905              BNE     REPEAT                  * return to the beginning of the function if unequal
00003676                          3906              
00003676  0C11 0059               3907              CMPI.B  #$59,(A1)               * compare the input with Y    
0000367A  6700 D98E               3908              BEQ     PROGLP                  * repeat the program
0000367E                          3909              
0000367E  0C11 0079               3910              CMPI.B  #$79,(A1)               * compare the input with y    
00003682  6700 D986               3911              BEQ     PROGLP                  * repeat the program
00003686                          3912              
00003686  0C11 004E               3913              CMPI.B  #$4E,(A1)               * compare the input with N    
0000368A  6700 0928               3914              BEQ     TERMINATE               * finish program
0000368E                          3915              
0000368E  0C11 006E               3916              CMPI.B  #$6E,(A1)               * compare the input with n    
00003692  6700 0920               3917              BEQ     TERMINATE               * finish program
00003696                          3918              
00003696  60BE                    3919              BRA     REPEAT                  * invalid input/repeat the function
00003698                          3920  
00003698                          3921  *---------------------------------------------------------------------------*
00003698                          3922  * EA DECODING INTERFACE
00003698                          3923  * [A0] - RESERVED FOR USE
00003698                          3924  * [D2] - RESERVED FOR USE
00003698                          3925  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00003698                          3926  *---------------------------------------------------------------------------*
00003698                          3927  GET_EA_EA_SRC
00003698                          3928      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003698                          3929      
00003698                          3930      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003698  2405                    3931      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000369A  E68A                    3932      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
0000369C  23C2 0000486E           3933      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
000036A2  7407                    3934      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
000036A4  C5B9 0000486E           3935      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
000036AA                          3936                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
000036AA                          3937      
000036AA                          3938      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
000036AA                          3939      *DESTINATION REGISTER FORMAT STANDARD         *
000036AA                          3940      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
000036AA                          3941      *WHEN BIT = 0(VALID ADDRESS MODE)             *
000036AA                          3942      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
000036AA                          3943      *0 - Dn                                       *
000036AA                          3944      *1 - An                                       *
000036AA                          3945      *2 - (An)                                     *
000036AA                          3946      *3 - (An)+                                    *
000036AA                          3947      *4 - -(An)                                    *
000036AA                          3948      *5 - (XXX).W                                  *
000036AA                          3949      *6 - (XXX).L                                  *
000036AA                          3950      *7 - #<data>                                  *
000036AA                          3951      ***********************************************
000036AA                          3952      
000036AA                          3953      *** Check if source ...  <ea> = Dn
000036AA                          3954  CHECK0    
000036AA  41F9 0000485E           3955            LEA     TEMP_REGISTER_FORMAT,A0
000036B0  1439 0000485D           3956            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036B6  1082                    3957            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036B8  0239 0001 0000485E      3958            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000036C0  0C39 0001 0000485E      3959            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
000036C8  6700 006A               3960            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000036CC  0CB9 00000000 0000486E  3961            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000036D6  6600 005C               3962            BNE     CHECK1
000036DA                          3963            
000036DA                          3964            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000036DA  163C 0020               3965            MOVE.B    #' ',D3
000036DE  6100 0856               3966            BSR       PUSH_STACK
000036E2  163C 0044               3967            MOVE.B    #'D',D3
000036E6  6100 084E               3968            BSR       PUSH_STACK
000036EA                          3969  
000036EA                          3970            *FIND REGISTER NUMBER END LOCATION*  
000036EA  13F9 00004860 00004866  3971            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000036F4  0239 000F 00004866      3972            AND.B   #$0F,VAR_BYTE_END
000036FC                          3973            
000036FC                          3974            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036FC  23C5 0000486A           3975            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003702  1439 00004866           3976            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003708                          3977            
00003708                          3978            *INTITIALIZE FOR BIT SHIFTING
00003708  41F9 0000486A           3979            LEA     VAR_TEMP_CLEANCOPY,A0
0000370E  2639 0000486A           3980            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003714                          3981  LOOP_SHIFTING
00003714  0C02 0000               3982            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003718  6700 0008               3983            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000371C  E24B                    3984            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000371E  5302                    3985            SUB.B   #1,D2                     *DECREMENT COUNTER
00003720  60F2                    3986            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00003722                          3987  MASKING_NEXT
00003722  C6BC 00000007           3988            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003728  0603 0030               3989            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000372C  6100 0808               3990            BSR     PUSH_STACK                *PUSH TO STACK
00003730                          3991            
00003730  6000 0394               3992            BRA     GET_SRC_SUCCESS           *RETURN          
00003734                          3993            
00003734                          3994            
00003734                          3995            *** Check if source ...  <ea> = An
00003734  41F9 0000485E           3996  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
0000373A  1439 0000485D           3997            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003740  1082                    3998            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003742  0239 0002 0000485E      3999            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
0000374A  0C39 0002 0000485E      4000            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003752  6700 006A               4001            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003756  0CB9 00000001 0000486E  4002            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003760  6600 005C               4003            BNE     CHECK2
00003764                          4004            
00003764                          4005            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003764  163C 0020               4006            MOVE.B    #' ',D3
00003768  6100 07CC               4007            BSR       PUSH_STACK
0000376C  163C 0041               4008            MOVE.B    #'A',D3
00003770  6100 07C4               4009            BSR       PUSH_STACK
00003774                          4010  
00003774                          4011            
00003774                          4012            *FIND REGISTER NUMBER END LOCATION*  
00003774  13F9 00004860 00004866  4013            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000377E  0239 000F 00004866      4014            AND.B   #$0F,VAR_BYTE_END
00003786                          4015            
00003786                          4016            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003786  23C5 0000486A           4017            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000378C  1439 00004866           4018            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003792                          4019            
00003792                          4020            *INTITIALIZE FOR BIT SHIFTING
00003792  41F9 0000486A           4021            LEA     VAR_TEMP_CLEANCOPY,A0
00003798  2639 0000486A           4022            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000379E                          4023  LOOP_SHIFTING1
0000379E  0C02 0000               4024            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037A2  6700 0008               4025            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000037A6  E24B                    4026            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037A8  5302                    4027            SUB.B   #1,D2                     *DECREMENT COUNTER
000037AA  60F2                    4028            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
000037AC                          4029  MASKING_NEXT1
000037AC  C6BC 00000007           4030            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037B2  0603 0030               4031            ADD.B   #$30,D3                   *CONVERT TO CHAR
000037B6  6100 077E               4032            BSR     PUSH_STACK                *PUSH TO STACK
000037BA                          4033            
000037BA  6000 030A               4034            BRA     GET_SRC_SUCCESS                   *RETURN 
000037BE                          4035            
000037BE                          4036            
000037BE                          4037            
000037BE                          4038            
000037BE                          4039            *** Check if source ...  <ea> = (An)       
000037BE  41F9 0000485E           4040  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
000037C4  1439 0000485D           4041            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037CA  1082                    4042            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037CC  0239 0004 0000485E      4043            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
000037D4  0C39 0004 0000485E      4044            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
000037DC  6700 007A               4045            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000037E0  0CB9 00000002 0000486E  4046            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000037EA  6600 006C               4047            BNE     CHECK3
000037EE                          4048            
000037EE                          4049            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000037EE  163C 0020               4050            MOVE.B    #' ',D3
000037F2  6100 0742               4051            BSR       PUSH_STACK
000037F6  163C 0028               4052            MOVE.B    #'(',D3
000037FA  6100 073A               4053            BSR       PUSH_STACK
000037FE  163C 0041               4054            MOVE.B    #'A',D3
00003802  6100 0732               4055            BSR       PUSH_STACK
00003806                          4056  
00003806                          4057            
00003806                          4058            *FIND REGISTER NUMBER END LOCATION*  
00003806  13F9 00004860 00004866  4059            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003810  0239 000F 00004866      4060            AND.B   #$0F,VAR_BYTE_END
00003818                          4061            
00003818                          4062            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003818  23C5 0000486A           4063            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000381E  1439 00004866           4064            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003824                          4065            
00003824                          4066            *INTITIALIZE FOR BIT SHIFTING
00003824  41F9 0000486A           4067            LEA     VAR_TEMP_CLEANCOPY,A0
0000382A  2639 0000486A           4068            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003830                          4069  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003830  0C02 0000               4070            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003834  6700 0008               4071            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003838  E24B                    4072            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000383A  5302                    4073            SUB.B   #1,D2                     *DECREMENT COUNTER
0000383C  60F2                    4074            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
0000383E                          4075  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
0000383E  0283 00000007           4076            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003844  0603 0030               4077            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003848  6100 06EC               4078            BSR     PUSH_STACK                *PUSH TO STACK
0000384C                          4079            
0000384C  163C 0029               4080            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003850  6100 06E4               4081            BSR       PUSH_STACK
00003854                          4082            
00003854  6000 0270               4083            BRA     GET_SRC_SUCCESS                   *RETURN 
00003858                          4084  
00003858                          4085            
00003858                          4086            
00003858                          4087                      
00003858                          4088  *** Check if source ...  <ea> = (An)+       
00003858  41F9 0000485E           4089  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
0000385E  1439 0000485D           4090            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003864  1082                    4091            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003866  0239 0008 0000485E      4092            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
0000386E  0C39 0008 0000485E      4093            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003876  6700 0082               4094            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000387A  0CB9 00000003 0000486E  4095            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003884  6600 0074               4096            BNE     CHECK4
00003888                          4097            
00003888                          4098            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003888  163C 0020               4099            MOVE.B    #' ',D3
0000388C  6100 06A8               4100            BSR       PUSH_STACK
00003890  163C 0028               4101            MOVE.B    #'(',D3
00003894  6100 06A0               4102            BSR       PUSH_STACK
00003898  163C 0041               4103            MOVE.B    #'A',D3
0000389C  6100 0698               4104            BSR       PUSH_STACK
000038A0                          4105  
000038A0                          4106            
000038A0                          4107            *FIND REGISTER NUMBER END LOCATION*  
000038A0  13F9 00004860 00004866  4108            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038AA  0239 000F 00004866      4109            ANDI.B   #$0F,VAR_BYTE_END
000038B2                          4110            
000038B2                          4111            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038B2  23C5 0000486A           4112            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038B8  1439 00004866           4113            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038BE                          4114            
000038BE                          4115            *INTITIALIZE FOR BIT SHIFTING
000038BE  41F9 0000486A           4116            LEA     VAR_TEMP_CLEANCOPY,A0
000038C4  2639 0000486A           4117            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038CA                          4118            
000038CA                          4119  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
000038CA  0C02 0000               4120            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038CE  6700 0008               4121            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000038D2  E24B                    4122            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000038D4  5302                    4123            SUBI.B   #1,D2                     *DECREMENT COUNTER
000038D6  60F2                    4124            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
000038D8                          4125                                               *change: NAME OF LABEL*
000038D8                          4126  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
000038D8  0283 00000007           4127            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000038DE  0603 0030               4128            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000038E2  6100 0652               4129            BSR     PUSH_STACK                *PUSH TO STACK
000038E6                          4130            
000038E6  163C 0029               4131            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000038EA  6100 064A               4132            BSR       PUSH_STACK
000038EE  163C 002B               4133            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000038F2  6100 0642               4134            BSR       PUSH_STACK
000038F6                          4135            
000038F6  6000 01CE               4136            BRA       GET_SRC_SUCCESS                   *RETURN 
000038FA                          4137  
000038FA                          4138            
000038FA                          4139            
000038FA                          4140                      
000038FA                          4141            *** Check if source ...  <ea> = -(An)       
000038FA  41F9 0000485E           4142  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003900  1439 0000485D           4143            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003906  1082                    4144            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003908  0239 0010 0000485E      4145            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003910  0C39 0010 0000485E      4146            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003918  6700 0082               4147            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000391C  0CB9 00000004 0000486E  4148            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003926  6600 0074               4149            BNE     CHECK7
0000392A                          4150            
0000392A                          4151            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000392A  163C 0020               4152            MOVE.B    #' ',D3
0000392E  6100 0606               4153            BSR       PUSH_STACK
00003932  163C 002D               4154            MOVE.B    #'-',D3
00003936  6100 05FE               4155            BSR       PUSH_STACK
0000393A  163C 0028               4156            MOVE.B    #'(',D3
0000393E  6100 05F6               4157            BSR       PUSH_STACK
00003942  163C 0041               4158            MOVE.B    #'A',D3
00003946  6100 05EE               4159            BSR       PUSH_STACK
0000394A                          4160  
0000394A                          4161            
0000394A                          4162            *FIND REGISTER NUMBER END LOCATION*  
0000394A  13F9 00004860 00004866  4163            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003954  0239 000F 00004866      4164            AND.B   #$0F,VAR_BYTE_END
0000395C                          4165            
0000395C                          4166            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000395C  23C5 0000486A           4167            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003962  1439 00004866           4168            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003968                          4169            
00003968                          4170            *INTITIALIZE FOR BIT SHIFTING
00003968  41F9 0000486A           4171            LEA     VAR_TEMP_CLEANCOPY,A0
0000396E  2639 0000486A           4172            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003974                          4173            
00003974                          4174  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003974  0C02 0000               4175            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003978  6700 0008               4176            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000397C  E24B                    4177            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000397E  5302                    4178            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003980  60F2                    4179            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003982                          4180                                               *change: NAME OF LABEL*
00003982                          4181  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003982  0283 00000007           4182            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003988  0603 0030               4183            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000398C  6100 05A8               4184            BSR     PUSH_STACK                *PUSH TO STACK
00003990                          4185            
00003990  163C 0029               4186            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003994  6100 05A0               4187            BSR       PUSH_STACK
00003998                          4188            
00003998  6000 012C               4189            BRA     GET_SRC_SUCCESS                   *RETURN
0000399C                          4190            
0000399C                          4191                      
0000399C                          4192            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000399C  0CB9 00000007 0000486E  4193  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
000039A6  6600 011A               4194            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
000039AA                          4195                   
000039AA                          4196            *NEXT: (MODE == 111) 
000039AA                          4197            *NOW: CHECK FOR SRC REGISTER 
000039AA                          4198                  *(000 = (xxx).W)
000039AA                          4199                  *(001 = (xxx).L)
000039AA                          4200                  *(010 = #<data>)
000039AA                          4201                  
000039AA                          4202            *FIND REGISTER NUMBER END LOCATION*  
000039AA  13F9 00004860 00004866  4203            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000039B4  0239 000F 00004866      4204            AND.B   #$0F,VAR_BYTE_END
000039BC                          4205            
000039BC                          4206            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000039BC  23C5 0000486A           4207            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000039C2  1439 00004866           4208            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000039C8                          4209            
000039C8                          4210            *INTITIALIZE FOR BIT SHIFTING
000039C8  41F9 0000486A           4211            LEA     VAR_TEMP_CLEANCOPY,A0
000039CE  2C39 0000486A           4212            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000039D4                          4213  SRC_LOOP_SHIFTING
000039D4  0C02 0000               4214            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000039D8  6700 0008               4215            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000039DC  E24E                    4216            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000039DE  5302                    4217            SUB.B   #1,D2                     *DECREMENT COUNTER
000039E0  60F2                    4218            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
000039E2                          4219  SRC_MASKING_NEXT
000039E2  CCBC 00000007           4220            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000039E8                          4221           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000039E8                          4222           
000039E8                          4223  CHECK_WORD  
000039E8  41F9 0000485E           4224            LEA     TEMP_REGISTER_FORMAT,A0
000039EE  1439 0000485D           4225            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039F4  1082                    4226            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039F6  0239 0020 0000485E      4227            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000039FE  0C39 0020 0000485E      4228            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A06  6700 0026               4229            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A0A  0C06 0000               4230            CMPI.B  #0,D6                          
00003A0E  6600 001E               4231            BNE     CHECK_LONG 
00003A12                          4232            
00003A12                          4233            *IT IS A WORD AT THIS POINT*
00003A12                          4234            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A12  163C 0020               4235            MOVE.B    #' ',D3
00003A16  6100 051E               4236            BSR       PUSH_STACK
00003A1A  163C 0024               4237            MOVE.B    #'$',D3
00003A1E  6100 0516               4238            BSR       PUSH_STACK
00003A22  321D                    4239            MOVE.W    (A5)+,D1
00003A24  7404                    4240            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A26  6100 D818               4241            BSR       HEX2ASCII2STACK
00003A2A  6000 009A               4242            BRA     GET_SRC_SUCCESS
00003A2E                          4243  
00003A2E                          4244  CHECK_LONG
00003A2E  41F9 0000485E           4245            LEA     TEMP_REGISTER_FORMAT,A0
00003A34  1439 0000485D           4246            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A3A  1082                    4247            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A3C  0239 0040 0000485E      4248            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003A44  0C39 0040 0000485E      4249            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A4C  6700 002E               4250            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A50  0C06 0001               4251            CMPI.B  #1,D6                          
00003A54  6600 0026               4252            BNE     CHECK_IMMEDIATE  
00003A58                          4253  
00003A58                          4254            *IT IS A WORD AT THIS POINT*
00003A58                          4255            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A58  163C 0020               4256            MOVE.B    #' ',D3
00003A5C  6100 04D8               4257            BSR       PUSH_STACK
00003A60  163C 0024               4258            MOVE.B    #'$',D3
00003A64  6100 04D0               4259            BSR       PUSH_STACK
00003A68  321D                    4260            MOVE.W    (A5)+,D1
00003A6A  7404                    4261            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A6C  6100 D7D2               4262            BSR       HEX2ASCII2STACK
00003A70  321D                    4263            MOVE.W    (A5)+,D1
00003A72  7404                    4264            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A74  6100 D7CA               4265            BSR       HEX2ASCII2STACK
00003A78  6000 004C               4266            BRA     GET_SRC_SUCCESS
00003A7C                          4267            
00003A7C                          4268  CHECK_IMMEDIATE
00003A7C  41F9 0000485E           4269            LEA     TEMP_REGISTER_FORMAT,A0
00003A82  1439 0000485D           4270            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A88  1082                    4271            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A8A  0239 0080 0000485E      4272            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003A92  0C39 0080 0000485E      4273            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A9A  6700 0026               4274            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A9E  0C06 0004               4275            CMPI.B  #4,D6                          
00003AA2  6600 001E               4276            BNE     GET_SRC_FAILED 
00003AA6                          4277  
00003AA6                          4278            *IT IS A WORD AT THIS POINT*
00003AA6                          4279            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003AA6  163C 0020               4280            MOVE.B    #' ',D3
00003AAA  6100 048A               4281            BSR       PUSH_STACK
00003AAE  163C 0023               4282            MOVE.B    #'#',D3
00003AB2  6100 0482               4283            BSR       PUSH_STACK
00003AB6  321D                    4284            MOVE.W    (A5)+,D1
00003AB8  7404                    4285            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003ABA  6100 D784               4286            BSR       HEX2ASCII2STACK
00003ABE  6000 0006               4287            BRA     GET_SRC_SUCCESS
00003AC2                          4288            
00003AC2                          4289  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003AC2  7801                    4290            MOVE.L #1,D4
00003AC4  4E75                    4291            RTS
00003AC6                          4292  GET_SRC_SUCCESS 
00003AC6  4E75                    4293            RTS
00003AC8                          4294                                 
00003AC8                          4295      
00003AC8                          4296  
00003AC8                          4297  
00003AC8                          4298  
00003AC8                          4299  
00003AC8                          4300  
00003AC8                          4301  
00003AC8                          4302  GET_EA_EA_DEST
00003AC8                          4303  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003AC8                          4304      
00003AC8                          4305      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003AC8  2405                    4306      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003ACA  EC8A                    4307      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003ACC  23C2 0000486E           4308      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003AD2  7407                    4309      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003AD4  C5B9 0000486E           4310      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003ADA                          4311                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003ADA                          4312      
00003ADA                          4313      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003ADA                          4314      *DESTINATION REGISTER FORMAT STANDARD         *
00003ADA                          4315      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003ADA                          4316      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003ADA                          4317      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003ADA                          4318      *0 - Dn                                       *
00003ADA                          4319      *1 - An                                       *
00003ADA                          4320      *2 - (An)                                     *
00003ADA                          4321      *3 - (An)+                                    *
00003ADA                          4322      *4 - -(An)                                    *
00003ADA                          4323      *5 - (XXX).W                                  *
00003ADA                          4324      *6 - (XXX).L                                  *
00003ADA                          4325      *7 - #<data>                                  *
00003ADA                          4326      ***********************************************
00003ADA                          4327      
00003ADA                          4328      *** Check if source ...  <ea> = Dn
00003ADA                          4329  DEST_CHECK0    
00003ADA  41F9 0000485E           4330            LEA     TEMP_REGISTER_FORMAT,A0
00003AE0  1439 0000485C           4331            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AE6  1082                    4332            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AE8  0239 0001 0000485E      4333            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003AF0  0C39 0001 0000485E      4334            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003AF8  6700 006A               4335            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003AFC  0CB9 00000000 0000486E  4336            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B06  6600 005C               4337            BNE     DEST_CHECK1
00003B0A                          4338            
00003B0A                          4339            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B0A  163C 0020               4340            MOVE.B    #' ',D3
00003B0E  6100 0426               4341            BSR       PUSH_STACK
00003B12  163C 0044               4342            MOVE.B    #'D',D3
00003B16  6100 041E               4343            BSR       PUSH_STACK
00003B1A                          4344  
00003B1A                          4345            *FIND REGISTER NUMBER END LOCATION*  
00003B1A  13F9 0000485F 00004866  4346            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B24  0239 000F 00004866      4347            AND.B   #$0F,VAR_BYTE_END
00003B2C                          4348            
00003B2C                          4349            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B2C  23C5 0000486A           4350            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B32  1439 00004866           4351            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003B38                          4352            
00003B38                          4353            *INTITIALIZE FOR BIT SHIFTING
00003B38  41F9 0000486A           4354            LEA     VAR_TEMP_CLEANCOPY,A0
00003B3E  2639 0000486A           4355            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B44                          4356  DEST_LOOP_SHIFTING
00003B44  0C02 0000               4357            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B48  6700 0008               4358            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003B4C  E24B                    4359            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B4E  5302                    4360            SUB.B   #1,D2                     *DECREMENT COUNTER
00003B50  60F2                    4361            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003B52                          4362  DEST_MASKING_NEXT
00003B52  C6BC 00000007           4363            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B58  0603 0030               4364            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003B5C  6100 03D8               4365            BSR     PUSH_STACK                *PUSH TO STACK
00003B60                          4366            
00003B60  6000 0394               4367            BRA     GET_DST_SUCCESS           *RETURN          
00003B64                          4368            
00003B64                          4369            
00003B64                          4370            *** Check if source ...  <ea> = An
00003B64                          4371  DEST_CHECK1    
00003B64  41F9 0000485E           4372            LEA     TEMP_REGISTER_FORMAT,A0
00003B6A  1439 0000485C           4373            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B70  1082                    4374            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B72  0239 0002 0000485E      4375            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003B7A  0C39 0002 0000485E      4376            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003B82  6700 006A               4377            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003B86  0CB9 00000001 0000486E  4378            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B90  6600 005C               4379            BNE     DEST_CHECK2
00003B94                          4380            
00003B94                          4381            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B94  163C 0020               4382            MOVE.B    #' ',D3
00003B98  6100 039C               4383            BSR       PUSH_STACK
00003B9C  163C 0041               4384            MOVE.B    #'A',D3
00003BA0  6100 0394               4385            BSR       PUSH_STACK
00003BA4                          4386  
00003BA4                          4387            
00003BA4                          4388            *FIND REGISTER NUMBER END LOCATION*  
00003BA4  13F9 0000485F 00004866  4389            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BAE  0239 000F 00004866      4390            AND.B   #$0F,VAR_BYTE_END
00003BB6                          4391            
00003BB6                          4392            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BB6  23C5 0000486A           4393            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BBC  1439 00004866           4394            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003BC2                          4395            
00003BC2                          4396            *INTITIALIZE FOR BIT SHIFTING
00003BC2  41F9 0000486A           4397            LEA     VAR_TEMP_CLEANCOPY,A0
00003BC8  2639 0000486A           4398            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003BCE                          4399  DEST_LOOP_SHIFTING1
00003BCE  0C02 0000               4400            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003BD2  6700 0008               4401            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003BD6  E24B                    4402            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003BD8  5302                    4403            SUB.B   #1,D2                     *DECREMENT COUNTER
00003BDA  60F2                    4404            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003BDC                          4405  DEST_MASKING_NEXT1
00003BDC  C6BC 00000007           4406            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003BE2  0603 0030               4407            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003BE6  6100 034E               4408            BSR     PUSH_STACK                *PUSH TO STACK
00003BEA                          4409            
00003BEA  6000 030A               4410            BRA     GET_DST_SUCCESS                   *RETURN 
00003BEE                          4411            
00003BEE                          4412            
00003BEE                          4413            
00003BEE                          4414            
00003BEE                          4415            *** Check if source ...  <ea> = (An)       
00003BEE                          4416  DEST_CHECK2    
00003BEE  41F9 0000485E           4417            LEA     TEMP_REGISTER_FORMAT,A0
00003BF4  1439 0000485C           4418            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003BFA  1082                    4419            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003BFC  0239 0004 0000485E      4420            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003C04  0C39 0004 0000485E      4421            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003C0C  6700 007A               4422            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003C10  0CB9 00000002 0000486E  4423            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003C1A  6600 006C               4424            BNE     DEST_CHECK3
00003C1E                          4425            
00003C1E                          4426            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003C1E  163C 0020               4427            MOVE.B    #' ',D3
00003C22  6100 0312               4428            BSR       PUSH_STACK
00003C26  163C 0028               4429            MOVE.B    #'(',D3
00003C2A  6100 030A               4430            BSR       PUSH_STACK
00003C2E  163C 0041               4431            MOVE.B    #'A',D3
00003C32  6100 0302               4432            BSR       PUSH_STACK
00003C36                          4433  
00003C36                          4434            
00003C36                          4435            *FIND REGISTER NUMBER END LOCATION*  
00003C36  13F9 0000485F 00004866  4436            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C40  0239 000F 00004866      4437            AND.B   #$0F,VAR_BYTE_END
00003C48                          4438            
00003C48                          4439            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C48  23C5 0000486A           4440            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C4E  1439 00004866           4441            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C54                          4442            
00003C54                          4443            *INTITIALIZE FOR BIT SHIFTING
00003C54  41F9 0000486A           4444            LEA     VAR_TEMP_CLEANCOPY,A0
00003C5A  2639 0000486A           4445            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C60                          4446  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003C60  0C02 0000               4447            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C64  6700 0008               4448            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003C68  E24B                    4449            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C6A  5302                    4450            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C6C  60F2                    4451            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003C6E                          4452  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003C6E  0283 00000007           4453            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C74  0603 0030               4454            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003C78  6100 02BC               4455            BSR     PUSH_STACK                *PUSH TO STACK
00003C7C                          4456            
00003C7C  163C 0029               4457            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C80  6100 02B4               4458            BSR       PUSH_STACK
00003C84                          4459            
00003C84  6000 0270               4460            BRA     GET_DST_SUCCESS                   *RETURN 
00003C88                          4461  
00003C88                          4462            
00003C88                          4463            
00003C88                          4464                      
00003C88                          4465  *** Check if source ...  <ea> = (An)+       
00003C88  41F9 0000485E           4466  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003C8E  1439 0000485C           4467            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C94  1082                    4468            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C96  0239 0008 0000485E      4469            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003C9E  0C39 0008 0000485E      4470            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CA6  6700 0082               4471            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CAA  0CB9 00000003 0000486E  4472            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003CB4  6600 0074               4473            BNE     DEST_CHECK4
00003CB8                          4474            
00003CB8                          4475            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CB8  163C 0020               4476            MOVE.B    #' ',D3
00003CBC  6100 0278               4477            BSR       PUSH_STACK
00003CC0  163C 0028               4478            MOVE.B    #'(',D3
00003CC4  6100 0270               4479            BSR       PUSH_STACK
00003CC8  163C 0041               4480            MOVE.B    #'A',D3
00003CCC  6100 0268               4481            BSR       PUSH_STACK
00003CD0                          4482  
00003CD0                          4483            
00003CD0                          4484            *FIND REGISTER NUMBER END LOCATION*  
00003CD0  13F9 0000485F 00004866  4485            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003CDA  0239 000F 00004866      4486            ANDI.B   #$0F,VAR_BYTE_END
00003CE2                          4487            
00003CE2                          4488            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003CE2  23C5 0000486A           4489            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003CE8  1439 00004866           4490            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003CEE                          4491            
00003CEE                          4492            *INTITIALIZE FOR BIT SHIFTING
00003CEE  41F9 0000486A           4493            LEA     VAR_TEMP_CLEANCOPY,A0
00003CF4  2639 0000486A           4494            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003CFA                          4495            
00003CFA                          4496  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003CFA  0C02 0000               4497            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003CFE  6700 0008               4498            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D02  E24B                    4499            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D04  5302                    4500            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003D06  60F2                    4501            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003D08                          4502                                               *change: NAME OF LABEL*
00003D08                          4503  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003D08  0283 00000007           4504            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D0E  0603 0030               4505            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D12  6100 0222               4506            BSR     PUSH_STACK                *PUSH TO STACK
00003D16                          4507            
00003D16  163C 0029               4508            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D1A  6100 021A               4509            BSR       PUSH_STACK
00003D1E  163C 002B               4510            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D22  6100 0212               4511            BSR       PUSH_STACK
00003D26                          4512            
00003D26  6000 01CE               4513            BRA       GET_DST_SUCCESS                   *RETURN 
00003D2A                          4514  
00003D2A                          4515            
00003D2A                          4516            
00003D2A                          4517                      
00003D2A                          4518            *** Check if source ...  <ea> = -(An)       
00003D2A                          4519  DEST_CHECK4    
00003D2A  41F9 0000485E           4520            LEA     TEMP_REGISTER_FORMAT,A0
00003D30  1439 0000485C           4521            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D36  1082                    4522            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D38  0239 0010 0000485E      4523            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003D40  0C39 0010 0000485E      4524            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D48  6700 0082               4525            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003D4C  0CB9 00000004 0000486E  4526            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003D56  6600 0074               4527            BNE     DEST_CHECK7
00003D5A                          4528            
00003D5A                          4529            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003D5A  163C 0020               4530            MOVE.B    #' ',D3
00003D5E  6100 01D6               4531            BSR       PUSH_STACK
00003D62  163C 002D               4532            MOVE.B    #'-',D3
00003D66  6100 01CE               4533            BSR       PUSH_STACK
00003D6A  163C 0028               4534            MOVE.B    #'(',D3
00003D6E  6100 01C6               4535            BSR       PUSH_STACK
00003D72  163C 0041               4536            MOVE.B    #'A',D3
00003D76  6100 01BE               4537            BSR       PUSH_STACK
00003D7A                          4538  
00003D7A                          4539            
00003D7A                          4540            *FIND REGISTER NUMBER END LOCATION*  
00003D7A  13F9 0000485F 00004866  4541            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D84  0239 000F 00004866      4542            AND.B   #$0F,VAR_BYTE_END
00003D8C                          4543            
00003D8C                          4544            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D8C  23C5 0000486A           4545            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D92  1439 00004866           4546            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D98                          4547            
00003D98                          4548            *INTITIALIZE FOR BIT SHIFTING
00003D98  41F9 0000486A           4549            LEA     VAR_TEMP_CLEANCOPY,A0
00003D9E  2639 0000486A           4550            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003DA4                          4551            
00003DA4                          4552  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003DA4  0C02 0000               4553            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DA8  6700 0008               4554            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003DAC  E24B                    4555            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DAE  5302                    4556            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003DB0  60F2                    4557            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003DB2                          4558                                               *change: NAME OF LABEL*
00003DB2                          4559  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003DB2  0283 00000007           4560            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003DB8  0603 0030               4561            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003DBC  6100 0178               4562            BSR     PUSH_STACK                *PUSH TO STACK
00003DC0                          4563            
00003DC0  163C 0029               4564            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DC4  6100 0170               4565            BSR       PUSH_STACK
00003DC8                          4566            
00003DC8  6000 012C               4567            BRA     GET_DST_SUCCESS                   *RETURN
00003DCC                          4568            
00003DCC                          4569                      
00003DCC                          4570            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003DCC                          4571  DEST_CHECK7    
00003DCC  0CB9 00000007 0000486E  4572            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003DD6  6600 011A               4573            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003DDA                          4574                   
00003DDA                          4575            *NEXT: (MODE == 111) 
00003DDA                          4576            *NOW: CHECK FOR SRC REGISTER 
00003DDA                          4577                  *(000 = (xxx).W)
00003DDA                          4578                  *(001 = (xxx).L)
00003DDA                          4579                  *(010 = #<data>)
00003DDA                          4580                  
00003DDA                          4581            *FIND REGISTER NUMBER END LOCATION*  
00003DDA  13F9 0000485F 00004866  4582            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003DE4  0239 000F 00004866      4583            AND.B   #$0F,VAR_BYTE_END
00003DEC                          4584            
00003DEC                          4585            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003DEC  23C5 0000486A           4586            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003DF2  1439 00004866           4587            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003DF8                          4588            
00003DF8                          4589            *INTITIALIZE FOR BIT SHIFTING
00003DF8  41F9 0000486A           4590            LEA     VAR_TEMP_CLEANCOPY,A0
00003DFE  2C39 0000486A           4591            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003E04                          4592  DEST_LOOP_SHIFTING7
00003E04  0C02 0000               4593            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E08  6700 0008               4594            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003E0C  E24E                    4595            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E0E  5302                    4596            SUB.B   #1,D2                     *DECREMENT COUNTER
00003E10  60F2                    4597            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003E12                          4598  DEST_MASKING_NEXT7
00003E12  CCBC 00000007           4599            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003E18                          4600           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003E18                          4601            
00003E18                          4602  DEST_CHECK_WORD  
00003E18  41F9 0000485E           4603            LEA     TEMP_REGISTER_FORMAT,A0
00003E1E  1439 0000485C           4604            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E24  1082                    4605            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E26  0239 0020 0000485E      4606            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003E2E  0C39 0020 0000485E      4607            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E36  6700 0026               4608            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E3A  0C06 0000               4609            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003E3E  6600 001E               4610            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003E42                          4611            *IT IS A WORD AT THIS POINT*
00003E42                          4612            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E42  163C 0020               4613            MOVE.B    #' ',D3
00003E46  6100 00EE               4614            BSR       PUSH_STACK
00003E4A  163C 0024               4615            MOVE.B    #'$',D3
00003E4E  6100 00E6               4616            BSR       PUSH_STACK
00003E52  321D                    4617            MOVE.W    (A5)+,D1
00003E54  7404                    4618            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003E56  6100 D3E8               4619            BSR       HEX2ASCII2STACK
00003E5A  6000 009A               4620            BRA       GET_DST_SUCCESS
00003E5E                          4621  
00003E5E                          4622  DEST_CHECK_LONG
00003E5E  41F9 0000485E           4623            LEA     TEMP_REGISTER_FORMAT,A0
00003E64  1439 0000485C           4624            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E6A  1082                    4625            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E6C  0239 0040 0000485E      4626            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003E74  0C39 0040 0000485E      4627            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E7C  6700 002E               4628            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E80  0C06 0001               4629            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003E84  6600 0026               4630            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003E88                          4631            *IT IS A WORD AT THIS POINT*
00003E88                          4632            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E88  163C 0020               4633            MOVE.B    #' ',D3
00003E8C  6100 00A8               4634            BSR       PUSH_STACK
00003E90  163C 0024               4635            MOVE.B    #'$',D3
00003E94  6100 00A0               4636            BSR       PUSH_STACK
00003E98  321D                    4637            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003E9A  7404                    4638            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003E9C  6100 D3A2               4639            BSR       HEX2ASCII2STACK
00003EA0  321D                    4640            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003EA2  7404                    4641            MOVE.L    #4,D2          
00003EA4  6100 D39A               4642            BSR       HEX2ASCII2STACK
00003EA8  6000 004C               4643            BRA     GET_DST_SUCCESS
00003EAC                          4644            
00003EAC                          4645  DEST_CHECK_IMMEDIATE
00003EAC  41F9 0000485E           4646            LEA     TEMP_REGISTER_FORMAT,A0
00003EB2  1439 0000485C           4647            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EB8  1082                    4648            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EBA  0239 0080 0000485E      4649            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003EC2  0C39 0080 0000485E      4650            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003ECA  6700 0026               4651            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003ECE  0C06 0004               4652            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003ED2  6600 001E               4653            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003ED6                          4654            
00003ED6                          4655            *IT IS A WORD AT THIS POINT*
00003ED6                          4656            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003ED6  163C 0020               4657            MOVE.B    #' ',D3
00003EDA  6100 005A               4658            BSR       PUSH_STACK
00003EDE  163C 0023               4659            MOVE.B    #'#',D3
00003EE2  6100 0052               4660            BSR       PUSH_STACK
00003EE6  321D                    4661            MOVE.W    (A5)+,D1
00003EE8  7404                    4662            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003EEA  6100 D354               4663            BSR       HEX2ASCII2STACK
00003EEE  6000 0006               4664            BRA       GET_DST_SUCCESS
00003EF2                          4665            
00003EF2                          4666  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003EF2  7801                    4667            MOVE.L #1,D4
00003EF4  4E75                    4668            RTS
00003EF6                          4669  GET_DST_SUCCESS 
00003EF6  4E75                    4670            RTS
00003EF8                          4671  
00003EF8                          4672  
00003EF8                          4673  *---------------------------------------------------------------------------*
00003EF8                          4674  * STACK/QUEUE INTERFACE
00003EF8                          4675  *---------------------------------------------------------------------------*
00003EF8                          4676  PRINT_STACK
00003EF8  0C39 0000 00004858      4677            CMP.B     #0,COUNTER
00003F00  6700 000E               4678            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003F04                          4679            
00003F04                          4680  PRINT_STACK_HELPER
00003F04  6100 0038               4681            BSR      POP_STACK          *PRINTS ADDRESS
00003F08  103C 0006               4682            MOVE.B   #6,D0              *Display single character in D1.B. 
00003F0C  4E4F                    4683            TRAP     #15             *ACTIVATES PRINT
00003F0E                          4684  
00003F0E  60E8                    4685            BRA       PRINT_STACK
00003F10                          4686  PRINT_STACK_RETURN
00003F10  4E75                    4687            RTS
00003F12                          4688            
00003F12                          4689            
00003F12                          4690  PRINT_QUEUE
00003F12  0C39 0000 00004858      4691            CMP.B     #0,COUNTER
00003F1A  6700 0018               4692            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003F1E                          4693            
00003F1E                          4694  PRINT_QUEUE_HELPER
00003F1E  33F9 00004858 0000485A  4695            MOVE.W   COUNTER,QUEUE_COUNTER
00003F28  6100 0022               4696            BSR      POP_FRONT          *PRINTS ADDRESS
00003F2C  103C 0006               4697            MOVE.B   #6,D0              *Display single character in D1.B. 
00003F30  4E4F                    4698            TRAP     #15             *ACTIVATES PRINT
00003F32                          4699  
00003F32  60DE                    4700            BRA       PRINT_QUEUE
00003F34                          4701  PRINT_QUEUE_RETURN
00003F34  4E75                    4702            RTS
00003F36                          4703            
00003F36                          4704  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003F36                          4705  PUSH_STACK
00003F36  1503                    4706              MOVE.B  D3,-(A2)
00003F38  6100 0058               4707              BSR     INCREMENT
00003F3C  4E75                    4708              RTS
00003F3E                          4709  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003F3E                          4710  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003F3E                          4711  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003F3E                          4712  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003F3E                          4713  *         TRAP        #15             *ACTIVATES PRINT
00003F3E                          4714  POP_STACK
00003F3E  BECA                    4715              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003F40  6700 0008               4716              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003F44  121A                    4717              MOVE.B  (A2)+,D1 
00003F46  6100 0052               4718              BSR     DECREMENT
00003F4A                          4719  POP_RETURN
00003F4A  4E75                    4720              RTS 
00003F4C                          4721        
00003F4C                          4722  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003F4C  0C39 0000 0000485A      4723  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003F54  6700 0030               4724              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003F58                          4725              
00003F58                          4726              
00003F58                          4727              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003F58  347C 7000               4728              MOVEA.W #STACK,A2   *START A2 AT STACK
00003F5C  0622 0000               4729              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003F60  384A                    4730              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003F62  0624 0000               4731              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003F66  1212                    4732              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003F68                          4733  POP_SHIFT_LOOP
00003F68  0C39 0000 0000485A      4734              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003F70  6700 0014               4735              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003F74  1494                    4736              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003F76  0624 0000               4737              ADD.B   #0,-(A4)
00003F7A  0622 0000               4738              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003F7E  5339 0000485A           4739              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003F84                          4740              
00003F84  60E2                    4741              BRA     POP_SHIFT_LOOP
00003F86                          4742                          
00003F86                          4743  POP_FRONT_RETURN 
00003F86                          4744              *RESET A2 BACK TO SP
00003F86  347C 7000               4745              MOVEA.W #STACK,A2    
00003F8A  5339 00004858           4746              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003F90  4E75                    4747              RTS   
00003F92                          4748  
00003F92                          4749  INCREMENT
00003F92  5239 00004858           4750              ADD.B   #1, COUNTER
00003F98  4E75                    4751              RTS           
00003F9A                          4752  DECREMENT
00003F9A  5339 00004858           4753              SUB.B   #1, COUNTER
00003FA0  4E75                    4754              RTS           
00003FA2                          4755  CLEAR_STACK
00003FA2  0C39 0000 00004858      4756              CMP.B     #0,COUNTER
00003FAA  6700 0006               4757              BEQ       CLEAR_RETURN
00003FAE  618E                    4758              BSR       POP_STACK
00003FB0  60F0                    4759              BRA       CLEAR_STACK
00003FB2                          4760   
00003FB2                          4761  CLEAR_RETURN
00003FB2  4E75                    4762              RTS    
00003FB4                          4763  *---------------------------------------------------------------------------*
00003FB4                          4764  * TERMINATE
00003FB4                          4765  *---------------------------------------------------------------------------*
00003FB4                          4766  TERMINATE   
00003FB4  43F9 00004364           4767              LEA     FINMSG,A1
00003FBA  103C 000E               4768              MOVE.B  #14,D0
00003FBE  4E4F                    4769              TRAP    #15
00003FC0                          4770  
00003FC0  103C 0009               4771              MOVE.B  #9,D0
00003FC4  4E4F                    4772              TRAP    #15
00003FC6                          4773  
00003FC6                          4774  *---------------------------------------------------------------------------*
00003FC6                          4775  * Data storage                                                 
00003FC6                          4776  *---------------------------------------------------------------------------*  
00003FC6                          4777  WELCOME
00003FC6= 20 20 20 20 20 20 ...   4778              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00004016= 3D 3D 3D 3D 3D 20 ...   4779              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004066= 3D 3D 3D 3D 3D 20 ...   4780              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000040B6                          4781      
000040B6= 20 20 20 20 20 20 ...   4782              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00004106= 20 20 20 20 20 20 ...   4783              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004156= 20 20 20 20 20 20 ...   4784              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000041A6                          4785      
000041A6= 20 20 20 20 20 20 ...   4786              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
000041F6= 3D 3D 3D 3D 3D 20 ...   4787              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00004246= 3D 3D 3D 3D 3D 20 ...   4788              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
0000429B                          4789  
0000429B                          4790  PROMPT_START
0000429B= 50 6C 65 61 73 65 ...   4791              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000042CA                          4792      
000042CA                          4793  PROMPT_END
000042CA= 50 6C 65 61 73 65 ...   4794              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
000042F7= 0D 0A 48 69 74 20 ...   4795  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00004321= 57 6F 75 6C 64 20 ...   4796  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004364= 54 68 61 6E 6B 20 ...   4797  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
0000438F= 45 72 72 6F 72 3A ...   4798  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000043AE= 45 72 72 6F 72 3A ...   4799  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
000043D3= 45 72 72 6F 72 3A ...   4800  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00004400                          4801  
00004400                          4802  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00004450                          4803  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
000044A0                          4804  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000044A4                          4805  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000044A8= 0D 0A 00                4806  ENDLINE_M   DC.B    CR,LF,0
000044AB                          4807  TMPINPUT    DS.B    80                      * temp store user input
000044FB                          4808  TMPOUTPUT   DS.B    80                      * temp store prog output
0000454B= 20 20 20 4F 52 49 ...   4809  DISP_ORI_B  DC.B    '   ORI.B',0
00004554= 20 20 20 4F 52 49 ...   4810  DISP_ORI_W  DC.B    '   ORI.W',0
0000455D= 20 20 20 4F 52 49 ...   4811  DISP_ORI_L  DC.B    '   ORI.L',0
00004566= 20 20 20 45 4F 52 ...   4812  DISP_EORI_B  DC.B    '   EORI.B',0
00004570= 20 20 20 45 4F 52 ...   4813  DISP_EORI_W  DC.B    '   EORI.W',0
0000457A= 20 20 20 45 4F 52 ...   4814  DISP_EORI_L  DC.B    '   EORI.L',0
00004584= 20 20 20 42 54 53 ...   4815  DISP_BTST   DC.B    '   BTST',0
0000458C= 20 20 20 43 4D 50 ...   4816  DISP_CMPI_B  DC.B    '   CMPI.B',0
00004596= 20 20 20 43 4D 50 ...   4817  DISP_CMPI_W  DC.B    '   CMPI.W',0
000045A0= 20 20 20 43 4D 50 ...   4818  DISP_CMPI_L  DC.B    '   CMPI.L',0
000045AA= 20 20 20 44 41 54 ...   4819  DISP_DATA   DC.B    '   DATA',0
000045B2= 20 20 20 4D 4F 56 ...   4820  DISP_MOVE_B DC.B    '   MOVE.B',0
000045BC= 20 20 20 4D 4F 56 ...   4821  DISP_MOVE_W DC.B    '   MOVE.W',0
000045C6= 20 20 20 4D 4F 56 ...   4822  DISP_MOVE_L DC.B    '   MOVE.L',0
000045D0= 20 20 20 52 54 53 00    4823  DISP_RTS    DC.B    '   RTS',0
000045D7= 20 20 20 4A 53 52 00    4824  DISP_JSR    DC.B    '   JSR',0
000045DE= 20 20 20 4E 45 47 ...   4825  DISP_NEG_B    DC.B    '   NEG.B',0
000045E7= 20 20 20 4E 45 47 ...   4826  DISP_NEG_W    DC.B    '   NEG.W',0
000045F0= 20 20 20 4E 45 47 ...   4827  DISP_NEG_L    DC.B    '   NEG.L',0
000045F9= 20 20 20 4E 4F 54 ...   4828  DISP_NOT_B  DC.B    '   NOT.B',0
00004602= 20 20 20 4E 4F 54 ...   4829  DISP_NOT_W  DC.B    '   NOT.W',0
0000460B= 20 20 20 4E 4F 54 ...   4830  DISP_NOT_L  DC.B    '   NOT.L',0
00004614= 20 20 20 4C 45 41 00    4831  DISP_LEA    DC.B    '   LEA',0
0000461B= 20 20 20 4D 4F 56 ...   4832  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004626= 20 20 20 4D 4F 56 ...   4833  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
00004631= 20 20 20 41 44 44 ...   4834  DISP_ADDQ_B DC.B    '   ADDQ.B',0
0000463B= 20 20 20 41 44 44 ...   4835  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00004645= 20 20 20 41 44 44 ...   4836  DISP_ADDQ_L DC.B    '   ADDQ.L',0
0000464F= 20 20 20 44 49 56 ...   4837  DISP_DIVS   DC.B    '   DIVS',0
00004657= 20 20 20 53 55 42 ...   4838  DISP_SUB_B  DC.B    '   SUB.B',0
00004660= 20 20 20 53 55 42 ...   4839  DISP_SUB_W  DC.B    '   SUB.W',0
00004669= 20 20 20 53 55 42 ...   4840  DISP_SUB_L  DC.B    '   SUB.L',0
00004672= 20 20 20 53 55 42 ...   4841  DISP_SUBI_B  DC.B    '   SUBI.B',0
0000467C= 20 20 20 53 55 42 ...   4842  DISP_SUBI_W  DC.B    '   SUBI.W',0
00004686= 20 20 20 53 55 42 ...   4843  DISP_SUBI_L  DC.B    '   SUBI.L',0
00004690= 20 20 20 53 55 42 ...   4844  DISP_SUBA_W  DC.B    '   SUBA.W',0
0000469A= 20 20 20 53 55 42 ...   4845  DISP_SUBA_L  DC.B    '   SUBA.L',0
000046A4= 20 20 20 45 4F 52 ...   4846  DISP_EOR_B  DC.B    '   EOR.B',0
000046AD= 20 20 20 45 4F 52 ...   4847  DISP_EOR_W  DC.B    '   EOR.W',0
000046B6= 20 20 20 45 4F 52 ...   4848  DISP_EOR_L  DC.B    '   EOR.L',0
000046BF= 20 20 20 43 4D 50 ...   4849  DISP_CMP_B  DC.B    '   CMP.B',0
000046C8= 20 20 20 43 4D 50 ...   4850  DISP_CMP_W  DC.B    '   CMP.W',0
000046D1= 20 20 20 43 4D 50 ...   4851  DISP_CMP_L  DC.B    '   CMP.L',0
000046DA= 20 20 20 43 4D 50 ...   4852  DISP_CMPA_W  DC.B    '   CMPA.W',0
000046E4= 20 20 20 43 4D 50 ...   4853  DISP_CMPA_L  DC.B    '   CMPA.L',0
000046EE= 20 20 20 4D 55 4C ...   4854  DISP_MULS_W DC.B    '   MULS.W',0
000046F8= 20 20 20 41 4E 44 ...   4855  DISP_AND_B  DC.B    '   AND.B',0
00004701= 20 20 20 41 4E 44 ...   4856  DISP_AND_W  DC.B    '   AND.W',0
0000470A= 20 20 20 41 4E 44 ...   4857  DISP_AND_L  DC.B    '   AND.L',0
00004713= 20 20 20 41 44 44 ...   4858  DISP_ADD_B  DC.B    '   ADD.B',0
0000471C= 20 20 20 41 44 44 ...   4859  DISP_ADD_W  DC.B    '   ADD.W',0
00004725= 20 20 20 41 44 44 ...   4860  DISP_ADD_L  DC.B    '   ADD.L',0
0000472E= 20 20 20 41 44 44 ...   4861  DISP_ADDA_W DC.B    '   ADDA.W',0
00004738= 20 20 20 41 44 44 ...   4862  DISP_ADDA_L DC.B    '   ADDA.L',0
00004742= 20 20 20 4C 53 52 ...   4863  DISP_LSR_B  DC.B    '   LSR.B',0
0000474B= 20 20 20 4C 53 4C ...   4864  DISP_LSL_B  DC.B    '   LSL.B',0
00004754= 20 20 20 4C 53 52 ...   4865  DISP_LSR_W  DC.B    '   LSR.W',0
0000475D= 20 20 20 4C 53 4C ...   4866  DISP_LSL_W  DC.B    '   LSL.W',0
00004766= 20 20 20 4C 53 52 ...   4867  DISP_LSR_L  DC.B    '   LSR.L',0
0000476F= 20 20 20 4C 53 4C ...   4868  DISP_LSL_L  DC.B    '   LSL.L',0
00004778= 20 20 20 41 53 52 ...   4869  DISP_ASR_B  DC.B    '   ASR.B',0
00004781= 20 20 20 41 53 4C ...   4870  DISP_ASL_B  DC.B    '   ASL.B',0
0000478A= 20 20 20 41 53 52 ...   4871  DISP_ASR_W  DC.B    '   ASR.W',0
00004793= 20 20 20 41 53 4C ...   4872  DISP_ASL_W  DC.B    '   ASL.W',0
0000479C= 20 20 20 41 53 52 ...   4873  DISP_ASR_L  DC.B    '   ASR.L',0
000047A5= 20 20 20 41 53 4C ...   4874  DISP_ASL_L  DC.B    '   ASL.L',0
000047AE= 20 20 20 52 4F 52 ...   4875  DISP_ROR_B  DC.B    '   ROR.B',0
000047B7= 20 20 20 52 4F 4C ...   4876  DISP_ROL_B  DC.B    '   ROL.B',0
000047C0= 20 20 20 52 4F 52 ...   4877  DISP_ROR_W  DC.B    '   ROR.W',0
000047C9= 20 20 20 52 4F 4C ...   4878  DISP_ROL_W  DC.B    '   ROL.W',0
000047D2= 20 20 20 52 4F 52 ...   4879  DISP_ROR_L  DC.B    '   ROR.L',0
000047DB= 20 20 20 52 4F 4C ...   4880  DISP_ROL_L  DC.B    '   ROL.L',0
000047E4= 20 20 20 42 52 41 00    4881  DISP_BRA    DC.B    '   BRA',0
000047EB= 20 20 20 42 4C 54 00    4882  DISP_BLT    DC.B    '   BLT',0
000047F2= 20 20 20 42 45 51 00    4883  DISP_BEQ    DC.B    '   BEQ',0
000047F9= 20 20 20 42 4E 45 00    4884  DISP_BNE    DC.B    '   BNE',0
00004800= 20 20 20 42 48 49 00    4885  DISP_BHI    DC.B    '   BHI',0
00004807= 20 20 20 4D 4F 56 ...   4886  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004812= 20 20 20 4D 4F 56 ...   4887  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
0000481D                          4888  
0000481D= 20 20 20 24 00          4889  DISP_HEX     DC.B    '   $',0
00004822= 20 20 20 44 00          4890  DISP_D  DC.B    '   D',0
00004827= 20 20 20 41 00          4891  DISP_A  DC.B    '   A',0
0000482C= 20 20 20 28 00          4892  DISP_OP  DC.B    '   (',0
00004831= 29 00                   4893  DISP_CP  DC.B   ')',0
00004833= 20 20 20 28 41 00       4894  DISP_AOP  DC.B    '   (A',0
00004839                          4895  
00004839= 20 20 20 2D 28 41 00    4896  DISP_PRE    DC.B    '   -(A',0
00004840= 29 2B 00                4897  DISP_POST   DC.B    ')+',0
00004843= 20 20 20 23 00          4898  DISP_LB DC.B    '   #',0
00004848= 30 00                   4899  DISP_0  DC.B    '0',0
0000484A= 31 00                   4900  DISP_1  DC.B    '1',0
0000484C= 32 00                   4901  DISP_2  DC.B    '2',0
0000484E= 33 00                   4902  DISP_3  DC.B    '3',0
00004850= 34 00                   4903  DISP_4  DC.B    '4',0
00004852= 35 00                   4904  DISP_5  DC.B    '5',0
00004854= 36 00                   4905  DISP_6  DC.B    '6',0
00004856= 37 00                   4906  DISP_7  DC.B    '7',0
00004858                          4907  
00004858                          4908  *STACK INTERFACE VARIABLES*
00004858                          4909  COUNTER         DS.W    1
0000485A                          4910  QUEUE_COUNTER   DS.W    1
0000485C                          4911  
0000485C                          4912  *EA DECODING INTERFACE VARIABLES* 
0000485C                          4913  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
0000485D                          4914  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
0000485E                          4915  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
0000485F                          4916  
0000485F                          4917  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
0000485F                          4918  * WORD + WORD = LONG
0000485F                          4919  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
0000485F                          4920  * A              + F            = AF         <= EXAMPLE
0000485F                          4921  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
0000485F                          4922  GET_DST_START_END    DS.B    1
00004860                          4923  GET_SRC_START_END    DS.B    1
00004861                          4924  
00004861                          4925  *STORES THE START + END BITS HERE (FROM ABOVE)
00004862                          4926  VAR_BYTE_START      DS.L    1
00004866                          4927  VAR_BYTE_END        DS.L    1
0000486A                          4928  VAR_TEMP_CLEANCOPY  DS.L    1
0000486E                          4929  
0000486E                          4930  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004872                          4931  
00004872                          4932  *MORE FOR STACK USAGE*
00004872= 2C 00                   4933  DISP_COMMA  DC.B    ',',0
00004874= 20 20 20 00             4934  DISP_INDENT  DC.B    '   ',0
00004878                          4935  
00004878                          4936  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004878                          4937  POINTER_WORD    DS.W       1
0000487A                          4938  
0000487A                          4939  
0000487A                          4940  
0000487A                          4941  *---------------------------------------------------------------------------*
0000487A                          4942  * Ends program
0000487A                          4943  *---------------------------------------------------------------------------*
0000487A                          4944              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            119C
ASCII2HEX           1196
ASC_ERR             11F8
ASC_LOW             11DA
ASC_NUM             11EA
ASC_SFT             11F2
ASC_UPP             11E2
CHECK0              36AA
CHECK1              3734
CHECK2              37BE
CHECK3              3858
CHECK4              38FA
CHECK7              399C
CHECK_IMMEDIATE     3A7C
CHECK_LONG          3A2E
CHECK_WORD          39E8
CLEAR_RETURN        3FB2
CLEAR_STACK         3FA2
COUNTER             4858
CR                  D
DECREMENT           3F9A
DEST_CHECK0         3ADA
DEST_CHECK1         3B64
DEST_CHECK2         3BEE
DEST_CHECK3         3C88
DEST_CHECK4         3D2A
DEST_CHECK7         3DCC
DEST_CHECK_IMMEDIATE  3EAC
DEST_CHECK_LONG     3E5E
DEST_CHECK_WORD     3E18
DEST_LOOP_SHIFTING  3B44
DEST_LOOP_SHIFTING1  3BCE
DEST_LOOP_SHIFTING2  3C60
DEST_LOOP_SHIFTING3  3CFA
DEST_LOOP_SHIFTING4  3DA4
DEST_LOOP_SHIFTING7  3E04
DEST_MASKING_NEXT   3B52
DEST_MASKING_NEXT1  3BDC
DEST_MASKING_NEXT2  3C6E
DEST_MASKING_NEXT3  3D08
DEST_MASKING_NEXT4  3DB2
DEST_MASKING_NEXT7  3E12
DEST_MODE           3262
DEST_REGISTER       3532
DEST_REGISTER_FORMAT  485C
DISPLAY_30_LINES    1344
DISP_0              4848
DISP_1              484A
DISP_2              484C
DISP_3              484E
DISP_4              4850
DISP_5              4852
DISP_6              4854
DISP_7              4856
DISP_A              4827
DISP_ADDA_L         4738
DISP_ADDA_W         472E
DISP_ADDQ_B         4631
DISP_ADDQ_L         4645
DISP_ADDQ_W         463B
DISP_ADD_B          4713
DISP_ADD_L          4725
DISP_ADD_W          471C
DISP_AND_B          46F8
DISP_AND_L          470A
DISP_AND_W          4701
DISP_AOP            4833
DISP_ASL_B          4781
DISP_ASL_L          47A5
DISP_ASL_W          4793
DISP_ASR_B          4778
DISP_ASR_L          479C
DISP_ASR_W          478A
DISP_BEQ            47F2
DISP_BHI            4800
DISP_BLT            47EB
DISP_BNE            47F9
DISP_BRA            47E4
DISP_BTST           4584
DISP_CMPA_L         46E4
DISP_CMPA_W         46DA
DISP_CMPI_B         458C
DISP_CMPI_L         45A0
DISP_CMPI_W         4596
DISP_CMP_B          46BF
DISP_CMP_L          46D1
DISP_CMP_W          46C8
DISP_COMMA          4872
DISP_CP             4831
DISP_D              4822
DISP_DATA           45AA
DISP_DIVS           464F
DISP_EORI_B         4566
DISP_EORI_L         457A
DISP_EORI_W         4570
DISP_EOR_B          46A4
DISP_EOR_L          46B6
DISP_EOR_W          46AD
DISP_HEX            481D
DISP_INDENT         4874
DISP_JSR            45D7
DISP_LB             4843
DISP_LEA            4614
DISP_LSL_B          474B
DISP_LSL_L          476F
DISP_LSL_W          475D
DISP_LSR_B          4742
DISP_LSR_L          4766
DISP_LSR_W          4754
DISP_MOVEA_L        4812
DISP_MOVEA_W        4807
DISP_MOVEM_L        4626
DISP_MOVEM_W        461B
DISP_MOVE_B         45B2
DISP_MOVE_L         45C6
DISP_MOVE_W         45BC
DISP_MULS_W         46EE
DISP_NEG_B          45DE
DISP_NEG_L          45F0
DISP_NEG_W          45E7
DISP_NEXT           42F7
DISP_NOT_B          45F9
DISP_NOT_L          460B
DISP_NOT_W          4602
DISP_OP             482C
DISP_ORI_B          454B
DISP_ORI_L          455D
DISP_ORI_W          4554
DISP_POST           4840
DISP_PRE            4839
DISP_ROL_B          47B7
DISP_ROL_L          47DB
DISP_ROL_W          47C9
DISP_ROR_B          47AE
DISP_ROR_L          47D2
DISP_ROR_W          47C0
DISP_RTS            45D0
DISP_SUBA_L         469A
DISP_SUBA_W         4690
DISP_SUBI_B         4672
DISP_SUBI_L         4686
DISP_SUBI_W         467C
DISP_SUB_B          4657
DISP_SUB_L          4669
DISP_SUB_W          4660
D_MODE000           3304
D_MODE010           334C
D_MODE011           33AC
D_MODE100           33CC
D_MODE111           341E
EA_ARITH            31FC
EA_DATA             1754
EA_GEN              3248
EA_MOVEA            3222
EA_NOSRC            31E8
ENDLINE_M           44A8
END_ADDR            10E2
ERRMSG_1            438F
ERRMSG_3            43AE
ERRMSG_5            43D3
ERROR_1             1146
ERROR_2             1156
ERROR_3             1166
ERROR_4             1176
ERROR_5             1186
E_ADDR_HX           44A4
FINMSG              4364
GET_DST_FAILED      3EF2
GET_DST_START_END   485F
GET_DST_SUCCESS     3EF6
GET_EA_EA_DEST      3AC8
GET_EA_EA_SRC       3698
GET_SRC_FAILED      3AC2
GET_SRC_START_END   4860
GET_SRC_SUCCESS     3AC6
HEX2ASCII           11FE
HEX2ASCII2STACK     1240
HEX_CHAR            122C
HEX_CONT            1230
HEX_LOOP            1212
IMMD_B              34D2
IMMD_L              3512
IMMD_W              34F2
IMMEDIATE           34A2
INCREMENT           3F92
INTRO               1028
IS_ODD              1284
IS_ODD_ERR          129A
JMPTABLE            1370
LF                  A
LONGMODE            3476
LOOP_SHIFTING       3714
LOOP_SHIFTING1      379E
LOOP_SHIFTING2      3830
LOOP_SHIFTING3      38CA
LOOP_SHIFTING4      3974
MAIN                12A0
MASKING_NEXT        3722
MASKING_NEXT1       37AC
MASKING_NEXT2       383E
MASKING_NEXT3       38D8
MASKING_NEXT4       3982
MODE000             32F0
MODE001             3318
MODE010             332C
MODE011             336C
MODE100             338C
MODE111             33EC
NEXTLINES           1352
OP0000              13D0
OP0000_BTST_B       153A
OP0000_CMPI         177C
OP0000_CMPI_B       17F2
OP0000_CMPI_L       1842
OP0000_CMPI_W       181A
OP0000_EOR_B        15E8
OP0000_EOR_L        1618
OP0000_EOR_W        1600
OP0000_ORI_B        18D6
OP0000_ORI_L        1926
OP0000_ORI_W        18FE
OP0000_RETURN_BTST  156A
OP0000_RETURN_CMPI  1866
OP0000_RETURN_EOR   162C
OP0000_RETURN_ORI   194A
OP0000_RETURN_SUBI  170E
OP0000_SUB_B        16CA
OP0000_SUB_L        16FA
OP0000_SUB_W        16E2
OP0001              194C
OP0010              19BA
OP0011              1AB8
OP0100              1BB4
OP0101              1E0A
OP0101_ADDQ_B       1E86
OP0101_ADDQ_B_0     1F02
OP0101_ADDQ_B_1     1F0E
OP0101_ADDQ_B_2     1F1A
OP0101_ADDQ_B_3     1F26
OP0101_ADDQ_B_4     1F32
OP0101_ADDQ_B_5     1F3E
OP0101_ADDQ_B_6     1F4A
OP0101_ADDQ_B_7     1F56
OP0101_ADDQ_B_8     1F62
OP0101_ADDQ_L       1E9E
OP0101_ADDQ_W       1E92
OP0101_RETURN       1EA6
OP0101_RETURN2      1F6A
OP0110              1FAE
OP0111              203C
OP1000              2040
OP1000_DIVS_DN_EA_OR_EA_DN  204E
OP1000_DIVS_RETURN  2132
OP1000_EA_DN_DIVS   207C
OP1000_PRINT_L_DIVS  20EA
OP1000_PRINT_W_DIVS  20A2
OP1001              2148
OP1001_ADD_RETURN   2496
OP1001_DETERMINE_DN_EA_OR_EA_DN  225E
OP1001_DN_EA        2296
OP1001_EA_DN        2396
OP1001_PRINT_B      23BE
OP1001_PRINT_B2     22BE
OP1001_PRINT_L      244E
OP1001_PRINT_L2     234E
OP1001_PRINT_W      2406
OP1001_PRINT_W2     2306
OP1001_SUBA_L       217A
OP1001_SUBA_W       21EC
OP1010              2504
OP1011              2508
OP1011_CMP          2562
OP1011_CMPA         2614
OP1011_CMPA_L       268E
OP1011_CMPA_W       2682
OP1011_CMP_B        25D6
OP1011_CMP_L        25EE
OP1011_CMP_W        25E2
OP1011_EOR          26B4
OP1011_EOR_B        2728
OP1011_EOR_L        2740
OP1011_EOR_W        2734
OP1011_RETURN       2748
OP1011_RETURN_CMP   25F6
OP1011_RETURN_CMPA  2696
OP1100              2808
OP1100_AND_RETURN   2B58
OP1100_DETERMINE_DN_EA_OR_EA_DN  291E
OP1100_DN_EA        2958
OP1100_EA_DN        2A58
OP1100_EA_DN_MULS   2866
OP1100_MULS_DN_EA_OR_EA_DN  2838
OP1100_MULS_RETURN  291C
OP1100_PRINT_B      2A80
OP1100_PRINT_B2     2980
OP1100_PRINT_L      2B10
OP1100_PRINT_L2     2A10
OP1100_PRINT_L_MULS  28D4
OP1100_PRINT_W      2AC8
OP1100_PRINT_W2     29C8
OP1100_PRINT_W_MULS  288C
OP1101              2B5A
OP1101_ADDA_L       2B8C
OP1101_ADDA_W       2BFE
OP1101_ADD_RETURN   2EA8
OP1101_DETERMINE_DN_EA_OR_EA_DN  2C70
OP1101_DN_EA        2CA8
OP1101_EA_DN        2DA8
OP1101_PRINT_B      2DD0
OP1101_PRINT_B2     2CD0
OP1101_PRINT_L      2E60
OP1101_PRINT_L2     2D60
OP1101_PRINT_W      2E18
OP1101_PRINT_W2     2D18
OP1110              2F36
OP1111              31E4
OP_ADDA_L           2F1E
OP_ADDA_W           2F06
OP_ADDQ_B           1F78
OP_ADDQ_L           1F9C
OP_ADDQ_W           1F8A
OP_ADD_B            2EBE
OP_ADD_L            2EEE
OP_ADD_W            2ED6
OP_ASL              30D6
OP_ASL_B            30FA
OP_ASL_L            310C
OP_ASL_W            311E
OP_ASR              307C
OP_ASR_B            30A0
OP_ASR_L            30B2
OP_ASR_W            30C4
OP_ASX              2F98
OP_BEQ              2012
OP_BHI              1FF6
OP_BLT              202E
OP_BNE              2004
OP_BRA              2020
OP_BTST             145A
OP_BTST_IMMEDIATE   14E4
OP_CMPA_L           2778
OP_CMPA_W           2766
OP_CMP_B            278A
OP_CMP_L            27BA
OP_CMP_W            27A2
OP_DATA             1730
OP_DIVS             2134
OP_EORI             156C
OP_EOR_B            27D2
OP_EOR_L            27F6
OP_EOR_W            27E4
OP_JSR              1DDC
OP_LEA              1C62
OP_LEA_DN_EA_OR_EA_DN  1C70
OP_LEA_RETURN       1CCE
OP_LSL              3022
OP_LSL_B            3046
OP_LSL_L            3058
OP_LSL_W            306A
OP_LSR              2FC8
OP_LSR_B            2FEC
OP_LSR_L            2FFE
OP_LSR_W            3010
OP_LSX              2F80
OP_MOVEA_L          1A48
OP_MOVEA_W          1B44
OP_MOVEM_L          1C50
OP_MOVEM_W          1C3E
OP_MOVE_B           1952
OP_MOVE_L           19E0
OP_MOVE_W           1ADC
OP_MULS             282A
OP_NEG              1CD0
OP_NEG_B            1D1C
OP_NEG_L            1D34
OP_NEG_PRINT_EA     1D40
OP_NEG_W            1D28
OP_NOT              1D56
OP_NOT_B            1DA2
OP_NOT_L            1DBA
OP_NOT_PRINT_EA     1DC6
OP_NOT_W            1DAE
OP_ORI              1868
OP_PRINT_L_LEA      1C8E
OP_ROL              318A
OP_ROL_B            31AE
OP_ROL_L            31C0
OP_ROL_W            31D2
OP_ROR              3130
OP_ROR_B            3154
OP_ROR_L            3166
OP_ROR_W            3178
OP_ROX              2FB0
OP_RTS              1DF0
OP_SUBA_L           24F2
OP_SUBA_W           24E0
OP_SUBI             164E
OP_SUB_B            2498
OP_SUB_L            24C8
OP_SUB_W            24B0
OUTPUT_PROCESSED_DATA  1324
POINTER_WORD        4878
POP_FRONT           3F4C
POP_FRONT_RETURN    3F86
POP_RETURN          3F4A
POP_SHIFT_LOOP      3F68
POP_STACK           3F3E
PRINT_QUEUE         3F12
PRINT_QUEUE_HELPER  3F1E
PRINT_QUEUE_RETURN  3F34
PRINT_STACK         3EF8
PRINT_STACK_HELPER  3F04
PRINT_STACK_RETURN  3F10
PROGLP              100A
PROMPT_END          42CA
PROMPT_START        429B
PUSH_STACK          3F36
QUEUE_COUNTER       485A
REG_0               35E6
REG_1               35F4
REG_2               3602
REG_3               3610
REG_4               361E
REG_5               362C
REG_6               363A
REG_7               3648
REPEAT              3656
REPEATMSG           4321
RETURN              11FC
SRC_LOOP_SHIFTING   39D4
SRC_MASKING_NEXT    39E2
SRC_MODE            32A6
SRC_REGISTER        358E
SRC_REGISTER_FORMAT  485D
STACK               7000
STACK_HEX_CHAR      126E
STACK_HEX_CONT      1272
STACK_HEX_LOOP      1254
START               1004
START_ADDR          1090
S_ADDR_HX           44A0
TEMP_REGISTER_FORMAT  485E
TERMINATE           3FB4
TESTING             1036
TMPINPUT            44AB
TMPOUTPUT           44FB
VAR_BYTE_END        4866
VAR_BYTE_START      4862
VAR_LONG_ADDRESS_MODE_CHECK  486E
VAR_TEMP_CLEANCOPY  486A
VR_E_ADDR           4450
VR_S_ADDR           4400
WELCOME             3FC6
WORDMODE            344A
