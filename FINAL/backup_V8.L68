00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 3:32:57 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001048             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109A             38              JSR     END_ADDR
00001016  43F9 000045A4             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012C0             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 000040C2             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  6DFE                      53              BLT     TESTING
00001038  6DFC                      54              BLT     TESTING
0000103A  6DFA                      55              BLT     TESTING
0000103C  6DF8                      56              BLT     TESTING
0000103E                            57              
0000103E                            58              
0000103E  67F6                      59              BEQ     TESTING
00001040  66F4                      60              BNE     TESTING
00001042  6DF2                      61              BLT     TESTING
00001044  62F0                      62              BHI     TESTING
00001046                            63  
00001046                            64  
00001046  4E75                      65              RTS
00001048                            66  *---------------------------------------------------------------------------*
00001048                            67  * START_ADDR: Compute the starting address
00001048                            68  *---------------------------------------------------------------------------*
00001048                            69  START_ADDR
00001048                            70              * Output
00001048  43F9 00004397             71              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000104E  103C 000E                 72              MOVE.B  #14,D0                  * Display PROMPT_START
00001052  4E4F                      73              TRAP    #15
00001054                            74      
00001054                            75              * Input
00001054  43F9 000044FC             76              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105A  103C 0002                 77              MOVE.B  #2,D0                   * Ask user for input
0000105E  4E4F                      78              TRAP    #15
00001060                            79              
00001060                            80              * Error Checking (length)
00001060  0C01 0000                 81              CMPI.B  #0, D1                  * Check if input length <= 0
00001064  6F00 0098                 82              BLE     ERROR_1
00001068  0C01 0008                 83              CMPI.B  #8, D1                  * Check if input length > 8
0000106C  6E00 0090                 84              BGT     ERROR_1
00001070                            85              
00001070                            86              * Conversion & Storage
00001070  4EB9 0000114E             87              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001076  0C07 0001                 88              CMPI.B  #1, D7                  * Check for error
0000107A  6700 0082                 89              BEQ     ERROR_1                 
0000107E  23C1 0000459C             90              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001084                            91              
00001084                            92              * Error Checking (Odd)
00001084  43F9 0000459C             93              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108A  4EB9 000012A4             94              JSR     IS_ODD                  * Check if the input address is odd
00001090  0C07 0001                 95              CMPI.B  #1, D7                  * Check for error
00001094  6700 0088                 96              BEQ     ERROR_3
00001098                            97              
00001098                            98              * Return
00001098  4E75                      99              RTS     
0000109A                           100  *---------------------------------------------------------------------------*
0000109A                           101  * END_ADDR: Compute the ending address
0000109A                           102  *---------------------------------------------------------------------------*
0000109A                           103  END_ADDR
0000109A                           104              * Output
0000109A  43F9 000043C6            105              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A0  103C 000E                106              MOVE.B  #14,D0                  * Display PROMPT_END
000010A4  4E4F                     107              TRAP    #15
000010A6                           108  
000010A6                           109              * Input
000010A6  43F9 0000454C            110              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AC  103C 0002                111              MOVE.B  #2,D0                   * Ask user for input
000010B0  4E4F                     112              TRAP    #15
000010B2                           113              
000010B2                           114              * Error Checking (length)
000010B2  0C01 0000                115              CMPI.B  #0, D1                  * Check if input length <= 0
000010B6  6F00 0056                116              BLE     ERROR_2
000010BA  0C01 0008                117              CMPI.B  #8, D1                  * Check if input length > 8
000010BE  6E00 004E                118              BGT     ERROR_2
000010C2                           119              
000010C2                           120              * Conversion & Storage
000010C2  4EB9 0000114E            121              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010C8  0C07 0001                122              CMPI.B  #1, D7                  * Check for error
000010CC  6700 0040                123              BEQ     ERROR_2
000010D0  23C1 000045A0            124              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D6                           125              
000010D6                           126              * Error Checking (start > end case)
000010D6  2439 0000459C            127              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DC  B282                     128              CMP.L   D2, D1                  * Compare starting and ending address
000010DE  6300 005E                129              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E2                           130              
000010E2                           131              * Error Checking (Odd case)
000010E2  43F9 000045A0            132              LEA     E_ADDR_HX, A1           * Move the ending address
000010E8  4EB9 000012A4            133              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010EE  0C07 0001                134              CMPI.B  #1, D7                  * Check for an error flag
000010F2  6700 003A                135              BEQ     ERROR_4
000010F6                           136              
000010F6                           137              * Inputs are valid
000010F6  2A79 0000459C            138              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FC                           139              
000010FC  4E75                     140              RTS
000010FE                           141              
000010FE                           142  *---------------------------------------------------------------------------*
000010FE                           143  * ERROR_1: Address error (Invalid starting address)
000010FE                           144  *---------------------------------------------------------------------------*
000010FE                           145  ERROR_1
000010FE  43F9 0000448B            146              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001104  103C 000E                147              MOVE.B  #14, D0                 * Display ERRMSG_1
00001108  4E4F                     148              TRAP    #15
0000110A  4EF8 1048                149              JMP     START_ADDR              * Jump to START_ADDR
0000110E                           150      
0000110E                           151  *---------------------------------------------------------------------------*
0000110E                           152  * ERROR_2: Address error (Invalid ending address)
0000110E                           153  *---------------------------------------------------------------------------*
0000110E                           154  ERROR_2
0000110E  43F9 0000448B            155              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001114  103C 000E                156              MOVE.B  #14, D0                 * Display ERRMSG_1
00001118  4E4F                     157              TRAP    #15
0000111A  4EF8 109A                158              JMP     END_ADDR                * Jump to END_ADDR
0000111E                           159  
0000111E                           160  *---------------------------------------------------------------------------*
0000111E                           161  * ERROR_3: Address error (Odd starting address)
0000111E                           162  *---------------------------------------------------------------------------*
0000111E                           163  ERROR_3
0000111E  43F9 000044AA            164              LEA     ERRMSG_3, A1
00001124  103C 000E                165              MOVE.B  #14, D0
00001128  4E4F                     166              TRAP    #15
0000112A  4EF8 1048                167              JMP     START_ADDR
0000112E                           168     
0000112E                           169  *---------------------------------------------------------------------------*
0000112E                           170  * ERROR_4: Address error (Odd ending address)
0000112E                           171  *---------------------------------------------------------------------------*         
0000112E                           172  ERROR_4
0000112E  43F9 000044AA            173              LEA     ERRMSG_3, A1
00001134  103C 000E                174              MOVE.B  #14, D0
00001138  4E4F                     175              TRAP    #15
0000113A  4EF8 109A                176              JMP     END_ADDR
0000113E                           177            
0000113E                           178  *---------------------------------------------------------------------------*
0000113E                           179  * ERROR_3: Address error (Ending address is less than starting address)
0000113E                           180  *---------------------------------------------------------------------------*
0000113E                           181  ERROR_5
0000113E  43F9 000044CF            182              LEA     ERRMSG_5, A1
00001144  103C 000E                183              MOVE.B  #14, D0
00001148  4E4F                     184              TRAP    #15
0000114A  4EF8 109A                185              JMP     END_ADDR
0000114E                           186    
0000114E                           187  *---------------------------------------------------------------------------*
0000114E                           188  * ASCII2HEX: Convert ASCii to Hexadecimal
0000114E                           189  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000114E                           190  *---------------------------------------------------------------------------*
0000114E  4281                     191  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001150  4287                     192              CLR.L   D7                      * Set the error flag to 0
00001152  4282                     193              CLR.L   D2                      * Clear D2 for temp storage
00001154                           194              
00001154  1419                     195  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001156  0C02 0000                196              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115A  6700 0058                197              BEQ     RETURN                  * If it's NULL, go to return
0000115E  0C02 0066                198              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001162  6E00 004C                199              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001166  0C02 0061                200              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116A  6C00 0026                201              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000116E  0C02 0046                202              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001172  6E00 003C                203              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001176  0C02 0041                204              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117A  6C00 001E                205              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000117E  0C02 0039                206              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001182  6E00 002C                207              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001186  0C02 0030                208              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118A  6C00 0016                209              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000118E  6000 0020                210              BRA     ASC_ERR                 * Invalid input
00001192                           211  
00001192  0442 0057                212  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001196  6000 0012                213              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119A                           214              
0000119A  0442 0037                215  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000119E  6000 000A                216              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A2                           217              
000011A2  0442 0030                218  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A6  6000 0002                219              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AA                           220              
000011AA  E981                     221  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AC  D202                     222              ADD.B   D2, D1                  * Add the converted input to D1
000011AE  60A4                     223              BRA     ASC2HXLP                * Loop
000011B0                           224  
000011B0  1E3C 0001                225  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B4  4E75                     226  RETURN      RTS     
000011B6                           227  
000011B6                           228  *---------------------------------------------------------------------------*
000011B6                           229  * ASCII2HEX: Convert ASCii to Hexadecimal
000011B6                           230  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011B6                           231  *---------------------------------------------------------------------------*
000011B6                           232  ASCII2HEX2STACK
000011B6  4283                     233              CLR.L   D3                      * Clear the destination 
000011B8  4287                     234              CLR.L   D7                      * Set the error flag to 0
000011BA  4282                     235              CLR.L   D2                      * Clear D2 for temp storage
000011BC                           236              
000011BC                           237  ASC2HXLP2STACK
000011BC  1419                     238              MOVE.B  (A1)+, D2               * Read a byte to D2
000011BE  0C02 0000                239              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011C2  6700 0058                240              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011C6  0C02 0066                241              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011CA  6E00 004C                242              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011CE  0C02 0061                243              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011D2  6C00 0026                244              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011D6  0C02 0046                245              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011DA  6E00 003C                246              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011DE  0C02 0041                247              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011E2  6C00 001E                248              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011E6  0C02 0039                249              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011EA  6E00 002C                250              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
000011EE  0C02 0030                251              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011F2  6C00 0016                252              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
000011F6  6000 0020                253              BRA     ASC_ERR2STACK                 * Invalid input
000011FA                           254  
000011FA                           255  ASC_LOW2STACK
000011FA  0442 0057                256              SUBI    #87, D2                 * Convert the ASCII input to Hex
000011FE  6000 0012                257              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
00001202                           258              
00001202                           259  ASC_UPP2STACK
00001202  0442 0037                260              SUBI    #55, D2                 * Convert the ASCII input to Hex
00001206  6000 000A                261              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
0000120A                           262              
0000120A                           263  ASC_NUM2STACK
0000120A  0442 0030                264              SUBI    #48, D2                 * Convert the ASCII input to Hex
0000120E  6000 0002                265              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
00001212                           266              
00001212                           267  ASC_SFT2STACK
00001212  E983                     268              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
00001214  D602                     269              ADD.B   D2, D3                  * Add the converted input to D1
00001216  60A4                     270              BRA     ASC2HXLP2STACK                * Loop
00001218                           271  
00001218                           272  ASC_ERR2STACK
00001218  1E3C 0001                273              MOVE.B  #1, D7                  * Set the error flag to 1            
0000121C                           274  RETURN2STACK
0000121C  4E75                     275              RTS  
0000121E                           276  *---------------------------------------------------------------------------*
0000121E                           277  * HEX2ASCII: Convert Hexadecimal to ASCii 
0000121E                           278  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
0000121E                           279  *---------------------------------------------------------------------------*
0000121E  0C02 0008                280  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001222  6700 000E                281              BEQ     HEX_LOOP
00001226  4841                     282              SWAP    D1
00001228  0C02 0002                283              CMPI.B  #2,D2
0000122C  6600 0004                284              BNE     HEX_LOOP
00001230  E189                     285              LSL.L   #8,D1
00001232                           286             
00001232  E999                     287  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001234  2601                     288              MOVE.L  D1, D3                  * Move D1 to D3
00001236  0283 0000000F            289              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000123C  0C03 0009                290              CMPI.B  #9, D3                  * Compare te digit
00001240  6E00 000A                291              BGT     HEX_CHAR              
00001244  0603 0030                292              ADDI.B  #48,D3                  * Add 48 for numerical output
00001248  6000 0006                293              BRA     HEX_CONT
0000124C                           294              
0000124C  0603 0037                295  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001250                           296  
00001250  12C3                     297  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001252  5342                     298              SUBI    #1, D2                  * Decrement the size
00001254  0C02 0000                299              CMPI.B  #0, D2                  * Check if D2 is 0
00001258  66D8                     300              BNE     HEX_LOOP                * Loop
0000125A  12BC 0000                301              MOVE.B  #$0,(A1)                * Null terminator
0000125E  4E75                     302              RTS
00001260                           303  *---------------------------------------------------------------------------*
00001260                           304  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001260                           305  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
00001260                           306  *---------------------------------------------------------------------------*
00001260                           307  HEX2ASCII2STACK
00001260  0C02 0008                308              CMPI.B  #8, D2                  * Check to see if the size is long
00001264  6700 000E                309              BEQ     STACK_HEX_LOOP
00001268  4841                     310              SWAP    D1
0000126A  0C02 0002                311              CMPI.B  #2,D2
0000126E  6600 0004                312              BNE     STACK_HEX_LOOP
00001272  E189                     313              LSL.L   #8,D1
00001274                           314             
00001274                           315  STACK_HEX_LOOP    
00001274  E999                     316              ROL.L   #4, D1                  * Roll D1 to left
00001276  2601                     317              MOVE.L  D1, D3                  * Move D1 to D3
00001278  0283 0000000F            318              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000127E  0C03 0009                319              CMPI.B  #9, D3                  * Compare te digit
00001282  6E00 000A                320              BGT     STACK_HEX_CHAR              
00001286  0603 0030                321              ADDI.B  #48,D3                  * Add 48 for numerical output
0000128A  6000 0006                322              BRA     STACK_HEX_CONT
0000128E                           323              
0000128E                           324  STACK_HEX_CHAR    
0000128E  0603 0037                325              ADDI.B  #55,D3                  * Add 55 for character output
00001292                           326  
00001292                           327  STACK_HEX_CONT    
00001292  6100 2D3A                328              BSR     PUSH_STACK              *PLACE INTO STACK
00001296  5342                     329              SUBI    #1, D2                  * Decrement the size
00001298  0C02 0000                330              CMPI.B  #0, D2                  * Check if D2 is 0
0000129C  66D6                     331              BNE     STACK_HEX_LOOP                * Loop
0000129E  12BC 0000                332              MOVE.B  #$0,(A1)                * Null terminator
000012A2  4E75                     333              RTS
000012A4                           334  
000012A4                           335  
000012A4                           336  *---------------------------------------------------------------------------*
000012A4                           337  * IS_ODD: Check whether the source address is odd
000012A4                           338  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
000012A4                           339  *---------------------------------------------------------------------------*
000012A4  4281                     340  IS_ODD      CLR.L   D1                      * Clear the result
000012A6  4287                     341              CLR.L   D7                      * Set the error flag to 0
000012A8  2211                     342              MOVE.L  (A1),D1                * Temp store the checking address to D1
000012AA  82FC 0002                343              DIVU    #2, D1                  * Divide the result by 2
000012AE  4841                     344              SWAP    D1                      * Swap remainder with quotient
000012B0  0C01 0001                345              CMPI.B  #1, D1                  * Check for error
000012B4  6700 0004                346              BEQ     IS_ODD_ERR
000012B8  4E75                     347              RTS
000012BA                           348              
000012BA  1E3C 0001                349  IS_ODD_ERR  MOVE.B  #1, D7
000012BE  4E75                     350              RTS
000012C0                           351  
000012C0                           352  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012C0                           353  * MAINDEBUG                    
000012C0                           354  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012C0                           355  * A5: Processing address
000012C0                           356  *
000012C0                           357  * D3: USED FOR PUSHING INTO STACK
000012C0                           358  *     To push into stack => MOVE.W #DATA,D3 
000012C0                           359  *                           BSR    PUSH_STACK
000012C0                           360  *     To print stack     => BSR    PRINT_STACK 
000012C0                           361  *     To clear stack     => BSR    CLEAR_STACK
000012C0                           362  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012C0                           363  MAIN        
000012C0                           364              *initialize stack pointer
000012C0  33FC 0000 00004954       365              MOVE.W  #0,COUNTER
000012C8  347C 7000                366              MOVEA.W #STACK,A2
000012CC  163C 0020                367              MOVE.B  #' ',D3
000012D0  6100 2CFC                368              BSR     PUSH_STACK
000012D4  6100 2CF8                369              BSR     PUSH_STACK
000012D8  6100 2CF4                370              BSR     PUSH_STACK
000012DC                           371              
000012DC                           372              * clear registers for temp storage
000012DC  4280                     373              CLR.L   D0                   
000012DE  4281                     374              CLR.L   D1                   
000012E0  227C 00000000            375              MOVEA.L #0, A1                
000012E6                           376              
000012E6  220D                     377              MOVE.L  A5,D1                   * check to see if the address is fully read
000012E8  23CD 0000459C            378              MOVE.L  A5,S_ADDR_HX
000012EE  B2B9 000045A0            379              CMP.L   E_ADDR_HX,D1
000012F4  6C00 23F8                380              BGE     REPEAT                  * go to repeat for user action
000012F8                           381  
000012F8  43F9 000045F7            382              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012FE  143C 0008                383              MOVE.B  #8,D2                   * set the output size
00001302  4EB8 121E                384              JSR     HEX2ASCII               
00001306  43F9 000045F7            385              LEA     TMPOUTPUT,A1
0000130C  103C 000E                386              MOVE.B  #14,D0
00001310  4E4F                     387              TRAP    #15
00001312                           388              
00001312  4285                     389              CLR.L    D5                      * clear the processing data
00001314  3A1D                     390              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
00001316                           391                                               * advance the current instruction pointer to the next
00001316                           392                                               * instruction in memory
00001316                           393  *----------------------------------------*
00001316                           394  * Registers          
00001316                           395  * [D1] - COPY OF D5
00001316                           396  * [D5] - DATA TO BE PROCESSED
00001316                           397  * [D6] - COUNTER FOR LINES PROCESSED
00001316                           398  *
00001316                           399  * [D4]      - ERROR FLAG BEFORE PRINTING
00001316                           400  * [STACK]   - PRINTS PROCESS DATA
00001316                           401  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
00001316                           402  *
00001316                           403  * [A1] - USED FOR JUMPING/PRINTING
00001316                           404  *
00001316                           405  *----------------------------------------*
00001316                           406  
00001316                           407              
00001316                           408              *Processing the first 4 most significant bits 
00001316  2205                     409              MOVE.L  D5,D1                    * copy the current processing data to D1
00001318  143C 000C                410              MOVE.B  #12,D2                   * shift to right by 12 bits
0000131C  E469                     411              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
0000131E  C2FC 0006                412              MULU    #6,D1                    * form offset
00001322  43F9 00001390            413              LEA     JMPTABLE,A1              * index into table
00001328  4EB1 1000                414              JSR     0(A1,D1)                 * jump indirect with index
0000132C                           415              
0000132C                           416              *SECURED EA*
0000132C  B83C 0001                417              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001330  6600 0012                418              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001334  6100 041A                419              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001338  6100 2D00                420              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000133C  183C 0000                421              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001340  6000 0022                422              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001344                           423             
00001344                           424  OUTPUT_PROCESSED_DATA       
00001344  163C 000D                425              MOVE.B  #$D,D3                  *carriage return
00001348  6100 2C84                426              BSR     PUSH_STACK
0000134C  163C 000A                427              MOVE.B  #$A,D3                  *new line feed
00001350  6100 2C7C                428              BSR     PUSH_STACK
00001354  163C 0000                429              MOVE.B  #$0,D3                  *null
00001358  6100 2C74                430              BSR     PUSH_STACK
0000135C                           431       
0000135C  6100 2C4C                432              BSR     PRINT_QUEUE
00001360  183C 0000                433              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001364                           434  DISPLAY_30_LINES
00001364                           435              * display 30 lines per page
00001364  5206                     436              ADDI.B  #1,D6
00001366  0C06 001E                437              CMPI.B  #30,D6
0000136A  6C00 0006                438              BGE     NEXTLINES
0000136E  6000 FF50                439              BRA     MAIN
00001372                           440            
00001372                           441  *---------------------------------------------------------------------------*
00001372                           442  * NEXTLINES: receive input from user to print the next 30 lines
00001372                           443  *---------------------------------------------------------------------------*  
00001372  4206                     444  NEXTLINES   CLR.B   D6
00001374  43F9 000043F3            445              LEA     DISP_NEXT,A1
0000137A  103C 000E                446              MOVE.B  #14,D0
0000137E  4E4F                     447              TRAP    #15
00001380  43F9 000045A7            448              LEA     TMPINPUT,A1
00001386  103C 0002                449              MOVE.B  #2,D0
0000138A  4E4F                     450              TRAP    #15
0000138C  4EF8 12C0                451              JMP     MAIN
00001390                           452    
00001390                           453  *---------------------------------------------------------------------------*
00001390                           454  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001390                           455  *---------------------------------------------------------------------------*  
00001390  4EF9 000013F0            456  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - JOSEPH
00001396  4EF9 0000196C            457              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
0000139C  4EF9 000019DA            458              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
000013A2  4EF9 00001AD8            459              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
000013A8  4EF9 00001BD4            460              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
000013AE  4EF9 00001E2A            461              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
000013B4  4EF9 00001FCE            462              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *SO FAR COMPLATED (BRA) *NEED TO DO BLT,BHI,BNE,BEQ
000013BA  4EF9 000020D4            463              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013C0  4EF9 000020D8            464              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
000013C6  4EF9 000021E0            465              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
000013CC  4EF9 0000259C            466              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013D2  4EF9 000025A0            467              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - JOSEPH
000013D8  4EF9 000028A0            468              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
000013DE  4EF9 00002BF2            469              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
000013E4  4EF9 00002FCE            470              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
000013EA  4EF9 0000327C            471              JMP     OP1111  * Special/Reserved
000013F0                           472              
000013F0                           473  *---------------------------------------------------------------------------*
000013F0                           474  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013F0                           475  *---------------------------------------------------------------------------*           
000013F0                           476  OP0000                                                                                  
000013F0  4281                     477              CLR.L   D1          * to temporarily store the address to process
000013F2  4280                     478              CLR.L   D0  
000013F4  4284                     479              CLR.L   D4                 
000013F6  227C 00000000            480              MOVEA.L #0, A1                
000013FC                           481              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013FC                           482              * Check if bit 11,10,9,8 are 0000)
000013FC  2205                     483              MOVE.L  D5,D1
000013FE  0281 00000F00            484              ANDI.L  #$0F00,D1
00001404  0C81 00000000            485              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
0000140A  6700 047C                486              BEQ     OP_ORI
0000140E                           487  
0000140E                           488              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
0000140E                           489              * check if bit 11,10,9,8 are 1100
0000140E  4281                     490              CLR.L   D1
00001410  2205                     491              MOVE.L  D5,D1
00001412  0281 00000F00            492              ANDI.L  #$0F00,D1
00001418  0C81 00000C00            493              CMPI.L  #$0C00,D1
0000141E  6700 037C                494              BEQ     OP0000_CMPI
00001422                           495              
00001422                           496              * check for SUBI
00001422  4281                     497              CLR.L   D1
00001424  2205                     498              MOVE.L  D5,D1
00001426  0281 00000F00            499              ANDI.L  #$0F00,D1
0000142C  0C81 00000400            500              CMPI.L  #$0400,D1
00001432  6700 023A                501              BEQ     OP_SUBI
00001436                           502              
00001436                           503              * check for EORI
00001436  4281                     504              CLR.L   D1
00001438  2205                     505              MOVE.L  D5,D1
0000143A  0281 00000F00            506              ANDI.L  #$0F00,D1
00001440  0C81 00000A00            507              CMPI.L  #$0A00,D1
00001446  6700 0144                508              BEQ     OP_EORI
0000144A                           509              
0000144A                           510              * check for BTST
0000144A  4281                     511              CLR.L   D1
0000144C  2205                     512              MOVE.L  D5,D1
0000144E  E099                     513              ROR.L   #8,D1
00001450  0281 00000001            514              ANDI.L  #$1,D1
00001456  0C01 0001                515              CMPI.B  #$1,D1
0000145A  6700 001E                516              BEQ     OP_BTST
0000145E  4281                     517              CLR.L   D1
00001460  2205                     518              MOVE.L  D5,D1
00001462  EC99                     519              ROR.L   #6,D1
00001464  0281 000003FF            520              ANDI.L  #$03FF,D1
0000146A  0C81 00000020            521              CMPI.L  #%000100000,D1
00001470  6700 0008                522              BEQ     OP_BTST
00001474                           523  
00001474                           524  
00001474                           525              * OP0000 series other than ORI/CMPI/BTST/EORI
00001474  4EF9 00001750            526              JMP     OP_DATA
0000147A                           527              
0000147A                           528  *---------------------------------------------------------------------------*
0000147A                           529  * OP_BTST: display BTST
0000147A                           530  *---------------------------------------------------------------------------* 
0000147A                           531  OP_BTST       
0000147A                           532              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000147A                           533              *bits #8 indicates which
0000147A                           534              *0 - #immediate format
0000147A                           535              *1 - Dn format
0000147A  4281                     536              CLR.L   D1
0000147C  2205                     537              MOVE.L  D5,D1
0000147E  E099                     538              ROR.L   #8,D1
00001480  0281 00000001            539              ANDI.L  #1,D1
00001486  0C01 0001                540              CMPI.B  #1,D1
0000148A  6600 0078                541              BNE     OP_BTST_IMMEDIATE
0000148E                           542  
0000148E                           543             
0000148E                           544             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000148E  13FC 0000 00004958       545             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001496  13FC 0002 00004959       546             MOVE.B   #$02,SRC_REGISTER_FORMAT
0000149E                           547             
0000149E                           548             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000149E  13FC 00B9 0000495B       549             MOVE.B   #$B9,GET_DST_START_END
000014A6  13FC 0020 0000495C       550             MOVE.B   #$20,GET_SRC_START_END
000014AE                           551             
000014AE  0285 0000FE3F            552             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014B4  0685 00000000            553             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014BA                           554              
000014BA                           555              *CLEAR D3
000014BA  4283                     556              CLR.L   D3
000014BC                           557              *LOAD STACK WITH THIS OPMODE
000014BC  6100 2B10                558              BSR     PUSH_STACK
000014C0  163C 0042                559              MOVE.B  #'B',D3
000014C4  6100 2B08                560              BSR     PUSH_STACK
000014C8  163C 0054                561              MOVE.B  #'T',D3
000014CC  6100 2B00                562              BSR     PUSH_STACK
000014D0  163C 0053                563              MOVE.B  #'S',D3
000014D4  6100 2AF8                564              BSR     PUSH_STACK
000014D8  163C 0054                565              MOVE.B  #'T',D3
000014DC  6100 2AF0                566              BSR     PUSH_STACK
000014E0  163C 002E                567              MOVE.B  #'.',D3
000014E4  6100 2AE8                568              BSR     PUSH_STACK
000014E8  163C 0042                569              MOVE.B  #'B',D3
000014EC  6100 2AE0                570              BSR     PUSH_STACK
000014F0                           571              
000014F0  6100 266E                572              BSR     GET_EA_EA_DEST
000014F4  163C 002C                573              MOVE.B  #',',D3
000014F8  6100 2AD4                574              BSR     PUSH_STACK
000014FC  6100 2232                575              BSR     GET_EA_EA_SRC
00001500                           576              
00001500  6000 0088                577              BRA     OP0000_RETURN_BTST
00001504                           578              
00001504                           579              
00001504                           580              *MOVE **** OR **** CMPI
00001504                           581              
00001504                           582  OP_BTST_IMMEDIATE              
00001504                           583   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001504  13FC 0000 00004958       584             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000150C  13FC 0082 00004959       585             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001514                           586             
00001514                           587             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001514  13FC 00B9 0000495B       588             MOVE.B   #$B9,GET_DST_START_END
0000151C  13FC 0020 0000495C       589             MOVE.B   #$20,GET_SRC_START_END
00001524                           590             
00001524                           591              *CLEAR D3
00001524  4283                     592              CLR.L   D3
00001526                           593              *LOAD STACK WITH THIS OPMODE
00001526  6100 2AA6                594              BSR     PUSH_STACK
0000152A  163C 0042                595              MOVE.B  #'B',D3
0000152E  6100 2A9E                596              BSR     PUSH_STACK
00001532  163C 0054                597              MOVE.B  #'T',D3
00001536  6100 2A96                598              BSR     PUSH_STACK
0000153A  163C 0053                599              MOVE.B  #'S',D3
0000153E  6100 2A8E                600              BSR     PUSH_STACK
00001542  163C 0054                601              MOVE.B  #'T',D3
00001546  6100 2A86                602              BSR     PUSH_STACK
0000154A  163C 002E                603              MOVE.B  #'.',D3
0000154E  6100 2A7E                604              BSR     PUSH_STACK
00001552  163C 0042                605              MOVE.B  #'B',D3
00001556  6100 2A76                606              BSR     PUSH_STACK
0000155A                           607  
0000155A                           608  OP0000_BTST_B
0000155A                           609              *GET DATA FROM ADDQ AND PRINT #0-8
0000155A                           610              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000155A  0285 0000F03F            611              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001560  0685 000001C0            612              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001566                           613  
00001566                           614              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001566                           615             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001566                           616             * MOVE.W    (A5)+,D1
00001566                           617             * MOVE.B  #' ',D3
00001566                           618             * BSR     PUSH_STACK
00001566                           619             * MOVE.B  #'#',D3
00001566                           620             * BSR     PUSH_STACK
00001566                           621             * BSR     HEX2ASCII2STACK
00001566                           622             * BSR     PUSH_STACK
00001566                           623              
00001566  163C 0020                624              MOVE.B  #' ',D3
0000156A  6100 2A62                625              BSR     PUSH_STACK
0000156E  163C 0023                626              MOVE.B  #'#',D3
00001572  6100 2A5A                627              BSR     PUSH_STACK
00001576  6100 25E8                628              BSR     GET_EA_EA_DEST
0000157A  163C 002C                629              MOVE.B  #',',D3
0000157E  6100 2A4E                630              BSR     PUSH_STACK
00001582  6100 21AC                631              BSR     GET_EA_EA_SRC
00001586  6000 0002                632              BRA     OP0000_RETURN_BTST
0000158A                           633  OP0000_RETURN_BTST
0000158A                           634              
0000158A  4E75                     635              RTS
0000158C                           636  
0000158C                           637  
0000158C                           638  *---------------------------------------------------------------------------*
0000158C                           639  * OP_EORI: decode and display EORI
0000158C                           640  *---------------------------------------------------------------------------* 
0000158C                           641  OP_EORI
0000158C                           642                         
0000158C                           643  
0000158C                           644   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000158C  13FC 0000 00004958       645             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001594  13FC 0080 00004959       646             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000159C                           647             
0000159C                           648             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000159C  13FC 00B9 0000495B       649             MOVE.B   #$B9,GET_DST_START_END
000015A4  13FC 0020 0000495C       650             MOVE.B   #$20,GET_SRC_START_END
000015AC                           651             
000015AC                           652              *CLEAR D3
000015AC  4283                     653              CLR.L   D3
000015AE                           654              *LOAD STACK WITH THIS OPMODE
000015AE  6100 2A1E                655              BSR     PUSH_STACK
000015B2  163C 0045                656              MOVE.B  #'E',D3
000015B6  6100 2A16                657              BSR     PUSH_STACK
000015BA  163C 004F                658              MOVE.B  #'O',D3
000015BE  6100 2A0E                659              BSR     PUSH_STACK
000015C2  163C 0052                660              MOVE.B  #'R',D3
000015C6  6100 2A06                661              BSR     PUSH_STACK
000015CA  163C 0049                662              MOVE.B  #'I',D3
000015CE  6100 29FE                663              BSR     PUSH_STACK
000015D2  163C 002E                664              MOVE.B  #'.',D3
000015D6  6100 29F6                665              BSR     PUSH_STACK
000015DA                           666              
000015DA                           667              *FIGURE OUT SIZE*
000015DA                           668              *00 = BYTE
000015DA                           669              *01 = WORD
000015DA                           670              *10 = LONG
000015DA                           671              * BITS 7&6
000015DA                           672              
000015DA                           673              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015DA  2205                     674              MOVE.L  D5,D1
000015DC  EC99                     675              ROR.L   #6,D1
000015DE  0281 00000003            676              ANDI.L  #$03,D1
000015E4  0C01 0000                677              CMPI.B  #%00,D1
000015E8  6700 001E                678              BEQ     OP0000_EOR_B
000015EC  0281 00000003            679              ANDI.L  #$03,D1
000015F2  0C01 0001                680              CMPI.B  #%01,D1
000015F6  6700 0028                681              BEQ     OP0000_EOR_W
000015FA  0281 00000003            682              ANDI.L  #$03,D1
00001600  0C01 0002                683              CMPI.B  #%10,D1
00001604  6700 0032                684              BEQ     OP0000_EOR_L
00001608                           685            
00001608                           686  OP0000_EOR_B
00001608                           687              
00001608  163C 0042                688              MOVE.B  #'B',D3
0000160C  6100 29C0                689              BSR     PUSH_STACK
00001610                           690              
00001610                           691              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001610  0285 0000F03F            692              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001616  0685 000001C0            693              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000161C                           694  
0000161C                           695              
0000161C  6000 002E                696              BRA     OP0000_RETURN_EOR
00001620                           697  OP0000_EOR_W
00001620                           698              
00001620  163C 0057                699              MOVE.B  #'W',D3
00001624  6100 29A8                700              BSR     PUSH_STACK
00001628                           701              
00001628                           702              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001628  0285 0000F03F            703              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000162E  0685 000001C0            704              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001634                           705  
00001634                           706              
00001634  6000 0016                707              BRA     OP0000_RETURN_EOR
00001638                           708  OP0000_EOR_L
00001638                           709              
00001638  163C 004C                710              MOVE.B  #'L',D3
0000163C  6100 2990                711              BSR     PUSH_STACK
00001640                           712              
00001640                           713              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001640  0285 0000FE3F            714              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001646  0685 000009C0            715              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000164C                           716  
0000164C                           717  
0000164C                           718  OP0000_RETURN_EOR       
0000164C  163C 0020                719              MOVE.B  #' ',D3
00001650  6100 297C                720              BSR     PUSH_STACK
00001654  163C 0023                721              MOVE.B  #'#',D3
00001658  6100 2974                722              BSR     PUSH_STACK
0000165C  6100 2502                723              BSR     GET_EA_EA_DEST
00001660  163C 002C                724              MOVE.B  #',',D3
00001664  6100 2968                725              BSR     PUSH_STACK
00001668  6100 20C6                726              BSR     GET_EA_EA_SRC
0000166C                           727              
0000166C  4E75                     728              RTS
0000166E                           729  
0000166E                           730  *---------------------------------------------------------------------------*
0000166E                           731  * OP_SUBI: decode SUBI.B/.W/.L
0000166E                           732  *---------------------------------------------------------------------------* 
0000166E                           733  OP_SUBI
0000166E                           734             
0000166E                           735   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000166E  13FC 0000 00004958       736             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001676  13FC 0080 00004959       737             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000167E                           738             
0000167E                           739             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000167E  13FC 00B9 0000495B       740             MOVE.B   #$B9,GET_DST_START_END
00001686  13FC 0020 0000495C       741             MOVE.B   #$20,GET_SRC_START_END
0000168E                           742             
0000168E                           743              *CLEAR D3
0000168E  4283                     744              CLR.L   D3
00001690                           745              *LOAD STACK WITH THIS OPMODE
00001690  6100 293C                746              BSR     PUSH_STACK
00001694  163C 0053                747              MOVE.B  #'S',D3
00001698  6100 2934                748              BSR     PUSH_STACK
0000169C  163C 0055                749              MOVE.B  #'U',D3
000016A0  6100 292C                750              BSR     PUSH_STACK
000016A4  163C 0042                751              MOVE.B  #'B',D3
000016A8  6100 2924                752              BSR     PUSH_STACK
000016AC  163C 0049                753              MOVE.B  #'I',D3
000016B0  6100 291C                754              BSR     PUSH_STACK
000016B4  163C 002E                755              MOVE.B  #'.',D3
000016B8  6100 2914                756              BSR     PUSH_STACK
000016BC                           757              
000016BC                           758              *FIGURE OUT SIZE*
000016BC                           759              *00 = BYTE
000016BC                           760              *01 = WORD
000016BC                           761              *10 = LONG
000016BC                           762              * BITS 7&6
000016BC                           763              
000016BC                           764              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016BC  2205                     765              MOVE.L  D5,D1
000016BE  EC99                     766              ROR.L   #6,D1
000016C0  0281 00000003            767              ANDI.L  #$03,D1
000016C6  0C01 0000                768              CMPI.B  #%00,D1
000016CA  6700 001E                769              BEQ     OP0000_SUB_B
000016CE  0281 00000003            770              ANDI.L  #$03,D1
000016D4  0C01 0001                771              CMPI.B  #%01,D1
000016D8  6700 0028                772              BEQ     OP0000_SUB_W
000016DC  0281 00000003            773              ANDI.L  #$03,D1
000016E2  0C01 0002                774              CMPI.B  #%10,D1
000016E6  6700 0032                775              BEQ     OP0000_SUB_L
000016EA                           776            
000016EA                           777  OP0000_SUB_B
000016EA                           778              
000016EA  163C 0042                779              MOVE.B  #'B',D3
000016EE  6100 28DE                780              BSR     PUSH_STACK
000016F2                           781              
000016F2                           782              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016F2  0285 0000F03F            783              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016F8  0685 000001C0            784              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000016FE                           785  
000016FE                           786              
000016FE  6000 002E                787              BRA     OP0000_RETURN_SUBI
00001702                           788  OP0000_SUB_W
00001702                           789              
00001702  163C 0057                790              MOVE.B  #'W',D3
00001706  6100 28C6                791              BSR     PUSH_STACK
0000170A                           792              
0000170A                           793              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000170A  0285 0000F03F            794              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001710  0685 000001C0            795              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001716                           796  
00001716                           797              
00001716  6000 0016                798              BRA     OP0000_RETURN_SUBI
0000171A                           799  OP0000_SUB_L
0000171A                           800              
0000171A  163C 004C                801              MOVE.B  #'L',D3
0000171E  6100 28AE                802              BSR     PUSH_STACK
00001722                           803              
00001722                           804              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001722  0285 0000F03F            805              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001728  0685 000003C0            806              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000172E                           807                      
0000172E                           808  OP0000_RETURN_SUBI            
0000172E  163C 0020                809              MOVE.B  #' ',D3
00001732  6100 289A                810              BSR     PUSH_STACK
00001736  163C 0023                811              MOVE.B  #'#',D3
0000173A  6100 2892                812              BSR     PUSH_STACK
0000173E  6100 2420                813              BSR     GET_EA_EA_DEST
00001742  163C 002C                814              MOVE.B  #',',D3
00001746  6100 2886                815              BSR     PUSH_STACK
0000174A  6100 1FE4                816              BSR     GET_EA_EA_SRC
0000174E                           817              
0000174E  4E75                     818              RTS
00001750                           819  
00001750                           820              
00001750                           821  *---------------------------------------------------------------------------*
00001750                           822  * OP_DATA : unidentified opcode
00001750                           823  *---------------------------------------------------------------------------* 
00001750                           824  OP_DATA
00001750  4280                     825              CLR.L   D0                   
00001752  4281                     826              CLR.L   D1     
00001754  4284                     827              CLR.L   D4                    
00001756  227C 00000000            828              MOVEA.L #0, A1             
0000175C  4287                     829              CLR.L   D7
0000175E  1E3C 0001                830              MOVE.B  #1,D7                   * error flag is true
00001762                           831              
00001762  43F9 000046A6            832              LEA     DISP_DATA,A1
00001768  103C 000E                833              MOVE.B  #14,D0
0000176C  4E4F                     834              TRAP    #15
0000176E                           835              
0000176E  4EF9 00001774            836              JMP     EA_DATA
00001774                           837             
00001774                           838             
00001774                           839  *---------------------------------------------------------------------------*
00001774                           840  * EA_DATA
00001774                           841  *---------------------------------------------------------------------------*       
00001774  43F9 000045F7            842  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000177A  2205                     843              MOVE.L  D5,D1           * transfer the processing data to D1
0000177C  7404                     844              MOVE.L  #4,D2           * set to word size
0000177E  4EB8 121E                845              JSR     HEX2ASCII       * prepare output in ascii
00001782  43F9 00004919            846              LEA     DISP_HEX,A1     * display $ symbol
00001788  103C 000E                847              MOVE.B  #14,D0      
0000178C  4E4F                     848              TRAP    #15
0000178E  43F9 000045F7            849              LEA     TMPOUTPUT,A1    * display with a new line
00001794  103C 000D                850              MOVE.B  #13,D0
00001798  4E4F                     851              TRAP    #15
0000179A                           852  
0000179A  4E75                     853              RTS
0000179C                           854              
0000179C                           855  *---------------------------------------------------------------------------*
0000179C                           856  * OP_CMPI : decode CMPI and its size
0000179C                           857  *---------------------------------------------------------------------------*          
0000179C                           858  OP0000_CMPI
0000179C                           859  
0000179C                           860              
0000179C                           861   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000179C  13FC 0000 00004958       862             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017A4  13FC 0082 00004959       863             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017AC                           864             
000017AC                           865             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017AC  13FC 00B9 0000495B       866             MOVE.B   #$B9,GET_DST_START_END
000017B4  13FC 0020 0000495C       867             MOVE.B   #$20,GET_SRC_START_END
000017BC                           868             
000017BC                           869              *CLEAR D3
000017BC  4283                     870              CLR.L   D3
000017BE                           871              *LOAD STACK WITH THIS OPMODE
000017BE  6100 280E                872              BSR     PUSH_STACK
000017C2  163C 0043                873              MOVE.B  #'C',D3
000017C6  6100 2806                874              BSR     PUSH_STACK
000017CA  163C 004D                875              MOVE.B  #'M',D3
000017CE  6100 27FE                876              BSR     PUSH_STACK
000017D2  163C 0050                877              MOVE.B  #'P',D3
000017D6  6100 27F6                878              BSR     PUSH_STACK
000017DA  163C 0049                879              MOVE.B  #'I',D3
000017DE  6100 27EE                880              BSR     PUSH_STACK
000017E2  163C 002E                881              MOVE.B  #'.',D3
000017E6  6100 27E6                882              BSR     PUSH_STACK
000017EA                           883              
000017EA                           884              *FIGURE OUT SIZE*
000017EA                           885              *00 = BYTE
000017EA                           886              *01 = WORD
000017EA                           887              *10 = LONG
000017EA                           888              * BITS 7&6
000017EA                           889              
000017EA                           890              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017EA  2205                     891              MOVE.L  D5,D1
000017EC  EC99                     892              ROR.L   #6,D1
000017EE  0281 00000003            893              ANDI.L  #$03,D1
000017F4  0C01 0000                894              CMPI.B  #%00,D1
000017F8  6700 0018                895              BEQ     OP0000_CMPI_B
000017FC  0C01 0001                896              CMPI.B  #%01,D1
00001800  6700 0038                897              BEQ     OP0000_CMPI_W
00001804  0281 00000003            898              ANDI.L  #$03,D1
0000180A  0C01 0002                899              CMPI.B  #%10,D1
0000180E  6700 0052                900              BEQ     OP0000_CMPI_L
00001812                           901  
00001812                           902  OP0000_CMPI_B
00001812  163C 0042                903              MOVE.B  #'B',D3
00001816  6100 27B6                904              BSR     PUSH_STACK
0000181A                           905  *GET DATA FROM ADDQ AND PRINT #0-8
0000181A                           906              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000181A  0285 0000F03F            907              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001820  0685 000001C0            908              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001826  6100 2338                909              BSR     GET_EA_EA_DEST
0000182A  163C 002C                910              MOVE.B  #',',D3
0000182E  6100 279E                911              BSR     PUSH_STACK
00001832  6100 1EFC                912              BSR     GET_EA_EA_SRC
00001836  6000 004E                913              BRA     OP0000_RETURN_CMPI
0000183A                           914  
0000183A                           915  OP0000_CMPI_W
0000183A  163C 0057                916              MOVE.B  #'W',D3
0000183E  6100 278E                917              BSR     PUSH_STACK
00001842                           918  *GET DATA FROM ADDQ AND PRINT #0-8
00001842                           919              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001842  0285 0000F03F            920              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001848  0685 000001C0            921              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000184E  6100 2310                922              BSR     GET_EA_EA_DEST
00001852  163C 002C                923              MOVE.B  #',',D3
00001856  6100 2776                924              BSR     PUSH_STACK
0000185A  6100 1ED4                925              BSR     GET_EA_EA_SRC
0000185E  6000 0026                926              BRA     OP0000_RETURN_CMPI
00001862                           927  
00001862                           928  OP0000_CMPI_L
00001862  163C 004C                929              MOVE.B  #'L',D3
00001866  6100 2766                930              BSR     PUSH_STACK
0000186A                           931              *GET DATA FROM ADDQ AND PRINT #0-8
0000186A                           932              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000186A  0285 0000F03F            933              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001870  0685 000003C0            934              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001876  6100 22E8                935              BSR     GET_EA_EA_DEST
0000187A  163C 002C                936              MOVE.B  #',',D3
0000187E  6100 274E                937              BSR     PUSH_STACK
00001882  6100 1EAC                938              BSR     GET_EA_EA_SRC
00001886                           939              
00001886                           940  OP0000_RETURN_CMPI
00001886                           941  
00001886                           942  
00001886                           943              
00001886  4E75                     944              RTS
00001888                           945   
00001888                           946  *---------------------------------------------------------------------------*
00001888                           947  * OP_ORI : decode ORI and its size
00001888                           948  *---------------------------------------------------------------------------* 
00001888                           949  OP_ORI      
00001888                           950           
00001888                           951   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001888  13FC 0000 00004958       952             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001890  13FC 0082 00004959       953             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001898                           954             
00001898                           955             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001898  13FC 00B9 0000495B       956             MOVE.B   #$B9,GET_DST_START_END
000018A0  13FC 0020 0000495C       957             MOVE.B   #$20,GET_SRC_START_END
000018A8                           958             
000018A8                           959              *CLEAR D3
000018A8  4283                     960              CLR.L   D3
000018AA                           961              *LOAD STACK WITH THIS OPMODE
000018AA  6100 2722                962              BSR     PUSH_STACK
000018AE  163C 004F                963              MOVE.B  #'O',D3
000018B2  6100 271A                964              BSR     PUSH_STACK
000018B6  163C 0052                965              MOVE.B  #'R',D3
000018BA  6100 2712                966              BSR     PUSH_STACK
000018BE  163C 0049                967              MOVE.B  #'I',D3
000018C2  6100 270A                968              BSR     PUSH_STACK
000018C6  163C 002E                969              MOVE.B  #'.',D3
000018CA  6100 2702                970              BSR     PUSH_STACK
000018CE                           971              
000018CE                           972              *FIGURE OUT SIZE*
000018CE                           973              *00 = BYTE
000018CE                           974              *01 = WORD
000018CE                           975              *10 = LONG
000018CE                           976              * BITS 7&6
000018CE                           977              
000018CE                           978              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018CE  2205                     979              MOVE.L  D5,D1
000018D0  EC99                     980              ROR.L   #6,D1
000018D2  0281 00000003            981              ANDI.L  #$03,D1
000018D8  0C01 0000                982              CMPI.B  #%00,D1
000018DC  6700 0018                983              BEQ     OP0000_ORI_B
000018E0  0C01 0001                984              CMPI.B  #%01,D1
000018E4  6700 0038                985              BEQ     OP0000_ORI_W
000018E8  0281 00000003            986              ANDI.L  #$03,D1
000018EE  0C01 0002                987              CMPI.B  #%10,D1
000018F2  6700 0052                988              BEQ     OP0000_ORI_L
000018F6                           989  
000018F6                           990  OP0000_ORI_B
000018F6  163C 0042                991              MOVE.B  #'B',D3
000018FA  6100 26D2                992              BSR     PUSH_STACK
000018FE                           993  *GET DATA FROM ADDQ AND PRINT #0-8
000018FE                           994              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000018FE  0285 0000F03F            995              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001904  0685 000001C0            996              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000190A  6100 2254                997              BSR     GET_EA_EA_DEST
0000190E  163C 002C                998              MOVE.B  #',',D3
00001912  6100 26BA                999              BSR     PUSH_STACK
00001916  6100 1E18               1000              BSR     GET_EA_EA_SRC
0000191A  6000 004E               1001              BRA     OP0000_RETURN_ORI
0000191E                          1002  
0000191E                          1003  OP0000_ORI_W
0000191E  163C 0057               1004              MOVE.B  #'W',D3
00001922  6100 26AA               1005              BSR     PUSH_STACK
00001926                          1006  *GET DATA FROM ADDQ AND PRINT #0-8
00001926                          1007              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001926  0285 0000F03F           1008              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000192C  0685 000001C0           1009              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001932  6100 222C               1010              BSR     GET_EA_EA_DEST
00001936  163C 002C               1011              MOVE.B  #',',D3
0000193A  6100 2692               1012              BSR     PUSH_STACK
0000193E  6100 1DF0               1013              BSR     GET_EA_EA_SRC
00001942  6000 0026               1014              BRA     OP0000_RETURN_ORI
00001946                          1015  
00001946                          1016  OP0000_ORI_L
00001946  163C 004C               1017              MOVE.B  #'L',D3
0000194A  6100 2682               1018              BSR     PUSH_STACK
0000194E                          1019              *GET DATA FROM ADDQ AND PRINT #0-8
0000194E                          1020              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000194E  0285 0000F03F           1021              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001954  0685 000003C0           1022              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000195A  6100 2204               1023              BSR     GET_EA_EA_DEST
0000195E  163C 002C               1024              MOVE.B  #',',D3
00001962  6100 266A               1025              BSR     PUSH_STACK
00001966  6100 1DC8               1026              BSR     GET_EA_EA_SRC
0000196A                          1027              
0000196A                          1028  OP0000_RETURN_ORI
0000196A                          1029  
0000196A                          1030  
0000196A                          1031              
0000196A  4E75                    1032              RTS
0000196C                          1033  
0000196C                          1034          
0000196C                          1035  *---------------------------------------------------------------------------*
0000196C                          1036  * OP0001: MOVE.B
0000196C                          1037  *---------------------------------------------------------------------------*
0000196C                          1038  OP0001      
0000196C  4EF9 00001972           1039              JMP     OP_MOVE_B   * display MOVE.B
00001972                          1040              
00001972                          1041  *---------------------------------------------------------------------------*
00001972                          1042  * OP_MOVE_B: display MOVE_B and proceed to EA
00001972                          1043  *---------------------------------------------------------------------------*
00001972                          1044  OP_MOVE_B                                                                       
00001972                          1045             
00001972                          1046             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001972  13FC 0082 00004958      1047             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000197A  13FC 0000 00004959      1048             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001982                          1049             
00001982                          1050             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001982  13FC 00B9 0000495B      1051             MOVE.B   #$B9,GET_DST_START_END
0000198A  13FC 0020 0000495C      1052             MOVE.B   #$20,GET_SRC_START_END
00001992                          1053             
00001992                          1054              *CLEAR D3
00001992  4283                    1055              CLR.L   D3
00001994                          1056              *LOAD STACK WITH THIS OPMODE
00001994  6100 2638               1057              BSR     PUSH_STACK
00001998  163C 004D               1058              MOVE.B  #'M',D3
0000199C  6100 2630               1059              BSR     PUSH_STACK
000019A0  163C 004F               1060              MOVE.B  #'O',D3
000019A4  6100 2628               1061              BSR     PUSH_STACK
000019A8  163C 0056               1062              MOVE.B  #'V',D3
000019AC  6100 2620               1063              BSR     PUSH_STACK
000019B0  163C 0045               1064              MOVE.B  #'E',D3
000019B4  6100 2618               1065              BSR     PUSH_STACK
000019B8  163C 002E               1066              MOVE.B  #'.',D3
000019BC  6100 2610               1067              BSR     PUSH_STACK
000019C0  163C 0042               1068              MOVE.B  #'B',D3
000019C4  6100 2608               1069              BSR     PUSH_STACK
000019C8                          1070              
000019C8  6100 1D66               1071              BSR     GET_EA_EA_SRC
000019CC  163C 002C               1072              MOVE.B  #',',D3
000019D0  6100 25FC               1073              BSR     PUSH_STACK
000019D4  6100 218A               1074              BSR     GET_EA_EA_DEST
000019D8                          1075              
000019D8  4E75                    1076              RTS
000019DA                          1077              
000019DA                          1078             
000019DA                          1079  *---------------------------------------------------------------------------*
000019DA                          1080  * OP0010: decode MOVE.L/MOVEA.L
000019DA                          1081  *---------------------------------------------------------------------------*
000019DA                          1082  OP0010      
000019DA  183C 0002               1083              MOVE.B  #2,D4
000019DE  4280                    1084              CLR.L   D0                     
000019E0  4281                    1085              CLR.L   D1                      
000019E2  227C 00000000           1086              MOVEA.L #0, A1                 
000019E8                          1087              
000019E8  2205                    1088              MOVE.L  D5,D1
000019EA  EA99                    1089              ROR.L   #5,D1
000019EC  0281 0000000E           1090              ANDI.L  #$E,D1
000019F2  0C01 0002               1091              CMPI.B  #2,D1
000019F6  6700 0070               1092              BEQ     OP_MOVEA_L
000019FA                          1093  
000019FA  4EF9 00001A00           1094              JMP     OP_MOVE_L
00001A00                          1095             
00001A00                          1096  
00001A00                          1097  *---------------------------------------------------------------------------*
00001A00                          1098  * OP_MOVE_L: display MOVE_L and proceed to EA
00001A00                          1099  *---------------------------------------------------------------------------*
00001A00                          1100  OP_MOVE_L   
00001A00                          1101             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A00  13FC 0082 00004958      1102             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A08  13FC 0000 00004959      1103             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A10                          1104             
00001A10                          1105             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A10  13FC 00B9 0000495B      1106             MOVE.B   #$B9,GET_DST_START_END
00001A18  13FC 0020 0000495C      1107             MOVE.B   #$20,GET_SRC_START_END
00001A20                          1108             
00001A20                          1109              *CLEAR D3
00001A20  4283                    1110              CLR.L   D3
00001A22                          1111              *LOAD STACK WITH THIS OPMODE
00001A22  6100 25AA               1112              BSR     PUSH_STACK
00001A26  163C 004D               1113              MOVE.B  #'M',D3
00001A2A  6100 25A2               1114              BSR     PUSH_STACK
00001A2E  163C 004F               1115              MOVE.B  #'O',D3
00001A32  6100 259A               1116              BSR     PUSH_STACK
00001A36  163C 0056               1117              MOVE.B  #'V',D3
00001A3A  6100 2592               1118              BSR     PUSH_STACK
00001A3E  163C 0045               1119              MOVE.B  #'E',D3
00001A42  6100 258A               1120              BSR     PUSH_STACK
00001A46  163C 002E               1121              MOVE.B  #'.',D3
00001A4A  6100 2582               1122              BSR     PUSH_STACK
00001A4E  163C 004C               1123              MOVE.B  #'L',D3
00001A52  6100 257A               1124              BSR     PUSH_STACK
00001A56                          1125              
00001A56  6100 1CD8               1126              BSR     GET_EA_EA_SRC
00001A5A  163C 002C               1127              MOVE.B  #',',D3
00001A5E  6100 256E               1128              BSR     PUSH_STACK
00001A62  6100 20FC               1129              BSR     GET_EA_EA_DEST
00001A66                          1130              
00001A66  4E75                    1131              RTS
00001A68                          1132  
00001A68                          1133  
00001A68                          1134  *---------------------------------------------------------------------------*
00001A68                          1135  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A68                          1136  *---------------------------------------------------------------------------*
00001A68                          1137  OP_MOVEA_L 
00001A68                          1138             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A68  13FC 00FD 00004958      1139             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A70  13FC 0000 00004959      1140             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A78                          1141             
00001A78                          1142             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A78  13FC 00B9 0000495B      1143             MOVE.B   #$B9,GET_DST_START_END
00001A80  13FC 0020 0000495C      1144             MOVE.B   #$20,GET_SRC_START_END
00001A88                          1145             
00001A88                          1146              *CLEAR D3
00001A88  4283                    1147              CLR.L   D3
00001A8A                          1148              *LOAD STACK WITH THIS OPMODE
00001A8A  6100 2542               1149              BSR     PUSH_STACK
00001A8E  163C 004D               1150              MOVE.B  #'M',D3
00001A92  6100 253A               1151              BSR     PUSH_STACK
00001A96  163C 004F               1152              MOVE.B  #'O',D3
00001A9A  6100 2532               1153              BSR     PUSH_STACK
00001A9E  163C 0056               1154              MOVE.B  #'V',D3
00001AA2  6100 252A               1155              BSR     PUSH_STACK
00001AA6  163C 0045               1156              MOVE.B  #'E',D3
00001AAA  6100 2522               1157              BSR     PUSH_STACK           
00001AAE  163C 0041               1158              MOVE.B  #'A',D3
00001AB2  6100 251A               1159              BSR     PUSH_STACK
00001AB6  163C 002E               1160              MOVE.B  #'.',D3
00001ABA  6100 2512               1161              BSR     PUSH_STACK
00001ABE  163C 004C               1162              MOVE.B  #'L',D3
00001AC2  6100 250A               1163              BSR     PUSH_STACK
00001AC6                          1164              
00001AC6  6100 1C68               1165              BSR     GET_EA_EA_SRC
00001ACA  163C 002C               1166              MOVE.B  #',',D3
00001ACE  6100 24FE               1167              BSR     PUSH_STACK
00001AD2  6100 208C               1168              BSR     GET_EA_EA_DEST
00001AD6                          1169              
00001AD6  4E75                    1170              RTS
00001AD8                          1171  
00001AD8                          1172              
00001AD8                          1173  *---------------------------------------------------------------------------*
00001AD8                          1174  * OP0011: decode MOVE.W/MOVEA.W
00001AD8                          1175  *---------------------------------------------------------------------------*
00001AD8                          1176  OP0011      
00001AD8  4280                    1177              CLR.L   D0                      
00001ADA  4281                    1178              CLR.L   D1  
00001ADC  4284                    1179              CLR.L   D4                   
00001ADE  227C 00000000           1180              MOVEA.L #0, A1 
00001AE4                          1181                
00001AE4  2205                    1182              MOVE.L  D5,D1
00001AE6  EC99                    1183              ROR.L   #6,D1
00001AE8  0281 00000007           1184              ANDI.L  #$07,D1
00001AEE  0C01 0001               1185              CMPI.B  #1,D1
00001AF2  6700 0070               1186              BEQ     OP_MOVEA_W
00001AF6                          1187              
00001AF6  4EF9 00001AFC           1188              JMP     OP_MOVE_W
00001AFC                          1189            
00001AFC                          1190  *---------------------------------------------------------------------------*
00001AFC                          1191  * OP_MOVE_W: display MOVE_W and proceed to EA
00001AFC                          1192  *---------------------------------------------------------------------------*
00001AFC                          1193  OP_MOVE_W   
00001AFC                          1194             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001AFC  13FC 0082 00004958      1195             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001B04  13FC 0000 00004959      1196             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B0C                          1197             
00001B0C                          1198             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B0C  13FC 00B9 0000495B      1199             MOVE.B   #$B9,GET_DST_START_END
00001B14  13FC 0020 0000495C      1200             MOVE.B   #$20,GET_SRC_START_END
00001B1C                          1201             
00001B1C                          1202              *CLEAR D3
00001B1C  4283                    1203              CLR.L   D3
00001B1E                          1204              *LOAD STACK WITH THIS OPMODE
00001B1E  6100 24AE               1205              BSR     PUSH_STACK
00001B22  163C 004D               1206              MOVE.B  #'M',D3
00001B26  6100 24A6               1207              BSR     PUSH_STACK
00001B2A  163C 004F               1208              MOVE.B  #'O',D3
00001B2E  6100 249E               1209              BSR     PUSH_STACK
00001B32  163C 0056               1210              MOVE.B  #'V',D3
00001B36  6100 2496               1211              BSR     PUSH_STACK
00001B3A  163C 0045               1212              MOVE.B  #'E',D3
00001B3E  6100 248E               1213              BSR     PUSH_STACK
00001B42  163C 002E               1214              MOVE.B  #'.',D3
00001B46  6100 2486               1215              BSR     PUSH_STACK
00001B4A  163C 0057               1216              MOVE.B  #'W',D3
00001B4E  6100 247E               1217              BSR     PUSH_STACK
00001B52                          1218              
00001B52  6100 1BDC               1219              BSR     GET_EA_EA_SRC
00001B56  163C 002C               1220              MOVE.B  #',',D3
00001B5A  6100 2472               1221              BSR     PUSH_STACK
00001B5E  6100 2000               1222              BSR     GET_EA_EA_DEST
00001B62                          1223              
00001B62  4E75                    1224              RTS
00001B64                          1225  
00001B64                          1226  *---------------------------------------------------------------------------*
00001B64                          1227  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B64                          1228  *---------------------------------------------------------------------------*
00001B64                          1229  OP_MOVEA_W 
00001B64                          1230             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B64  13FC 00FD 00004958      1231             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B6C  13FC 0000 00004959      1232             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B74                          1233             
00001B74                          1234             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B74  13FC 00B9 0000495B      1235             MOVE.B   #$B9,GET_DST_START_END
00001B7C  13FC 0020 0000495C      1236             MOVE.B   #$20,GET_SRC_START_END
00001B84                          1237             
00001B84                          1238              *CLEAR D3
00001B84  4283                    1239              CLR.L   D3
00001B86                          1240              *LOAD STACK WITH THIS OPMODE
00001B86  6100 2446               1241              BSR     PUSH_STACK
00001B8A  163C 004D               1242              MOVE.B  #'M',D3
00001B8E  6100 243E               1243              BSR     PUSH_STACK
00001B92  163C 004F               1244              MOVE.B  #'O',D3
00001B96  6100 2436               1245              BSR     PUSH_STACK
00001B9A  163C 0056               1246              MOVE.B  #'V',D3
00001B9E  6100 242E               1247              BSR     PUSH_STACK
00001BA2  163C 0045               1248              MOVE.B  #'E',D3
00001BA6  6100 2426               1249              BSR     PUSH_STACK           
00001BAA  163C 0041               1250              MOVE.B  #'A',D3
00001BAE  6100 241E               1251              BSR     PUSH_STACK
00001BB2  163C 002E               1252              MOVE.B  #'.',D3
00001BB6  6100 2416               1253              BSR     PUSH_STACK
00001BBA  163C 0057               1254              MOVE.B  #'W',D3
00001BBE  6100 240E               1255              BSR     PUSH_STACK
00001BC2                          1256              
00001BC2  6100 1B6C               1257              BSR     GET_EA_EA_SRC
00001BC6  163C 002C               1258              MOVE.B  #',',D3
00001BCA  6100 2402               1259              BSR     PUSH_STACK
00001BCE  6100 1F90               1260              BSR     GET_EA_EA_DEST
00001BD2                          1261            
00001BD2  4E75                    1262              RTS
00001BD4                          1263  *---------------------------------------------------------------------------*
00001BD4                          1264  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BD4                          1265  *---------------------------------------------------------------------------*
00001BD4                          1266  OP0100
00001BD4  4280                    1267              CLR.L   D0                      
00001BD6  4281                    1268              CLR.L   D1  
00001BD8  4284                    1269              CLR.L   D4                      
00001BDA  227C 00000000           1270              MOVEA.L #0, A1                  
00001BE0  2205                    1271              MOVE.L  D5,D1  
00001BE2                          1272              
00001BE2                          1273              * check for RTS
00001BE2  0C41 4E75               1274              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BE6  6700 0228               1275              BEQ     OP_RTS
00001BEA                          1276              
00001BEA                          1277              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BEA  4281                    1278              CLR.L   D1 
00001BEC  2205                    1279              MOVE.L  D5,D1  
00001BEE  0241 0F00               1280              ANDI.W  #$0F00,D1
00001BF2  0C41 0E00               1281              CMPI.W  #$0E00,D1
00001BF6  6700 0204               1282              BEQ     OP_JSR
00001BFA                          1283  
00001BFA                          1284              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001BFA  4281                    1285              CLR.L   D1 
00001BFC  2205                    1286              MOVE.L  D5,D1  
00001BFE  0241 0F00               1287              ANDI.W  #$0F00,D1
00001C02  0C41 0400               1288              CMPI.W  #$0400,D1
00001C06  6700 00E8               1289              BEQ     OP_NEG
00001C0A                          1290              
00001C0A                          1291              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001C0A  4281                    1292              CLR.L   D1 
00001C0C  2205                    1293              MOVE.L  D5,D1  
00001C0E  0241 0F00               1294              ANDI.W  #$0F00,D1
00001C12  0C41 0600               1295              CMPI.W  #$0600,D1
00001C16  6700 015E               1296              BEQ     OP_NOT
00001C1A                          1297              
00001C1A                          1298              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C1A  4281                    1299              CLR.L   D1 
00001C1C  2205                    1300              MOVE.L  D5,D1  
00001C1E  EC99                    1301              ROR.L   #6,D1
00001C20  0281 00000007           1302              ANDI.L  #7,D1
00001C26  0C81 00000007           1303              CMPI.L  #7,D1
00001C2C  6700 0054               1304              BEQ     OP_LEA
00001C30                          1305              
00001C30                          1306              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C30  4281                    1307              CLR.L   D1 
00001C32  2205                    1308              MOVE.L  D5,D1  
00001C34  EB59                    1309              ROL.W   #5,D1
00001C36  0C01 0001               1310              CMPI.B  #1,D1
00001C3A  6600 FB14               1311              BNE     OP_DATA
00001C3E  E959                    1312              ROL.W   #4,D1
00001C40  0C01 0001               1313              CMPI.B  #1,D1
00001C44  6600 FB0A               1314              BNE     OP_DATA
00001C48  E359                    1315              ROL.W   #1,D1
00001C4A  0C01 0000               1316              CMPI.B  #0,D1
00001C4E  6700 000E               1317              BEQ     OP_MOVEM_W
00001C52  0C01 0001               1318              CMPI.B  #1,D1
00001C56  6700 0018               1319              BEQ     OP_MOVEM_L
00001C5A  4EF8 1750               1320              JMP     OP_DATA
00001C5E                          1321  
00001C5E                          1322  *---------------------------------------------------------------------------*
00001C5E                          1323  * OP_MOVEM_W: display MOVEM_W
00001C5E                          1324  *---------------------------------------------------------------------------*    
00001C5E                          1325  OP_MOVEM_W  
00001C5E  183C 0001               1326              MOVE.B  #1,D4
00001C62  43F9 00004717           1327              LEA     DISP_MOVEM_W,A1
00001C68  103C 000E               1328              MOVE.B  #14,D0
00001C6C  4E4F                    1329              TRAP    #15
00001C6E  4E75                    1330              RTS
00001C70                          1331  
00001C70                          1332  *---------------------------------------------------------------------------*
00001C70                          1333  * OP_MOVEM_L: display MOVEM_L
00001C70                          1334  *---------------------------------------------------------------------------*
00001C70                          1335  OP_MOVEM_L  
00001C70  183C 0002               1336              MOVE.B  #2,D4
00001C74  43F9 00004722           1337              LEA     DISP_MOVEM_L,A1
00001C7A  103C 000E               1338              MOVE.B  #14,D0
00001C7E  4E4F                    1339              TRAP    #15
00001C80  4E75                    1340              RTS
00001C82                          1341     
00001C82                          1342  *---------------------------------------------------------------------------*
00001C82                          1343  * OP_LEA: decode and display LEA
00001C82                          1344  *---------------------------------------------------------------------------*
00001C82                          1345  OP_LEA      
00001C82  4281                    1346               CLR.L   D1       
00001C84  4284                    1347              CLR.L   D4                   
00001C86  227C 00000000           1348              MOVEA.L #0, A1              
00001C8C  2205                    1349              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C8E                          1350              *CLEAR D3
00001C8E  4283                    1351              CLR.L   D3
00001C90                          1352  
00001C90                          1353  OP_LEA_DN_EA_OR_EA_DN 
00001C90                          1354              *LOAD STACK WITH THIS OPMODE
00001C90  6100 233C               1355              BSR     PUSH_STACK
00001C94  163C 004C               1356              MOVE.B  #'L',D3
00001C98  6100 2334               1357              BSR     PUSH_STACK
00001C9C  163C 0045               1358              MOVE.B  #'E',D3
00001CA0  6100 232C               1359              BSR     PUSH_STACK
00001CA4  163C 0041               1360              MOVE.B  #'A',D3
00001CA8  6100 2324               1361              BSR     PUSH_STACK
00001CAC  2205                    1362              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CAE                          1363          
00001CAE                          1364  
00001CAE                          1365  OP_PRINT_L_LEA
00001CAE                          1366                          
00001CAE                          1367              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CAE  13FC 0000 00004958      1368              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CB6  13FC 009B 00004959      1369              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CBE                          1370             
00001CBE                          1371              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CBE  13FC 00B9 0000495B      1372              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CC6  13FC 0020 0000495C      1373              MOVE.B   #$20,GET_SRC_START_END
00001CCE                          1374  
00001CCE                          1375              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CCE  0285 0000FE3F           1376              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CD4  0685 00000040           1377              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CDA                          1378  
00001CDA  6100 1A54               1379              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CDE  163C 002C               1380              MOVE.B  #',',D3
00001CE2  6100 22EA               1381              BSR     PUSH_STACK           
00001CE6  6100 1E78               1382              BSR     GET_EA_EA_DEST       *GETS Dn    
00001CEA                          1383  
00001CEA                          1384              
00001CEA  6000 0002               1385              BRA     OP_LEA_RETURN
00001CEE                          1386              
00001CEE                          1387  OP_LEA_RETURN
00001CEE  4E75                    1388              RTS
00001CF0                          1389              
00001CF0                          1390  
00001CF0                          1391  
00001CF0                          1392  *---------------------------------------------------------------------------*
00001CF0                          1393  * OP_NEG: decode and display NEG 
00001CF0                          1394  *---------------------------------------------------------------------------*
00001CF0                          1395  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001CF0  4281                    1396              CLR.L   D1
00001CF2  4284                    1397              CLR.L   D4
00001CF4  2205                    1398              MOVE.L  D5,D1
00001CF6                          1399              
00001CF6                          1400              *CLEAR D3
00001CF6  4283                    1401              CLR.L   D3
00001CF8                          1402              *LOAD STACK WITH THIS OPMODE
00001CF8  6100 22D4               1403              BSR     PUSH_STACK
00001CFC  163C 004E               1404              MOVE.B  #'N',D3
00001D00  6100 22CC               1405              BSR     PUSH_STACK
00001D04  163C 0045               1406              MOVE.B  #'E',D3
00001D08  6100 22C4               1407              BSR     PUSH_STACK
00001D0C  163C 0047               1408              MOVE.B  #'G',D3
00001D10  6100 22BC               1409              BSR     PUSH_STACK
00001D14  163C 002E               1410              MOVE.B  #'.',D3
00001D18  6100 22B4               1411              BSR     PUSH_STACK
00001D1C                          1412              
00001D1C                          1413              
00001D1C  EC99                    1414              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D1E  0281 00000007           1415              ANDI.L  #$07,D1
00001D24                          1416              
00001D24  0C01 0000               1417              CMPI.B  #0,D1
00001D28  6700 0012               1418              BEQ     OP_NEG_B    * size is byte
00001D2C  0C01 0001               1419              CMPI.B  #1,D1
00001D30  6700 0016               1420              BEQ     OP_NEG_W    * size is word
00001D34  0C01 0002               1421              CMPI.B  #2,D1
00001D38  6700 001A               1422              BEQ     OP_NEG_L    * size is long
00001D3C                          1423                         
00001D3C                          1424  
00001D3C                          1425  OP_NEG_B    * size is byte   
00001D3C  163C 0042               1426              MOVE.B  #'B',D3
00001D40  6100 228C               1427              BSR     PUSH_STACK
00001D44  6000 001A               1428              BRA     OP_NEG_PRINT_EA
00001D48                          1429  
00001D48                          1430              
00001D48                          1431  OP_NEG_W    * size is word
00001D48  163C 0057               1432              MOVE.B  #'W',D3
00001D4C  6100 2280               1433              BSR     PUSH_STACK
00001D50  6000 000E               1434              BRA     OP_NEG_PRINT_EA
00001D54                          1435  
00001D54                          1436              
00001D54                          1437  OP_NEG_L    * size is long
00001D54  163C 004C               1438              MOVE.B  #'L',D3
00001D58  6100 2274               1439              BSR     PUSH_STACK
00001D5C  6000 0002               1440              BRA     OP_NEG_PRINT_EA
00001D60                          1441  
00001D60                          1442  
00001D60                          1443  OP_NEG_PRINT_EA
00001D60                          1444   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D60  13FC 0082 00004959      1445             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D68                          1446             
00001D68                          1447             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D68  13FC 0020 0000495C      1448             MOVE.B   #$20,GET_SRC_START_END
00001D70                          1449                         
00001D70                          1450  
00001D70  6100 19BE               1451              BSR     GET_EA_EA_SRC
00001D74                          1452              
00001D74  4E75                    1453              RTS
00001D76                          1454  
00001D76                          1455  *---------------------------------------------------------------------------*
00001D76                          1456  * OP_NOT: decode and display NOT 
00001D76                          1457  *---------------------------------------------------------------------------*
00001D76                          1458  OP_NOT
00001D76  4281                    1459              CLR.L   D1
00001D78  4284                    1460              CLR.L   D4
00001D7A  2205                    1461              MOVE.L  D5,D1
00001D7C                          1462              
00001D7C                          1463              *CLEAR D3
00001D7C  4283                    1464              CLR.L   D3
00001D7E                          1465              *LOAD STACK WITH THIS OPMODE
00001D7E  6100 224E               1466              BSR     PUSH_STACK
00001D82  163C 004E               1467              MOVE.B  #'N',D3
00001D86  6100 2246               1468              BSR     PUSH_STACK
00001D8A  163C 004F               1469              MOVE.B  #'O',D3
00001D8E  6100 223E               1470              BSR     PUSH_STACK
00001D92  163C 0054               1471              MOVE.B  #'T',D3
00001D96  6100 2236               1472              BSR     PUSH_STACK
00001D9A  163C 002E               1473              MOVE.B  #'.',D3
00001D9E  6100 222E               1474              BSR     PUSH_STACK
00001DA2                          1475              
00001DA2                          1476              
00001DA2  EC99                    1477              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DA4  0281 00000007           1478              ANDI.L  #$07,D1
00001DAA                          1479              
00001DAA  0C01 0000               1480              CMPI.B  #0,D1
00001DAE  6700 0012               1481              BEQ     OP_NOT_B    * size is byte
00001DB2  0C01 0001               1482              CMPI.B  #1,D1
00001DB6  6700 0016               1483              BEQ     OP_NOT_W    * size is word
00001DBA  0C01 0002               1484              CMPI.B  #2,D1
00001DBE  6700 001A               1485              BEQ     OP_NOT_L    * size is long
00001DC2                          1486                         
00001DC2                          1487  
00001DC2                          1488  OP_NOT_B    * size is byte   
00001DC2  163C 0042               1489              MOVE.B  #'B',D3
00001DC6  6100 2206               1490              BSR     PUSH_STACK
00001DCA  6000 001A               1491              BRA     OP_NOT_PRINT_EA
00001DCE                          1492  
00001DCE                          1493              
00001DCE                          1494  OP_NOT_W    * size is word
00001DCE  163C 0057               1495              MOVE.B  #'W',D3
00001DD2  6100 21FA               1496              BSR     PUSH_STACK
00001DD6  6000 000E               1497              BRA     OP_NOT_PRINT_EA
00001DDA                          1498  
00001DDA                          1499              
00001DDA                          1500  OP_NOT_L    * size is long
00001DDA  163C 004C               1501              MOVE.B  #'L',D3
00001DDE  6100 21EE               1502              BSR     PUSH_STACK
00001DE2  6000 0002               1503              BRA     OP_NOT_PRINT_EA
00001DE6                          1504  
00001DE6                          1505  
00001DE6                          1506  OP_NOT_PRINT_EA
00001DE6                          1507   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DE6  13FC 0082 00004959      1508             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001DEE                          1509             
00001DEE                          1510             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DEE  13FC 0020 0000495C      1511             MOVE.B   #$20,GET_SRC_START_END
00001DF6  6100 1938               1512              BSR     GET_EA_EA_SRC
00001DFA                          1513              
00001DFA  4E75                    1514              RTS
00001DFC                          1515  
00001DFC                          1516  
00001DFC                          1517  *---------------------------------------------------------------------------*
00001DFC                          1518  * OP_JSR: display JSR     
00001DFC                          1519  *---------------------------------------------------------------------------*
00001DFC  43F9 000046D3           1520  OP_JSR      LEA     DISP_JSR,A1
00001E02  103C 000E               1521              MOVE.B  #14,D0
00001E06  4E4F                    1522              TRAP    #15
00001E08  4EB9 00003280           1523              JSR     EA_NOSRC
00001E0E                          1524  
00001E0E  4E75                    1525              RTS
00001E10                          1526  
00001E10                          1527  *---------------------------------------------------------------------------*
00001E10                          1528  * OP_RTS: display RTS     
00001E10                          1529  *---------------------------------------------------------------------------* 
00001E10                          1530  OP_RTS      
00001E10  163C 0052               1531              MOVE.B #'R',D3
00001E14  6100 21B8               1532              BSR     PUSH_STACK
00001E18  163C 0054               1533              MOVE.B #'T',D3
00001E1C  6100 21B0               1534              BSR     PUSH_STACK
00001E20  163C 0053               1535              MOVE.B #'S',D3
00001E24  6100 21A8               1536              BSR     PUSH_STACK
00001E28  4E75                    1537              RTS
00001E2A                          1538  
00001E2A                          1539  *---------------------------------------------------------------------------*
00001E2A                          1540  * OP0101: decode ADDQ
00001E2A                          1541  *---------------------------------------------------------------------------* 
00001E2A                          1542  OP0101      
00001E2A                          1543             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E2A  13FC 0082 00004958      1544             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E32  13FC 0080 00004959      1545             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E3A                          1546             
00001E3A                          1547             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E3A  13FC 00B9 0000495B      1548             MOVE.B   #$B9,GET_DST_START_END
00001E42  13FC 0020 0000495C      1549             MOVE.B   #$20,GET_SRC_START_END
00001E4A                          1550             
00001E4A                          1551              *CLEAR D3
00001E4A  4283                    1552              CLR.L   D3
00001E4C                          1553              *LOAD STACK WITH THIS OPMODE
00001E4C  6100 2180               1554              BSR     PUSH_STACK
00001E50  163C 0041               1555              MOVE.B  #'A',D3
00001E54  6100 2178               1556              BSR     PUSH_STACK
00001E58  163C 0044               1557              MOVE.B  #'D',D3
00001E5C  6100 2170               1558              BSR     PUSH_STACK
00001E60  163C 0044               1559              MOVE.B  #'D',D3
00001E64  6100 2168               1560              BSR     PUSH_STACK
00001E68  163C 0051               1561              MOVE.B  #'Q',D3
00001E6C  6100 2160               1562              BSR     PUSH_STACK
00001E70  163C 002E               1563              MOVE.B  #'.',D3
00001E74  6100 2158               1564              BSR     PUSH_STACK
00001E78                          1565              
00001E78                          1566              *FIGURE OUT SIZE*
00001E78                          1567              *00 = BYTE
00001E78                          1568              *01 = WORD
00001E78                          1569              *10 = LONG
00001E78                          1570              * BITS 7&6
00001E78                          1571              
00001E78                          1572              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E78  2205                    1573              MOVE.L  D5,D1
00001E7A  EC99                    1574              ROR.L   #6,D1
00001E7C  0281 00000003           1575              ANDI.L  #$03,D1
00001E82  0C01 0000               1576              CMPI.B  #%00,D1
00001E86  6700 001E               1577              BEQ     OP0101_ADDQ_B
00001E8A  0281 00000003           1578              ANDI.L  #$03,D1
00001E90  0C01 0001               1579              CMPI.B  #%01,D1
00001E94  6700 001C               1580              BEQ     OP0101_ADDQ_W
00001E98  0281 00000003           1581              ANDI.L  #$03,D1
00001E9E  0C01 0002               1582              CMPI.B  #%10,D1
00001EA2  6700 001A               1583              BEQ     OP0101_ADDQ_L
00001EA6                          1584            
00001EA6                          1585  OP0101_ADDQ_B
00001EA6                          1586              
00001EA6  163C 0042               1587              MOVE.B  #'B',D3
00001EAA  6100 2122               1588              BSR     PUSH_STACK
00001EAE  6000 0016               1589              BRA     OP0101_RETURN
00001EB2                          1590  OP0101_ADDQ_W
00001EB2                          1591              
00001EB2  163C 0057               1592              MOVE.B  #'W',D3
00001EB6  6100 2116               1593              BSR     PUSH_STACK
00001EBA  6000 000A               1594              BRA     OP0101_RETURN
00001EBE                          1595  OP0101_ADDQ_L
00001EBE                          1596              
00001EBE  163C 004C               1597              MOVE.B  #'L',D3
00001EC2  6100 210A               1598              BSR     PUSH_STACK
00001EC6                          1599  OP0101_RETURN            
00001EC6                          1600  
00001EC6                          1601              
00001EC6                          1602  *GET DATA FROM ADDQ AND PRINT #0-8
00001EC6  163C 0020               1603              MOVE.B  #' ',D3
00001ECA  6100 2102               1604              BSR     PUSH_STACK
00001ECE  163C 0023               1605              MOVE.B  #'#',D3
00001ED2  6100 20FA               1606              BSR     PUSH_STACK 
00001ED6                          1607  
00001ED6                          1608                       
00001ED6                          1609              *GET DATA #   
00001ED6  2205                    1610              MOVE.L  D5,D1
00001ED8  EC99                    1611              ROR.L   #6,D1            
00001EDA  E699                    1612              ROR.L   #3,D1
00001EDC  0281 00000007           1613              ANDI.L  #$07,D1
00001EE2                          1614              
00001EE2  0C01 0000               1615              CMPI.B  #%000,D1
00001EE6  6700 009A               1616              BEQ     OP0101_ADDQ_B_8
00001EEA  0C01 0001               1617              CMPI.B  #%001,D1
00001EEE  6700 003E               1618              BEQ     OP0101_ADDQ_B_1
00001EF2  0C01 0002               1619              CMPI.B  #%010,D1
00001EF6  6700 0042               1620              BEQ     OP0101_ADDQ_B_2
00001EFA  0C01 0003               1621              CMPI.B  #%011,D1
00001EFE  6700 0046               1622              BEQ     OP0101_ADDQ_B_3
00001F02  0C01 0004               1623              CMPI.B  #%100,D1
00001F06  6700 004A               1624              BEQ     OP0101_ADDQ_B_4
00001F0A  0C01 0005               1625              CMPI.B  #%101,D1
00001F0E  6700 004E               1626              BEQ     OP0101_ADDQ_B_5
00001F12  0C01 0006               1627              CMPI.B  #%110,D1
00001F16  6700 0052               1628              BEQ     OP0101_ADDQ_B_6
00001F1A  0C01 0007               1629              CMPI.B  #%111,D1
00001F1E  6700 0056               1630              BEQ     OP0101_ADDQ_B_7
00001F22                          1631              
00001F22                          1632  OP0101_ADDQ_B_0
00001F22  163C 0030               1633              MOVE.B  #'0',D3
00001F26  6100 20A6               1634              BSR     PUSH_STACK
00001F2A  6000 005E               1635              BRA     OP0101_RETURN2            
00001F2E                          1636  OP0101_ADDQ_B_1
00001F2E  163C 0031               1637              MOVE.B  #'1',D3
00001F32  6100 209A               1638              BSR     PUSH_STACK
00001F36  6000 0052               1639              BRA     OP0101_RETURN2            
00001F3A                          1640  OP0101_ADDQ_B_2
00001F3A  163C 0032               1641              MOVE.B  #'2',D3
00001F3E  6100 208E               1642              BSR     PUSH_STACK
00001F42  6000 0046               1643              BRA     OP0101_RETURN2            
00001F46                          1644  OP0101_ADDQ_B_3
00001F46  163C 0033               1645              MOVE.B  #'3',D3
00001F4A  6100 2082               1646              BSR     PUSH_STACK
00001F4E  6000 003A               1647              BRA     OP0101_RETURN2            
00001F52                          1648  OP0101_ADDQ_B_4
00001F52  163C 0034               1649              MOVE.B  #'4',D3
00001F56  6100 2076               1650              BSR     PUSH_STACK
00001F5A  6000 002E               1651              BRA     OP0101_RETURN2            
00001F5E                          1652  OP0101_ADDQ_B_5
00001F5E  163C 0035               1653              MOVE.B  #'5',D3
00001F62  6100 206A               1654              BSR     PUSH_STACK
00001F66  6000 0022               1655              BRA     OP0101_RETURN2
00001F6A                          1656  OP0101_ADDQ_B_6
00001F6A  163C 0036               1657              MOVE.B  #'6',D3
00001F6E  6100 205E               1658              BSR     PUSH_STACK
00001F72  6000 0016               1659              BRA     OP0101_RETURN2
00001F76                          1660  OP0101_ADDQ_B_7
00001F76  163C 0037               1661              MOVE.B  #'7',D3
00001F7A  6100 2052               1662              BSR     PUSH_STACK
00001F7E  6000 000A               1663              BRA     OP0101_RETURN2
00001F82                          1664  
00001F82                          1665  OP0101_ADDQ_B_8
00001F82  163C 0038               1666              MOVE.B  #'8',D3
00001F86  6100 2046               1667              BSR     PUSH_STACK
00001F8A                          1668              
00001F8A                          1669  OP0101_RETURN2            
00001F8A  163C 002C               1670              MOVE.B  #',',D3
00001F8E  6100 203E               1671              BSR     PUSH_STACK
00001F92  6100 179C               1672              BSR     GET_EA_EA_SRC
00001F96                          1673              
00001F96  4E75                    1674              RTS
00001F98                          1675  
00001F98                          1676  
00001F98                          1677              
00001F98                          1678  *---------------------------------------------------------------------------*
00001F98                          1679  * OP_ADDQ: display ADDQ
00001F98                          1680  *---------------------------------------------------------------------------*              
00001F98                          1681  OP_ADDQ_B    * size is byte   
00001F98  183C 0000               1682              MOVE.B  #0,D4 
00001F9C  43F9 0000472D           1683              LEA     DISP_ADDQ_B,A1
00001FA2  103C 000E               1684              MOVE.B  #14,D0
00001FA6  4E4F                    1685              TRAP    #15
00001FA8  4E75                    1686              RTS
00001FAA                          1687              
00001FAA                          1688  OP_ADDQ_W    * size is word
00001FAA  183C 0001               1689              MOVE.B  #1,D4
00001FAE  43F9 00004737           1690              LEA     DISP_ADDQ_W,A1
00001FB4  103C 000E               1691              MOVE.B  #14,D0
00001FB8  4E4F                    1692              TRAP    #15
00001FBA  4E75                    1693              RTS
00001FBC                          1694              
00001FBC                          1695  OP_ADDQ_L    * size is long
00001FBC  183C 0002               1696              MOVE.B  #2,D4
00001FC0  43F9 00004741           1697              LEA     DISP_ADDQ_L,A1
00001FC6  103C 000E               1698              MOVE.B  #14,D0
00001FCA  4E4F                    1699              TRAP    #15
00001FCC  4E75                    1700              RTS
00001FCE                          1701  
00001FCE                          1702  *---------------------------------------------------------------------------*
00001FCE                          1703  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FCE                          1704  *---------------------------------------------------------------------------*              
00001FCE  4280                    1705  OP0110      CLR.L   D0                  
00001FD0  4281                    1706              CLR.L   D1   
00001FD2  4284                    1707              CLR.L   D4                 
00001FD4  227C 00000000           1708              MOVEA.L #0,A1
00001FDA  2205                    1709              MOVE.L  D5, D1                
00001FDC  0281 000000FF           1710              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FE2  2205                    1711              MOVE.L  D5,D1                  
00001FE4  0281 00000F00           1712              ANDI.L  #$0F00,D1
00001FEA                          1713                 
00001FEA  0C41 0000               1714              CMPI.W  #$0000,D1               * Check for BRA
00001FEE  6700 0098               1715              BEQ     OP_BRA                  
00001FF2                          1716                          
00001FF2  0C41 0D00               1717              CMPI.W  #$0D00,D1               * Check for BLT
00001FF6  6700 00B6               1718              BEQ     OP_BLT      
00001FFA                          1719  
00001FFA  0C41 0700               1720              CMPI.W  #$0700,D1               * Check for BEQ
00001FFE  6700 0062               1721              BEQ     OP_BEQ      
00002002                          1722  
00002002  0C41 0600               1723              CMPI.W  #$0600,D1               * Check for BNE
00002006  6700 0034               1724              BEQ     OP_BNE  
0000200A                          1725              
0000200A  0C41 0200               1726              CMPI.W  #$0200,D1               * Check for BHI
0000200E  6700 0006               1727              BEQ     OP_BHI
00002012                          1728  
00002012  4EF8 1750               1729              JMP     OP_DATA
00002016                          1730              
00002016  163C 0042               1731  OP_BHI      MOVE.B  #'B',D3
0000201A  6100 1FB2               1732              BSR     PUSH_STACK
0000201E  163C 0048               1733              MOVE.B  #'H',D3
00002022  6100 1FAA               1734              BSR     PUSH_STACK
00002026  163C 0049               1735              MOVE.B  #'I',D3
0000202A  6100 1FA2               1736              BSR     PUSH_STACK
0000202E  163C 0009               1737              MOVE.B  #$9,D3
00002032  6100 1F9A               1738              BSR     PUSH_STACK
00002036  6100 2014               1739              BSR     GET_DISPLACEMENT_ADDRESS
0000203A  4E75                    1740              RTS
0000203C                          1741  
0000203C  163C 0042               1742  OP_BNE      MOVE.B  #'B',D3
00002040  6100 1F8C               1743              BSR     PUSH_STACK
00002044  163C 004E               1744              MOVE.B  #'N',D3
00002048  6100 1F84               1745              BSR     PUSH_STACK
0000204C  163C 0045               1746              MOVE.B  #'E',D3
00002050  6100 1F7C               1747              BSR     PUSH_STACK
00002054  163C 0009               1748              MOVE.B  #$9,D3
00002058  6100 1F74               1749              BSR     PUSH_STACK
0000205C  6100 1FEE               1750              BSR     GET_DISPLACEMENT_ADDRESS
00002060  4E75                    1751              RTS
00002062                          1752  
00002062  163C 0042               1753  OP_BEQ      MOVE.B  #'B',D3
00002066  6100 1F66               1754              BSR     PUSH_STACK
0000206A  163C 0045               1755              MOVE.B  #'E',D3
0000206E  6100 1F5E               1756              BSR     PUSH_STACK
00002072  163C 0051               1757              MOVE.B  #'Q',D3
00002076  6100 1F56               1758              BSR     PUSH_STACK
0000207A  163C 0009               1759              MOVE.B  #$9,D3
0000207E  6100 1F4E               1760              BSR     PUSH_STACK
00002082  6100 1FC8               1761              BSR     GET_DISPLACEMENT_ADDRESS
00002086  4E75                    1762              RTS          
00002088                          1763                          
00002088                          1764  OP_BRA      
00002088  163C 0042               1765              MOVE.B  #'B',D3
0000208C  6100 1F40               1766              BSR     PUSH_STACK
00002090  163C 0052               1767              MOVE.B  #'R',D3
00002094  6100 1F38               1768              BSR     PUSH_STACK
00002098  163C 0041               1769              MOVE.B  #'A',D3
0000209C  6100 1F30               1770              BSR     PUSH_STACK
000020A0  163C 0009               1771              MOVE.B  #$9,D3
000020A4  6100 1F28               1772              BSR     PUSH_STACK
000020A8  6100 1FA2               1773              BSR     GET_DISPLACEMENT_ADDRESS
000020AC                          1774              
000020AC  4E75                    1775              RTS
000020AE                          1776              
000020AE  163C 0042               1777  OP_BLT      MOVE.B  #'B',D3
000020B2  6100 1F1A               1778              BSR     PUSH_STACK
000020B6  163C 004C               1779              MOVE.B  #'L',D3
000020BA  6100 1F12               1780              BSR     PUSH_STACK
000020BE  163C 0054               1781              MOVE.B  #'T',D3
000020C2  6100 1F0A               1782              BSR     PUSH_STACK
000020C6  163C 0009               1783              MOVE.B  #$9,D3
000020CA  6100 1F02               1784              BSR     PUSH_STACK
000020CE  6100 1F7C               1785              BSR     GET_DISPLACEMENT_ADDRESS
000020D2  4E75                    1786              RTS
000020D4                          1787     
000020D4                          1788  *---------------------------------------------------------------------------*
000020D4                          1789  * OP0111 : MOVEQ not required
000020D4                          1790  *---------------------------------------------------------------------------*           
000020D4  4EF8 1750               1791  OP0111      JMP     OP_DATA
000020D8                          1792             
000020D8                          1793  *---------------------------------------------------------------------------*
000020D8                          1794  * OP1000 : decode DIVS
000020D8                          1795  *---------------------------------------------------------------------------*           
000020D8                          1796  OP1000                           
000020D8  4281                    1797              CLR.L   D1       
000020DA  4284                    1798              CLR.L   D4                   
000020DC  227C 00000000           1799              MOVEA.L #0, A1              
000020E2  2205                    1800              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020E4                          1801              *CLEAR D3
000020E4  4283                    1802              CLR.L   D3
000020E6                          1803  
000020E6                          1804  OP1000_DIVS_DN_EA_OR_EA_DN 
000020E6                          1805              *LOAD STACK WITH THIS OPMODE
000020E6  6100 1EE6               1806              BSR     PUSH_STACK
000020EA  163C 0044               1807              MOVE.B  #'D',D3
000020EE  6100 1EDE               1808              BSR     PUSH_STACK
000020F2  163C 0049               1809              MOVE.B  #'I',D3
000020F6  6100 1ED6               1810              BSR     PUSH_STACK
000020FA  163C 0056               1811              MOVE.B  #'V',D3
000020FE  6100 1ECE               1812              BSR     PUSH_STACK
00002102  163C 0053               1813              MOVE.B  #'S',D3
00002106  6100 1EC6               1814              BSR     PUSH_STACK
0000210A  163C 002E               1815              MOVE.B  #'.',D3
0000210E  6100 1EBE               1816              BSR     PUSH_STACK
00002112                          1817              
00002112  2205                    1818              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002114                          1819              
00002114                          1820  OP1000_EA_DN_DIVS
00002114                          1821              *BITS (7 TO 6) 
00002114                          1822              *00 = .B
00002114                          1823              *01 = .W
00002114                          1824              *10 = .L 
00002114  2205                    1825              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002116  EC99                    1826              ROR.L   #6,D1
00002118  0281 00000003           1827              ANDI.L  #$03,D1
0000211E  0C81 00000003           1828              CMPI.L  #%11,D1 *EQUALS .W
00002124  6700 0014               1829              BEQ     OP1000_PRINT_W_DIVS
00002128  0C81 00000000           1830              CMPI.L  #%00,D1 *EQUALS .L
0000212E  6700 0052               1831              BEQ     OP1000_PRINT_L_DIVS
00002132                          1832              
00002132  183C 0001               1833              MOVE.B  #1,D4               *ERROR READ
00002136  6000 0092               1834              BRA     OP1000_DIVS_RETURN
0000213A                          1835  OP1000_PRINT_W_DIVS
0000213A  163C 0057               1836              MOVE.B  #'W',D3
0000213E  6100 1E8E               1837              BSR     PUSH_STACK
00002142                          1838  
00002142                          1839              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002142  13FC 0000 00004958      1840              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000214A  13FC 0000 00004959      1841              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002152                          1842             
00002152                          1843              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002152  13FC 00B9 0000495B      1844              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000215A  13FC 0020 0000495C      1845              MOVE.B   #$20,GET_SRC_START_END
00002162                          1846  
00002162                          1847             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002162  0285 0000FE3F           1848              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002168  0685 00000000           1849              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000216E                          1850  
0000216E                          1851              
0000216E  6100 15C0               1852              BSR     GET_EA_EA_SRC      *GETS <ea>
00002172  163C 002C               1853              MOVE.B  #',',D3
00002176  6100 1E56               1854              BSR     PUSH_STACK
0000217A  6100 19E4               1855              BSR     GET_EA_EA_DEST       *GETS Dn    
0000217E                          1856              
0000217E  6000 004A               1857              BRA     OP1000_DIVS_RETURN
00002182                          1858  OP1000_PRINT_L_DIVS
00002182  163C 004C               1859              MOVE.B  #'L',D3
00002186  6100 1E46               1860              BSR     PUSH_STACK
0000218A                          1861              
0000218A                          1862              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000218A  13FC 0000 00004958      1863              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002192  13FC 0000 00004959      1864              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000219A                          1865             
0000219A                          1866              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000219A  13FC 00B9 0000495B      1867              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021A2  13FC 0020 0000495C      1868              MOVE.B   #$20,GET_SRC_START_END
000021AA                          1869  
000021AA                          1870              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021AA  0285 0000FE3F           1871              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021B0  0685 00000000           1872              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021B6                          1873  
000021B6                          1874                     
000021B6  6100 1578               1875              BSR     GET_EA_EA_SRC      *GETS <ea>
000021BA  163C 002C               1876              MOVE.B  #',',D3
000021BE  6100 1E0E               1877              BSR     PUSH_STACK                  
000021C2  6100 199C               1878              BSR     GET_EA_EA_DEST       *GETS Dn    
000021C6                          1879  
000021C6                          1880              
000021C6  6000 0002               1881              BRA     OP1000_DIVS_RETURN
000021CA                          1882              
000021CA                          1883  OP1000_DIVS_RETURN
000021CA  4E75                    1884              RTS
000021CC                          1885              
000021CC                          1886  
000021CC                          1887  
000021CC                          1888  *---------------------------------------------------------------------------*
000021CC                          1889  * OP_DIVS: display DIVS and proceed to EA
000021CC                          1890  *---------------------------------------------------------------------------*  
000021CC  43F9 0000474B           1891  OP_DIVS     LEA     DISP_DIVS,A1
000021D2  103C 000E               1892              MOVE.B  #14,D0
000021D6  4E4F                    1893              TRAP    #15
000021D8  4EF9 00003294           1894              JMP     EA_ARITH
000021DE                          1895  
000021DE  4E75                    1896              RTS
000021E0                          1897              
000021E0                          1898  *---------------------------------------------------------------------------*
000021E0                          1899  * OP1001: decode SUB/SUBA
000021E0                          1900  *---------------------------------------------------------------------------*      
000021E0                          1901  OP1001      
000021E0  4280                    1902              CLR.L   D0                  
000021E2  4281                    1903              CLR.L   D1       
000021E4  4284                    1904              CLR.L   D4                   
000021E6  227C 00000000           1905              MOVEA.L #0, A1              
000021EC  2205                    1906              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000021EE                          1907              
000021EE                          1908              *CLEAR D3
000021EE  4283                    1909              CLR.L   D3
000021F0                          1910              
000021F0                          1911              
000021F0                          1912              
000021F0                          1913              **INTEGRATING SUB.W/.L INTO THIS CODE**
000021F0  2205                    1914              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021F2                          1915              *BITS (INDEX 8) 
000021F2                          1916              *0 = ADD.B/W/L <EA>,Dn
000021F2                          1917              *1 = ADD.B/W/L Dn,<EA> 
000021F2  EC99                    1918              ROR.L   #6,D1
000021F4  0281 00000007           1919              ANDI.L  #$07,D1                 *MASKS WITH 00000111
000021FA  0C81 00000007           1920              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002200  6700 0010               1921              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00002204  0C81 00000003           1922              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
0000220A  6700 0078               1923              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
0000220E  6000 00E6               1924              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002212                          1925              
00002212                          1926  OP1001_SUBA_L
00002212                          1927              *LOAD STACK WITH THIS OPMODE
00002212  6100 1DBA               1928              BSR     PUSH_STACK
00002216  163C 0053               1929              MOVE.B  #'S',D3
0000221A  6100 1DB2               1930              BSR     PUSH_STACK
0000221E  163C 0055               1931              MOVE.B  #'U',D3
00002222  6100 1DAA               1932              BSR     PUSH_STACK
00002226  163C 0042               1933              MOVE.B  #'B',D3
0000222A  6100 1DA2               1934              BSR     PUSH_STACK
0000222E  163C 0041               1935              MOVE.B  #'A',D3
00002232  6100 1D9A               1936              BSR     PUSH_STACK
00002236  163C 002E               1937              MOVE.B  #'.',D3
0000223A  6100 1D92               1938              BSR     PUSH_STACK
0000223E  163C 004C               1939              MOVE.B  #'L',D3
00002242  6100 1D8A               1940              BSR     PUSH_STACK
00002246                          1941              
00002246                          1942             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002246  13FC 0000 00004958      1943             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000224E  13FC 0000 00004959      1944             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002256                          1945             
00002256                          1946             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002256  13FC 00B9 0000495B      1947             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000225E  13FC 0020 0000495C      1948             MOVE.B   #$20,GET_SRC_START_END
00002266                          1949  
00002266                          1950              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002266  0285 0000FE3F           1951              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000226C  0685 00000040           1952              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002272                          1953       
00002272                          1954              *PRINT <EA>,AN
00002272  6100 14BC               1955              BSR     GET_EA_EA_SRC       *GETS <ea>
00002276  163C 002C               1956              MOVE.B  #',',D3
0000227A  6100 1D52               1957              BSR     PUSH_STACK                     
0000227E  6100 18E0               1958              BSR     GET_EA_EA_DEST      *GETS Dn
00002282                          1959  
00002282                          1960              
00002282                          1961              
00002282  4E75                    1962              RTS
00002284                          1963  OP1001_SUBA_W
00002284                          1964              *LOAD STACK WITH THIS OPMODE
00002284  6100 1D48               1965              BSR     PUSH_STACK
00002288  163C 0053               1966              MOVE.B  #'S',D3
0000228C  6100 1D40               1967              BSR     PUSH_STACK
00002290  163C 0055               1968              MOVE.B  #'U',D3
00002294  6100 1D38               1969              BSR     PUSH_STACK
00002298  163C 0042               1970              MOVE.B  #'B',D3
0000229C  6100 1D30               1971              BSR     PUSH_STACK
000022A0  163C 0041               1972              MOVE.B  #'A',D3
000022A4  6100 1D28               1973              BSR     PUSH_STACK
000022A8  163C 002E               1974              MOVE.B  #'.',D3
000022AC  6100 1D20               1975              BSR     PUSH_STACK
000022B0  163C 0057               1976              MOVE.B  #'W',D3
000022B4  6100 1D18               1977              BSR     PUSH_STACK
000022B8                          1978              
000022B8                          1979             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022B8  13FC 0000 00004958      1980             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022C0  13FC 0000 00004959      1981             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022C8                          1982             
000022C8                          1983             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022C8  13FC 00B9 0000495B      1984             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022D0  13FC 0020 0000495C      1985             MOVE.B   #$20,GET_SRC_START_END
000022D8                          1986  
000022D8                          1987              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022D8  0285 0000FE3F           1988              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022DE  0685 00000040           1989              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022E4                          1990       
000022E4                          1991              *PRINT <EA>,AN
000022E4  6100 144A               1992              BSR     GET_EA_EA_SRC       *GETS <ea>
000022E8  163C 002C               1993              MOVE.B  #',',D3
000022EC  6100 1CE0               1994              BSR     PUSH_STACK                     
000022F0  6100 186E               1995              BSR     GET_EA_EA_DEST      *GETS Dn
000022F4                          1996  
000022F4  4E75                    1997              RTS
000022F6                          1998  
000022F6                          1999  OP1001_DETERMINE_DN_EA_OR_EA_DN 
000022F6                          2000              *LOAD STACK WITH THIS OPMODE
000022F6  6100 1CD6               2001              BSR     PUSH_STACK
000022FA  163C 0053               2002              MOVE.B  #'S',D3
000022FE  6100 1CCE               2003              BSR     PUSH_STACK
00002302  163C 0055               2004              MOVE.B  #'U',D3
00002306  6100 1CC6               2005              BSR     PUSH_STACK
0000230A  163C 0042               2006              MOVE.B  #'B',D3
0000230E  6100 1CBE               2007              BSR     PUSH_STACK
00002312  163C 002E               2008              MOVE.B  #'.',D3
00002316  6100 1CB6               2009              BSR     PUSH_STACK
0000231A                          2010              
0000231A  2205                    2011              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000231C                          2012              
0000231C                          2013              *BITS (INDEX 8) 
0000231C                          2014              *0 = ADD.B/W/L <EA>,Dn
0000231C                          2015              *1 = ADD.B/W/L Dn,<EA> 
0000231C  E099                    2016              ROR.L   #8,D1
0000231E  0281 00000001           2017              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002324  0C81 00000000           2018              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000232A  6700 0102               2019              BEQ     OP1001_EA_DN
0000232E                          2020              *else procede to Dn_EA
0000232E                          2021              
0000232E                          2022  OP1001_DN_EA
0000232E                          2023              *BITS (7 TO 6) 
0000232E                          2024              *00 = .B
0000232E                          2025              *01 = .W
0000232E                          2026              *10 = .L 
0000232E  2205                    2027              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002330  EC99                    2028              ROR.L   #6,D1
00002332  0281 00000003           2029              ANDI.L  #$03,D1
00002338  0C81 00000000           2030              CMPI.L  #$00,D1 *EQUALS .B
0000233E  6700 0016               2031              BEQ     OP1001_PRINT_B2
00002342  0C81 00000001           2032              CMPI.L  #$01,D1 *EQUALS .W
00002348  6700 0054               2033              BEQ     OP1001_PRINT_W2
0000234C  0C81 00000002           2034              CMPI.L  #$02,D1 *EQUALS .L
00002352  6700 0092               2035              BEQ     OP1001_PRINT_L2
00002356                          2036  OP1001_PRINT_B2
00002356                          2037              *PUSH 'B'
00002356  163C 0042               2038              MOVE.B  #'B',D3
0000235A  6100 1C72               2039              BSR     PUSH_STACK
0000235E                          2040             
0000235E                          2041              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000235E  13FC 0000 00004958      2042             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002366  13FC 0083 00004959      2043             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000236E                          2044             
0000236E                          2045             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000236E  13FC 00B9 0000495B      2046             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002376  13FC 0020 0000495C      2047             MOVE.B   #$20,GET_SRC_START_END
0000237E                          2048  
0000237E                          2049              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000237E  0285 0000FE3F           2050              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002384  0685 00000040           2051              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000238A                          2052       
0000238A  6100 17D4               2053              BSR     GET_EA_EA_DEST      *GETS Dn
0000238E  163C 002C               2054              MOVE.B  #',',D3
00002392  6100 1C3A               2055              BSR     PUSH_STACK                     
00002396  6100 1398               2056              BSR     GET_EA_EA_SRC       *GETS <ea>
0000239A                          2057  
0000239A                          2058              
0000239A  6000 0BA4               2059              BRA     OP1101_ADD_RETURN
0000239E                          2060  OP1001_PRINT_W2
0000239E  163C 0057               2061              MOVE.B  #'W',D3
000023A2  6100 1C2A               2062              BSR     PUSH_STACK
000023A6                          2063  
000023A6                          2064              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023A6  13FC 0000 00004958      2065              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023AE  13FC 0083 00004959      2066              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023B6                          2067             
000023B6                          2068              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023B6  13FC 00B9 0000495B      2069              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023BE  13FC 0020 0000495C      2070              MOVE.B   #$20,GET_SRC_START_END
000023C6                          2071  
000023C6                          2072              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023C6  0285 0000FE3F           2073              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023CC  0685 00000040           2074              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000023D2                          2075  
000023D2                          2076        
000023D2  6100 178C               2077              BSR     GET_EA_EA_DEST      *GETS Dn
000023D6  163C 002C               2078              MOVE.B  #',',D3
000023DA  6100 1BF2               2079              BSR     PUSH_STACK               
000023DE  6100 1350               2080              BSR     GET_EA_EA_SRC       *GETS <ea>       
000023E2                          2081  
000023E2                          2082  
000023E2                          2083  
000023E2  6000 0B5C               2084              BRA     OP1101_ADD_RETURN
000023E6                          2085  OP1001_PRINT_L2 
000023E6  163C 004C               2086              MOVE.B  #'L',D3
000023EA  6100 1BE2               2087              BSR     PUSH_STACK
000023EE                          2088              
000023EE                          2089              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023EE  13FC 0000 00004958      2090              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023F6  13FC 0083 00004959      2091              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023FE                          2092             
000023FE                          2093              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023FE  13FC 00B9 0000495B      2094              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002406  13FC 0020 0000495C      2095              MOVE.B   #$20,GET_SRC_START_END
0000240E                          2096  
0000240E                          2097             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000240E  0285 0000FE3F           2098              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002414  0685 00000040           2099              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000241A                          2100  
0000241A                          2101               
0000241A  6100 1744               2102              BSR     GET_EA_EA_DEST       *GETS Dn
0000241E  163C 002C               2103              MOVE.B  #',',D3
00002422  6100 1BAA               2104              BSR     PUSH_STACK          
00002426  6100 1308               2105              BSR     GET_EA_EA_SRC        *GETS <ea>
0000242A                          2106  
0000242A  6000 0B14               2107              BRA     OP1101_ADD_RETURN
0000242E                          2108              
0000242E                          2109  OP1001_EA_DN           
0000242E                          2110              *BITS (7 TO 6) 
0000242E                          2111              *00 = .B
0000242E                          2112              *01 = .W
0000242E                          2113              *10 = .L 
0000242E  2205                    2114              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002430  EC99                    2115              ROR.L   #6,D1
00002432  0281 00000003           2116              ANDI.L  #$03,D1
00002438  0C81 00000000           2117              CMPI.L  #$00,D1 *EQUALS .B
0000243E  6700 0016               2118              BEQ     OP1001_PRINT_B
00002442  0C81 00000001           2119              CMPI.L  #$01,D1 *EQUALS .W
00002448  6700 0054               2120              BEQ     OP1001_PRINT_W
0000244C  0C81 00000002           2121              CMPI.L  #$02,D1 *EQUALS .L
00002452  6700 0092               2122              BEQ     OP1001_PRINT_L
00002456                          2123  OP1001_PRINT_B
00002456  163C 0042               2124              MOVE.B  #'B',D3
0000245A  6100 1B72               2125              BSR     PUSH_STACK
0000245E                          2126                
0000245E                          2127              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000245E  13FC 0000 00004958      2128              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002466  13FC 0002 00004959      2129              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000246E                          2130             
0000246E                          2131              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000246E  13FC 00B9 0000495B      2132              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002476  13FC 0020 0000495C      2133              MOVE.B   #$20,GET_SRC_START_END
0000247E                          2134  
0000247E                          2135             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000247E  0285 0000FE3F           2136              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002484  0685 00000040           2137              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
0000248A                          2138  
0000248A                          2139              
0000248A  6100 12A4               2140              BSR     GET_EA_EA_SRC      *GETS <ea>
0000248E  163C 002C               2141              MOVE.B  #',',D3
00002492  6100 1B3A               2142              BSR     PUSH_STACK          
00002496  6100 16C8               2143              BSR     GET_EA_EA_DEST       *GETS Dn
0000249A                          2144              
0000249A  6000 0AA4               2145              BRA     OP1101_ADD_RETURN
0000249E                          2146  OP1001_PRINT_W
0000249E  163C 0057               2147              MOVE.B  #'W',D3
000024A2  6100 1B2A               2148              BSR     PUSH_STACK
000024A6                          2149  
000024A6                          2150              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024A6  13FC 0000 00004958      2151              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024AE  13FC 0000 00004959      2152              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024B6                          2153             
000024B6                          2154              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024B6  13FC 00B9 0000495B      2155              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024BE  13FC 0020 0000495C      2156              MOVE.B   #$20,GET_SRC_START_END
000024C6                          2157  
000024C6                          2158             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024C6  0285 0000FE3F           2159              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024CC  0685 00000040           2160              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024D2                          2161  
000024D2                          2162              
000024D2  6100 125C               2163              BSR     GET_EA_EA_SRC      *GETS <ea>
000024D6  163C 002C               2164              MOVE.B  #',',D3
000024DA  6100 1AF2               2165              BSR     PUSH_STACK
000024DE  6100 1680               2166              BSR     GET_EA_EA_DEST       *GETS Dn    
000024E2                          2167              
000024E2  6000 004A               2168              BRA     OP1001_ADD_RETURN
000024E6                          2169  OP1001_PRINT_L 
000024E6  163C 004C               2170              MOVE.B  #'L',D3
000024EA  6100 1AE2               2171              BSR     PUSH_STACK
000024EE                          2172              
000024EE                          2173              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024EE  13FC 0000 00004958      2174              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024F6  13FC 0000 00004959      2175              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024FE                          2176             
000024FE                          2177              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024FE  13FC 00B9 0000495B      2178              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002506  13FC 0020 0000495C      2179              MOVE.B   #$20,GET_SRC_START_END
0000250E                          2180  
0000250E                          2181              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000250E  0285 0000FE3F           2182              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002514  0685 00000040           2183              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000251A                          2184  
0000251A                          2185                     
0000251A  6100 1214               2186              BSR     GET_EA_EA_SRC      *GETS <ea>
0000251E  163C 002C               2187              MOVE.B  #',',D3
00002522  6100 1AAA               2188              BSR     PUSH_STACK                  
00002526  6100 1638               2189              BSR     GET_EA_EA_DEST       *GETS Dn    
0000252A                          2190  
0000252A                          2191              
0000252A  6000 0002               2192              BRA     OP1001_ADD_RETURN
0000252E                          2193              
0000252E                          2194  OP1001_ADD_RETURN
0000252E  4E75                    2195              RTS
00002530                          2196  
00002530                          2197    
00002530                          2198  *---------------------------------------------------------------------------*
00002530                          2199  * OP_SUB: display SUB and proceed to EA
00002530                          2200  *---------------------------------------------------------------------------*            
00002530  43F9 00004753           2201  OP_SUB_B    LEA     DISP_SUB_B,A1
00002536  103C 000E               2202              MOVE.B  #14,D0
0000253A  4E4F                    2203              TRAP    #15
0000253C  183C 0000               2204              MOVE.B  #0,D4
00002540  4EF9 000032E0           2205              JMP     EA_GEN
00002546                          2206  
00002546  4E75                    2207              RTS
00002548                          2208  
00002548  43F9 0000475C           2209  OP_SUB_W    LEA     DISP_SUB_W,A1
0000254E  103C 000E               2210              MOVE.B  #14,D0
00002552  4E4F                    2211              TRAP    #15
00002554  183C 0001               2212              MOVE.B  #1,D4
00002558  4EF9 000032E0           2213              JMP     EA_GEN
0000255E                          2214  
0000255E  4E75                    2215              RTS
00002560                          2216  
00002560  43F9 00004765           2217  OP_SUB_L    LEA     DISP_SUB_L,A1
00002566  103C 000E               2218              MOVE.B  #14,D0
0000256A  4E4F                    2219              TRAP    #15
0000256C  183C 0002               2220              MOVE.B  #2,D4
00002570  4EF9 000032E0           2221              JMP     EA_GEN
00002576                          2222  
00002576  4E75                    2223              RTS
00002578                          2224  
00002578                          2225  *---------------------------------------------------------------------------*
00002578                          2226  * OP_SUBA: display SUBA
00002578                          2227  *---------------------------------------------------------------------------*  
00002578  43F9 0000478C           2228  OP_SUBA_W   LEA     DISP_SUBA_W,A1
0000257E  103C 000E               2229              MOVE.B  #14,D0
00002582  4E4F                    2230              TRAP    #15
00002584  183C 0001               2231              MOVE.B  #1,D4
00002588  4E75                    2232              RTS
0000258A                          2233  
0000258A  43F9 00004796           2234  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00002590  103C 000E               2235              MOVE.B  #14,D0
00002594  4E4F                    2236              TRAP    #15
00002596  183C 0002               2237              MOVE.B  #2,D4
0000259A  4E75                    2238              RTS         
0000259C                          2239  *---------------------------------------------------------------------------*
0000259C                          2240  * OP1010 : unassigned
0000259C                          2241  *---------------------------------------------------------------------------*           
0000259C  4EF8 1750               2242  OP1010      JMP     OP_DATA
000025A0                          2243              
000025A0                          2244  *---------------------------------------------------------------------------*
000025A0                          2245  * OP1011 : decode CMP/EOR/CMPA
000025A0                          2246  *---------------------------------------------------------------------------*           
000025A0  4280                    2247  OP1011      CLR.L   D0                
000025A2  4281                    2248              CLR.L   D1            
000025A4  4284                    2249              CLR.L   D4                   
000025A6  227C 00000000           2250              MOVEA.L #0, A1               
000025AC  2205                    2251              MOVE.L  D5,D1
000025AE  EA99                    2252              ROR.L   #5,D1
000025B0  0281 0000000E           2253              ANDI.L  #$E,D1
000025B6  0C01 0000               2254              CMPI.B  #$0,D1
000025BA  6700 003E               2255              BEQ     OP1011_CMP
000025BE  0C01 0002               2256              CMPI.B  #$2,D1
000025C2  6700 0036               2257              BEQ     OP1011_CMP
000025C6  0C01 0004               2258              CMPI.B  #$4,D1
000025CA  6700 002E               2259              BEQ     OP1011_CMP
000025CE  0C01 0008               2260              CMPI.B  #$8,D1
000025D2  6700 0178               2261              BEQ     OP1011_EOR
000025D6  0C01 000A               2262              CMPI.B  #$A,D1
000025DA  6700 0170               2263              BEQ     OP1011_EOR
000025DE  0C01 000C               2264              CMPI.B  #$C,D1
000025E2  6700 0168               2265              BEQ     OP1011_EOR  
000025E6  0C01 0006               2266              CMPI.B  #$6,D1
000025EA  6700 00C0               2267              BEQ     OP1011_CMPA
000025EE  0C01 000E               2268              CMPI.B  #$E,D1
000025F2  6700 00B8               2269              BEQ     OP1011_CMPA 
000025F6                          2270  
000025F6  4EF8 1750               2271              JMP     OP_DATA          
000025FA                          2272  
000025FA                          2273  
000025FA                          2274  
000025FA                          2275  
000025FA                          2276  OP1011_CMP
000025FA                          2277             
000025FA                          2278   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025FA  13FC 0082 00004958      2279             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002602  13FC 0000 00004959      2280             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000260A                          2281             
0000260A                          2282             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000260A  13FC 00B9 0000495B      2283             MOVE.B   #$B9,GET_DST_START_END
00002612  13FC 0020 0000495C      2284             MOVE.B   #$20,GET_SRC_START_END
0000261A                          2285             
0000261A                          2286              *CLEAR D3
0000261A  4283                    2287              CLR.L   D3
0000261C                          2288              *LOAD STACK WITH THIS OPMODE
0000261C  6100 19B0               2289              BSR     PUSH_STACK
00002620  163C 0043               2290              MOVE.B  #'C',D3
00002624  6100 19A8               2291              BSR     PUSH_STACK
00002628  163C 004D               2292              MOVE.B  #'M',D3
0000262C  6100 19A0               2293              BSR     PUSH_STACK
00002630  163C 0050               2294              MOVE.B  #'P',D3
00002634  6100 1998               2295              BSR     PUSH_STACK
00002638  163C 002E               2296              MOVE.B  #'.',D3
0000263C  6100 1990               2297              BSR     PUSH_STACK
00002640                          2298              
00002640                          2299              *FIGURE OUT SIZE*
00002640                          2300              *00 = BYTE
00002640                          2301              *01 = WORD
00002640                          2302              *10 = LONG
00002640                          2303              * BITS 7&6
00002640                          2304              
00002640                          2305              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002640  2205                    2306              MOVE.L  D5,D1
00002642  EC99                    2307              ROR.L   #6,D1
00002644  0281 00000003           2308              ANDI.L  #$03,D1
0000264A  0C01 0000               2309              CMPI.B  #%00,D1
0000264E  6700 001E               2310              BEQ     OP1011_CMP_B
00002652  0281 00000003           2311              ANDI.L  #$03,D1
00002658  0C01 0001               2312              CMPI.B  #%01,D1
0000265C  6700 001C               2313              BEQ     OP1011_CMP_W
00002660  0281 00000003           2314              ANDI.L  #$03,D1
00002666  0C01 0002               2315              CMPI.B  #%10,D1
0000266A  6700 001A               2316              BEQ     OP1011_CMP_L
0000266E                          2317            
0000266E                          2318  OP1011_CMP_B
0000266E                          2319              
0000266E  163C 0042               2320              MOVE.B  #'B',D3
00002672  6100 195A               2321              BSR     PUSH_STACK
00002676  6000 0016               2322              BRA     OP1011_RETURN_CMP  
0000267A                          2323  OP1011_CMP_W
0000267A                          2324              
0000267A  163C 0057               2325              MOVE.B  #'W',D3
0000267E  6100 194E               2326              BSR     PUSH_STACK
00002682  6000 000A               2327              BRA     OP1011_RETURN_CMP  
00002686                          2328  OP1011_CMP_L
00002686                          2329              
00002686  163C 004C               2330              MOVE.B  #'L',D3
0000268A  6100 1942               2331              BSR     PUSH_STACK
0000268E                          2332  OP1011_RETURN_CMP            
0000268E                          2333  
0000268E                          2334              
0000268E                          2335  *GET DATA FROM ADDQ AND PRINT #0-8
0000268E                          2336       
0000268E                          2337              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000268E  0285 0000FE3F           2338              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002694  0685 00000000           2339              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000269A                          2340  
0000269A  6100 1094               2341              BSR     GET_EA_EA_SRC
0000269E  163C 002C               2342              MOVE.B  #',',D3
000026A2  6100 192A               2343              BSR     PUSH_STACK
000026A6  6100 14B8               2344              BSR     GET_EA_EA_DEST
000026AA                          2345              
000026AA  4E75                    2346              RTS
000026AC                          2347              
000026AC                          2348  
000026AC                          2349  
000026AC                          2350  OP1011_CMPA
000026AC                          2351              
000026AC                          2352   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026AC  13FC 0080 00004958      2353             MOVE.B   #$80,DEST_REGISTER_FORMAT
000026B4  13FC 0000 00004959      2354             MOVE.B   #$00,SRC_REGISTER_FORMAT
000026BC                          2355             
000026BC                          2356             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026BC  13FC 00B9 0000495B      2357             MOVE.B   #$B9,GET_DST_START_END
000026C4  13FC 0020 0000495C      2358             MOVE.B   #$20,GET_SRC_START_END
000026CC                          2359             
000026CC                          2360              *CLEAR D3
000026CC  4283                    2361              CLR.L   D3
000026CE                          2362              *LOAD STACK WITH THIS OPMODE
000026CE  6100 18FE               2363              BSR     PUSH_STACK
000026D2  163C 0043               2364              MOVE.B  #'C',D3
000026D6  6100 18F6               2365              BSR     PUSH_STACK
000026DA  163C 004D               2366              MOVE.B  #'M',D3
000026DE  6100 18EE               2367              BSR     PUSH_STACK
000026E2  163C 0050               2368              MOVE.B  #'P',D3
000026E6  6100 18E6               2369              BSR     PUSH_STACK
000026EA  163C 0041               2370              MOVE.B  #'A',D3
000026EE  6100 18DE               2371              BSR     PUSH_STACK
000026F2  163C 002E               2372              MOVE.B  #'.',D3
000026F6  6100 18D6               2373              BSR     PUSH_STACK
000026FA                          2374              
000026FA                          2375              *FIGURE OUT SIZE*
000026FA                          2376              *00 = BYTE
000026FA                          2377              *01 = WORD
000026FA                          2378              *10 = LONG
000026FA                          2379              * BITS 7&6
000026FA                          2380              
000026FA                          2381              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000026FA  2205                    2382              MOVE.L  D5,D1
000026FC  EC99                    2383              ROR.L   #6,D1
000026FE  0281 00000003           2384              ANDI.L  #$03,D1
00002704  0C01 0001               2385              CMPI.B  #%01,D1
00002708  6700 0010               2386              BEQ     OP1011_CMPA_W
0000270C  0281 00000003           2387              ANDI.L  #$03,D1
00002712  0C01 0002               2388              CMPI.B  #%10,D1
00002716  6700 000E               2389              BEQ     OP1011_CMPA_L
0000271A                          2390  OP1011_CMPA_W
0000271A                          2391              
0000271A  163C 0057               2392              MOVE.B  #'W',D3
0000271E  6100 18AE               2393              BSR     PUSH_STACK
00002722  6000 000A               2394              BRA     OP1011_RETURN_CMPA 
00002726                          2395  OP1011_CMPA_L
00002726                          2396              
00002726  163C 004C               2397              MOVE.B  #'L',D3
0000272A  6100 18A2               2398              BSR     PUSH_STACK
0000272E                          2399  OP1011_RETURN_CMPA            
0000272E                          2400  
0000272E                          2401              
0000272E                          2402  *GET DATA FROM ADDQ AND PRINT #0-8
0000272E                          2403       
0000272E                          2404              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000272E  0285 0000FE3F           2405              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002734  0685 00000040           2406              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000273A                          2407  
0000273A  6100 0FF4               2408              BSR     GET_EA_EA_SRC
0000273E  163C 002C               2409              MOVE.B  #',',D3
00002742  6100 188A               2410              BSR     PUSH_STACK
00002746  6100 1418               2411              BSR     GET_EA_EA_DEST
0000274A                          2412              
0000274A  4E75                    2413              RTS
0000274C                          2414  
0000274C                          2415  OP1011_EOR
0000274C                          2416  
0000274C                          2417   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000274C  13FC 0082 00004958      2418             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002754  13FC 0080 00004959      2419             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000275C                          2420             
0000275C                          2421             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000275C  13FC 00B9 0000495B      2422             MOVE.B   #$B9,GET_DST_START_END
00002764  13FC 0020 0000495C      2423             MOVE.B   #$20,GET_SRC_START_END
0000276C                          2424             
0000276C                          2425              *CLEAR D3
0000276C  4283                    2426              CLR.L   D3
0000276E                          2427              *LOAD STACK WITH THIS OPMODE
0000276E  6100 185E               2428              BSR     PUSH_STACK
00002772  163C 0045               2429              MOVE.B  #'E',D3
00002776  6100 1856               2430              BSR     PUSH_STACK
0000277A  163C 004F               2431              MOVE.B  #'O',D3
0000277E  6100 184E               2432              BSR     PUSH_STACK
00002782  163C 0052               2433              MOVE.B  #'R',D3
00002786  6100 1846               2434              BSR     PUSH_STACK
0000278A  163C 002E               2435              MOVE.B  #'.',D3
0000278E  6100 183E               2436              BSR     PUSH_STACK
00002792                          2437              
00002792                          2438              *FIGURE OUT SIZE*
00002792                          2439              *00 = BYTE
00002792                          2440              *01 = WORD
00002792                          2441              *10 = LONG
00002792                          2442              * BITS 7&6
00002792                          2443              
00002792                          2444              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002792  2205                    2445              MOVE.L  D5,D1
00002794  EC99                    2446              ROR.L   #6,D1
00002796  0281 00000003           2447              ANDI.L  #$03,D1
0000279C  0C01 0000               2448              CMPI.B  #%00,D1
000027A0  6700 001E               2449              BEQ     OP1011_EOR_B
000027A4  0281 00000003           2450              ANDI.L  #$03,D1
000027AA  0C01 0001               2451              CMPI.B  #%01,D1
000027AE  6700 001C               2452              BEQ     OP1011_EOR_W
000027B2  0281 00000003           2453              ANDI.L  #$03,D1
000027B8  0C01 0002               2454              CMPI.B  #%10,D1
000027BC  6700 001A               2455              BEQ     OP1011_EOR_L
000027C0                          2456            
000027C0                          2457  OP1011_EOR_B
000027C0                          2458              
000027C0  163C 0042               2459              MOVE.B  #'B',D3
000027C4  6100 1808               2460              BSR     PUSH_STACK
000027C8  6000 0016               2461              BRA     OP1011_RETURN
000027CC                          2462  OP1011_EOR_W
000027CC                          2463              
000027CC  163C 0057               2464              MOVE.B  #'W',D3
000027D0  6100 17FC               2465              BSR     PUSH_STACK
000027D4  6000 000A               2466              BRA     OP1011_RETURN
000027D8                          2467  OP1011_EOR_L
000027D8                          2468              
000027D8  163C 004C               2469              MOVE.B  #'L',D3
000027DC  6100 17F0               2470              BSR     PUSH_STACK
000027E0                          2471  OP1011_RETURN            
000027E0                          2472  
000027E0                          2473              
000027E0                          2474  *GET DATA FROM ADDQ AND PRINT #0-8
000027E0                          2475       
000027E0                          2476              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027E0  0285 0000FE3F           2477              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027E6  0685 00000000           2478              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027EC                          2479  
000027EC  6100 1372               2480              BSR     GET_EA_EA_DEST
000027F0  163C 002C               2481              MOVE.B  #',',D3
000027F4  6100 17D8               2482              BSR     PUSH_STACK
000027F8  6100 0F36               2483              BSR     GET_EA_EA_SRC
000027FC                          2484              
000027FC  4E75                    2485              RTS
000027FE                          2486              
000027FE                          2487              
000027FE                          2488              
000027FE                          2489              
000027FE                          2490  
000027FE                          2491  *---------------------------------------------------------------------------*
000027FE                          2492  * OP_CMPA: display CMPA 
000027FE                          2493  *---------------------------------------------------------------------------
000027FE  43F9 000047D6           2494  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00002804  103C 000E               2495              MOVE.B  #14,D0
00002808  4E4F                    2496              TRAP    #15
0000280A  183C 0001               2497              MOVE.B  #1,D4
0000280E  4E75                    2498              RTS
00002810                          2499  
00002810  43F9 000047E0           2500  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002816  103C 000E               2501              MOVE.B  #14,D0
0000281A  4E4F                    2502              TRAP    #15
0000281C  183C 0002               2503              MOVE.B  #2,D4
00002820  4E75                    2504              RTS
00002822                          2505  
00002822                          2506  *---------------------------------------------------------------------------*
00002822                          2507  * OP_CMP: display CMP and proceed to EA
00002822                          2508  *---------------------------------------------------------------------------*  
00002822  43F9 000047BB           2509  OP_CMP_B    LEA     DISP_CMP_B,A1
00002828  103C 000E               2510              MOVE.B  #14,D0
0000282C  4E4F                    2511              TRAP    #15
0000282E  183C 0000               2512              MOVE.B  #0,D4
00002832  4EF9 000032E0           2513              JMP     EA_GEN
00002838                          2514  
00002838  4E75                    2515              RTS
0000283A                          2516              
0000283A  43F9 000047C4           2517  OP_CMP_W    LEA     DISP_CMP_W,A1
00002840  103C 000E               2518              MOVE.B  #14,D0
00002844  4E4F                    2519              TRAP    #15
00002846  183C 0001               2520              MOVE.B  #1,D4
0000284A  4EF9 000032E0           2521              JMP     EA_GEN
00002850                          2522  
00002850  4E75                    2523              RTS
00002852                          2524              
00002852  43F9 000047CD           2525  OP_CMP_L    LEA     DISP_CMP_L,A1
00002858  103C 000E               2526              MOVE.B  #14,D0
0000285C  4E4F                    2527              TRAP    #15
0000285E  183C 0002               2528              MOVE.B  #2,D4
00002862  4EF9 000032E0           2529              JMP     EA_GEN
00002868                          2530  
00002868  4E75                    2531              RTS
0000286A                          2532              
0000286A                          2533  *---------------------------------------------------------------------------*
0000286A                          2534  * OP_EOR: display EOR
0000286A                          2535  *---------------------------------------------------------------------------*  
0000286A  43F9 000047A0           2536  OP_EOR_B    LEA     DISP_EOR_B,A1
00002870  103C 000E               2537              MOVE.B  #14,D0
00002874  4E4F                    2538              TRAP    #15
00002876  183C 0000               2539              MOVE.B  #0,D4
0000287A  4E75                    2540              RTS
0000287C                          2541              
0000287C  43F9 000047A9           2542  OP_EOR_W    LEA     DISP_EOR_W,A1
00002882  103C 000E               2543              MOVE.B  #14,D0
00002886  4E4F                    2544              TRAP    #15
00002888  183C 0001               2545              MOVE.B  #1,D4
0000288C  4E75                    2546              RTS
0000288E                          2547              
0000288E  43F9 000047B2           2548  OP_EOR_L    LEA     DISP_EOR_L,A1
00002894  103C 000E               2549              MOVE.B  #14,D0
00002898  4E4F                    2550              TRAP    #15
0000289A  183C 0002               2551              MOVE.B  #2,D4
0000289E  4E75                    2552              RTS    
000028A0                          2553  
000028A0                          2554  *---------------------------------------------------------------------------*
000028A0                          2555  * OP1100: Decode and display MULS/AND and proceed to EA
000028A0                          2556  *---------------------------------------------------------------------------* 
000028A0  4280                    2557  OP1100      CLR.L   D0                 
000028A2  4281                    2558              CLR.L   D1    
000028A4  4284                    2559              CLR.L   D4                
000028A6  227C 00000000           2560              MOVEA.L #0, A1        
000028AC  2205                    2561              MOVE.L  D5,D1
000028AE  EA89                    2562              LSR.L   #5,D1
000028B0  0281 0000000E           2563              ANDI.L  #$E,D1
000028B6  0C41 000E               2564              CMPI.W  #$E,D1
000028BA  6700 0006               2565              BEQ     OP_MULS
000028BE  6000 00F6               2566              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000028C2                          2567  
000028C2                          2568  OP_MULS                      
000028C2  4281                    2569              CLR.L   D1       
000028C4  4284                    2570              CLR.L   D4                   
000028C6  227C 00000000           2571              MOVEA.L #0, A1              
000028CC  2205                    2572              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000028CE                          2573              *CLEAR D3
000028CE  4283                    2574              CLR.L   D3
000028D0                          2575  
000028D0                          2576  OP1100_MULS_DN_EA_OR_EA_DN 
000028D0                          2577              *LOAD STACK WITH THIS OPMODE
000028D0  6100 16FC               2578              BSR     PUSH_STACK
000028D4  163C 004D               2579              MOVE.B  #'M',D3
000028D8  6100 16F4               2580              BSR     PUSH_STACK
000028DC  163C 0055               2581              MOVE.B  #'U',D3
000028E0  6100 16EC               2582              BSR     PUSH_STACK
000028E4  163C 004C               2583              MOVE.B  #'L',D3
000028E8  6100 16E4               2584              BSR     PUSH_STACK
000028EC  163C 0053               2585              MOVE.B  #'S',D3
000028F0  6100 16DC               2586              BSR     PUSH_STACK
000028F4  163C 002E               2587              MOVE.B  #'.',D3
000028F8  6100 16D4               2588              BSR     PUSH_STACK
000028FC                          2589              
000028FC  2205                    2590              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000028FE                          2591              
000028FE                          2592  OP1100_EA_DN_MULS           
000028FE                          2593              *BITS (7 TO 6) 
000028FE                          2594              *00 = .B
000028FE                          2595              *01 = .W
000028FE                          2596              *10 = .L 
000028FE  2205                    2597              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002900  EC99                    2598              ROR.L   #6,D1
00002902  0281 00000003           2599              ANDI.L  #$03,D1
00002908  0C81 00000003           2600              CMPI.L  #%11,D1 *EQUALS .W
0000290E  6700 0014               2601              BEQ     OP1100_PRINT_W_MULS
00002912  0C81 00000000           2602              CMPI.L  #%00,D1 *EQUALS .L
00002918  6700 0052               2603              BEQ     OP1100_PRINT_L_MULS
0000291C                          2604              
0000291C  183C 0001               2605              MOVE.B  #1,D4               *ERROR READ
00002920  6000 0092               2606              BRA     OP1100_MULS_RETURN
00002924                          2607  OP1100_PRINT_W_MULS
00002924  163C 0057               2608              MOVE.B  #'W',D3
00002928  6100 16A4               2609              BSR     PUSH_STACK
0000292C                          2610  
0000292C                          2611              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000292C  13FC 0000 00004958      2612              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002934  13FC 0000 00004959      2613              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000293C                          2614             
0000293C                          2615              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000293C  13FC 00B9 0000495B      2616              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002944  13FC 0020 0000495C      2617              MOVE.B   #$20,GET_SRC_START_END
0000294C                          2618  
0000294C                          2619             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000294C  0285 0000FE3F           2620              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002952  0685 00000000           2621              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002958                          2622  
00002958                          2623              
00002958  6100 0DD6               2624              BSR     GET_EA_EA_SRC      *GETS <ea>
0000295C  163C 002C               2625              MOVE.B  #',',D3
00002960  6100 166C               2626              BSR     PUSH_STACK
00002964  6100 11FA               2627              BSR     GET_EA_EA_DEST       *GETS Dn    
00002968                          2628              
00002968  6000 004A               2629              BRA     OP1100_MULS_RETURN
0000296C                          2630  OP1100_PRINT_L_MULS 
0000296C  163C 004C               2631              MOVE.B  #'L',D3
00002970  6100 165C               2632              BSR     PUSH_STACK
00002974                          2633              
00002974                          2634              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002974  13FC 0000 00004958      2635              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000297C  13FC 0000 00004959      2636              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002984                          2637             
00002984                          2638              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002984  13FC 00B9 0000495B      2639              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000298C  13FC 0020 0000495C      2640              MOVE.B   #$20,GET_SRC_START_END
00002994                          2641  
00002994                          2642              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002994  0285 0000FE3F           2643              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000299A  0685 00000000           2644              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000029A0                          2645  
000029A0                          2646                     
000029A0  6100 0D8E               2647              BSR     GET_EA_EA_SRC      *GETS <ea>
000029A4  163C 002C               2648              MOVE.B  #',',D3
000029A8  6100 1624               2649              BSR     PUSH_STACK                  
000029AC  6100 11B2               2650              BSR     GET_EA_EA_DEST       *GETS Dn    
000029B0                          2651  
000029B0                          2652              
000029B0  6000 0002               2653              BRA     OP1100_MULS_RETURN
000029B4                          2654              
000029B4                          2655  OP1100_MULS_RETURN
000029B4  4E75                    2656              RTS
000029B6                          2657              
000029B6                          2658  
000029B6                          2659  
000029B6                          2660  
000029B6                          2661  
000029B6                          2662  
000029B6                          2663  
000029B6                          2664  
000029B6                          2665  
000029B6                          2666  
000029B6                          2667  
000029B6                          2668  
000029B6                          2669  
000029B6                          2670  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000029B6                          2671              *LOAD STACK WITH THIS OPMODE
000029B6  4283                    2672              CLR.L   D3
000029B8  6100 1614               2673              BSR     PUSH_STACK
000029BC  163C 0041               2674              MOVE.B  #'A',D3
000029C0  6100 160C               2675              BSR     PUSH_STACK
000029C4  163C 004E               2676              MOVE.B  #'N',D3
000029C8  6100 1604               2677              BSR     PUSH_STACK
000029CC  163C 0044               2678              MOVE.B  #'D',D3
000029D0  6100 15FC               2679              BSR     PUSH_STACK
000029D4  163C 002E               2680              MOVE.B  #'.',D3
000029D8  6100 15F4               2681              BSR     PUSH_STACK
000029DC                          2682              
000029DC  2205                    2683              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000029DE                          2684              
000029DE                          2685              *BITS (INDEX 8) 
000029DE                          2686              *0 = ADD.B/W/L <EA>,Dn
000029DE                          2687              *1 = ADD.B/W/L Dn,<EA> 
000029DE  E099                    2688              ROR.L   #8,D1
000029E0  0281 00000001           2689              ANDI.L  #$01,D1     *MASKS WITH 00000001
000029E6  0C81 00000000           2690              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000029EC  6700 0102               2691              BEQ     OP1100_EA_DN
000029F0                          2692              *else procede to Dn_EA
000029F0                          2693              
000029F0                          2694  OP1100_DN_EA
000029F0                          2695              *BITS (7 TO 6) 
000029F0                          2696              *00 = .B
000029F0                          2697              *01 = .W
000029F0                          2698              *10 = .L 
000029F0  2205                    2699              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000029F2  EC99                    2700              ROR.L   #6,D1
000029F4  0281 00000003           2701              ANDI.L  #$03,D1
000029FA  0C81 00000000           2702              CMPI.L  #$00,D1 *EQUALS .B
00002A00  6700 0016               2703              BEQ     OP1100_PRINT_B2
00002A04  0C81 00000001           2704              CMPI.L  #$01,D1 *EQUALS .W
00002A0A  6700 0054               2705              BEQ     OP1100_PRINT_W2
00002A0E  0C81 00000002           2706              CMPI.L  #$02,D1 *EQUALS .L
00002A14  6700 0092               2707              BEQ     OP1100_PRINT_L2
00002A18                          2708  OP1100_PRINT_B2
00002A18                          2709              *PUSH 'B'
00002A18  163C 0042               2710              MOVE.B  #'B',D3
00002A1C  6100 15B0               2711              BSR     PUSH_STACK
00002A20                          2712             
00002A20                          2713              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A20  13FC 0000 00004958      2714             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A28  13FC 0083 00004959      2715             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A30                          2716             
00002A30                          2717             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A30  13FC 00B9 0000495B      2718             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A38  13FC 0020 0000495C      2719             MOVE.B   #$20,GET_SRC_START_END
00002A40                          2720  
00002A40                          2721              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A40  0285 0000FE3F           2722              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A46  0685 00000000           2723              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A4C                          2724       
00002A4C  6100 1112               2725              BSR     GET_EA_EA_DEST      *GETS Dn
00002A50  163C 002C               2726              MOVE.B  #',',D3
00002A54  6100 1578               2727              BSR     PUSH_STACK                     
00002A58  6100 0CD6               2728              BSR     GET_EA_EA_SRC       *GETS <ea>
00002A5C                          2729  
00002A5C                          2730              
00002A5C  6000 0192               2731              BRA     OP1100_AND_RETURN
00002A60                          2732  OP1100_PRINT_W2
00002A60  163C 0057               2733              MOVE.B  #'W',D3
00002A64  6100 1568               2734              BSR     PUSH_STACK
00002A68                          2735  
00002A68                          2736              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A68  13FC 0000 00004958      2737              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A70  13FC 0083 00004959      2738              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A78                          2739             
00002A78                          2740              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A78  13FC 00B9 0000495B      2741              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A80  13FC 0020 0000495C      2742              MOVE.B   #$20,GET_SRC_START_END
00002A88                          2743  
00002A88                          2744              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A88  0285 0000FE3F           2745              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A8E  0685 00000000           2746              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002A94                          2747  
00002A94                          2748        
00002A94  6100 10CA               2749              BSR     GET_EA_EA_DEST      *GETS Dn
00002A98  163C 002C               2750              MOVE.B  #',',D3
00002A9C  6100 1530               2751              BSR     PUSH_STACK               
00002AA0  6100 0C8E               2752              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002AA4                          2753  
00002AA4                          2754  
00002AA4                          2755  
00002AA4  6000 049A               2756              BRA     OP1101_ADD_RETURN
00002AA8                          2757  OP1100_PRINT_L2 
00002AA8  163C 004C               2758              MOVE.B  #'L',D3
00002AAC  6100 1520               2759              BSR     PUSH_STACK
00002AB0                          2760              
00002AB0                          2761              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AB0  13FC 0000 00004958      2762              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AB8  13FC 0083 00004959      2763              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AC0                          2764             
00002AC0                          2765              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AC0  13FC 00B9 0000495B      2766              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AC8  13FC 0020 0000495C      2767              MOVE.B   #$20,GET_SRC_START_END
00002AD0                          2768  
00002AD0                          2769             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AD0  0285 0000FE3F           2770              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AD6  0685 00000000           2771              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002ADC                          2772  
00002ADC                          2773               
00002ADC  6100 1082               2774              BSR     GET_EA_EA_DEST       *GETS Dn
00002AE0  163C 002C               2775              MOVE.B  #',',D3
00002AE4  6100 14E8               2776              BSR     PUSH_STACK          
00002AE8  6100 0C46               2777              BSR     GET_EA_EA_SRC        *GETS <ea>
00002AEC                          2778  
00002AEC  6000 0102               2779              BRA     OP1100_AND_RETURN
00002AF0                          2780              
00002AF0                          2781  OP1100_EA_DN           
00002AF0                          2782              *BITS (7 TO 6) 
00002AF0                          2783              *00 = .B
00002AF0                          2784              *01 = .W
00002AF0                          2785              *10 = .L 
00002AF0  2205                    2786              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002AF2  EC99                    2787              ROR.L   #6,D1
00002AF4  0281 00000003           2788              ANDI.L  #$03,D1
00002AFA  0C81 00000000           2789              CMPI.L  #$00,D1 *EQUALS .B
00002B00  6700 0016               2790              BEQ     OP1100_PRINT_B
00002B04  0C81 00000001           2791              CMPI.L  #$01,D1 *EQUALS .W
00002B0A  6700 0054               2792              BEQ     OP1100_PRINT_W
00002B0E  0C81 00000002           2793              CMPI.L  #$02,D1 *EQUALS .L
00002B14  6700 0092               2794              BEQ     OP1100_PRINT_L
00002B18                          2795  OP1100_PRINT_B
00002B18  163C 0042               2796              MOVE.B  #'B',D3
00002B1C  6100 14B0               2797              BSR     PUSH_STACK
00002B20                          2798                
00002B20                          2799              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B20  13FC 0000 00004958      2800              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B28  13FC 0002 00004959      2801              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B30                          2802             
00002B30                          2803              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B30  13FC 00B9 0000495B      2804              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B38  13FC 0020 0000495C      2805              MOVE.B   #$20,GET_SRC_START_END
00002B40                          2806  
00002B40                          2807             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B40  0285 0000FE3F           2808              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B46  0685 00000000           2809              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002B4C                          2810  
00002B4C                          2811              
00002B4C  6100 0BE2               2812              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B50  163C 002C               2813              MOVE.B  #',',D3
00002B54  6100 1478               2814              BSR     PUSH_STACK          
00002B58  6100 1006               2815              BSR     GET_EA_EA_DEST       *GETS Dn
00002B5C                          2816              
00002B5C  6000 03E2               2817              BRA     OP1101_ADD_RETURN
00002B60                          2818  OP1100_PRINT_W
00002B60  163C 0057               2819              MOVE.B  #'W',D3
00002B64  6100 1468               2820              BSR     PUSH_STACK
00002B68                          2821  
00002B68                          2822              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B68  13FC 0000 00004958      2823              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B70  13FC 0002 00004959      2824              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B78                          2825             
00002B78                          2826              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B78  13FC 00B9 0000495B      2827              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B80  13FC 0020 0000495C      2828              MOVE.B   #$20,GET_SRC_START_END
00002B88                          2829  
00002B88                          2830             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B88  0285 0000FE3F           2831              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B8E  0685 00000000           2832              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B94                          2833  
00002B94                          2834              
00002B94  6100 0B9A               2835              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B98  163C 002C               2836              MOVE.B  #',',D3
00002B9C  6100 1430               2837              BSR     PUSH_STACK
00002BA0  6100 0FBE               2838              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BA4                          2839              
00002BA4  6000 F988               2840              BRA     OP1001_ADD_RETURN
00002BA8                          2841  OP1100_PRINT_L 
00002BA8  163C 004C               2842              MOVE.B  #'L',D3
00002BAC  6100 1420               2843              BSR     PUSH_STACK
00002BB0                          2844              
00002BB0                          2845              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BB0  13FC 0000 00004958      2846              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BB8  13FC 0002 00004959      2847              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BC0                          2848             
00002BC0                          2849              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BC0  13FC 00B9 0000495B      2850              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BC8  13FC 0020 0000495C      2851              MOVE.B   #$20,GET_SRC_START_END
00002BD0                          2852  
00002BD0                          2853              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BD0  0285 0000FE3F           2854              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BD6  0685 00000000           2855              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BDC                          2856  
00002BDC                          2857                     
00002BDC  6100 0B52               2858              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BE0  163C 002C               2859              MOVE.B  #',',D3
00002BE4  6100 13E8               2860              BSR     PUSH_STACK                  
00002BE8  6100 0F76               2861              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BEC                          2862  
00002BEC                          2863              
00002BEC  6000 0002               2864              BRA     OP1100_AND_RETURN
00002BF0                          2865              
00002BF0                          2866  OP1100_AND_RETURN
00002BF0  4E75                    2867              RTS
00002BF2                          2868  
00002BF2                          2869  
00002BF2                          2870  *---------------------------------------------------------------------------*
00002BF2                          2871  * OP1101: Decode ADD/ADDA
00002BF2                          2872  *---------------------------------------------------------------------------* 
00002BF2  4280                    2873  OP1101      CLR.L   D0                  
00002BF4  4281                    2874              CLR.L   D1       
00002BF6  4284                    2875              CLR.L   D4                   
00002BF8  227C 00000000           2876              MOVEA.L #0, A1              
00002BFE  2205                    2877              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002C00                          2878              
00002C00                          2879              *CLEAR D3
00002C00  4283                    2880              CLR.L   D3
00002C02                          2881              
00002C02                          2882              
00002C02                          2883              
00002C02                          2884              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002C02  2205                    2885              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C04                          2886              *BITS (INDEX 8) 
00002C04                          2887              *0 = ADD.B/W/L <EA>,Dn
00002C04                          2888              *1 = ADD.B/W/L Dn,<EA> 
00002C04  EC99                    2889              ROR.L   #6,D1
00002C06  0281 00000007           2890              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002C0C  0C81 00000007           2891              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002C12  6700 0010               2892              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002C16  0C81 00000003           2893              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002C1C  6700 0078               2894              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002C20  6000 00E6               2895              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002C24                          2896              
00002C24                          2897  OP1101_ADDA_L
00002C24                          2898              *LOAD STACK WITH THIS OPMODE
00002C24  6100 13A8               2899              BSR     PUSH_STACK
00002C28  163C 0041               2900              MOVE.B  #'A',D3
00002C2C  6100 13A0               2901              BSR     PUSH_STACK
00002C30  163C 0044               2902              MOVE.B  #'D',D3
00002C34  6100 1398               2903              BSR     PUSH_STACK
00002C38  163C 0044               2904              MOVE.B  #'D',D3
00002C3C  6100 1390               2905              BSR     PUSH_STACK
00002C40  163C 0041               2906              MOVE.B  #'A',D3
00002C44  6100 1388               2907              BSR     PUSH_STACK
00002C48  163C 002E               2908              MOVE.B  #'.',D3
00002C4C  6100 1380               2909              BSR     PUSH_STACK
00002C50  163C 004C               2910              MOVE.B  #'L',D3
00002C54  6100 1378               2911              BSR     PUSH_STACK
00002C58                          2912              
00002C58                          2913             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C58  13FC 0000 00004958      2914             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C60  13FC 0000 00004959      2915             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C68                          2916             
00002C68                          2917             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C68  13FC 00B9 0000495B      2918             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C70  13FC 0020 0000495C      2919             MOVE.B   #$20,GET_SRC_START_END
00002C78                          2920  
00002C78                          2921              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C78  0285 0000FE3F           2922              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C7E  0685 00000040           2923              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C84                          2924       
00002C84                          2925              *PRINT <EA>,AN
00002C84  6100 0AAA               2926              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C88  163C 002C               2927              MOVE.B  #',',D3
00002C8C  6100 1340               2928              BSR     PUSH_STACK                     
00002C90  6100 0ECE               2929              BSR     GET_EA_EA_DEST      *GETS Dn
00002C94                          2930  
00002C94                          2931              
00002C94                          2932              
00002C94  4E75                    2933              RTS
00002C96                          2934  OP1101_ADDA_W
00002C96                          2935              *LOAD STACK WITH THIS OPMODE
00002C96  6100 1336               2936              BSR     PUSH_STACK
00002C9A  163C 0041               2937              MOVE.B  #'A',D3
00002C9E  6100 132E               2938              BSR     PUSH_STACK
00002CA2  163C 0044               2939              MOVE.B  #'D',D3
00002CA6  6100 1326               2940              BSR     PUSH_STACK
00002CAA  163C 0044               2941              MOVE.B  #'D',D3
00002CAE  6100 131E               2942              BSR     PUSH_STACK
00002CB2  163C 0041               2943              MOVE.B  #'A',D3
00002CB6  6100 1316               2944              BSR     PUSH_STACK
00002CBA  163C 002E               2945              MOVE.B  #'.',D3
00002CBE  6100 130E               2946              BSR     PUSH_STACK
00002CC2  163C 0057               2947              MOVE.B  #'W',D3
00002CC6  6100 1306               2948              BSR     PUSH_STACK
00002CCA                          2949              
00002CCA                          2950             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CCA  13FC 0000 00004958      2951             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CD2  13FC 0000 00004959      2952             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CDA                          2953             
00002CDA                          2954             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CDA  13FC 00B9 0000495B      2955             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CE2  13FC 0020 0000495C      2956             MOVE.B   #$20,GET_SRC_START_END
00002CEA                          2957  
00002CEA                          2958              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CEA  0285 0000FE3F           2959              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CF0  0685 00000040           2960              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002CF6                          2961       
00002CF6                          2962              *PRINT <EA>,AN
00002CF6  6100 0A38               2963              BSR     GET_EA_EA_SRC       *GETS <ea>
00002CFA  163C 002C               2964              MOVE.B  #',',D3
00002CFE  6100 12CE               2965              BSR     PUSH_STACK                     
00002D02  6100 0E5C               2966              BSR     GET_EA_EA_DEST      *GETS Dn
00002D06                          2967  
00002D06  4E75                    2968              RTS
00002D08                          2969  
00002D08                          2970  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002D08                          2971              *LOAD STACK WITH THIS OPMODE
00002D08  6100 12C4               2972              BSR     PUSH_STACK
00002D0C  163C 0041               2973              MOVE.B  #'A',D3
00002D10  6100 12BC               2974              BSR     PUSH_STACK
00002D14  163C 0044               2975              MOVE.B  #'D',D3
00002D18  6100 12B4               2976              BSR     PUSH_STACK
00002D1C  163C 0044               2977              MOVE.B  #'D',D3
00002D20  6100 12AC               2978              BSR     PUSH_STACK
00002D24  163C 002E               2979              MOVE.B  #'.',D3
00002D28  6100 12A4               2980              BSR     PUSH_STACK
00002D2C                          2981              
00002D2C  2205                    2982              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002D2E                          2983              
00002D2E                          2984              *BITS (INDEX 8) 
00002D2E                          2985              *0 = ADD.B/W/L <EA>,Dn
00002D2E                          2986              *1 = ADD.B/W/L Dn,<EA> 
00002D2E  E099                    2987              ROR.L   #8,D1
00002D30  0281 00000001           2988              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002D36  0C81 00000000           2989              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002D3C  6700 0102               2990              BEQ     OP1101_EA_DN
00002D40                          2991              *else procede to Dn_EA
00002D40                          2992              
00002D40                          2993  OP1101_DN_EA
00002D40                          2994              *BITS (7 TO 6) 
00002D40                          2995              *00 = .B
00002D40                          2996              *01 = .W
00002D40                          2997              *10 = .L 
00002D40  2205                    2998              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002D42  EC99                    2999              ROR.L   #6,D1
00002D44  0281 00000003           3000              ANDI.L  #$03,D1
00002D4A  0C81 00000000           3001              CMPI.L  #$00,D1 *EQUALS .B
00002D50  6700 0016               3002              BEQ     OP1101_PRINT_B2
00002D54  0C81 00000001           3003              CMPI.L  #$01,D1 *EQUALS .W
00002D5A  6700 0054               3004              BEQ     OP1101_PRINT_W2
00002D5E  0C81 00000002           3005              CMPI.L  #$02,D1 *EQUALS .L
00002D64  6700 0092               3006              BEQ     OP1101_PRINT_L2
00002D68                          3007  OP1101_PRINT_B2
00002D68                          3008              *PUSH 'B'
00002D68  163C 0042               3009              MOVE.B  #'B',D3
00002D6C  6100 1260               3010              BSR     PUSH_STACK
00002D70                          3011             
00002D70                          3012              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D70  13FC 0002 00004958      3013             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D78  13FC 0083 00004959      3014             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D80                          3015             
00002D80                          3016             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D80  13FC 00B9 0000495B      3017             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D88  13FC 0020 0000495C      3018             MOVE.B   #$20,GET_SRC_START_END
00002D90                          3019  
00002D90                          3020              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D90  0285 0000FE3F           3021              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D96  0685 00000000           3022              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D9C                          3023       
00002D9C  6100 0DC2               3024              BSR     GET_EA_EA_DEST      *GETS Dn
00002DA0  163C 002C               3025              MOVE.B  #',',D3
00002DA4  6100 1228               3026              BSR     PUSH_STACK                     
00002DA8  6100 0986               3027              BSR     GET_EA_EA_SRC       *GETS <ea>
00002DAC                          3028  
00002DAC                          3029              
00002DAC  6000 0192               3030              BRA     OP1101_ADD_RETURN
00002DB0                          3031  OP1101_PRINT_W2
00002DB0  163C 0057               3032              MOVE.B  #'W',D3
00002DB4  6100 1218               3033              BSR     PUSH_STACK
00002DB8                          3034  
00002DB8                          3035              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DB8  13FC 0000 00004958      3036              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DC0  13FC 0083 00004959      3037              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DC8                          3038             
00002DC8                          3039              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DC8  13FC 00B9 0000495B      3040              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DD0  13FC 0020 0000495C      3041              MOVE.B   #$20,GET_SRC_START_END
00002DD8                          3042  
00002DD8                          3043              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DD8  0285 0000FE3F           3044              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DDE  0685 00000000           3045              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DE4                          3046  
00002DE4                          3047        
00002DE4  6100 0D7A               3048              BSR     GET_EA_EA_DEST      *GETS Dn
00002DE8  163C 002C               3049              MOVE.B  #',',D3
00002DEC  6100 11E0               3050              BSR     PUSH_STACK               
00002DF0  6100 093E               3051              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002DF4                          3052  
00002DF4                          3053  
00002DF4                          3054  
00002DF4  6000 014A               3055              BRA     OP1101_ADD_RETURN
00002DF8                          3056  OP1101_PRINT_L2 
00002DF8  163C 004C               3057              MOVE.B  #'L',D3
00002DFC  6100 11D0               3058              BSR     PUSH_STACK
00002E00                          3059              
00002E00                          3060              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E00  13FC 0000 00004958      3061              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E08  13FC 0083 00004959      3062              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E10                          3063             
00002E10                          3064              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E10  13FC 00B9 0000495B      3065              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E18  13FC 0020 0000495C      3066              MOVE.B   #$20,GET_SRC_START_END
00002E20                          3067  
00002E20                          3068             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E20  0285 0000FE3F           3069              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E26  0685 00000000           3070              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E2C                          3071  
00002E2C                          3072               
00002E2C  6100 0D32               3073              BSR     GET_EA_EA_DEST       *GETS Dn
00002E30  163C 002C               3074              MOVE.B  #',',D3
00002E34  6100 1198               3075              BSR     PUSH_STACK          
00002E38  6100 08F6               3076              BSR     GET_EA_EA_SRC        *GETS <ea>
00002E3C                          3077  
00002E3C  6000 0102               3078              BRA     OP1101_ADD_RETURN
00002E40                          3079              
00002E40                          3080  OP1101_EA_DN           
00002E40                          3081              *BITS (7 TO 6) 
00002E40                          3082              *00 = .B
00002E40                          3083              *01 = .W
00002E40                          3084              *10 = .L 
00002E40  2205                    3085              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002E42  EC99                    3086              ROR.L   #6,D1
00002E44  0281 00000003           3087              ANDI.L  #$03,D1
00002E4A  0C81 00000000           3088              CMPI.L  #$00,D1 *EQUALS .B
00002E50  6700 0016               3089              BEQ     OP1101_PRINT_B
00002E54  0C81 00000001           3090              CMPI.L  #$01,D1 *EQUALS .W
00002E5A  6700 0054               3091              BEQ     OP1101_PRINT_W
00002E5E  0C81 00000002           3092              CMPI.L  #$02,D1 *EQUALS .L
00002E64  6700 0092               3093              BEQ     OP1101_PRINT_L
00002E68                          3094  OP1101_PRINT_B
00002E68  163C 0042               3095              MOVE.B  #'B',D3
00002E6C  6100 1160               3096              BSR     PUSH_STACK
00002E70                          3097                
00002E70                          3098              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E70  13FC 0002 00004958      3099              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E78  13FC 0002 00004959      3100              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E80                          3101             
00002E80                          3102              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E80  13FC 00B9 0000495B      3103              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E88  13FC 0020 0000495C      3104              MOVE.B   #$20,GET_SRC_START_END
00002E90                          3105  
00002E90                          3106             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E90  0285 0000FE3F           3107              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E96  0685 00000000           3108              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E9C                          3109  
00002E9C                          3110              
00002E9C  6100 0892               3111              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EA0  163C 002C               3112              MOVE.B  #',',D3
00002EA4  6100 1128               3113              BSR     PUSH_STACK          
00002EA8  6100 0CB6               3114              BSR     GET_EA_EA_DEST       *GETS Dn
00002EAC                          3115              
00002EAC  6000 0092               3116              BRA     OP1101_ADD_RETURN
00002EB0                          3117  OP1101_PRINT_W
00002EB0  163C 0057               3118              MOVE.B  #'W',D3
00002EB4  6100 1118               3119              BSR     PUSH_STACK
00002EB8                          3120  
00002EB8                          3121              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002EB8  13FC 0000 00004958      3122              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002EC0  13FC 0000 00004959      3123              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002EC8                          3124             
00002EC8                          3125              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002EC8  13FC 00B9 0000495B      3126              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002ED0  13FC 0020 0000495C      3127              MOVE.B   #$20,GET_SRC_START_END
00002ED8                          3128  
00002ED8                          3129             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002ED8  0285 0000FE3F           3130              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EDE  0685 00000000           3131              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EE4                          3132  
00002EE4                          3133              
00002EE4  6100 084A               3134              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EE8  163C 002C               3135              MOVE.B  #',',D3
00002EEC  6100 10E0               3136              BSR     PUSH_STACK
00002EF0  6100 0C6E               3137              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EF4                          3138              
00002EF4  6000 004A               3139              BRA     OP1101_ADD_RETURN
00002EF8                          3140  OP1101_PRINT_L 
00002EF8  163C 004C               3141              MOVE.B  #'L',D3
00002EFC  6100 10D0               3142              BSR     PUSH_STACK
00002F00                          3143              
00002F00                          3144              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002F00  13FC 0000 00004958      3145              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002F08  13FC 0000 00004959      3146              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002F10                          3147             
00002F10                          3148              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002F10  13FC 00B9 0000495B      3149              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002F18  13FC 0020 0000495C      3150              MOVE.B   #$20,GET_SRC_START_END
00002F20                          3151  
00002F20                          3152              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002F20  0285 0000FE3F           3153              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002F26  0685 00000000           3154              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002F2C                          3155  
00002F2C                          3156                     
00002F2C  6100 0802               3157              BSR     GET_EA_EA_SRC      *GETS <ea>
00002F30  163C 002C               3158              MOVE.B  #',',D3
00002F34  6100 1098               3159              BSR     PUSH_STACK                  
00002F38  6100 0C26               3160              BSR     GET_EA_EA_DEST       *GETS Dn    
00002F3C                          3161  
00002F3C                          3162              
00002F3C  6000 0002               3163              BRA     OP1101_ADD_RETURN
00002F40                          3164              
00002F40                          3165  OP1101_ADD_RETURN
00002F40  4E75                    3166              RTS
00002F42                          3167              
00002F42                          3168              *ADDW
00002F42  0C01 0006               3169              CMPI.B  #$6,D1
00002F46  6700 0056               3170              BEQ     OP_ADDA_W
00002F4A  0C01 000E               3171              CMPI.B  #$E,D1
00002F4E  6700 0066               3172              BEQ     OP_ADDA_L 
00002F52                          3173  
00002F52  4EF8 1750               3174              JMP     OP_DATA  
00002F56                          3175            
00002F56                          3176  *---------------------------------------------------------------------------*
00002F56                          3177  * OP_ADD: display ADD and proceed to EA
00002F56                          3178  *---------------------------------------------------------------------------*  
00002F56  43F9 0000480F           3179  OP_ADD_B    LEA     DISP_ADD_B,A1
00002F5C  103C 000E               3180              MOVE.B  #14,D0
00002F60  4E4F                    3181              TRAP    #15
00002F62  183C 0000               3182              MOVE.B  #0,D4
00002F66  4EF9 000032E0           3183              JMP     EA_GEN
00002F6C                          3184  
00002F6C  4E75                    3185              RTS
00002F6E                          3186  
00002F6E  43F9 00004818           3187  OP_ADD_W    LEA     DISP_ADD_W,A1
00002F74  103C 000E               3188              MOVE.B  #14,D0
00002F78  4E4F                    3189              TRAP    #15
00002F7A  183C 0001               3190              MOVE.B  #1,D4
00002F7E  4EF9 000032E0           3191              JMP     EA_GEN
00002F84                          3192  
00002F84  4E75                    3193              RTS
00002F86                          3194  
00002F86  43F9 00004821           3195  OP_ADD_L    LEA     DISP_ADD_L,A1
00002F8C  103C 000E               3196              MOVE.B  #14,D0
00002F90  4E4F                    3197              TRAP    #15
00002F92  183C 0002               3198              MOVE.B  #2,D4
00002F96  4EF9 000032E0           3199              JMP     EA_GEN
00002F9C                          3200  
00002F9C  4E75                    3201              RTS
00002F9E                          3202  
00002F9E                          3203  *---------------------------------------------------------------------------*
00002F9E                          3204  * OP_ADDA: display ADDA and proceed to EA
00002F9E                          3205  *---------------------------------------------------------------------------*  
00002F9E  43F9 0000482A           3206  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002FA4  103C 000E               3207              MOVE.B  #14,D0
00002FA8  4E4F                    3208              TRAP    #15
00002FAA  183C 0001               3209              MOVE.B  #1,D4
00002FAE  4EF9 000032E0           3210              JMP     EA_GEN
00002FB4                          3211  
00002FB4  4E75                    3212              RTS
00002FB6                          3213  
00002FB6  43F9 00004834           3214  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002FBC  103C 000E               3215              MOVE.B  #14,D0
00002FC0  4E4F                    3216              TRAP    #15
00002FC2  183C 0002               3217              MOVE.B  #2,D4
00002FC6  4EF9 000032E0           3218              JMP     EA_GEN
00002FCC                          3219  
00002FCC  4E75                    3220              RTS
00002FCE                          3221              
00002FCE                          3222  *---------------------------------------------------------------------------*
00002FCE                          3223  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002FCE                          3224  *---------------------------------------------------------------------------* 
00002FCE  4280                    3225  OP1110      CLR.L   D0                  
00002FD0  4281                    3226              CLR.L   D1   
00002FD2  4284                    3227              CLR.L   D4                   
00002FD4  227C 00000000           3228              MOVEA.L #0, A1                 
00002FDA  2205                    3229              MOVE.L  D5,D1
00002FDC                          3230              
00002FDC                          3231              * check for LSX
00002FDC  E699                    3232              ROR.L   #3,D1
00002FDE  0281 00000001           3233              ANDI.L  #$1,D1
00002FE4  0C01 0001               3234              CMPI.B  #1,D1
00002FE8  6700 002E               3235              BEQ     OP_LSX
00002FEC                          3236              
00002FEC                          3237              * reset D1 and check for ASX
00002FEC  4281                    3238              CLR.L   D1
00002FEE  2205                    3239              MOVE.L  D5,D1
00002FF0  E699                    3240              ROR.L   #3,D1
00002FF2  0281 00000001           3241              ANDI.L  #$1,D1
00002FF8  0C01 0000               3242              CMPI.B  #0,D1
00002FFC  6700 0032               3243              BEQ     OP_ASX
00003000                          3244  
00003000                          3245              * reset D1 and check for ROX
00003000  4281                    3246              CLR.L   D1
00003002  2205                    3247              MOVE.L  D5,D1
00003004  E699                    3248              ROR.L   #3,D1
00003006  0281 00000001           3249              ANDI.L  #$1,D1
0000300C  0C01 0003               3250              CMPI.B  #3,D1
00003010  6700 0036               3251              BEQ     OP_ROX
00003014                          3252              
00003014  4EF8 1750               3253              JMP     OP_DATA
00003018                          3254  
00003018                          3255  *---------------------------------------------------------------------------*
00003018                          3256  * OP_LSX: process LSR/LSL
00003018                          3257  *---------------------------------------------------------------------------*            
00003018  EA99                    3258  OP_LSX      ROR.L   #5,D1
0000301A  0281 00000001           3259              ANDI.L  #$1,D1
00003020  0C01 0000               3260              CMPI.B  #0,D1
00003024  6700 003A               3261              BEQ     OP_LSR
00003028  0C01 0001               3262              CMPI.B  #1,D1
0000302C  6700 008C               3263              BEQ     OP_LSL
00003030                          3264              
00003030                          3265  *---------------------------------------------------------------------------*
00003030                          3266  * OP_ASX: process ASR/ASL
00003030                          3267  *---------------------------------------------------------------------------*  
00003030  EA99                    3268  OP_ASX      ROR.L   #5,D1
00003032  0281 00000001           3269              ANDI.L  #$1,D1
00003038  0C01 0000               3270              CMPI.B  #0,D1
0000303C  6700 00D6               3271              BEQ     OP_ASR
00003040  0C01 0001               3272              CMPI.B  #1,D1
00003044  6700 0128               3273              BEQ     OP_ASL
00003048                          3274              
00003048                          3275  *---------------------------------------------------------------------------*
00003048                          3276  * OP_ROX: process ROR/ROL
00003048                          3277  *---------------------------------------------------------------------------*  
00003048  EA99                    3278  OP_ROX      ROR.L   #5,D1
0000304A  0281 00000001           3279              ANDI.L  #$1,D1
00003050  0C01 0000               3280              CMPI.B  #0,D1
00003054  6700 0172               3281              BEQ     OP_ROR
00003058  0C01 0001               3282              CMPI.B  #1,D1
0000305C  6700 01C4               3283              BEQ     OP_ROL
00003060                          3284  
00003060                          3285  *---------------------------------------------------------------------------*
00003060                          3286  * OP_LSR: decode and display LSR
00003060                          3287  *---------------------------------------------------------------------------*        
00003060  E599                    3288  OP_LSR      ROL.L   #2,D1
00003062  0281 00000003           3289              ANDI.L  #$3,D1
00003068  0C01 0000               3290              CMPI.B  #0,D1
0000306C  6700 0016               3291              BEQ     OP_LSR_B
00003070  0C01 0001               3292              CMPI.B  #$1,D1
00003074  6700 0032               3293              BEQ     OP_LSR_W
00003078  0C01 0002               3294              CMPI.B  #$2,D1
0000307C  6700 0018               3295              BEQ     OP_LSR_L
00003080                          3296              
00003080  4EF8 1750               3297              JMP     OP_DATA
00003084                          3298  
00003084  43F9 0000483E           3299  OP_LSR_B    LEA     DISP_LSR_B,A1
0000308A  103C 000E               3300              MOVE.B  #14,D0
0000308E  4E4F                    3301              TRAP    #15
00003090  183C 0000               3302              MOVE.B  #0,D4
00003094  4E75                    3303              RTS
00003096                          3304  
00003096  43F9 00004862           3305  OP_LSR_L    LEA     DISP_LSR_L,A1
0000309C  103C 000E               3306              MOVE.B  #14,D0
000030A0  4E4F                    3307              TRAP    #15
000030A2  183C 0002               3308              MOVE.B  #2,D4
000030A6  4E75                    3309              RTS
000030A8                          3310  
000030A8  43F9 00004850           3311  OP_LSR_W    LEA     DISP_LSR_W,A1
000030AE  103C 000E               3312              MOVE.B  #14,D0
000030B2  4E4F                    3313              TRAP    #15
000030B4  183C 0001               3314              MOVE.B  #1,D4
000030B8  4E75                    3315              RTS
000030BA                          3316   
000030BA                          3317  *---------------------------------------------------------------------------*
000030BA                          3318  * OP_LSL: decode and display LSL
000030BA                          3319  *---------------------------------------------------------------------------*             
000030BA  E599                    3320  OP_LSL      ROL.L   #2,D1
000030BC  0281 00000003           3321              ANDI.L  #$3,D1
000030C2  0C01 0000               3322              CMPI.B  #0,D1
000030C6  6700 0016               3323              BEQ     OP_LSL_B
000030CA  0C01 0001               3324              CMPI.B  #$1,D1
000030CE  6700 0032               3325              BEQ     OP_LSL_W
000030D2  0C01 0002               3326              CMPI.B  #$2,D1
000030D6  6700 0018               3327              BEQ     OP_LSL_L
000030DA                          3328              
000030DA  4EF8 1750               3329              JMP OP_DATA
000030DE                          3330  
000030DE  43F9 00004847           3331  OP_LSL_B    LEA     DISP_LSL_B,A1
000030E4  103C 000E               3332              MOVE.B  #14,D0
000030E8  4E4F                    3333              TRAP    #15
000030EA  183C 0000               3334              MOVE.B  #0,D4
000030EE  4E75                    3335              RTS
000030F0                          3336  
000030F0  43F9 0000486B           3337  OP_LSL_L    LEA     DISP_LSL_L,A1
000030F6  103C 000E               3338              MOVE.B  #14,D0
000030FA  4E4F                    3339              TRAP    #15
000030FC  183C 0002               3340              MOVE.B  #2,D4
00003100  4E75                    3341              RTS
00003102                          3342  
00003102  43F9 00004859           3343  OP_LSL_W    LEA     DISP_LSL_W,A1
00003108  103C 000E               3344              MOVE.B  #14,D0
0000310C  4E4F                    3345              TRAP    #15
0000310E  183C 0001               3346              MOVE.B  #1,D4
00003112  4E75                    3347              RTS
00003114                          3348   
00003114                          3349  *---------------------------------------------------------------------------*
00003114                          3350  * OP_ASR: decode and display ASR
00003114                          3351  *---------------------------------------------------------------------------*             
00003114  E599                    3352  OP_ASR      ROL.L   #2,D1
00003116  0281 00000003           3353              ANDI.L  #$3,D1
0000311C  0C01 0000               3354              CMPI.B  #0,D1
00003120  6700 0016               3355              BEQ     OP_ASR_B
00003124  0C01 0001               3356              CMPI.B  #$1,D1
00003128  6700 0032               3357              BEQ     OP_ASR_W
0000312C  0C01 0002               3358              CMPI.B  #$2,D1
00003130  6700 0018               3359              BEQ     OP_ASR_L
00003134                          3360              
00003134  4EF8 1750               3361              JMP OP_DATA
00003138                          3362  
00003138  43F9 00004874           3363  OP_ASR_B    LEA     DISP_ASR_B,A1
0000313E  103C 000E               3364              MOVE.B  #14,D0
00003142  4E4F                    3365              TRAP    #15
00003144  183C 0000               3366              MOVE.B  #0,D4
00003148  4E75                    3367              RTS
0000314A                          3368  
0000314A  43F9 00004898           3369  OP_ASR_L    LEA     DISP_ASR_L,A1
00003150  103C 000E               3370              MOVE.B  #14,D0
00003154  4E4F                    3371              TRAP    #15
00003156  183C 0002               3372              MOVE.B  #2,D4
0000315A  4E75                    3373              RTS
0000315C                          3374  
0000315C  43F9 00004886           3375  OP_ASR_W    LEA     DISP_ASR_W,A1
00003162  103C 000E               3376              MOVE.B  #14,D0
00003166  4E4F                    3377              TRAP    #15
00003168  183C 0001               3378              MOVE.B  #1,D4
0000316C  4E75                    3379              RTS
0000316E                          3380       
0000316E                          3381  *---------------------------------------------------------------------------*
0000316E                          3382  * OP_ASL: decode and display ASL
0000316E                          3383  *---------------------------------------------------------------------------*         
0000316E  E599                    3384  OP_ASL      ROL.L   #2,D1
00003170  0281 00000003           3385              ANDI.L  #$3,D1
00003176  0C01 0000               3386              CMPI.B  #0,D1
0000317A  6700 0016               3387              BEQ     OP_ASL_B
0000317E  0C01 0001               3388              CMPI.B  #$1,D1
00003182  6700 0032               3389              BEQ     OP_ASL_W
00003186  0C01 0002               3390              CMPI.B  #$2,D1
0000318A  6700 0018               3391              BEQ     OP_ASL_L
0000318E                          3392              
0000318E  4EF8 1750               3393              JMP OP_DATA
00003192                          3394  
00003192  43F9 0000487D           3395  OP_ASL_B    LEA     DISP_ASL_B,A1
00003198  103C 000E               3396              MOVE.B  #14,D0
0000319C  4E4F                    3397              TRAP    #15
0000319E  183C 0000               3398              MOVE.B  #0,D4
000031A2  4E75                    3399              RTS
000031A4                          3400  
000031A4  43F9 000048A1           3401  OP_ASL_L    LEA     DISP_ASL_L,A1
000031AA  103C 000E               3402              MOVE.B  #14,D0
000031AE  4E4F                    3403              TRAP    #15
000031B0  183C 0002               3404              MOVE.B  #2,D4
000031B4  4E75                    3405              RTS
000031B6                          3406  
000031B6  43F9 0000488F           3407  OP_ASL_W    LEA     DISP_ASL_W,A1
000031BC  103C 000E               3408              MOVE.B  #14,D0
000031C0  4E4F                    3409              TRAP    #15
000031C2  183C 0001               3410              MOVE.B  #1,D4
000031C6  4E75                    3411              RTS
000031C8                          3412   
000031C8                          3413  *---------------------------------------------------------------------------*
000031C8                          3414  * OP_ROR: decode and display ROR
000031C8                          3415  *---------------------------------------------------------------------------*             
000031C8  E599                    3416  OP_ROR      ROL.L   #2,D1
000031CA  0281 00000003           3417              ANDI.L  #$3,D1
000031D0  0C01 0000               3418              CMPI.B  #0,D1
000031D4  6700 0016               3419              BEQ     OP_ROR_B
000031D8  0C01 0001               3420              CMPI.B  #$1,D1
000031DC  6700 0032               3421              BEQ     OP_ROR_W
000031E0  0C01 0002               3422              CMPI.B  #$2,D1
000031E4  6700 0018               3423              BEQ     OP_ROR_L
000031E8                          3424              
000031E8  4EF8 1750               3425              JMP OP_DATA
000031EC                          3426  
000031EC  43F9 000048AA           3427  OP_ROR_B    LEA     DISP_ROR_B,A1
000031F2  103C 000E               3428              MOVE.B  #14,D0
000031F6  4E4F                    3429              TRAP    #15
000031F8  183C 0000               3430              MOVE.B  #0,D4
000031FC  4E75                    3431              RTS
000031FE                          3432  
000031FE  43F9 000048CE           3433  OP_ROR_L    LEA     DISP_ROR_L,A1
00003204  103C 000E               3434              MOVE.B  #14,D0
00003208  4E4F                    3435              TRAP    #15
0000320A  183C 0002               3436              MOVE.B  #2,D4
0000320E  4E75                    3437              RTS
00003210                          3438  
00003210  43F9 000048BC           3439  OP_ROR_W    LEA     DISP_ROR_W,A1
00003216  103C 000E               3440              MOVE.B  #14,D0
0000321A  4E4F                    3441              TRAP    #15
0000321C  183C 0001               3442              MOVE.B  #1,D4
00003220  4E75                    3443              RTS
00003222                          3444  
00003222                          3445  *---------------------------------------------------------------------------*
00003222                          3446  * OP_ROL: decode and display ROL
00003222                          3447  *---------------------------------------------------------------------------*             
00003222  E599                    3448  OP_ROL      ROL.L   #2,D1
00003224  0281 00000003           3449              ANDI.L  #$3,D1
0000322A  0C01 0000               3450              CMPI.B  #0,D1
0000322E  6700 0016               3451              BEQ     OP_ROL_B
00003232  0C01 0001               3452              CMPI.B  #$1,D1
00003236  6700 0032               3453              BEQ     OP_ROL_W
0000323A  0C01 0002               3454              CMPI.B  #$2,D1
0000323E  6700 0018               3455              BEQ     OP_ROL_L
00003242                          3456              
00003242  4EF8 1750               3457              JMP OP_DATA
00003246                          3458  
00003246                          3459  
00003246  43F9 000048B3           3460  OP_ROL_B    LEA     DISP_ROL_B,A1
0000324C  103C 000E               3461              MOVE.B  #14,D0
00003250  4E4F                    3462              TRAP    #15
00003252  183C 0000               3463              MOVE.B  #0,D4
00003256  4E75                    3464              RTS
00003258                          3465  
00003258  43F9 000048D7           3466  OP_ROL_L    LEA     DISP_ROL_L,A1
0000325E  103C 000E               3467              MOVE.B  #14,D0
00003262  4E4F                    3468              TRAP    #15
00003264  183C 0002               3469              MOVE.B  #2,D4
00003268  4E75                    3470              RTS
0000326A                          3471  
0000326A  43F9 000048C5           3472  OP_ROL_W    LEA     DISP_ROL_W,A1
00003270  103C 000E               3473              MOVE.B  #14,D0
00003274  4E4F                    3474              TRAP    #15
00003276  183C 0001               3475              MOVE.B  #1,D4
0000327A  4E75                    3476              RTS
0000327C                          3477              
0000327C                          3478  *---------------------------------------------------------------------------*
0000327C                          3479  * OP1111 : Special reserved
0000327C                          3480  *---------------------------------------------------------------------------*           
0000327C  4EF8 1750               3481  OP1111      JMP     OP_DATA
00003280                          3482  
00003280                          3483  *---------------------------------------------------------------------------*
00003280                          3484  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00003280                          3485  *---------------------------------------------------------------------------*
00003280                          3486  EA_NOSRC    
00003280  4EB9 0000333E           3487              JSR     SRC_MODE
00003286  43F9 000045A4           3488              LEA     ENDLINE_M,A1
0000328C  103C 000E               3489              MOVE.B  #14,D0
00003290  4E4F                    3490              TRAP    #15
00003292  4E75                    3491              RTS
00003294                          3492              
00003294                          3493  *---------------------------------------------------------------------------*
00003294                          3494  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00003294                          3495  *---------------------------------------------------------------------------*
00003294                          3496  EA_ARITH
00003294  4EB9 0000333E           3497              JSR     SRC_MODE
0000329A  43F9 0000491E           3498              LEA     DISP_D,A1
000032A0  103C 000E               3499              MOVE.B  #14,D0
000032A4  4E4F                    3500              TRAP    #15
000032A6  4EB9 000035CA           3501              JSR     DEST_REGISTER
000032AC  43F9 000045A4           3502              LEA     ENDLINE_M,A1
000032B2  103C 000E               3503              MOVE.B  #14,D0
000032B6  4E4F                    3504              TRAP    #15
000032B8  4E75                    3505              RTS
000032BA                          3506              
000032BA                          3507  *---------------------------------------------------------------------------*
000032BA                          3508  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000032BA                          3509  *---------------------------------------------------------------------------*
000032BA                          3510  EA_MOVEA
000032BA  4EB9 0000333E           3511              JSR     SRC_MODE
000032C0  43F9 0000492F           3512              LEA     DISP_AOP,A1
000032C6  103C 000E               3513              MOVE.B  #14,D0
000032CA  4E4F                    3514              TRAP    #15
000032CC  4EB9 000035CA           3515              JSR     DEST_REGISTER
000032D2  43F9 0000492D           3516              LEA     DISP_CP,A1
000032D8  103C 000D               3517              MOVE.B  #13,D0
000032DC  4E4F                    3518              TRAP    #15
000032DE  4E75                    3519              RTS
000032E0                          3520              
000032E0                          3521  *---------------------------------------------------------------------------*
000032E0                          3522  * EA_GEN: decode and display effective addresses for MOVE
000032E0                          3523  *---------------------------------------------------------------------------*
000032E0                          3524  EA_GEN          
000032E0                          3525              * retrieve/display source mode/register
000032E0  4EB9 0000333E           3526              JSR     SRC_MODE
000032E6                          3527              
000032E6                          3528              * retrieve/display destination mode/register
000032E6  4EB9 000032FA           3529              JSR     DEST_MODE
000032EC                          3530              
000032EC  43F9 000045A4           3531              LEA     ENDLINE_M,A1
000032F2  103C 000E               3532              MOVE.B  #14,D0
000032F6  4E4F                    3533              TRAP    #15
000032F8                          3534              
000032F8  4E75                    3535              RTS
000032FA                          3536  
000032FA                          3537  *---------------------------------------------------------------------------*
000032FA                          3538  * DEST_MODE: decode and display destination mode (bit 8 - 6)
000032FA                          3539  *---------------------------------------------------------------------------*           
000032FA                          3540  DEST_MODE   
000032FA                          3541              * clear registers to store temp data
000032FA  4280                    3542              CLR.L   D0                      
000032FC  4281                    3543              CLR.L   D1                      
000032FE  207C 00000000           3544              MOVEA.L #0, A0                  
00003304  227C 00000000           3545              MOVEA.L #0, A1                  
0000330A  2205                    3546              MOVE.L  D5,D1
0000330C  EC89                    3547              LSR.L   #6,D1
0000330E  0281 00000007           3548              ANDI.L  #$7,D1
00003314  0C01 0000               3549              CMPI.B  #0,D1   * Dn
00003318  6700 0082               3550              BEQ     D_MODE000
0000331C  0C01 0002               3551              CMPI.B  #2,D1   * (An)
00003320  6700 00C2               3552              BEQ     D_MODE010
00003324  0C01 0003               3553              CMPI.B  #3,D1   * (An)+
00003328  6700 011A               3554              BEQ     D_MODE011
0000332C  0C01 0004               3555              CMPI.B  #4,D1   * -(An)
00003330  6700 0132               3556              BEQ     D_MODE100
00003334  0C01 0007               3557              CMPI.B  #7,D1  * abs
00003338  6700 017C               3558              BEQ     D_MODE111 
0000333C  4E75                    3559              RTS
0000333E                          3560  
0000333E                          3561  *---------------------------------------------------------------------------*
0000333E                          3562  * SRC_MODE: decode and display source mode (bit 5 - 3)
0000333E                          3563  *---------------------------------------------------------------------------*  
0000333E                          3564  SRC_MODE    
0000333E                          3565              * clear registers to store temp data
0000333E  4280                    3566              CLR.L   D0                      
00003340  4281                    3567              CLR.L   D1                      
00003342  207C 00000000           3568              MOVEA.L #0, A0                  
00003348  227C 00000000           3569              MOVEA.L #0, A1                  
0000334E  2205                    3570              MOVE.L  D5,D1
00003350  E489                    3571              LSR.L   #2,D1
00003352  0281 0000000E           3572              ANDI.L  #$E,D1
00003358                          3573              
00003358  0C01 0000               3574              CMPI.B  #0,D1   * Dn
0000335C  6700 002A               3575              BEQ     MODE000
00003360  0C01 0002               3576              CMPI.B  #2,D1   * An 
00003364  6700 004A               3577              BEQ     MODE001
00003368  0C01 0004               3578              CMPI.B  #4,D1   * (An)
0000336C  6700 0056               3579              BEQ     MODE010
00003370  0C01 0006               3580              CMPI.B  #6,D1   * (An)+
00003374  6700 008E               3581              BEQ     MODE011
00003378  0C01 0008               3582              CMPI.B  #8,D1   * -(An)
0000337C  6700 00A6               3583              BEQ     MODE100
00003380  0C01 000F               3584              CMPI.B  #15,D1  * abs/immediate
00003384  6700 00FE               3585              BEQ     MODE111 
00003388                          3586        
00003388                          3587  *---------------------------------------------------------------------------*
00003388                          3588  * MODE000: decode and display source mode Dn
00003388                          3589  *---------------------------------------------------------------------------*           
00003388                          3590  MODE000     *Dn
00003388  43F9 0000491E           3591              LEA     DISP_D,A1
0000338E  103C 000E               3592              MOVE.B  #14,D0
00003392  4E4F                    3593              TRAP    #15
00003394  4EB9 00003626           3594              JSR     SRC_REGISTER
0000339A  4E75                    3595              RTS
0000339C                          3596  
0000339C                          3597  *---------------------------------------------------------------------------*
0000339C                          3598  * D_MODE000: decode and display dest mode Dn
0000339C                          3599  *---------------------------------------------------------------------------*
0000339C                          3600  D_MODE000     *Dn
0000339C  43F9 0000491E           3601              LEA     DISP_D,A1
000033A2  103C 000E               3602              MOVE.B  #14,D0
000033A6  4E4F                    3603              TRAP    #15
000033A8  4EB9 000035CA           3604              JSR     DEST_REGISTER
000033AE  4E75                    3605              RTS
000033B0                          3606  
000033B0                          3607  *---------------------------------------------------------------------------*
000033B0                          3608  * MODE001: decode and display source mode An
000033B0                          3609  *---------------------------------------------------------------------------* 
000033B0                          3610  MODE001 *An
000033B0  43F9 00004923           3611              LEA     DISP_A,A1
000033B6  103C 000E               3612              MOVE.B  #14,D0
000033BA  4E4F                    3613              TRAP    #15
000033BC  4EB9 00003626           3614              JSR     SRC_REGISTER
000033C2                          3615          
000033C2  4E75                    3616              RTS
000033C4                          3617  
000033C4                          3618  *---------------------------------------------------------------------------*
000033C4                          3619  * MODE010: decode and display source mode (An)
000033C4                          3620  *---------------------------------------------------------------------------*    
000033C4                          3621  MODE010 *(An)
000033C4  43F9 0000492F           3622              LEA     DISP_AOP,A1  *display (A
000033CA  103C 000E               3623              MOVE.B  #14,D0
000033CE  4E4F                    3624              TRAP    #15
000033D0                          3625  
000033D0  4EB9 00003626           3626              JSR     SRC_REGISTER * display register
000033D6                          3627  
000033D6  43F9 0000492D           3628              LEA     DISP_CP,A1   *display )
000033DC  103C 000E               3629              MOVE.B  #14,D0
000033E0  4E4F                    3630              TRAP    #15
000033E2                          3631              
000033E2  4E75                    3632              RTS
000033E4                          3633  
000033E4                          3634  *---------------------------------------------------------------------------*
000033E4                          3635  * D_MODE010: decode and display dest mode (An)
000033E4                          3636  *---------------------------------------------------------------------------*
000033E4                          3637  D_MODE010 *(An)
000033E4  43F9 0000492F           3638              LEA     DISP_AOP,A1  *display (A
000033EA  103C 000E               3639              MOVE.B  #14,D0
000033EE  4E4F                    3640              TRAP    #15
000033F0                          3641     
000033F0  4EB9 000035CA           3642              JSR     DEST_REGISTER * display register
000033F6                          3643  
000033F6  43F9 0000492D           3644              LEA     DISP_CP,A1   *display )
000033FC  103C 000E               3645              MOVE.B  #14,D0
00003400  4E4F                    3646              TRAP    #15
00003402                          3647              
00003402  4E75                    3648              RTS
00003404                          3649  
00003404                          3650  *---------------------------------------------------------------------------*
00003404                          3651  * MODE011: decode and display source mode (An)+
00003404                          3652  *---------------------------------------------------------------------------*
00003404                          3653  MODE011 *(An)+
00003404  43F9 0000492F           3654              LEA     DISP_AOP,A1      *display (A
0000340A  103C 000E               3655              MOVE.B  #14,D0
0000340E  4E4F                    3656              TRAP    #15
00003410                          3657              
00003410  4EB9 00003626           3658              JSR     SRC_REGISTER    * display register
00003416                          3659  
00003416  43F9 0000493C           3660              LEA     DISP_POST,A1    *display )+
0000341C  103C 000E               3661              MOVE.B  #14,D0
00003420  4E4F                    3662              TRAP    #15
00003422                          3663              
00003422  4E75                    3664              RTS
00003424                          3665              
00003424                          3666  *---------------------------------------------------------------------------*
00003424                          3667  * MODE100: decode and display source mode -(An)
00003424                          3668  *---------------------------------------------------------------------------*
00003424                          3669  MODE100 *-(An)
00003424  43F9 00004935           3670              LEA     DISP_PRE,A1    *display -(A
0000342A  103C 000E               3671              MOVE.B  #14,D0
0000342E  4E4F                    3672              TRAP    #15
00003430                          3673  
00003430  4EB9 00003626           3674              JSR     SRC_REGISTER    *display register
00003436                          3675  
00003436  43F9 0000492D           3676              LEA     DISP_CP,A1   *display )
0000343C  103C 000E               3677              MOVE.B  #14,D0
00003440  4E4F                    3678              TRAP    #15
00003442                          3679              
00003442  4E75                    3680              RTS
00003444                          3681  
00003444                          3682  *---------------------------------------------------------------------------*
00003444                          3683  * D_MODE011: decode and display dest mode (An)+
00003444                          3684  *---------------------------------------------------------------------------*
00003444                          3685  D_MODE011 *(An)+
00003444  43F9 0000492F           3686              LEA     DISP_AOP,A1      *display (A
0000344A  103C 000E               3687              MOVE.B  #14,D0
0000344E  4E4F                    3688              TRAP    #15
00003450                          3689  
00003450  4EB9 000035CA           3690              JSR     DEST_REGISTER    * display register
00003456                          3691  
00003456  43F9 0000493C           3692              LEA     DISP_POST,A1    *display )+
0000345C  103C 000E               3693              MOVE.B  #14,D0
00003460  4E4F                    3694              TRAP    #15
00003462                          3695              
00003462  4E75                    3696              RTS
00003464                          3697              
00003464                          3698  *---------------------------------------------------------------------------*
00003464                          3699  * D_MODE100: decode and display dest mode -(An)
00003464                          3700  *---------------------------------------------------------------------------*            
00003464                          3701  D_MODE100 *-(An)
00003464  43F9 00004935           3702              LEA     DISP_PRE,A1    *display -(A
0000346A  103C 000E               3703              MOVE.B  #14,D0
0000346E  4E4F                    3704              TRAP    #15
00003470                          3705              
00003470  4EB9 000035CA           3706              JSR     DEST_REGISTER    *display register
00003476                          3707  
00003476  43F9 0000492D           3708              LEA     DISP_CP,A1   *display )
0000347C  103C 000E               3709              MOVE.B  #14,D0
00003480  4E4F                    3710              TRAP    #15
00003482                          3711              
00003482  4E75                    3712              RTS
00003484                          3713  
00003484                          3714  *---------------------------------------------------------------------------*
00003484                          3715  * MODE111: decode and display source mode absolute/immediate
00003484                          3716  *---------------------------------------------------------------------------*
00003484                          3717  MODE111     * abs/immediate
00003484                          3718              * clear registers to store temp data
00003484  4280                    3719              CLR.L   D0                      
00003486  4281                    3720              CLR.L   D1                      
00003488  207C 00000000           3721              MOVEA.L #0, A0                  
0000348E  227C 00000000           3722              MOVEA.L #0, A1                  
00003494  2205                    3723              MOVE.L  D5,D1
00003496                          3724              
00003496                          3725              * retrieve source register for MODE 111
00003496  E389                    3726              LSL.L   #1,D1   * shift the bits to left by 1
00003498  0281 0000000E           3727              ANDI.L  #$E,D1  * mask the first 4 bits 
0000349E  0C01 0000               3728              CMPI.B  #0, D1  * if it's 0000, absolute word address
000034A2  6700 003E               3729              BEQ     WORDMODE
000034A6  0C01 0002               3730              CMPI.B  #2, D1  * if it's 0010, absolute long address
000034AA  6700 0062               3731              BEQ     LONGMODE
000034AE  0C01 0008               3732              CMPI.B  #8, D1  * if it's 1000, immediate data
000034B2  6700 0086               3733              BEQ     IMMEDIATE
000034B6                          3734       
000034B6                          3735  *---------------------------------------------------------------------------*
000034B6                          3736  * D_MODE111: decode and display dest mode absolute/immediate
000034B6                          3737  *---------------------------------------------------------------------------*           
000034B6                          3738  D_MODE111   * abs
000034B6                          3739              * clear registers to store temp data
000034B6  4280                    3740              CLR.L   D0                      
000034B8  4281                    3741              CLR.L   D1                      
000034BA  207C 00000000           3742              MOVEA.L #0, A0                  
000034C0  227C 00000000           3743              MOVEA.L #0, A1                  
000034C6  2205                    3744              MOVE.L  D5,D1
000034C8                          3745              
000034C8                          3746              * retrieve dest register for MODE 111
000034C8  EC89                    3747              LSR.L   #6,D1   * shift the bits to right by 6
000034CA  E689                    3748              LSR.L   #3,D1   * shift the bits to right by extra 3
000034CC  0201 0001               3749              ANDI.B  #1,D1   * mask the first 2 bits 
000034D0  0C01 0000               3750              CMPI.B  #0, D1  * if it's 000, absolute word address
000034D4  6700 000C               3751              BEQ     WORDMODE
000034D8  0C01 0001               3752              CMPI.B  #1, D1  * if it's 001, absolute long address
000034DC  6700 0030               3753              BEQ     LONGMODE
000034E0                          3754              *JSR     OP_DATA *not sure..
000034E0  4E75                    3755              RTS
000034E2                          3756  
000034E2                          3757  
000034E2                          3758  *---------------------------------------------------------------------------*
000034E2                          3759  * WORDMODE: absolute word address
000034E2                          3760  *---------------------------------------------------------------------------*
000034E2  43F9 00004919           3761  WORDMODE    LEA     DISP_HEX,A1
000034E8  103C 000E               3762              MOVE.B  #14,D0
000034EC  4E4F                    3763              TRAP    #15
000034EE                          3764              
000034EE  4285                    3765              CLR.L   D5
000034F0  3A1D                    3766              MOVE.W  (A5)+,D5
000034F2                          3767              
000034F2  43F9 000045F7           3768              LEA     TMPOUTPUT,A1
000034F8  2205                    3769              MOVE.L  D5,D1
000034FA  7404                    3770              MOVE.L  #4,D2       *move word size 4
000034FC  4EB8 121E               3771              JSR     HEX2ASCII
00003500  43F9 000045F7           3772              LEA     TMPOUTPUT,A1
00003506  103C 000E               3773              MOVE.B  #14,D0
0000350A  4E4F                    3774              TRAP    #15
0000350C                          3775              
0000350C  4E75                    3776              RTS
0000350E                          3777  
0000350E                          3778  *---------------------------------------------------------------------------*
0000350E                          3779  * LONGMODE: absolute long address
0000350E                          3780  *---------------------------------------------------------------------------*
0000350E  43F9 00004919           3781  LONGMODE    LEA     DISP_HEX,A1
00003514  103C 000E               3782              MOVE.B  #14,D0
00003518  4E4F                    3783              TRAP    #15
0000351A                          3784              
0000351A  4285                    3785              CLR.L   D5
0000351C  2A1D                    3786              MOVE.L  (A5)+,D5
0000351E                          3787              
0000351E  43F9 000045F7           3788              LEA     TMPOUTPUT,A1
00003524  2205                    3789              MOVE.L  D5,D1
00003526  7408                    3790              MOVE.L  #8,D2           *move longword size 8
00003528  4EB8 121E               3791              JSR     HEX2ASCII
0000352C  43F9 000045F7           3792              LEA     TMPOUTPUT,A1
00003532  103C 000E               3793              MOVE.B  #14,D0
00003536  4E4F                    3794              TRAP    #15
00003538                          3795              
00003538  4E75                    3796              RTS
0000353A                          3797  
0000353A                          3798  
0000353A                          3799  *---------------------------------------------------------------------------*
0000353A                          3800  * IMMEDIATE: immediate address
0000353A                          3801  *---------------------------------------------------------------------------*
0000353A  43F9 0000493F           3802  IMMEDIATE   LEA     DISP_LB,A1
00003540  103C 000E               3803              MOVE.B  #14,D0
00003544  4E4F                    3804              TRAP    #15
00003546  43F9 00004919           3805              LEA     DISP_HEX,A1
0000354C  103C 000E               3806              MOVE.B  #14,D0
00003550  4E4F                    3807              TRAP    #15
00003552                          3808              
00003552                          3809              * check for size
00003552  0C04 0000               3810              CMPI.B  #0,D4
00003556  6700 0012               3811              BEQ     IMMD_B
0000355A  0C04 0001               3812              CMPI.B  #1,D4
0000355E  6700 002A               3813              BEQ     IMMD_W
00003562  0C04 0002               3814              CMPI.B  #2,D4
00003566  6700 0042               3815              BEQ     IMMD_L
0000356A                          3816  
0000356A                          3817  IMMD_B
0000356A  4285                    3818              CLR.L   D5
0000356C  3A1D                    3819              MOVE.W  (A5)+,D5
0000356E                          3820              
0000356E  43F9 000045F7           3821              LEA     TMPOUTPUT,A1
00003574  2205                    3822              MOVE.L  D5,D1
00003576  7402                    3823              MOVE.L  #2,D2
00003578  4EB8 121E               3824              JSR     HEX2ASCII
0000357C  43F9 000045F7           3825              LEA     TMPOUTPUT,A1
00003582  103C 000E               3826              MOVE.B  #14,D0
00003586  4E4F                    3827              TRAP    #15
00003588  4E75                    3828              RTS
0000358A                          3829              
0000358A                          3830  IMMD_W
0000358A  4285                    3831              CLR.L   D5
0000358C  3A1D                    3832              MOVE.W  (A5)+,D5
0000358E                          3833              
0000358E  43F9 000045F7           3834              LEA     TMPOUTPUT,A1
00003594  2205                    3835              MOVE.L  D5,D1
00003596  7404                    3836              MOVE.L  #4,D2
00003598  4EB8 121E               3837              JSR     HEX2ASCII
0000359C  43F9 000045F7           3838              LEA     TMPOUTPUT,A1
000035A2  103C 000E               3839              MOVE.B  #14,D0
000035A6  4E4F                    3840              TRAP    #15
000035A8  4E75                    3841              RTS
000035AA                          3842              
000035AA                          3843  
000035AA                          3844  IMMD_L
000035AA  4285                    3845              CLR.L   D5
000035AC  3A1D                    3846              MOVE.W  (A5)+,D5
000035AE                          3847              
000035AE  43F9 000045F7           3848              LEA     TMPOUTPUT,A1
000035B4  2205                    3849              MOVE.L  D5,D1
000035B6  7408                    3850              MOVE.L  #8,D2
000035B8  4EB8 121E               3851              JSR     HEX2ASCII
000035BC  43F9 000045F7           3852              LEA     TMPOUTPUT,A1
000035C2  103C 000E               3853              MOVE.B  #14,D0
000035C6  4E4F                    3854              TRAP    #15
000035C8  4E75                    3855              RTS
000035CA                          3856  
000035CA                          3857  
000035CA                          3858  *---------------------------------------------------------------------------*
000035CA                          3859  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000035CA                          3860  *---------------------------------------------------------------------------*
000035CA                          3861  DEST_REGISTER
000035CA                          3862              * clear registers to store temp data
000035CA  4280                    3863              CLR.L   D0                      
000035CC  4281                    3864              CLR.L   D1                      
000035CE  207C 00000000           3865              MOVEA.L #0, A0                  
000035D4  227C 00000000           3866              MOVEA.L #0, A1 
000035DA                          3867              
000035DA  2205                    3868              MOVE.L  D5,D1
000035DC  EC89                    3869              LSR.L   #6,D1
000035DE  E689                    3870              LSR.L   #3,D1
000035E0  0281 00000007           3871              ANDI.L  #7,D1
000035E6                          3872              
000035E6  0C01 0000               3873              CMPI.B  #0,D1
000035EA  6700 0092               3874              BEQ     REG_0
000035EE  0C01 0001               3875              CMPI.B  #1,D1
000035F2  6700 0098               3876              BEQ     REG_1
000035F6  0C01 0002               3877              CMPI.B  #2,D1
000035FA  6700 009E               3878              BEQ     REG_2
000035FE  0C01 0003               3879              CMPI.B  #3,D1
00003602  6700 00A4               3880              BEQ     REG_3
00003606  0C01 0004               3881              CMPI.B  #4,D1
0000360A  6700 00AA               3882              BEQ     REG_4
0000360E  0C01 0005               3883              CMPI.B  #5,D1
00003612  6700 00B0               3884              BEQ     REG_5
00003616  0C01 0006               3885              CMPI.B  #6,D1
0000361A  6700 00B6               3886              BEQ     REG_6
0000361E  0C01 0007               3887              CMPI.B  #7,D1
00003622  6700 00BC               3888              BEQ     REG_7
00003626                          3889  
00003626                          3890  *---------------------------------------------------------------------------*
00003626                          3891  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003626                          3892  *---------------------------------------------------------------------------*           
00003626                          3893  SRC_REGISTER 
00003626                          3894              * clear registers to store temp data
00003626  4280                    3895              CLR.L   D0                      
00003628  4281                    3896              CLR.L   D1                      
0000362A  207C 00000000           3897              MOVEA.L #0, A0                  
00003630  227C 00000000           3898              MOVEA.L #0, A1                  
00003636                          3899              
00003636  2205                    3900              MOVE.L  D5,D1   * temp store the processing data
00003638  0281 00000007           3901              ANDI.L  #7,D1   * mask the first 4 bits with 0111
0000363E                          3902              
0000363E  0C01 0000               3903              CMPI.B  #0,D1
00003642  6700 003A               3904              BEQ     REG_0
00003646  0C01 0001               3905              CMPI.B  #1,D1
0000364A  6700 0040               3906              BEQ     REG_1
0000364E  0C01 0002               3907              CMPI.B  #2,D1
00003652  6700 0046               3908              BEQ     REG_2
00003656  0C01 0003               3909              CMPI.B  #3,D1
0000365A  6700 004C               3910              BEQ     REG_3
0000365E  0C01 0004               3911              CMPI.B  #4,D1
00003662  6700 0052               3912              BEQ     REG_4
00003666  0C01 0005               3913              CMPI.B  #5,D1
0000366A  6700 0058               3914              BEQ     REG_5
0000366E  0C01 0006               3915              CMPI.B  #6,D1
00003672  6700 005E               3916              BEQ     REG_6
00003676  0C01 0007               3917              CMPI.B  #7,D1
0000367A  6700 0064               3918              BEQ     REG_7
0000367E                          3919  
0000367E                          3920  *---------------------------------------------------------------------------*
0000367E                          3921  * REG_0 ~ REG_7: display register 0 to 7
0000367E                          3922  *---------------------------------------------------------------------------*
0000367E  43F9 00004944           3923  REG_0       LEA     DISP_0,A1
00003684  103C 000E               3924              MOVE.B  #14,D0
00003688  4E4F                    3925              TRAP    #15
0000368A  4E75                    3926              RTS
0000368C                          3927              
0000368C  43F9 00004946           3928  REG_1       LEA     DISP_1,A1
00003692  103C 000E               3929              MOVE.B  #14,D0
00003696  4E4F                    3930              TRAP    #15
00003698  4E75                    3931              RTS
0000369A                          3932              
0000369A                          3933  
0000369A  43F9 00004948           3934  REG_2       LEA     DISP_2,A1
000036A0  103C 000E               3935              MOVE.B  #14,D0
000036A4  4E4F                    3936              TRAP    #15
000036A6  4E75                    3937              RTS
000036A8                          3938            
000036A8  43F9 0000494A           3939  REG_3       LEA     DISP_3,A1
000036AE  103C 000E               3940              MOVE.B  #14,D0
000036B2  4E4F                    3941              TRAP    #15
000036B4  4E75                    3942              RTS
000036B6                          3943              
000036B6  43F9 0000494C           3944  REG_4       LEA     DISP_4,A1
000036BC  103C 000E               3945              MOVE.B  #14,D0
000036C0  4E4F                    3946              TRAP    #15
000036C2  4E75                    3947              RTS
000036C4                          3948              
000036C4  43F9 0000494E           3949  REG_5       LEA     DISP_5,A1
000036CA  103C 000E               3950              MOVE.B  #14,D0
000036CE  4E4F                    3951              TRAP    #15
000036D0  4E75                    3952              RTS
000036D2                          3953              
000036D2  43F9 00004950           3954  REG_6       LEA     DISP_6,A1
000036D8  103C 000E               3955              MOVE.B  #14,D0
000036DC  4E4F                    3956              TRAP    #15
000036DE  4E75                    3957              RTS
000036E0                          3958              
000036E0  43F9 00004952           3959  REG_7       LEA     DISP_7,A1
000036E6  103C 000E               3960              MOVE.B  #14,D0
000036EA  4E4F                    3961              TRAP    #15
000036EC  4E75                    3962              RTS
000036EE                          3963              
000036EE                          3964  *---------------------------------------------------------------------------*
000036EE                          3965  * REPEAT : Ask user whether they wish to run the program again
000036EE                          3966  *---------------------------------------------------------------------------*           
000036EE  4246                    3967  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
000036F0  43F9 0000441D           3968              LEA     REPEATMSG,A1
000036F6  103C 000E               3969              MOVE.B  #14,D0
000036FA  4E4F                    3970              TRAP    #15
000036FC                          3971              
000036FC  43F9 000045A7           3972              LEA     TMPINPUT,A1             * allocate space to temp store user input
00003702  103C 0002               3973              MOVE.B  #2,D0
00003706  4E4F                    3974              TRAP    #15
00003708                          3975  
00003708  0C01 0001               3976              CMPI.B  #1,D1                   * check for length of user input
0000370C  66E0                    3977              BNE     REPEAT                  * return to the beginning of the function if unequal
0000370E                          3978              
0000370E  0C11 0059               3979              CMPI.B  #$59,(A1)               * compare the input with Y    
00003712  6700 D8F6               3980              BEQ     PROGLP                  * repeat the program
00003716                          3981              
00003716  0C11 0079               3982              CMPI.B  #$79,(A1)               * compare the input with y    
0000371A  6700 D8EE               3983              BEQ     PROGLP                  * repeat the program
0000371E                          3984              
0000371E  0C11 004E               3985              CMPI.B  #$4E,(A1)               * compare the input with N    
00003722  6700 098C               3986              BEQ     TERMINATE               * finish program
00003726                          3987              
00003726  0C11 006E               3988              CMPI.B  #$6E,(A1)               * compare the input with n    
0000372A  6700 0984               3989              BEQ     TERMINATE               * finish program
0000372E                          3990              
0000372E  60BE                    3991              BRA     REPEAT                  * invalid input/repeat the function
00003730                          3992  
00003730                          3993  *---------------------------------------------------------------------------*
00003730                          3994  * EA DECODING INTERFACE
00003730                          3995  * [A0] - RESERVED FOR USE
00003730                          3996  * [D2] - RESERVED FOR USE
00003730                          3997  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00003730                          3998  *---------------------------------------------------------------------------*
00003730                          3999  GET_EA_EA_SRC
00003730                          4000      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003730                          4001      
00003730                          4002      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003730  2405                    4003      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003732  E68A                    4004      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00003734  23C2 0000496A           4005      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
0000373A  7407                    4006      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
0000373C  C5B9 0000496A           4007      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003742                          4008                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003742                          4009      
00003742                          4010      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003742                          4011      *DESTINATION REGISTER FORMAT STANDARD         *
00003742                          4012      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003742                          4013      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003742                          4014      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003742                          4015      *0 - Dn                                       *
00003742                          4016      *1 - An                                       *
00003742                          4017      *2 - (An)                                     *
00003742                          4018      *3 - (An)+                                    *
00003742                          4019      *4 - -(An)                                    *
00003742                          4020      *5 - (XXX).W                                  *
00003742                          4021      *6 - (XXX).L                                  *
00003742                          4022      *7 - #<data>                                  *
00003742                          4023      ***********************************************
00003742                          4024      
00003742                          4025      *** Check if source ...  <ea> = Dn
00003742                          4026  CHECK0    
00003742  41F9 0000495A           4027            LEA     TEMP_REGISTER_FORMAT,A0
00003748  1439 00004959           4028            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000374E  1082                    4029            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003750  0239 0001 0000495A      4030            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003758  0C39 0001 0000495A      4031            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003760  6700 006A               4032            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003764  0CB9 00000000 0000496A  4033            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
0000376E  6600 005C               4034            BNE     CHECK1
00003772                          4035            
00003772                          4036            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003772  163C 0020               4037            MOVE.B    #' ',D3
00003776  6100 0856               4038            BSR       PUSH_STACK
0000377A  163C 0044               4039            MOVE.B    #'D',D3
0000377E  6100 084E               4040            BSR       PUSH_STACK
00003782                          4041  
00003782                          4042            *FIND REGISTER NUMBER END LOCATION*  
00003782  13F9 0000495C 00004962  4043            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000378C  0239 000F 00004962      4044            AND.B   #$0F,VAR_BYTE_END
00003794                          4045            
00003794                          4046            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003794  23C5 00004966           4047            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000379A  1439 00004962           4048            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000037A0                          4049            
000037A0                          4050            *INTITIALIZE FOR BIT SHIFTING
000037A0  41F9 00004966           4051            LEA     VAR_TEMP_CLEANCOPY,A0
000037A6  2639 00004966           4052            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037AC                          4053  LOOP_SHIFTING
000037AC  0C02 0000               4054            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037B0  6700 0008               4055            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000037B4  E24B                    4056            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037B6  5302                    4057            SUB.B   #1,D2                     *DECREMENT COUNTER
000037B8  60F2                    4058            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000037BA                          4059  MASKING_NEXT
000037BA  C6BC 00000007           4060            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037C0  0603 0030               4061            ADD.B   #$30,D3                   *CONVERT TO CHAR
000037C4  6100 0808               4062            BSR     PUSH_STACK                *PUSH TO STACK
000037C8                          4063            
000037C8  6000 0394               4064            BRA     GET_SRC_SUCCESS           *RETURN          
000037CC                          4065            
000037CC                          4066            
000037CC                          4067            *** Check if source ...  <ea> = An
000037CC  41F9 0000495A           4068  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000037D2  1439 00004959           4069            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037D8  1082                    4070            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037DA  0239 0002 0000495A      4071            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000037E2  0C39 0002 0000495A      4072            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000037EA  6700 006A               4073            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000037EE  0CB9 00000001 0000496A  4074            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
000037F8  6600 005C               4075            BNE     CHECK2
000037FC                          4076            
000037FC                          4077            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000037FC  163C 0020               4078            MOVE.B    #' ',D3
00003800  6100 07CC               4079            BSR       PUSH_STACK
00003804  163C 0041               4080            MOVE.B    #'A',D3
00003808  6100 07C4               4081            BSR       PUSH_STACK
0000380C                          4082  
0000380C                          4083            
0000380C                          4084            *FIND REGISTER NUMBER END LOCATION*  
0000380C  13F9 0000495C 00004962  4085            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003816  0239 000F 00004962      4086            AND.B   #$0F,VAR_BYTE_END
0000381E                          4087            
0000381E                          4088            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000381E  23C5 00004966           4089            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003824  1439 00004962           4090            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
0000382A                          4091            
0000382A                          4092            *INTITIALIZE FOR BIT SHIFTING
0000382A  41F9 00004966           4093            LEA     VAR_TEMP_CLEANCOPY,A0
00003830  2639 00004966           4094            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003836                          4095  LOOP_SHIFTING1
00003836  0C02 0000               4096            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000383A  6700 0008               4097            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000383E  E24B                    4098            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003840  5302                    4099            SUB.B   #1,D2                     *DECREMENT COUNTER
00003842  60F2                    4100            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003844                          4101  MASKING_NEXT1
00003844  C6BC 00000007           4102            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000384A  0603 0030               4103            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000384E  6100 077E               4104            BSR     PUSH_STACK                *PUSH TO STACK
00003852                          4105            
00003852  6000 030A               4106            BRA     GET_SRC_SUCCESS                   *RETURN 
00003856                          4107            
00003856                          4108            
00003856                          4109            
00003856                          4110            
00003856                          4111            *** Check if source ...  <ea> = (An)       
00003856  41F9 0000495A           4112  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
0000385C  1439 00004959           4113            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003862  1082                    4114            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003864  0239 0004 0000495A      4115            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
0000386C  0C39 0004 0000495A      4116            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003874  6700 007A               4117            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003878  0CB9 00000002 0000496A  4118            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003882  6600 006C               4119            BNE     CHECK3
00003886                          4120            
00003886                          4121            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003886  163C 0020               4122            MOVE.B    #' ',D3
0000388A  6100 0742               4123            BSR       PUSH_STACK
0000388E  163C 0028               4124            MOVE.B    #'(',D3
00003892  6100 073A               4125            BSR       PUSH_STACK
00003896  163C 0041               4126            MOVE.B    #'A',D3
0000389A  6100 0732               4127            BSR       PUSH_STACK
0000389E                          4128  
0000389E                          4129            
0000389E                          4130            *FIND REGISTER NUMBER END LOCATION*  
0000389E  13F9 0000495C 00004962  4131            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038A8  0239 000F 00004962      4132            AND.B   #$0F,VAR_BYTE_END
000038B0                          4133            
000038B0                          4134            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038B0  23C5 00004966           4135            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038B6  1439 00004962           4136            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038BC                          4137            
000038BC                          4138            *INTITIALIZE FOR BIT SHIFTING
000038BC  41F9 00004966           4139            LEA     VAR_TEMP_CLEANCOPY,A0
000038C2  2639 00004966           4140            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038C8                          4141  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000038C8  0C02 0000               4142            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038CC  6700 0008               4143            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000038D0  E24B                    4144            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000038D2  5302                    4145            SUB.B   #1,D2                     *DECREMENT COUNTER
000038D4  60F2                    4146            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000038D6                          4147  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000038D6  0283 00000007           4148            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000038DC  0603 0030               4149            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000038E0  6100 06EC               4150            BSR     PUSH_STACK                *PUSH TO STACK
000038E4                          4151            
000038E4  163C 0029               4152            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000038E8  6100 06E4               4153            BSR       PUSH_STACK
000038EC                          4154            
000038EC  6000 0270               4155            BRA     GET_SRC_SUCCESS                   *RETURN 
000038F0                          4156  
000038F0                          4157            
000038F0                          4158            
000038F0                          4159                      
000038F0                          4160  *** Check if source ...  <ea> = (An)+       
000038F0  41F9 0000495A           4161  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000038F6  1439 00004959           4162            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000038FC  1082                    4163            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000038FE  0239 0008 0000495A      4164            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003906  0C39 0008 0000495A      4165            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
0000390E  6700 0082               4166            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003912  0CB9 00000003 0000496A  4167            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000391C  6600 0074               4168            BNE     CHECK4
00003920                          4169            
00003920                          4170            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003920  163C 0020               4171            MOVE.B    #' ',D3
00003924  6100 06A8               4172            BSR       PUSH_STACK
00003928  163C 0028               4173            MOVE.B    #'(',D3
0000392C  6100 06A0               4174            BSR       PUSH_STACK
00003930  163C 0041               4175            MOVE.B    #'A',D3
00003934  6100 0698               4176            BSR       PUSH_STACK
00003938                          4177  
00003938                          4178            
00003938                          4179            *FIND REGISTER NUMBER END LOCATION*  
00003938  13F9 0000495C 00004962  4180            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003942  0239 000F 00004962      4181            ANDI.B   #$0F,VAR_BYTE_END
0000394A                          4182            
0000394A                          4183            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000394A  23C5 00004966           4184            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003950  1439 00004962           4185            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003956                          4186            
00003956                          4187            *INTITIALIZE FOR BIT SHIFTING
00003956  41F9 00004966           4188            LEA     VAR_TEMP_CLEANCOPY,A0
0000395C  2639 00004966           4189            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003962                          4190            
00003962                          4191  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003962  0C02 0000               4192            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003966  6700 0008               4193            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000396A  E24B                    4194            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000396C  5302                    4195            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000396E  60F2                    4196            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003970                          4197                                               *change: NAME OF LABEL*
00003970                          4198  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003970  0283 00000007           4199            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003976  0603 0030               4200            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000397A  6100 0652               4201            BSR     PUSH_STACK                *PUSH TO STACK
0000397E                          4202            
0000397E  163C 0029               4203            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003982  6100 064A               4204            BSR       PUSH_STACK
00003986  163C 002B               4205            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000398A  6100 0642               4206            BSR       PUSH_STACK
0000398E                          4207            
0000398E  6000 01CE               4208            BRA       GET_SRC_SUCCESS                   *RETURN 
00003992                          4209  
00003992                          4210            
00003992                          4211            
00003992                          4212                      
00003992                          4213            *** Check if source ...  <ea> = -(An)       
00003992  41F9 0000495A           4214  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003998  1439 00004959           4215            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000399E  1082                    4216            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039A0  0239 0010 0000495A      4217            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000039A8  0C39 0010 0000495A      4218            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039B0  6700 0082               4219            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000039B4  0CB9 00000004 0000496A  4220            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000039BE  6600 0074               4221            BNE     CHECK7
000039C2                          4222            
000039C2                          4223            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000039C2  163C 0020               4224            MOVE.B    #' ',D3
000039C6  6100 0606               4225            BSR       PUSH_STACK
000039CA  163C 002D               4226            MOVE.B    #'-',D3
000039CE  6100 05FE               4227            BSR       PUSH_STACK
000039D2  163C 0028               4228            MOVE.B    #'(',D3
000039D6  6100 05F6               4229            BSR       PUSH_STACK
000039DA  163C 0041               4230            MOVE.B    #'A',D3
000039DE  6100 05EE               4231            BSR       PUSH_STACK
000039E2                          4232  
000039E2                          4233            
000039E2                          4234            *FIND REGISTER NUMBER END LOCATION*  
000039E2  13F9 0000495C 00004962  4235            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000039EC  0239 000F 00004962      4236            AND.B   #$0F,VAR_BYTE_END
000039F4                          4237            
000039F4                          4238            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000039F4  23C5 00004966           4239            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000039FA  1439 00004962           4240            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A00                          4241            
00003A00                          4242            *INTITIALIZE FOR BIT SHIFTING
00003A00  41F9 00004966           4243            LEA     VAR_TEMP_CLEANCOPY,A0
00003A06  2639 00004966           4244            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003A0C                          4245            
00003A0C                          4246  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003A0C  0C02 0000               4247            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A10  6700 0008               4248            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003A14  E24B                    4249            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A16  5302                    4250            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003A18  60F2                    4251            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003A1A                          4252                                               *change: NAME OF LABEL*
00003A1A                          4253  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003A1A  0283 00000007           4254            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A20  0603 0030               4255            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003A24  6100 05A8               4256            BSR     PUSH_STACK                *PUSH TO STACK
00003A28                          4257            
00003A28  163C 0029               4258            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003A2C  6100 05A0               4259            BSR       PUSH_STACK
00003A30                          4260            
00003A30  6000 012C               4261            BRA     GET_SRC_SUCCESS                   *RETURN
00003A34                          4262            
00003A34                          4263                      
00003A34                          4264            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003A34  0CB9 00000007 0000496A  4265  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003A3E  6600 011A               4266            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003A42                          4267                   
00003A42                          4268            *NEXT: (MODE == 111) 
00003A42                          4269            *NOW: CHECK FOR SRC REGISTER 
00003A42                          4270                  *(000 = (xxx).W)
00003A42                          4271                  *(001 = (xxx).L)
00003A42                          4272                  *(010 = #<data>)
00003A42                          4273                  
00003A42                          4274            *FIND REGISTER NUMBER END LOCATION*  
00003A42  13F9 0000495C 00004962  4275            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A4C  0239 000F 00004962      4276            AND.B   #$0F,VAR_BYTE_END
00003A54                          4277            
00003A54                          4278            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A54  23C5 00004966           4279            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A5A  1439 00004962           4280            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A60                          4281            
00003A60                          4282            *INTITIALIZE FOR BIT SHIFTING
00003A60  41F9 00004966           4283            LEA     VAR_TEMP_CLEANCOPY,A0
00003A66  2C39 00004966           4284            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003A6C                          4285  SRC_LOOP_SHIFTING
00003A6C  0C02 0000               4286            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A70  6700 0008               4287            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003A74  E24E                    4288            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A76  5302                    4289            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A78  60F2                    4290            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003A7A                          4291  SRC_MASKING_NEXT
00003A7A  CCBC 00000007           4292            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003A80                          4293           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003A80                          4294           
00003A80                          4295  CHECK_WORD  
00003A80  41F9 0000495A           4296            LEA     TEMP_REGISTER_FORMAT,A0
00003A86  1439 00004959           4297            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A8C  1082                    4298            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A8E  0239 0020 0000495A      4299            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003A96  0C39 0020 0000495A      4300            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A9E  6700 0026               4301            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003AA2  0C06 0000               4302            CMPI.B  #0,D6                          
00003AA6  6600 001E               4303            BNE     CHECK_LONG 
00003AAA                          4304            
00003AAA                          4305            *IT IS A WORD AT THIS POINT*
00003AAA                          4306            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003AAA  163C 0020               4307            MOVE.B    #' ',D3
00003AAE  6100 051E               4308            BSR       PUSH_STACK
00003AB2  163C 0024               4309            MOVE.B    #'$',D3
00003AB6  6100 0516               4310            BSR       PUSH_STACK
00003ABA  321D                    4311            MOVE.W    (A5)+,D1
00003ABC  7404                    4312            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003ABE  6100 D7A0               4313            BSR       HEX2ASCII2STACK
00003AC2  6000 009A               4314            BRA     GET_SRC_SUCCESS
00003AC6                          4315  
00003AC6                          4316  CHECK_LONG
00003AC6  41F9 0000495A           4317            LEA     TEMP_REGISTER_FORMAT,A0
00003ACC  1439 00004959           4318            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AD2  1082                    4319            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AD4  0239 0040 0000495A      4320            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003ADC  0C39 0040 0000495A      4321            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003AE4  6700 002E               4322            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003AE8  0C06 0001               4323            CMPI.B  #1,D6                          
00003AEC  6600 0026               4324            BNE     CHECK_IMMEDIATE  
00003AF0                          4325  
00003AF0                          4326            *IT IS A WORD AT THIS POINT*
00003AF0                          4327            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003AF0  163C 0020               4328            MOVE.B    #' ',D3
00003AF4  6100 04D8               4329            BSR       PUSH_STACK
00003AF8  163C 0024               4330            MOVE.B    #'$',D3
00003AFC  6100 04D0               4331            BSR       PUSH_STACK
00003B00  321D                    4332            MOVE.W    (A5)+,D1
00003B02  7404                    4333            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B04  6100 D75A               4334            BSR       HEX2ASCII2STACK
00003B08  321D                    4335            MOVE.W    (A5)+,D1
00003B0A  7404                    4336            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B0C  6100 D752               4337            BSR       HEX2ASCII2STACK
00003B10  6000 004C               4338            BRA     GET_SRC_SUCCESS
00003B14                          4339            
00003B14                          4340  CHECK_IMMEDIATE
00003B14  41F9 0000495A           4341            LEA     TEMP_REGISTER_FORMAT,A0
00003B1A  1439 00004959           4342            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B20  1082                    4343            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B22  0239 0080 0000495A      4344            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003B2A  0C39 0080 0000495A      4345            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B32  6700 0026               4346            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003B36  0C06 0004               4347            CMPI.B  #4,D6                          
00003B3A  6600 001E               4348            BNE     GET_SRC_FAILED 
00003B3E                          4349  
00003B3E                          4350            *IT IS A WORD AT THIS POINT*
00003B3E                          4351            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B3E  163C 0020               4352            MOVE.B    #' ',D3
00003B42  6100 048A               4353            BSR       PUSH_STACK
00003B46  163C 0023               4354            MOVE.B    #'#',D3
00003B4A  6100 0482               4355            BSR       PUSH_STACK
00003B4E  321D                    4356            MOVE.W    (A5)+,D1
00003B50  7404                    4357            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B52  6100 D70C               4358            BSR       HEX2ASCII2STACK
00003B56  6000 0006               4359            BRA     GET_SRC_SUCCESS
00003B5A                          4360            
00003B5A                          4361  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003B5A  7801                    4362            MOVE.L #1,D4
00003B5C  4E75                    4363            RTS
00003B5E                          4364  GET_SRC_SUCCESS 
00003B5E  4E75                    4365            RTS
00003B60                          4366                                 
00003B60                          4367      
00003B60                          4368  
00003B60                          4369  
00003B60                          4370  
00003B60                          4371  
00003B60                          4372  
00003B60                          4373  
00003B60                          4374  GET_EA_EA_DEST
00003B60                          4375  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003B60                          4376      
00003B60                          4377      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003B60  2405                    4378      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003B62  EC8A                    4379      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003B64  23C2 0000496A           4380      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003B6A  7407                    4381      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003B6C  C5B9 0000496A           4382      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003B72                          4383                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003B72                          4384      
00003B72                          4385      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003B72                          4386      *DESTINATION REGISTER FORMAT STANDARD         *
00003B72                          4387      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003B72                          4388      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003B72                          4389      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003B72                          4390      *0 - Dn                                       *
00003B72                          4391      *1 - An                                       *
00003B72                          4392      *2 - (An)                                     *
00003B72                          4393      *3 - (An)+                                    *
00003B72                          4394      *4 - -(An)                                    *
00003B72                          4395      *5 - (XXX).W                                  *
00003B72                          4396      *6 - (XXX).L                                  *
00003B72                          4397      *7 - #<data>                                  *
00003B72                          4398      ***********************************************
00003B72                          4399      
00003B72                          4400      *** Check if source ...  <ea> = Dn
00003B72                          4401  DEST_CHECK0    
00003B72  41F9 0000495A           4402            LEA     TEMP_REGISTER_FORMAT,A0
00003B78  1439 00004958           4403            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B7E  1082                    4404            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B80  0239 0001 0000495A      4405            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003B88  0C39 0001 0000495A      4406            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003B90  6700 006A               4407            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003B94  0CB9 00000000 0000496A  4408            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B9E  6600 005C               4409            BNE     DEST_CHECK1
00003BA2                          4410            
00003BA2                          4411            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003BA2  163C 0020               4412            MOVE.B    #' ',D3
00003BA6  6100 0426               4413            BSR       PUSH_STACK
00003BAA  163C 0044               4414            MOVE.B    #'D',D3
00003BAE  6100 041E               4415            BSR       PUSH_STACK
00003BB2                          4416  
00003BB2                          4417            *FIND REGISTER NUMBER END LOCATION*  
00003BB2  13F9 0000495B 00004962  4418            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BBC  0239 000F 00004962      4419            AND.B   #$0F,VAR_BYTE_END
00003BC4                          4420            
00003BC4                          4421            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BC4  23C5 00004966           4422            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BCA  1439 00004962           4423            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003BD0                          4424            
00003BD0                          4425            *INTITIALIZE FOR BIT SHIFTING
00003BD0  41F9 00004966           4426            LEA     VAR_TEMP_CLEANCOPY,A0
00003BD6  2639 00004966           4427            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003BDC                          4428  DEST_LOOP_SHIFTING
00003BDC  0C02 0000               4429            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003BE0  6700 0008               4430            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003BE4  E24B                    4431            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003BE6  5302                    4432            SUB.B   #1,D2                     *DECREMENT COUNTER
00003BE8  60F2                    4433            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003BEA                          4434  DEST_MASKING_NEXT
00003BEA  C6BC 00000007           4435            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003BF0  0603 0030               4436            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003BF4  6100 03D8               4437            BSR     PUSH_STACK                *PUSH TO STACK
00003BF8                          4438            
00003BF8  6000 0394               4439            BRA     GET_DST_SUCCESS           *RETURN          
00003BFC                          4440            
00003BFC                          4441            
00003BFC                          4442            *** Check if source ...  <ea> = An
00003BFC                          4443  DEST_CHECK1    
00003BFC  41F9 0000495A           4444            LEA     TEMP_REGISTER_FORMAT,A0
00003C02  1439 00004958           4445            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C08  1082                    4446            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C0A  0239 0002 0000495A      4447            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003C12  0C39 0002 0000495A      4448            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003C1A  6700 006A               4449            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003C1E  0CB9 00000001 0000496A  4450            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003C28  6600 005C               4451            BNE     DEST_CHECK2
00003C2C                          4452            
00003C2C                          4453            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003C2C  163C 0020               4454            MOVE.B    #' ',D3
00003C30  6100 039C               4455            BSR       PUSH_STACK
00003C34  163C 0041               4456            MOVE.B    #'A',D3
00003C38  6100 0394               4457            BSR       PUSH_STACK
00003C3C                          4458  
00003C3C                          4459            
00003C3C                          4460            *FIND REGISTER NUMBER END LOCATION*  
00003C3C  13F9 0000495B 00004962  4461            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C46  0239 000F 00004962      4462            AND.B   #$0F,VAR_BYTE_END
00003C4E                          4463            
00003C4E                          4464            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C4E  23C5 00004966           4465            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C54  1439 00004962           4466            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003C5A                          4467            
00003C5A                          4468            *INTITIALIZE FOR BIT SHIFTING
00003C5A  41F9 00004966           4469            LEA     VAR_TEMP_CLEANCOPY,A0
00003C60  2639 00004966           4470            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C66                          4471  DEST_LOOP_SHIFTING1
00003C66  0C02 0000               4472            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C6A  6700 0008               4473            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C6E  E24B                    4474            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C70  5302                    4475            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C72  60F2                    4476            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003C74                          4477  DEST_MASKING_NEXT1
00003C74  C6BC 00000007           4478            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C7A  0603 0030               4479            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003C7E  6100 034E               4480            BSR     PUSH_STACK                *PUSH TO STACK
00003C82                          4481            
00003C82  6000 030A               4482            BRA     GET_DST_SUCCESS                   *RETURN 
00003C86                          4483            
00003C86                          4484            
00003C86                          4485            
00003C86                          4486            
00003C86                          4487            *** Check if source ...  <ea> = (An)       
00003C86                          4488  DEST_CHECK2    
00003C86  41F9 0000495A           4489            LEA     TEMP_REGISTER_FORMAT,A0
00003C8C  1439 00004958           4490            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C92  1082                    4491            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C94  0239 0004 0000495A      4492            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003C9C  0C39 0004 0000495A      4493            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CA4  6700 007A               4494            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CA8  0CB9 00000002 0000496A  4495            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003CB2  6600 006C               4496            BNE     DEST_CHECK3
00003CB6                          4497            
00003CB6                          4498            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CB6  163C 0020               4499            MOVE.B    #' ',D3
00003CBA  6100 0312               4500            BSR       PUSH_STACK
00003CBE  163C 0028               4501            MOVE.B    #'(',D3
00003CC2  6100 030A               4502            BSR       PUSH_STACK
00003CC6  163C 0041               4503            MOVE.B    #'A',D3
00003CCA  6100 0302               4504            BSR       PUSH_STACK
00003CCE                          4505  
00003CCE                          4506            
00003CCE                          4507            *FIND REGISTER NUMBER END LOCATION*  
00003CCE  13F9 0000495B 00004962  4508            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003CD8  0239 000F 00004962      4509            AND.B   #$0F,VAR_BYTE_END
00003CE0                          4510            
00003CE0                          4511            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003CE0  23C5 00004966           4512            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003CE6  1439 00004962           4513            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003CEC                          4514            
00003CEC                          4515            *INTITIALIZE FOR BIT SHIFTING
00003CEC  41F9 00004966           4516            LEA     VAR_TEMP_CLEANCOPY,A0
00003CF2  2639 00004966           4517            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003CF8                          4518  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003CF8  0C02 0000               4519            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003CFC  6700 0008               4520            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D00  E24B                    4521            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D02  5302                    4522            SUB.B   #1,D2                     *DECREMENT COUNTER
00003D04  60F2                    4523            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003D06                          4524  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003D06  0283 00000007           4525            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D0C  0603 0030               4526            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D10  6100 02BC               4527            BSR     PUSH_STACK                *PUSH TO STACK
00003D14                          4528            
00003D14  163C 0029               4529            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D18  6100 02B4               4530            BSR       PUSH_STACK
00003D1C                          4531            
00003D1C  6000 0270               4532            BRA     GET_DST_SUCCESS                   *RETURN 
00003D20                          4533  
00003D20                          4534            
00003D20                          4535            
00003D20                          4536                      
00003D20                          4537  *** Check if source ...  <ea> = (An)+       
00003D20  41F9 0000495A           4538  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003D26  1439 00004958           4539            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D2C  1082                    4540            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D2E  0239 0008 0000495A      4541            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003D36  0C39 0008 0000495A      4542            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D3E  6700 0082               4543            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003D42  0CB9 00000003 0000496A  4544            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003D4C  6600 0074               4545            BNE     DEST_CHECK4
00003D50                          4546            
00003D50                          4547            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003D50  163C 0020               4548            MOVE.B    #' ',D3
00003D54  6100 0278               4549            BSR       PUSH_STACK
00003D58  163C 0028               4550            MOVE.B    #'(',D3
00003D5C  6100 0270               4551            BSR       PUSH_STACK
00003D60  163C 0041               4552            MOVE.B    #'A',D3
00003D64  6100 0268               4553            BSR       PUSH_STACK
00003D68                          4554  
00003D68                          4555            
00003D68                          4556            *FIND REGISTER NUMBER END LOCATION*  
00003D68  13F9 0000495B 00004962  4557            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D72  0239 000F 00004962      4558            ANDI.B   #$0F,VAR_BYTE_END
00003D7A                          4559            
00003D7A                          4560            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D7A  23C5 00004966           4561            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D80  1439 00004962           4562            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D86                          4563            
00003D86                          4564            *INTITIALIZE FOR BIT SHIFTING
00003D86  41F9 00004966           4565            LEA     VAR_TEMP_CLEANCOPY,A0
00003D8C  2639 00004966           4566            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D92                          4567            
00003D92                          4568  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003D92  0C02 0000               4569            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D96  6700 0008               4570            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D9A  E24B                    4571            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D9C  5302                    4572            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003D9E  60F2                    4573            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003DA0                          4574                                               *change: NAME OF LABEL*
00003DA0                          4575  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003DA0  0283 00000007           4576            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003DA6  0603 0030               4577            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003DAA  6100 0222               4578            BSR     PUSH_STACK                *PUSH TO STACK
00003DAE                          4579            
00003DAE  163C 0029               4580            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DB2  6100 021A               4581            BSR       PUSH_STACK
00003DB6  163C 002B               4582            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DBA  6100 0212               4583            BSR       PUSH_STACK
00003DBE                          4584            
00003DBE  6000 01CE               4585            BRA       GET_DST_SUCCESS                   *RETURN 
00003DC2                          4586  
00003DC2                          4587            
00003DC2                          4588            
00003DC2                          4589                      
00003DC2                          4590            *** Check if source ...  <ea> = -(An)       
00003DC2                          4591  DEST_CHECK4    
00003DC2  41F9 0000495A           4592            LEA     TEMP_REGISTER_FORMAT,A0
00003DC8  1439 00004958           4593            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003DCE  1082                    4594            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003DD0  0239 0010 0000495A      4595            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003DD8  0C39 0010 0000495A      4596            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003DE0  6700 0082               4597            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003DE4  0CB9 00000004 0000496A  4598            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003DEE  6600 0074               4599            BNE     DEST_CHECK7
00003DF2                          4600            
00003DF2                          4601            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003DF2  163C 0020               4602            MOVE.B    #' ',D3
00003DF6  6100 01D6               4603            BSR       PUSH_STACK
00003DFA  163C 002D               4604            MOVE.B    #'-',D3
00003DFE  6100 01CE               4605            BSR       PUSH_STACK
00003E02  163C 0028               4606            MOVE.B    #'(',D3
00003E06  6100 01C6               4607            BSR       PUSH_STACK
00003E0A  163C 0041               4608            MOVE.B    #'A',D3
00003E0E  6100 01BE               4609            BSR       PUSH_STACK
00003E12                          4610  
00003E12                          4611            
00003E12                          4612            *FIND REGISTER NUMBER END LOCATION*  
00003E12  13F9 0000495B 00004962  4613            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E1C  0239 000F 00004962      4614            AND.B   #$0F,VAR_BYTE_END
00003E24                          4615            
00003E24                          4616            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E24  23C5 00004966           4617            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E2A  1439 00004962           4618            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003E30                          4619            
00003E30                          4620            *INTITIALIZE FOR BIT SHIFTING
00003E30  41F9 00004966           4621            LEA     VAR_TEMP_CLEANCOPY,A0
00003E36  2639 00004966           4622            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003E3C                          4623            
00003E3C                          4624  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003E3C  0C02 0000               4625            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E40  6700 0008               4626            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003E44  E24B                    4627            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E46  5302                    4628            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003E48  60F2                    4629            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003E4A                          4630                                               *change: NAME OF LABEL*
00003E4A                          4631  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003E4A  0283 00000007           4632            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003E50  0603 0030               4633            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003E54  6100 0178               4634            BSR     PUSH_STACK                *PUSH TO STACK
00003E58                          4635            
00003E58  163C 0029               4636            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003E5C  6100 0170               4637            BSR       PUSH_STACK
00003E60                          4638            
00003E60  6000 012C               4639            BRA     GET_DST_SUCCESS                   *RETURN
00003E64                          4640            
00003E64                          4641                      
00003E64                          4642            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003E64                          4643  DEST_CHECK7    
00003E64  0CB9 00000007 0000496A  4644            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003E6E  6600 011A               4645            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003E72                          4646                   
00003E72                          4647            *NEXT: (MODE == 111) 
00003E72                          4648            *NOW: CHECK FOR SRC REGISTER 
00003E72                          4649                  *(000 = (xxx).W)
00003E72                          4650                  *(001 = (xxx).L)
00003E72                          4651                  *(010 = #<data>)
00003E72                          4652                  
00003E72                          4653            *FIND REGISTER NUMBER END LOCATION*  
00003E72  13F9 0000495B 00004962  4654            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E7C  0239 000F 00004962      4655            AND.B   #$0F,VAR_BYTE_END
00003E84                          4656            
00003E84                          4657            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E84  23C5 00004966           4658            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E8A  1439 00004962           4659            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003E90                          4660            
00003E90                          4661            *INTITIALIZE FOR BIT SHIFTING
00003E90  41F9 00004966           4662            LEA     VAR_TEMP_CLEANCOPY,A0
00003E96  2C39 00004966           4663            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003E9C                          4664  DEST_LOOP_SHIFTING7
00003E9C  0C02 0000               4665            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003EA0  6700 0008               4666            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003EA4  E24E                    4667            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003EA6  5302                    4668            SUB.B   #1,D2                     *DECREMENT COUNTER
00003EA8  60F2                    4669            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003EAA                          4670  DEST_MASKING_NEXT7
00003EAA  CCBC 00000007           4671            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003EB0                          4672           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003EB0                          4673            
00003EB0                          4674  DEST_CHECK_WORD  
00003EB0  41F9 0000495A           4675            LEA     TEMP_REGISTER_FORMAT,A0
00003EB6  1439 00004958           4676            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EBC  1082                    4677            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EBE  0239 0020 0000495A      4678            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003EC6  0C39 0020 0000495A      4679            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003ECE  6700 0026               4680            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003ED2  0C06 0000               4681            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003ED6  6600 001E               4682            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003EDA                          4683            *IT IS A WORD AT THIS POINT*
00003EDA                          4684            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003EDA  163C 0020               4685            MOVE.B    #' ',D3
00003EDE  6100 00EE               4686            BSR       PUSH_STACK
00003EE2  163C 0024               4687            MOVE.B    #'$',D3
00003EE6  6100 00E6               4688            BSR       PUSH_STACK
00003EEA  321D                    4689            MOVE.W    (A5)+,D1
00003EEC  7404                    4690            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003EEE  6100 D370               4691            BSR       HEX2ASCII2STACK
00003EF2  6000 009A               4692            BRA       GET_DST_SUCCESS
00003EF6                          4693  
00003EF6                          4694  DEST_CHECK_LONG
00003EF6  41F9 0000495A           4695            LEA     TEMP_REGISTER_FORMAT,A0
00003EFC  1439 00004958           4696            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F02  1082                    4697            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F04  0239 0040 0000495A      4698            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F0C  0C39 0040 0000495A      4699            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F14  6700 002E               4700            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F18  0C06 0001               4701            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003F1C  6600 0026               4702            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003F20                          4703            *IT IS A WORD AT THIS POINT*
00003F20                          4704            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F20  163C 0020               4705            MOVE.B    #' ',D3
00003F24  6100 00A8               4706            BSR       PUSH_STACK
00003F28  163C 0024               4707            MOVE.B    #'$',D3
00003F2C  6100 00A0               4708            BSR       PUSH_STACK
00003F30  321D                    4709            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F32  7404                    4710            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003F34  6100 D32A               4711            BSR       HEX2ASCII2STACK
00003F38  321D                    4712            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F3A  7404                    4713            MOVE.L    #4,D2          
00003F3C  6100 D322               4714            BSR       HEX2ASCII2STACK
00003F40  6000 004C               4715            BRA     GET_DST_SUCCESS
00003F44                          4716            
00003F44                          4717  DEST_CHECK_IMMEDIATE
00003F44  41F9 0000495A           4718            LEA     TEMP_REGISTER_FORMAT,A0
00003F4A  1439 00004958           4719            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F50  1082                    4720            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F52  0239 0080 0000495A      4721            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F5A  0C39 0080 0000495A      4722            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F62  6700 0026               4723            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F66  0C06 0004               4724            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003F6A  6600 001E               4725            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003F6E                          4726            
00003F6E                          4727            *IT IS A WORD AT THIS POINT*
00003F6E                          4728            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F6E  163C 0020               4729            MOVE.B    #' ',D3
00003F72  6100 005A               4730            BSR       PUSH_STACK
00003F76  163C 0023               4731            MOVE.B    #'#',D3
00003F7A  6100 0052               4732            BSR       PUSH_STACK
00003F7E  321D                    4733            MOVE.W    (A5)+,D1
00003F80  7404                    4734            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003F82  6100 D2DC               4735            BSR       HEX2ASCII2STACK
00003F86  6000 0006               4736            BRA       GET_DST_SUCCESS
00003F8A                          4737            
00003F8A                          4738  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003F8A  7801                    4739            MOVE.L #1,D4
00003F8C  4E75                    4740            RTS
00003F8E                          4741  GET_DST_SUCCESS 
00003F8E  4E75                    4742            RTS
00003F90                          4743  
00003F90                          4744  
00003F90                          4745  *---------------------------------------------------------------------------*
00003F90                          4746  * STACK/QUEUE INTERFACE
00003F90                          4747  *---------------------------------------------------------------------------*
00003F90                          4748  PRINT_STACK
00003F90  0C39 0000 00004954      4749            CMP.B     #0,COUNTER
00003F98  6700 000E               4750            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003F9C                          4751            
00003F9C                          4752  PRINT_STACK_HELPER
00003F9C  6100 0038               4753            BSR      POP_STACK          *PRINTS ADDRESS
00003FA0  103C 0006               4754            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FA4  4E4F                    4755            TRAP     #15             *ACTIVATES PRINT
00003FA6                          4756  
00003FA6  60E8                    4757            BRA       PRINT_STACK
00003FA8                          4758  PRINT_STACK_RETURN
00003FA8  4E75                    4759            RTS
00003FAA                          4760            
00003FAA                          4761            
00003FAA                          4762  PRINT_QUEUE
00003FAA  0C39 0000 00004954      4763            CMP.B     #0,COUNTER
00003FB2  6700 0018               4764            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003FB6                          4765            
00003FB6                          4766  PRINT_QUEUE_HELPER
00003FB6  33F9 00004954 00004956  4767            MOVE.W   COUNTER,QUEUE_COUNTER
00003FC0  6100 0022               4768            BSR      POP_FRONT          *PRINTS ADDRESS
00003FC4  103C 0006               4769            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FC8  4E4F                    4770            TRAP     #15             *ACTIVATES PRINT
00003FCA                          4771  
00003FCA  60DE                    4772            BRA       PRINT_QUEUE
00003FCC                          4773  PRINT_QUEUE_RETURN
00003FCC  4E75                    4774            RTS
00003FCE                          4775            
00003FCE                          4776  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003FCE                          4777  PUSH_STACK
00003FCE  1503                    4778              MOVE.B  D3,-(A2)
00003FD0  6100 0058               4779              BSR     INCREMENT
00003FD4  4E75                    4780              RTS
00003FD6                          4781  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003FD6                          4782  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003FD6                          4783  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003FD6                          4784  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003FD6                          4785  *         TRAP        #15             *ACTIVATES PRINT
00003FD6                          4786  POP_STACK
00003FD6  BECA                    4787              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003FD8  6700 0008               4788              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003FDC  121A                    4789              MOVE.B  (A2)+,D1 
00003FDE  6100 0052               4790              BSR     DECREMENT
00003FE2                          4791  POP_RETURN
00003FE2  4E75                    4792              RTS 
00003FE4                          4793        
00003FE4                          4794  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003FE4  0C39 0000 00004956      4795  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003FEC  6700 0030               4796              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003FF0                          4797              
00003FF0                          4798              
00003FF0                          4799              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003FF0  347C 7000               4800              MOVEA.W #STACK,A2   *START A2 AT STACK
00003FF4  0622 0000               4801              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003FF8  384A                    4802              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003FFA  0624 0000               4803              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003FFE  1212                    4804              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00004000                          4805  POP_SHIFT_LOOP
00004000  0C39 0000 00004956      4806              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00004008  6700 0014               4807              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000400C  1494                    4808              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
0000400E  0624 0000               4809              ADD.B   #0,-(A4)
00004012  0622 0000               4810              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00004016  5339 00004956           4811              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
0000401C                          4812              
0000401C  60E2                    4813              BRA     POP_SHIFT_LOOP
0000401E                          4814                          
0000401E                          4815  POP_FRONT_RETURN 
0000401E                          4816              *RESET A2 BACK TO SP
0000401E  347C 7000               4817              MOVEA.W #STACK,A2    
00004022  5339 00004954           4818              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00004028  4E75                    4819              RTS   
0000402A                          4820  
0000402A                          4821  INCREMENT
0000402A  5239 00004954           4822              ADD.B   #1, COUNTER
00004030  4E75                    4823              RTS           
00004032                          4824  DECREMENT
00004032  5339 00004954           4825              SUB.B   #1, COUNTER
00004038  4E75                    4826              RTS           
0000403A                          4827  CLEAR_STACK
0000403A  0C39 0000 00004954      4828              CMP.B     #0,COUNTER
00004042  6700 0006               4829              BEQ       CLEAR_RETURN
00004046  618E                    4830              BSR       POP_STACK
00004048  60F0                    4831              BRA       CLEAR_STACK
0000404A                          4832   
0000404A                          4833  CLEAR_RETURN
0000404A  4E75                    4834              RTS    
0000404C                          4835              
0000404C                          4836  *---------------------------------------------------------------------------*
0000404C                          4837  * 8/16/32-bit Address getter
0000404C                          4838  *---------------------------------------------------------------------------*
0000404C                          4839  *get displacement value from bits 0 to 8
0000404C                          4840  *if displacement is not $00, than it is 8 otherwise check for word
0000404C                          4841  *if displacement is not $FF, than it is a long
0000404C                          4842  *add the displacement to the current address being processed + a word
0000404C                          4843  *place results into D3, so that it can be pushed to stack
0000404C                          4844  GET_DISPLACEMENT_ADDRESS
0000404C  2805                    4845              MOVE.L  D5,D4                   * COPIES DATA INTO D6
0000404E  0286 000000FF           4846              ANDI.L  #$00FF,D6               * MASKS DATA
00004054  0C84 00000000           4847              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
0000405A  6700 0022               4848              BEQ     GET_DISPLACEMENT_WORD
0000405E  0C84 000000FF           4849              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00004064  6700 0030               4850              BEQ     GET_DISPLACEMENT_LONG
00004068                          4851              
00004068  2E3C 00000100           4852              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
0000406E  9E04                    4853              SUB.B   D4,D7
00004070                          4854              
00004070  280D                    4855              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004072  9807                    4856              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00004074  7404                    4857              MOVE.L  #4,D2
00004076  2204                    4858              MOVE.L  D4,D1  
00004078  6100 D1E6               4859              BSR     HEX2ASCII2STACK
0000407C  4E75                    4860              RTS
0000407E                          4861              
0000407E                          4862  GET_DISPLACEMENT_WORD
0000407E  2E3C 000000FF           4863              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00004084  9E04                    4864              SUB.B   D4,D7
00004086                          4865              
00004086  280D                    4866              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004088  9807                    4867              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
0000408A  7404                    4868              MOVE.L  #4,D2
0000408C  2604                    4869              MOVE.L  D4,D3
0000408E  2204                    4870              MOVE.L  D4,D1
00004090  6100 D1CE               4871              BSR     HEX2ASCII2STACK
00004094  4E75                    4872              RTS     
00004096                          4873  GET_DISPLACEMENT_LONG   
00004096  2E3C 000000FF           4874              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
0000409C  9E04                    4875              SUB.B   D4,D7
0000409E                          4876              
0000409E  280D                    4877              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040A0  9807                    4878              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040A2  7408                    4879              MOVE.L  #8,D2
000040A4  2604                    4880              MOVE.L  D4,D3                   * PREPARE TO PUSH
000040A6  2204                    4881              MOVE.L  D4,D1
000040A8  6100 D1B6               4882              BSR     HEX2ASCII2STACK
000040AC                          4883  
000040AC  4284                    4884              CLR.L   D4
000040AE  4E75                    4885              RTS
000040B0                          4886  
000040B0                          4887  *---------------------------------------------------------------------------*
000040B0                          4888  * TERMINATE
000040B0                          4889  *---------------------------------------------------------------------------*
000040B0                          4890  TERMINATE   
000040B0  43F9 00004460           4891              LEA     FINMSG,A1
000040B6  103C 000E               4892              MOVE.B  #14,D0
000040BA  4E4F                    4893              TRAP    #15
000040BC                          4894  
000040BC  103C 0009               4895              MOVE.B  #9,D0
000040C0  4E4F                    4896              TRAP    #15
000040C2                          4897  
000040C2                          4898  *---------------------------------------------------------------------------*
000040C2                          4899  * Data storage                                                 
000040C2                          4900  *---------------------------------------------------------------------------*  
000040C2                          4901  WELCOME
000040C2= 20 20 20 20 20 20 ...   4902              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00004112= 3D 3D 3D 3D 3D 20 ...   4903              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004162= 3D 3D 3D 3D 3D 20 ...   4904              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000041B2                          4905      
000041B2= 20 20 20 20 20 20 ...   4906              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00004202= 20 20 20 20 20 20 ...   4907              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004252= 20 20 20 20 20 20 ...   4908              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000042A2                          4909      
000042A2= 20 20 20 20 20 20 ...   4910              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
000042F2= 3D 3D 3D 3D 3D 20 ...   4911              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00004342= 3D 3D 3D 3D 3D 20 ...   4912              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
00004397                          4913  
00004397                          4914  PROMPT_START
00004397= 50 6C 65 61 73 65 ...   4915              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000043C6                          4916      
000043C6                          4917  PROMPT_END
000043C6= 50 6C 65 61 73 65 ...   4918              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
000043F3= 0D 0A 48 69 74 20 ...   4919  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
0000441D= 57 6F 75 6C 64 20 ...   4920  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004460= 54 68 61 6E 6B 20 ...   4921  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
0000448B= 45 72 72 6F 72 3A ...   4922  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000044AA= 45 72 72 6F 72 3A ...   4923  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
000044CF= 45 72 72 6F 72 3A ...   4924  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
000044FC                          4925  
000044FC                          4926  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
0000454C                          4927  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
0000459C                          4928  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000045A0                          4929  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000045A4= 0D 0A 00                4930  ENDLINE_M   DC.B    CR,LF,0
000045A7                          4931  TMPINPUT    DS.B    80                      * temp store user input
000045F7                          4932  TMPOUTPUT   DS.B    80                      * temp store prog output
00004647= 20 20 20 4F 52 49 ...   4933  DISP_ORI_B  DC.B    '   ORI.B',0
00004650= 20 20 20 4F 52 49 ...   4934  DISP_ORI_W  DC.B    '   ORI.W',0
00004659= 20 20 20 4F 52 49 ...   4935  DISP_ORI_L  DC.B    '   ORI.L',0
00004662= 20 20 20 45 4F 52 ...   4936  DISP_EORI_B  DC.B    '   EORI.B',0
0000466C= 20 20 20 45 4F 52 ...   4937  DISP_EORI_W  DC.B    '   EORI.W',0
00004676= 20 20 20 45 4F 52 ...   4938  DISP_EORI_L  DC.B    '   EORI.L',0
00004680= 20 20 20 42 54 53 ...   4939  DISP_BTST   DC.B    '   BTST',0
00004688= 20 20 20 43 4D 50 ...   4940  DISP_CMPI_B  DC.B    '   CMPI.B',0
00004692= 20 20 20 43 4D 50 ...   4941  DISP_CMPI_W  DC.B    '   CMPI.W',0
0000469C= 20 20 20 43 4D 50 ...   4942  DISP_CMPI_L  DC.B    '   CMPI.L',0
000046A6= 20 20 20 44 41 54 ...   4943  DISP_DATA   DC.B    '   DATA',0
000046AE= 20 20 20 4D 4F 56 ...   4944  DISP_MOVE_B DC.B    '   MOVE.B',0
000046B8= 20 20 20 4D 4F 56 ...   4945  DISP_MOVE_W DC.B    '   MOVE.W',0
000046C2= 20 20 20 4D 4F 56 ...   4946  DISP_MOVE_L DC.B    '   MOVE.L',0
000046CC= 20 20 20 52 54 53 00    4947  DISP_RTS    DC.B    '   RTS',0
000046D3= 20 20 20 4A 53 52 00    4948  DISP_JSR    DC.B    '   JSR',0
000046DA= 20 20 20 4E 45 47 ...   4949  DISP_NEG_B    DC.B    '   NEG.B',0
000046E3= 20 20 20 4E 45 47 ...   4950  DISP_NEG_W    DC.B    '   NEG.W',0
000046EC= 20 20 20 4E 45 47 ...   4951  DISP_NEG_L    DC.B    '   NEG.L',0
000046F5= 20 20 20 4E 4F 54 ...   4952  DISP_NOT_B  DC.B    '   NOT.B',0
000046FE= 20 20 20 4E 4F 54 ...   4953  DISP_NOT_W  DC.B    '   NOT.W',0
00004707= 20 20 20 4E 4F 54 ...   4954  DISP_NOT_L  DC.B    '   NOT.L',0
00004710= 20 20 20 4C 45 41 00    4955  DISP_LEA    DC.B    '   LEA',0
00004717= 20 20 20 4D 4F 56 ...   4956  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004722= 20 20 20 4D 4F 56 ...   4957  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
0000472D= 20 20 20 41 44 44 ...   4958  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00004737= 20 20 20 41 44 44 ...   4959  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00004741= 20 20 20 41 44 44 ...   4960  DISP_ADDQ_L DC.B    '   ADDQ.L',0
0000474B= 20 20 20 44 49 56 ...   4961  DISP_DIVS   DC.B    '   DIVS',0
00004753= 20 20 20 53 55 42 ...   4962  DISP_SUB_B  DC.B    '   SUB.B',0
0000475C= 20 20 20 53 55 42 ...   4963  DISP_SUB_W  DC.B    '   SUB.W',0
00004765= 20 20 20 53 55 42 ...   4964  DISP_SUB_L  DC.B    '   SUB.L',0
0000476E= 20 20 20 53 55 42 ...   4965  DISP_SUBI_B  DC.B    '   SUBI.B',0
00004778= 20 20 20 53 55 42 ...   4966  DISP_SUBI_W  DC.B    '   SUBI.W',0
00004782= 20 20 20 53 55 42 ...   4967  DISP_SUBI_L  DC.B    '   SUBI.L',0
0000478C= 20 20 20 53 55 42 ...   4968  DISP_SUBA_W  DC.B    '   SUBA.W',0
00004796= 20 20 20 53 55 42 ...   4969  DISP_SUBA_L  DC.B    '   SUBA.L',0
000047A0= 20 20 20 45 4F 52 ...   4970  DISP_EOR_B  DC.B    '   EOR.B',0
000047A9= 20 20 20 45 4F 52 ...   4971  DISP_EOR_W  DC.B    '   EOR.W',0
000047B2= 20 20 20 45 4F 52 ...   4972  DISP_EOR_L  DC.B    '   EOR.L',0
000047BB= 20 20 20 43 4D 50 ...   4973  DISP_CMP_B  DC.B    '   CMP.B',0
000047C4= 20 20 20 43 4D 50 ...   4974  DISP_CMP_W  DC.B    '   CMP.W',0
000047CD= 20 20 20 43 4D 50 ...   4975  DISP_CMP_L  DC.B    '   CMP.L',0
000047D6= 20 20 20 43 4D 50 ...   4976  DISP_CMPA_W  DC.B    '   CMPA.W',0
000047E0= 20 20 20 43 4D 50 ...   4977  DISP_CMPA_L  DC.B    '   CMPA.L',0
000047EA= 20 20 20 4D 55 4C ...   4978  DISP_MULS_W DC.B    '   MULS.W',0
000047F4= 20 20 20 41 4E 44 ...   4979  DISP_AND_B  DC.B    '   AND.B',0
000047FD= 20 20 20 41 4E 44 ...   4980  DISP_AND_W  DC.B    '   AND.W',0
00004806= 20 20 20 41 4E 44 ...   4981  DISP_AND_L  DC.B    '   AND.L',0
0000480F= 20 20 20 41 44 44 ...   4982  DISP_ADD_B  DC.B    '   ADD.B',0
00004818= 20 20 20 41 44 44 ...   4983  DISP_ADD_W  DC.B    '   ADD.W',0
00004821= 20 20 20 41 44 44 ...   4984  DISP_ADD_L  DC.B    '   ADD.L',0
0000482A= 20 20 20 41 44 44 ...   4985  DISP_ADDA_W DC.B    '   ADDA.W',0
00004834= 20 20 20 41 44 44 ...   4986  DISP_ADDA_L DC.B    '   ADDA.L',0
0000483E= 20 20 20 4C 53 52 ...   4987  DISP_LSR_B  DC.B    '   LSR.B',0
00004847= 20 20 20 4C 53 4C ...   4988  DISP_LSL_B  DC.B    '   LSL.B',0
00004850= 20 20 20 4C 53 52 ...   4989  DISP_LSR_W  DC.B    '   LSR.W',0
00004859= 20 20 20 4C 53 4C ...   4990  DISP_LSL_W  DC.B    '   LSL.W',0
00004862= 20 20 20 4C 53 52 ...   4991  DISP_LSR_L  DC.B    '   LSR.L',0
0000486B= 20 20 20 4C 53 4C ...   4992  DISP_LSL_L  DC.B    '   LSL.L',0
00004874= 20 20 20 41 53 52 ...   4993  DISP_ASR_B  DC.B    '   ASR.B',0
0000487D= 20 20 20 41 53 4C ...   4994  DISP_ASL_B  DC.B    '   ASL.B',0
00004886= 20 20 20 41 53 52 ...   4995  DISP_ASR_W  DC.B    '   ASR.W',0
0000488F= 20 20 20 41 53 4C ...   4996  DISP_ASL_W  DC.B    '   ASL.W',0
00004898= 20 20 20 41 53 52 ...   4997  DISP_ASR_L  DC.B    '   ASR.L',0
000048A1= 20 20 20 41 53 4C ...   4998  DISP_ASL_L  DC.B    '   ASL.L',0
000048AA= 20 20 20 52 4F 52 ...   4999  DISP_ROR_B  DC.B    '   ROR.B',0
000048B3= 20 20 20 52 4F 4C ...   5000  DISP_ROL_B  DC.B    '   ROL.B',0
000048BC= 20 20 20 52 4F 52 ...   5001  DISP_ROR_W  DC.B    '   ROR.W',0
000048C5= 20 20 20 52 4F 4C ...   5002  DISP_ROL_W  DC.B    '   ROL.W',0
000048CE= 20 20 20 52 4F 52 ...   5003  DISP_ROR_L  DC.B    '   ROR.L',0
000048D7= 20 20 20 52 4F 4C ...   5004  DISP_ROL_L  DC.B    '   ROL.L',0
000048E0= 20 20 20 42 52 41 00    5005  DISP_BRA    DC.B    '   BRA',0
000048E7= 20 20 20 42 4C 54 00    5006  DISP_BLT    DC.B    '   BLT',0
000048EE= 20 20 20 42 45 51 00    5007  DISP_BEQ    DC.B    '   BEQ',0
000048F5= 20 20 20 42 4E 45 00    5008  DISP_BNE    DC.B    '   BNE',0
000048FC= 20 20 20 42 48 49 00    5009  DISP_BHI    DC.B    '   BHI',0
00004903= 20 20 20 4D 4F 56 ...   5010  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
0000490E= 20 20 20 4D 4F 56 ...   5011  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004919                          5012  
00004919= 20 20 20 24 00          5013  DISP_HEX     DC.B    '   $',0
0000491E= 20 20 20 44 00          5014  DISP_D  DC.B    '   D',0
00004923= 20 20 20 41 00          5015  DISP_A  DC.B    '   A',0
00004928= 20 20 20 28 00          5016  DISP_OP  DC.B    '   (',0
0000492D= 29 00                   5017  DISP_CP  DC.B   ')',0
0000492F= 20 20 20 28 41 00       5018  DISP_AOP  DC.B    '   (A',0
00004935                          5019  
00004935= 20 20 20 2D 28 41 00    5020  DISP_PRE    DC.B    '   -(A',0
0000493C= 29 2B 00                5021  DISP_POST   DC.B    ')+',0
0000493F= 20 20 20 23 00          5022  DISP_LB DC.B    '   #',0
00004944= 30 00                   5023  DISP_0  DC.B    '0',0
00004946= 31 00                   5024  DISP_1  DC.B    '1',0
00004948= 32 00                   5025  DISP_2  DC.B    '2',0
0000494A= 33 00                   5026  DISP_3  DC.B    '3',0
0000494C= 34 00                   5027  DISP_4  DC.B    '4',0
0000494E= 35 00                   5028  DISP_5  DC.B    '5',0
00004950= 36 00                   5029  DISP_6  DC.B    '6',0
00004952= 37 00                   5030  DISP_7  DC.B    '7',0
00004954                          5031  
00004954                          5032  *STACK INTERFACE VARIABLES*
00004954                          5033  COUNTER         DS.W    1
00004956                          5034  QUEUE_COUNTER   DS.W    1
00004958                          5035  
00004958                          5036  *EA DECODING INTERFACE VARIABLES* 
00004958                          5037  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004959                          5038  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
0000495A                          5039  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
0000495B                          5040  
0000495B                          5041  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
0000495B                          5042  * WORD + WORD = LONG
0000495B                          5043  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
0000495B                          5044  * A              + F            = AF         <= EXAMPLE
0000495B                          5045  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
0000495B                          5046  GET_DST_START_END    DS.B    1
0000495C                          5047  GET_SRC_START_END    DS.B    1
0000495D                          5048  
0000495D                          5049  *STORES THE START + END BITS HERE (FROM ABOVE)
0000495E                          5050  VAR_BYTE_START      DS.L    1
00004962                          5051  VAR_BYTE_END        DS.L    1
00004966                          5052  VAR_TEMP_CLEANCOPY  DS.L    1
0000496A                          5053  
0000496A                          5054  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
0000496E                          5055  
0000496E                          5056  *MORE FOR STACK USAGE*
0000496E= 2C 00                   5057  DISP_COMMA  DC.B    ',',0
00004970= 20 20 20 00             5058  DISP_INDENT  DC.B    '   ',0
00004974                          5059  
00004974                          5060  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004974                          5061  POINTER_WORD    DS.W       1
00004976                          5062  
00004976                          5063  
00004976                          5064  
00004976                          5065  *---------------------------------------------------------------------------*
00004976                          5066  * Ends program
00004976                          5067  *---------------------------------------------------------------------------*
00004976                          5068              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1154
ASC2HXLP2STACK      11BC
ASCII2HEX           114E
ASCII2HEX2STACK     11B6
ASC_ERR             11B0
ASC_ERR2STACK       1218
ASC_LOW             1192
ASC_LOW2STACK       11FA
ASC_NUM             11A2
ASC_NUM2STACK       120A
ASC_SFT             11AA
ASC_SFT2STACK       1212
ASC_UPP             119A
ASC_UPP2STACK       1202
CHECK0              3742
CHECK1              37CC
CHECK2              3856
CHECK3              38F0
CHECK4              3992
CHECK7              3A34
CHECK_IMMEDIATE     3B14
CHECK_LONG          3AC6
CHECK_WORD          3A80
CLEAR_RETURN        404A
CLEAR_STACK         403A
COUNTER             4954
CR                  D
DECREMENT           4032
DEST_CHECK0         3B72
DEST_CHECK1         3BFC
DEST_CHECK2         3C86
DEST_CHECK3         3D20
DEST_CHECK4         3DC2
DEST_CHECK7         3E64
DEST_CHECK_IMMEDIATE  3F44
DEST_CHECK_LONG     3EF6
DEST_CHECK_WORD     3EB0
DEST_LOOP_SHIFTING  3BDC
DEST_LOOP_SHIFTING1  3C66
DEST_LOOP_SHIFTING2  3CF8
DEST_LOOP_SHIFTING3  3D92
DEST_LOOP_SHIFTING4  3E3C
DEST_LOOP_SHIFTING7  3E9C
DEST_MASKING_NEXT   3BEA
DEST_MASKING_NEXT1  3C74
DEST_MASKING_NEXT2  3D06
DEST_MASKING_NEXT3  3DA0
DEST_MASKING_NEXT4  3E4A
DEST_MASKING_NEXT7  3EAA
DEST_MODE           32FA
DEST_REGISTER       35CA
DEST_REGISTER_FORMAT  4958
DISPLAY_30_LINES    1364
DISP_0              4944
DISP_1              4946
DISP_2              4948
DISP_3              494A
DISP_4              494C
DISP_5              494E
DISP_6              4950
DISP_7              4952
DISP_A              4923
DISP_ADDA_L         4834
DISP_ADDA_W         482A
DISP_ADDQ_B         472D
DISP_ADDQ_L         4741
DISP_ADDQ_W         4737
DISP_ADD_B          480F
DISP_ADD_L          4821
DISP_ADD_W          4818
DISP_AND_B          47F4
DISP_AND_L          4806
DISP_AND_W          47FD
DISP_AOP            492F
DISP_ASL_B          487D
DISP_ASL_L          48A1
DISP_ASL_W          488F
DISP_ASR_B          4874
DISP_ASR_L          4898
DISP_ASR_W          4886
DISP_BEQ            48EE
DISP_BHI            48FC
DISP_BLT            48E7
DISP_BNE            48F5
DISP_BRA            48E0
DISP_BTST           4680
DISP_CMPA_L         47E0
DISP_CMPA_W         47D6
DISP_CMPI_B         4688
DISP_CMPI_L         469C
DISP_CMPI_W         4692
DISP_CMP_B          47BB
DISP_CMP_L          47CD
DISP_CMP_W          47C4
DISP_COMMA          496E
DISP_CP             492D
DISP_D              491E
DISP_DATA           46A6
DISP_DIVS           474B
DISP_EORI_B         4662
DISP_EORI_L         4676
DISP_EORI_W         466C
DISP_EOR_B          47A0
DISP_EOR_L          47B2
DISP_EOR_W          47A9
DISP_HEX            4919
DISP_INDENT         4970
DISP_JSR            46D3
DISP_LB             493F
DISP_LEA            4710
DISP_LSL_B          4847
DISP_LSL_L          486B
DISP_LSL_W          4859
DISP_LSR_B          483E
DISP_LSR_L          4862
DISP_LSR_W          4850
DISP_MOVEA_L        490E
DISP_MOVEA_W        4903
DISP_MOVEM_L        4722
DISP_MOVEM_W        4717
DISP_MOVE_B         46AE
DISP_MOVE_L         46C2
DISP_MOVE_W         46B8
DISP_MULS_W         47EA
DISP_NEG_B          46DA
DISP_NEG_L          46EC
DISP_NEG_W          46E3
DISP_NEXT           43F3
DISP_NOT_B          46F5
DISP_NOT_L          4707
DISP_NOT_W          46FE
DISP_OP             4928
DISP_ORI_B          4647
DISP_ORI_L          4659
DISP_ORI_W          4650
DISP_POST           493C
DISP_PRE            4935
DISP_ROL_B          48B3
DISP_ROL_L          48D7
DISP_ROL_W          48C5
DISP_ROR_B          48AA
DISP_ROR_L          48CE
DISP_ROR_W          48BC
DISP_RTS            46CC
DISP_SUBA_L         4796
DISP_SUBA_W         478C
DISP_SUBI_B         476E
DISP_SUBI_L         4782
DISP_SUBI_W         4778
DISP_SUB_B          4753
DISP_SUB_L          4765
DISP_SUB_W          475C
D_MODE000           339C
D_MODE010           33E4
D_MODE011           3444
D_MODE100           3464
D_MODE111           34B6
EA_ARITH            3294
EA_DATA             1774
EA_GEN              32E0
EA_MOVEA            32BA
EA_NOSRC            3280
ENDLINE_M           45A4
END_ADDR            109A
ERRMSG_1            448B
ERRMSG_3            44AA
ERRMSG_5            44CF
ERROR_1             10FE
ERROR_2             110E
ERROR_3             111E
ERROR_4             112E
ERROR_5             113E
E_ADDR_HX           45A0
FINMSG              4460
GET_DISPLACEMENT_ADDRESS  404C
GET_DISPLACEMENT_LONG  4096
GET_DISPLACEMENT_WORD  407E
GET_DST_FAILED      3F8A
GET_DST_START_END   495B
GET_DST_SUCCESS     3F8E
GET_EA_EA_DEST      3B60
GET_EA_EA_SRC       3730
GET_SRC_FAILED      3B5A
GET_SRC_START_END   495C
GET_SRC_SUCCESS     3B5E
HEX2ASCII           121E
HEX2ASCII2STACK     1260
HEX_CHAR            124C
HEX_CONT            1250
HEX_LOOP            1232
IMMD_B              356A
IMMD_L              35AA
IMMD_W              358A
IMMEDIATE           353A
INCREMENT           402A
INTRO               1028
IS_ODD              12A4
IS_ODD_ERR          12BA
JMPTABLE            1390
LF                  A
LONGMODE            350E
LOOP_SHIFTING       37AC
LOOP_SHIFTING1      3836
LOOP_SHIFTING2      38C8
LOOP_SHIFTING3      3962
LOOP_SHIFTING4      3A0C
MAIN                12C0
MASKING_NEXT        37BA
MASKING_NEXT1       3844
MASKING_NEXT2       38D6
MASKING_NEXT3       3970
MASKING_NEXT4       3A1A
MODE000             3388
MODE001             33B0
MODE010             33C4
MODE011             3404
MODE100             3424
MODE111             3484
NEXTLINES           1372
OP0000              13F0
OP0000_BTST_B       155A
OP0000_CMPI         179C
OP0000_CMPI_B       1812
OP0000_CMPI_L       1862
OP0000_CMPI_W       183A
OP0000_EOR_B        1608
OP0000_EOR_L        1638
OP0000_EOR_W        1620
OP0000_ORI_B        18F6
OP0000_ORI_L        1946
OP0000_ORI_W        191E
OP0000_RETURN_BTST  158A
OP0000_RETURN_CMPI  1886
OP0000_RETURN_EOR   164C
OP0000_RETURN_ORI   196A
OP0000_RETURN_SUBI  172E
OP0000_SUB_B        16EA
OP0000_SUB_L        171A
OP0000_SUB_W        1702
OP0001              196C
OP0010              19DA
OP0011              1AD8
OP0100              1BD4
OP0101              1E2A
OP0101_ADDQ_B       1EA6
OP0101_ADDQ_B_0     1F22
OP0101_ADDQ_B_1     1F2E
OP0101_ADDQ_B_2     1F3A
OP0101_ADDQ_B_3     1F46
OP0101_ADDQ_B_4     1F52
OP0101_ADDQ_B_5     1F5E
OP0101_ADDQ_B_6     1F6A
OP0101_ADDQ_B_7     1F76
OP0101_ADDQ_B_8     1F82
OP0101_ADDQ_L       1EBE
OP0101_ADDQ_W       1EB2
OP0101_RETURN       1EC6
OP0101_RETURN2      1F8A
OP0110              1FCE
OP0111              20D4
OP1000              20D8
OP1000_DIVS_DN_EA_OR_EA_DN  20E6
OP1000_DIVS_RETURN  21CA
OP1000_EA_DN_DIVS   2114
OP1000_PRINT_L_DIVS  2182
OP1000_PRINT_W_DIVS  213A
OP1001              21E0
OP1001_ADD_RETURN   252E
OP1001_DETERMINE_DN_EA_OR_EA_DN  22F6
OP1001_DN_EA        232E
OP1001_EA_DN        242E
OP1001_PRINT_B      2456
OP1001_PRINT_B2     2356
OP1001_PRINT_L      24E6
OP1001_PRINT_L2     23E6
OP1001_PRINT_W      249E
OP1001_PRINT_W2     239E
OP1001_SUBA_L       2212
OP1001_SUBA_W       2284
OP1010              259C
OP1011              25A0
OP1011_CMP          25FA
OP1011_CMPA         26AC
OP1011_CMPA_L       2726
OP1011_CMPA_W       271A
OP1011_CMP_B        266E
OP1011_CMP_L        2686
OP1011_CMP_W        267A
OP1011_EOR          274C
OP1011_EOR_B        27C0
OP1011_EOR_L        27D8
OP1011_EOR_W        27CC
OP1011_RETURN       27E0
OP1011_RETURN_CMP   268E
OP1011_RETURN_CMPA  272E
OP1100              28A0
OP1100_AND_RETURN   2BF0
OP1100_DETERMINE_DN_EA_OR_EA_DN  29B6
OP1100_DN_EA        29F0
OP1100_EA_DN        2AF0
OP1100_EA_DN_MULS   28FE
OP1100_MULS_DN_EA_OR_EA_DN  28D0
OP1100_MULS_RETURN  29B4
OP1100_PRINT_B      2B18
OP1100_PRINT_B2     2A18
OP1100_PRINT_L      2BA8
OP1100_PRINT_L2     2AA8
OP1100_PRINT_L_MULS  296C
OP1100_PRINT_W      2B60
OP1100_PRINT_W2     2A60
OP1100_PRINT_W_MULS  2924
OP1101              2BF2
OP1101_ADDA_L       2C24
OP1101_ADDA_W       2C96
OP1101_ADD_RETURN   2F40
OP1101_DETERMINE_DN_EA_OR_EA_DN  2D08
OP1101_DN_EA        2D40
OP1101_EA_DN        2E40
OP1101_PRINT_B      2E68
OP1101_PRINT_B2     2D68
OP1101_PRINT_L      2EF8
OP1101_PRINT_L2     2DF8
OP1101_PRINT_W      2EB0
OP1101_PRINT_W2     2DB0
OP1110              2FCE
OP1111              327C
OP_ADDA_L           2FB6
OP_ADDA_W           2F9E
OP_ADDQ_B           1F98
OP_ADDQ_L           1FBC
OP_ADDQ_W           1FAA
OP_ADD_B            2F56
OP_ADD_L            2F86
OP_ADD_W            2F6E
OP_ASL              316E
OP_ASL_B            3192
OP_ASL_L            31A4
OP_ASL_W            31B6
OP_ASR              3114
OP_ASR_B            3138
OP_ASR_L            314A
OP_ASR_W            315C
OP_ASX              3030
OP_BEQ              2062
OP_BHI              2016
OP_BLT              20AE
OP_BNE              203C
OP_BRA              2088
OP_BTST             147A
OP_BTST_IMMEDIATE   1504
OP_CMPA_L           2810
OP_CMPA_W           27FE
OP_CMP_B            2822
OP_CMP_L            2852
OP_CMP_W            283A
OP_DATA             1750
OP_DIVS             21CC
OP_EORI             158C
OP_EOR_B            286A
OP_EOR_L            288E
OP_EOR_W            287C
OP_JSR              1DFC
OP_LEA              1C82
OP_LEA_DN_EA_OR_EA_DN  1C90
OP_LEA_RETURN       1CEE
OP_LSL              30BA
OP_LSL_B            30DE
OP_LSL_L            30F0
OP_LSL_W            3102
OP_LSR              3060
OP_LSR_B            3084
OP_LSR_L            3096
OP_LSR_W            30A8
OP_LSX              3018
OP_MOVEA_L          1A68
OP_MOVEA_W          1B64
OP_MOVEM_L          1C70
OP_MOVEM_W          1C5E
OP_MOVE_B           1972
OP_MOVE_L           1A00
OP_MOVE_W           1AFC
OP_MULS             28C2
OP_NEG              1CF0
OP_NEG_B            1D3C
OP_NEG_L            1D54
OP_NEG_PRINT_EA     1D60
OP_NEG_W            1D48
OP_NOT              1D76
OP_NOT_B            1DC2
OP_NOT_L            1DDA
OP_NOT_PRINT_EA     1DE6
OP_NOT_W            1DCE
OP_ORI              1888
OP_PRINT_L_LEA      1CAE
OP_ROL              3222
OP_ROL_B            3246
OP_ROL_L            3258
OP_ROL_W            326A
OP_ROR              31C8
OP_ROR_B            31EC
OP_ROR_L            31FE
OP_ROR_W            3210
OP_ROX              3048
OP_RTS              1E10
OP_SUBA_L           258A
OP_SUBA_W           2578
OP_SUBI             166E
OP_SUB_B            2530
OP_SUB_L            2560
OP_SUB_W            2548
OUTPUT_PROCESSED_DATA  1344
POINTER_WORD        4974
POP_FRONT           3FE4
POP_FRONT_RETURN    401E
POP_RETURN          3FE2
POP_SHIFT_LOOP      4000
POP_STACK           3FD6
PRINT_QUEUE         3FAA
PRINT_QUEUE_HELPER  3FB6
PRINT_QUEUE_RETURN  3FCC
PRINT_STACK         3F90
PRINT_STACK_HELPER  3F9C
PRINT_STACK_RETURN  3FA8
PROGLP              100A
PROMPT_END          43C6
PROMPT_START        4397
PUSH_STACK          3FCE
QUEUE_COUNTER       4956
REG_0               367E
REG_1               368C
REG_2               369A
REG_3               36A8
REG_4               36B6
REG_5               36C4
REG_6               36D2
REG_7               36E0
REPEAT              36EE
REPEATMSG           441D
RETURN              11B4
RETURN2STACK        121C
SRC_LOOP_SHIFTING   3A6C
SRC_MASKING_NEXT    3A7A
SRC_MODE            333E
SRC_REGISTER        3626
SRC_REGISTER_FORMAT  4959
STACK               7000
STACK_HEX_CHAR      128E
STACK_HEX_CONT      1292
STACK_HEX_LOOP      1274
START               1004
START_ADDR          1048
S_ADDR_HX           459C
TEMP_REGISTER_FORMAT  495A
TERMINATE           40B0
TESTING             1036
TMPINPUT            45A7
TMPOUTPUT           45F7
VAR_BYTE_END        4962
VAR_BYTE_START      495E
VAR_LONG_ADDRESS_MODE_CHECK  496A
VAR_TEMP_CLEANCOPY  4966
VR_E_ADDR           454C
VR_S_ADDR           44FC
WELCOME             40C2
WORDMODE            34E2
