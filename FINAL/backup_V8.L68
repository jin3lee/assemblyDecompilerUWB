00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 12/10/2014 11:23:32 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001036             37  PROGLP      JSR     START_ADDR
00001010  4EB9 00001088             38              JSR     END_ADDR
00001016  43F9 000044AE             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012AE             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003FCC             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  *---------------------------------------------------------------------------*
00001036                            53  * START_ADDR: Compute the starting address
00001036                            54  *---------------------------------------------------------------------------*
00001036                            55  START_ADDR
00001036                            56              * Output
00001036  43F9 000042A1             57              LEA     PROMPT_START,A1         * Load PROMPT_START 
0000103C  103C 000E                 58              MOVE.B  #14,D0                  * Display PROMPT_START
00001040  4E4F                      59              TRAP    #15
00001042                            60      
00001042                            61              * Input
00001042  43F9 00004406             62              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
00001048  103C 0002                 63              MOVE.B  #2,D0                   * Ask user for input
0000104C  4E4F                      64              TRAP    #15
0000104E                            65              
0000104E                            66              * Error Checking (length)
0000104E  0C01 0000                 67              CMPI.B  #0, D1                  * Check if input length <= 0
00001052  6F00 0098                 68              BLE     ERROR_1
00001056  0C01 0008                 69              CMPI.B  #8, D1                  * Check if input length > 8
0000105A  6E00 0090                 70              BGT     ERROR_1
0000105E                            71              
0000105E                            72              * Conversion & Storage
0000105E  4EB9 0000113C             73              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001064  0C07 0001                 74              CMPI.B  #1, D7                  * Check for error
00001068  6700 0082                 75              BEQ     ERROR_1                 
0000106C  23C1 000044A6             76              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001072                            77              
00001072                            78              * Error Checking (Odd)
00001072  43F9 000044A6             79              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
00001078  4EB9 00001292             80              JSR     IS_ODD                  * Check if the input address is odd
0000107E  0C07 0001                 81              CMPI.B  #1, D7                  * Check for error
00001082  6700 0088                 82              BEQ     ERROR_3
00001086                            83              
00001086                            84              * Return
00001086  4E75                      85              RTS     
00001088                            86  *---------------------------------------------------------------------------*
00001088                            87  * END_ADDR: Compute the ending address
00001088                            88  *---------------------------------------------------------------------------*
00001088                            89  END_ADDR
00001088                            90              * Output
00001088  43F9 000042D0             91              LEA     PROMPT_END,A1           * Load PROMPT_END
0000108E  103C 000E                 92              MOVE.B  #14,D0                  * Display PROMPT_END
00001092  4E4F                      93              TRAP    #15
00001094                            94  
00001094                            95              * Input
00001094  43F9 00004456             96              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
0000109A  103C 0002                 97              MOVE.B  #2,D0                   * Ask user for input
0000109E  4E4F                      98              TRAP    #15
000010A0                            99              
000010A0                           100              * Error Checking (length)
000010A0  0C01 0000                101              CMPI.B  #0, D1                  * Check if input length <= 0
000010A4  6F00 0056                102              BLE     ERROR_2
000010A8  0C01 0008                103              CMPI.B  #8, D1                  * Check if input length > 8
000010AC  6E00 004E                104              BGT     ERROR_2
000010B0                           105              
000010B0                           106              * Conversion & Storage
000010B0  4EB9 0000113C            107              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010B6  0C07 0001                108              CMPI.B  #1, D7                  * Check for error
000010BA  6700 0040                109              BEQ     ERROR_2
000010BE  23C1 000044AA            110              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010C4                           111              
000010C4                           112              * Error Checking (start > end case)
000010C4  2439 000044A6            113              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010CA  B282                     114              CMP.L   D2, D1                  * Compare starting and ending address
000010CC  6300 005E                115              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010D0                           116              
000010D0                           117              * Error Checking (Odd case)
000010D0  43F9 000044AA            118              LEA     E_ADDR_HX, A1           * Move the ending address
000010D6  4EB9 00001292            119              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010DC  0C07 0001                120              CMPI.B  #1, D7                  * Check for an error flag
000010E0  6700 003A                121              BEQ     ERROR_4
000010E4                           122              
000010E4                           123              * Inputs are valid
000010E4  2A79 000044A6            124              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010EA                           125              
000010EA  4E75                     126              RTS
000010EC                           127              
000010EC                           128  *---------------------------------------------------------------------------*
000010EC                           129  * ERROR_1: Address error (Invalid starting address)
000010EC                           130  *---------------------------------------------------------------------------*
000010EC                           131  ERROR_1
000010EC  43F9 00004395            132              LEA     ERRMSG_1, A1            * Load ERRMSG_1
000010F2  103C 000E                133              MOVE.B  #14, D0                 * Display ERRMSG_1
000010F6  4E4F                     134              TRAP    #15
000010F8  4EF8 1036                135              JMP     START_ADDR              * Jump to START_ADDR
000010FC                           136      
000010FC                           137  *---------------------------------------------------------------------------*
000010FC                           138  * ERROR_2: Address error (Invalid ending address)
000010FC                           139  *---------------------------------------------------------------------------*
000010FC                           140  ERROR_2
000010FC  43F9 00004395            141              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001102  103C 000E                142              MOVE.B  #14, D0                 * Display ERRMSG_1
00001106  4E4F                     143              TRAP    #15
00001108  4EF8 1088                144              JMP     END_ADDR                * Jump to END_ADDR
0000110C                           145  
0000110C                           146  *---------------------------------------------------------------------------*
0000110C                           147  * ERROR_3: Address error (Odd starting address)
0000110C                           148  *---------------------------------------------------------------------------*
0000110C                           149  ERROR_3
0000110C  43F9 000043B4            150              LEA     ERRMSG_3, A1
00001112  103C 000E                151              MOVE.B  #14, D0
00001116  4E4F                     152              TRAP    #15
00001118  4EF8 1036                153              JMP     START_ADDR
0000111C                           154     
0000111C                           155  *---------------------------------------------------------------------------*
0000111C                           156  * ERROR_4: Address error (Odd ending address)
0000111C                           157  *---------------------------------------------------------------------------*         
0000111C                           158  ERROR_4
0000111C  43F9 000043B4            159              LEA     ERRMSG_3, A1
00001122  103C 000E                160              MOVE.B  #14, D0
00001126  4E4F                     161              TRAP    #15
00001128  4EF8 1088                162              JMP     END_ADDR
0000112C                           163            
0000112C                           164  *---------------------------------------------------------------------------*
0000112C                           165  * ERROR_3: Address error (Ending address is less than starting address)
0000112C                           166  *---------------------------------------------------------------------------*
0000112C                           167  ERROR_5
0000112C  43F9 000043D9            168              LEA     ERRMSG_5, A1
00001132  103C 000E                169              MOVE.B  #14, D0
00001136  4E4F                     170              TRAP    #15
00001138  4EF8 1088                171              JMP     END_ADDR
0000113C                           172    
0000113C                           173  *---------------------------------------------------------------------------*
0000113C                           174  * ASCII2HEX: Convert ASCii to Hexadecimal
0000113C                           175  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
0000113C                           176  *---------------------------------------------------------------------------*
0000113C  4281                     177  ASCII2HEX   CLR.L   D1                      * Clear the destination 
0000113E  4287                     178              CLR.L   D7                      * Set the error flag to 0
00001140  4282                     179              CLR.L   D2                      * Clear D2 for temp storage
00001142                           180              
00001142  1419                     181  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001144  0C02 0000                182              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
00001148  6700 0058                183              BEQ     RETURN                  * If it's NULL, go to return
0000114C  0C02 0066                184              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001150  6E00 004C                185              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001154  0C02 0061                186              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
00001158  6C00 0026                187              BGE     ASC_LOW                 * ASCII >= a (valid input)
0000115C  0C02 0046                188              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001160  6E00 003C                189              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001164  0C02 0041                190              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
00001168  6C00 001E                191              BGE     ASC_UPP                 * ASCII >= A (valid input)
0000116C  0C02 0039                192              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001170  6E00 002C                193              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001174  0C02 0030                194              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
00001178  6C00 0016                195              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
0000117C  6000 0020                196              BRA     ASC_ERR                 * Invalid input
00001180                           197  
00001180  0442 0057                198  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001184  6000 0012                199              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
00001188                           200              
00001188  0442 0037                201  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
0000118C  6000 000A                202              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
00001190                           203              
00001190  0442 0030                204  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
00001194  6000 0002                205              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
00001198                           206              
00001198  E981                     207  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
0000119A  D202                     208              ADD.B   D2, D1                  * Add the converted input to D1
0000119C  60A4                     209              BRA     ASC2HXLP                * Loop
0000119E                           210  
0000119E  1E3C 0001                211  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011A2  4E75                     212  RETURN      RTS     
000011A4                           213  
000011A4                           214  *---------------------------------------------------------------------------*
000011A4                           215  * ASCII2HEX: Convert ASCii to Hexadecimal
000011A4                           216  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011A4                           217  *---------------------------------------------------------------------------*
000011A4                           218  ASCII2HEX2STACK
000011A4  4283                     219              CLR.L   D3                      * Clear the destination 
000011A6  4287                     220              CLR.L   D7                      * Set the error flag to 0
000011A8  4282                     221              CLR.L   D2                      * Clear D2 for temp storage
000011AA                           222              
000011AA                           223  ASC2HXLP2STACK
000011AA  1419                     224              MOVE.B  (A1)+, D2               * Read a byte to D2
000011AC  0C02 0000                225              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011B0  6700 0058                226              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011B4  0C02 0066                227              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011B8  6E00 004C                228              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011BC  0C02 0061                229              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011C0  6C00 0026                230              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011C4  0C02 0046                231              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011C8  6E00 003C                232              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011CC  0C02 0041                233              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011D0  6C00 001E                234              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011D4  0C02 0039                235              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011D8  6E00 002C                236              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
000011DC  0C02 0030                237              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011E0  6C00 0016                238              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
000011E4  6000 0020                239              BRA     ASC_ERR2STACK                 * Invalid input
000011E8                           240  
000011E8                           241  ASC_LOW2STACK
000011E8  0442 0057                242              SUBI    #87, D2                 * Convert the ASCII input to Hex
000011EC  6000 0012                243              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
000011F0                           244              
000011F0                           245  ASC_UPP2STACK
000011F0  0442 0037                246              SUBI    #55, D2                 * Convert the ASCII input to Hex
000011F4  6000 000A                247              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
000011F8                           248              
000011F8                           249  ASC_NUM2STACK
000011F8  0442 0030                250              SUBI    #48, D2                 * Convert the ASCII input to Hex
000011FC  6000 0002                251              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
00001200                           252              
00001200                           253  ASC_SFT2STACK
00001200  E983                     254              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
00001202  D602                     255              ADD.B   D2, D3                  * Add the converted input to D1
00001204  60A4                     256              BRA     ASC2HXLP2STACK                * Loop
00001206                           257  
00001206                           258  ASC_ERR2STACK
00001206  1E3C 0001                259              MOVE.B  #1, D7                  * Set the error flag to 1            
0000120A                           260  RETURN2STACK
0000120A  4E75                     261              RTS  
0000120C                           262  *---------------------------------------------------------------------------*
0000120C                           263  * HEX2ASCII: Convert Hexadecimal to ASCii 
0000120C                           264  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
0000120C                           265  *---------------------------------------------------------------------------*
0000120C  0C02 0008                266  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001210  6700 000E                267              BEQ     HEX_LOOP
00001214  4841                     268              SWAP    D1
00001216  0C02 0002                269              CMPI.B  #2,D2
0000121A  6600 0004                270              BNE     HEX_LOOP
0000121E  E189                     271              LSL.L   #8,D1
00001220                           272             
00001220  E999                     273  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001222  2601                     274              MOVE.L  D1, D3                  * Move D1 to D3
00001224  0283 0000000F            275              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000122A  0C03 0009                276              CMPI.B  #9, D3                  * Compare te digit
0000122E  6E00 000A                277              BGT     HEX_CHAR              
00001232  0603 0030                278              ADDI.B  #48,D3                  * Add 48 for numerical output
00001236  6000 0006                279              BRA     HEX_CONT
0000123A                           280              
0000123A  0603 0037                281  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
0000123E                           282  
0000123E  12C3                     283  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001240  5342                     284              SUBI    #1, D2                  * Decrement the size
00001242  0C02 0000                285              CMPI.B  #0, D2                  * Check if D2 is 0
00001246  66D8                     286              BNE     HEX_LOOP                * Loop
00001248  12BC 0000                287              MOVE.B  #$0,(A1)                * Null terminator
0000124C  4E75                     288              RTS
0000124E                           289  *---------------------------------------------------------------------------*
0000124E                           290  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
0000124E                           291  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
0000124E                           292  *---------------------------------------------------------------------------*
0000124E                           293  HEX2ASCII2STACK
0000124E  0C02 0008                294              CMPI.B  #8, D2                  * Check to see if the size is long
00001252  6700 000E                295              BEQ     STACK_HEX_LOOP
00001256  4841                     296              SWAP    D1
00001258  0C02 0002                297              CMPI.B  #2,D2
0000125C  6600 0004                298              BNE     STACK_HEX_LOOP
00001260  E189                     299              LSL.L   #8,D1
00001262                           300             
00001262                           301  STACK_HEX_LOOP    
00001262  E999                     302              ROL.L   #4, D1                  * Roll D1 to left
00001264  2601                     303              MOVE.L  D1, D3                  * Move D1 to D3
00001266  0283 0000000F            304              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000126C  0C03 0009                305              CMPI.B  #9, D3                  * Compare te digit
00001270  6E00 000A                306              BGT     STACK_HEX_CHAR              
00001274  0603 0030                307              ADDI.B  #48,D3                  * Add 48 for numerical output
00001278  6000 0006                308              BRA     STACK_HEX_CONT
0000127C                           309              
0000127C                           310  STACK_HEX_CHAR    
0000127C  0603 0037                311              ADDI.B  #55,D3                  * Add 55 for character output
00001280                           312  
00001280                           313  STACK_HEX_CONT    
00001280  6100 2C56                314              BSR     PUSH_STACK              *PLACE INTO STACK
00001284  5342                     315              SUBI    #1, D2                  * Decrement the size
00001286  0C02 0000                316              CMPI.B  #0, D2                  * Check if D2 is 0
0000128A  66D6                     317              BNE     STACK_HEX_LOOP                * Loop
0000128C  12BC 0000                318              MOVE.B  #$0,(A1)                * Null terminator
00001290  4E75                     319              RTS
00001292                           320  
00001292                           321  
00001292                           322  *---------------------------------------------------------------------------*
00001292                           323  * IS_ODD: Check whether the source address is odd
00001292                           324  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
00001292                           325  *---------------------------------------------------------------------------*
00001292  4281                     326  IS_ODD      CLR.L   D1                      * Clear the result
00001294  4287                     327              CLR.L   D7                      * Set the error flag to 0
00001296  2211                     328              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001298  82FC 0002                329              DIVU    #2, D1                  * Divide the result by 2
0000129C  4841                     330              SWAP    D1                      * Swap remainder with quotient
0000129E  0C01 0001                331              CMPI.B  #1, D1                  * Check for error
000012A2  6700 0004                332              BEQ     IS_ODD_ERR
000012A6  4E75                     333              RTS
000012A8                           334              
000012A8  1E3C 0001                335  IS_ODD_ERR  MOVE.B  #1, D7
000012AC  4E75                     336              RTS
000012AE                           337  
000012AE                           338  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012AE                           339  * MAINDEBUG                    
000012AE                           340  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012AE                           341  * A5: Processing address
000012AE                           342  *
000012AE                           343  * D3: USED FOR PUSHING INTO STACK
000012AE                           344  *     To push into stack => MOVE.W #DATA,D3 
000012AE                           345  *                           BSR    PUSH_STACK
000012AE                           346  *     To print stack     => BSR    PRINT_STACK 
000012AE                           347  *     To clear stack     => BSR    CLEAR_STACK
000012AE                           348  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012AE                           349  MAIN        
000012AE                           350              *initialize stack pointer
000012AE  33FC 0000 0000455E       351              MOVE.W  #0,COUNTER
000012B6  347C 7000                352              MOVEA.W #STACK,A2
000012BA  163C 0020                353              MOVE.B  #' ',D3
000012BE  6100 2C18                354              BSR     PUSH_STACK
000012C2  6100 2C14                355              BSR     PUSH_STACK
000012C6  6100 2C10                356              BSR     PUSH_STACK
000012CA                           357              
000012CA                           358              * clear registers for temp storage
000012CA  4280                     359              CLR.L   D0                   
000012CC  4281                     360              CLR.L   D1                   
000012CE  227C 00000000            361              MOVEA.L #0, A1                
000012D4                           362              
000012D4  220D                     363              MOVE.L  A5,D1                   * check to see if the address is fully read
000012D6  23CD 000044A6            364              MOVE.L  A5,S_ADDR_HX
000012DC  B2B9 000044AA            365              CMP.L   E_ADDR_HX,D1
000012E2  6C00 2314                366              BGE     REPEAT                  * go to repeat for user action
000012E6                           367  
000012E6  43F9 00004501            368              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012EC  143C 0008                369              MOVE.B  #8,D2                   * set the output size
000012F0  4EB8 120C                370              JSR     HEX2ASCII               
000012F4  43F9 00004501            371              LEA     TMPOUTPUT,A1
000012FA  103C 000E                372              MOVE.B  #14,D0
000012FE  4E4F                     373              TRAP    #15
00001300                           374              
00001300  4285                     375              CLR.L    D5                      * clear the processing data
00001302  3A1D                     376              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
00001304                           377                                               * advance the current instruction pointer to the next
00001304                           378                                               * instruction in memory
00001304                           379  *----------------------------------------*
00001304                           380  * Registers          
00001304                           381  * [D1] - COPY OF D5
00001304                           382  * [D5] - DATA TO BE PROCESSED
00001304                           383  * [D6] - COUNTER FOR LINES PROCESSED
00001304                           384  *
00001304                           385  * [D4]      - ERROR FLAG BEFORE PRINTING
00001304                           386  * [STACK]   - PRINTS PROCESS DATA
00001304                           387  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
00001304                           388  *
00001304                           389  * [A1] - USED FOR JUMPING/PRINTING
00001304                           390  *
00001304                           391  *----------------------------------------*
00001304                           392  
00001304                           393              
00001304                           394              *Processing the first 4 most significant bits 
00001304  2205                     395              MOVE.L  D5,D1                    * copy the current processing data to D1
00001306  143C 000C                396              MOVE.B  #12,D2                   * shift to right by 12 bits
0000130A  E469                     397              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
0000130C  C2FC 0006                398              MULU    #6,D1                    * form offset
00001310  43F9 00001380            399              LEA     JMPTABLE,A1              * index into table
00001316  4EB1 1000                400              JSR     0(A1,D1)                 * jump indirect with index
0000131A                           401              
0000131A                           402              *SECURED EA*
0000131A  B83C 0001                403              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
0000131E  6600 0012                404              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001322  6100 041C                405              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001326  6100 2C1C                406              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000132A  183C 0000                407              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000132E  6000 0022                408              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001332                           409             
00001332                           410  OUTPUT_PROCESSED_DATA       
00001332  163C 000D                411              MOVE.B  #$D,D3                  *carriage return
00001336  6100 2BA0                412              BSR     PUSH_STACK
0000133A  163C 000A                413              MOVE.B  #$A,D3                  *new line feed
0000133E  6100 2B98                414              BSR     PUSH_STACK
00001342  163C 0000                415              MOVE.B  #$0,D3                  *null
00001346  6100 2B90                416              BSR     PUSH_STACK
0000134A                           417       
0000134A  6100 2B68                418              BSR     PRINT_QUEUE
0000134E  183C 0000                419              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001352                           420  DISPLAY_30_LINES
00001352                           421              * display 30 lines per page
00001352  5287                     422              ADDI.L  #1,D7
00001354  0C87 00000019            423              CMPI.L  #25,D7
0000135A  6C00 0006                424              BGE     NEXTLINES
0000135E  6000 FF4E                425              BRA     MAIN
00001362                           426            
00001362                           427  *---------------------------------------------------------------------------*
00001362                           428  * NEXTLINES: receive input from user to print the next 30 lines
00001362                           429  *---------------------------------------------------------------------------*  
00001362  4287                     430  NEXTLINES   CLR.L   D7
00001364  43F9 000042FD            431              LEA     DISP_NEXT,A1
0000136A  103C 000E                432              MOVE.B  #14,D0
0000136E  4E4F                     433              TRAP    #15
00001370  43F9 000044B1            434              LEA     TMPINPUT,A1
00001376  103C 0002                435              MOVE.B  #2,D0
0000137A  4E4F                     436              TRAP    #15
0000137C  4EF8 12AE                437              JMP     MAIN
00001380                           438    
00001380                           439  *---------------------------------------------------------------------------*
00001380                           440  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001380                           441  *---------------------------------------------------------------------------*  
00001380  4EF9 000013E0            442  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - 
00001386  4EF9 0000195C            443              JMP     OP0001  * MOVE.B                                        *FINISHED - 
0000138C  4EF9 000019CA            444              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - 
00001392  4EF9 00001AC8            445              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - 
00001398  4EF9 00001BC4            446              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - need to do movem
0000139E  4EF9 00001EF0            447              JMP     OP0101  * ADDQ                                          *FINISHED - 
000013A4  4EF9 0000205E            448              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *FINISHED - 
000013AA  4EF9 00002164            449              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - 
000013B0  4EF9 00002168            450              JMP     OP1000  * DIVS                                          *FINISHED - 
000013B6  4EF9 0000225C            451              JMP     OP1001  * SUB/SUBA                                      *FINISHED - 
000013BC  4EF9 000025AC            452              JMP     OP1010  * Unassigned                                    *FINISHED - 
000013C2  4EF9 000025B0            453              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - 
000013C8  4EF9 0000280E            454              JMP     OP1100  * MULS/AND                                      *FINISHED - 
000013CE  4EF9 00002B60            455              JMP     OP1101  * ADD/ADDA                                      *FINISHED - 
000013D4  4EF9 00002EB0            456              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR                       *FINISHED - 
000013DA  4EF9 00003570            457              JMP     OP1111  * Special/Reserved
000013E0                           458              
000013E0                           459  *---------------------------------------------------------------------------*
000013E0                           460  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013E0                           461  *---------------------------------------------------------------------------*           
000013E0                           462  OP0000                                                                                  
000013E0  4281                     463              CLR.L   D1          * to temporarily store the address to process
000013E2  4280                     464              CLR.L   D0  
000013E4  4284                     465              CLR.L   D4                 
000013E6  227C 00000000            466              MOVEA.L #0, A1                
000013EC                           467              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013EC                           468              * Check if bit 11,10,9,8 are 0000)
000013EC  2205                     469              MOVE.L  D5,D1
000013EE  0281 00000F00            470              ANDI.L  #$0F00,D1
000013F4  0C81 00000000            471              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013FA  6700 047C                472              BEQ     OP_ORI
000013FE                           473  
000013FE                           474              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013FE                           475              * check if bit 11,10,9,8 are 1100
000013FE  4281                     476              CLR.L   D1
00001400  2205                     477              MOVE.L  D5,D1
00001402  0281 00000F00            478              ANDI.L  #$0F00,D1
00001408  0C81 00000C00            479              CMPI.L  #$0C00,D1
0000140E  6700 037C                480              BEQ     OP0000_CMPI
00001412                           481              
00001412                           482              * check for SUBI
00001412  4281                     483              CLR.L   D1
00001414  2205                     484              MOVE.L  D5,D1
00001416  0281 00000F00            485              ANDI.L  #$0F00,D1
0000141C  0C81 00000400            486              CMPI.L  #$0400,D1
00001422  6700 023A                487              BEQ     OP_SUBI
00001426                           488              
00001426                           489              * check for EORI
00001426  4281                     490              CLR.L   D1
00001428  2205                     491              MOVE.L  D5,D1
0000142A  0281 00000F00            492              ANDI.L  #$0F00,D1
00001430  0C81 00000A00            493              CMPI.L  #$0A00,D1
00001436  6700 0144                494              BEQ     OP_EORI
0000143A                           495              
0000143A                           496              * check for BTST
0000143A  4281                     497              CLR.L   D1
0000143C  2205                     498              MOVE.L  D5,D1
0000143E  E099                     499              ROR.L   #8,D1
00001440  0281 00000001            500              ANDI.L  #$1,D1
00001446  0C01 0001                501              CMPI.B  #$1,D1
0000144A  6700 001E                502              BEQ     OP_BTST
0000144E  4281                     503              CLR.L   D1
00001450  2205                     504              MOVE.L  D5,D1
00001452  EC99                     505              ROR.L   #6,D1
00001454  0281 000003FF            506              ANDI.L  #$03FF,D1
0000145A  0C81 00000020            507              CMPI.L  #%000100000,D1
00001460  6700 0008                508              BEQ     OP_BTST
00001464                           509  
00001464                           510  
00001464                           511              * OP0000 series other than ORI/CMPI/BTST/EORI
00001464  4EF9 00001740            512              JMP     OP_DATA
0000146A                           513              
0000146A                           514  *---------------------------------------------------------------------------*
0000146A                           515  * OP_BTST: display BTST
0000146A                           516  *---------------------------------------------------------------------------* 
0000146A                           517  OP_BTST       
0000146A                           518              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000146A                           519              *bits #8 indicates which
0000146A                           520              *0 - #immediate format
0000146A                           521              *1 - Dn format
0000146A  4281                     522              CLR.L   D1
0000146C  2205                     523              MOVE.L  D5,D1
0000146E  E099                     524              ROR.L   #8,D1
00001470  0281 00000001            525              ANDI.L  #1,D1
00001476  0C01 0001                526              CMPI.B  #1,D1
0000147A  6600 0078                527              BNE     OP_BTST_IMMEDIATE
0000147E                           528  
0000147E                           529             
0000147E                           530             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000147E  13FC 0000 00004562       531             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001486  13FC 0002 00004563       532             MOVE.B   #$02,SRC_REGISTER_FORMAT
0000148E                           533             
0000148E                           534             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000148E  13FC 00B9 00004565       535             MOVE.B   #$B9,GET_DST_START_END
00001496  13FC 0020 00004566       536             MOVE.B   #$20,GET_SRC_START_END
0000149E                           537             
0000149E  0285 0000FE3F            538             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014A4  0685 00000000            539             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014AA                           540              
000014AA                           541              *CLEAR D3
000014AA  4283                     542              CLR.L   D3
000014AC                           543              *LOAD STACK WITH THIS OPMODE
000014AC  6100 2A2A                544              BSR     PUSH_STACK
000014B0  163C 0042                545              MOVE.B  #'B',D3
000014B4  6100 2A22                546              BSR     PUSH_STACK
000014B8  163C 0054                547              MOVE.B  #'T',D3
000014BC  6100 2A1A                548              BSR     PUSH_STACK
000014C0  163C 0053                549              MOVE.B  #'S',D3
000014C4  6100 2A12                550              BSR     PUSH_STACK
000014C8  163C 0054                551              MOVE.B  #'T',D3
000014CC  6100 2A0A                552              BSR     PUSH_STACK
000014D0  163C 002E                553              MOVE.B  #'.',D3
000014D4  6100 2A02                554              BSR     PUSH_STACK
000014D8  163C 0042                555              MOVE.B  #'B',D3
000014DC  6100 29FA                556              BSR     PUSH_STACK
000014E0                           557              
000014E0  6100 2588                558              BSR     GET_EA_EA_DEST
000014E4  163C 002C                559              MOVE.B  #',',D3
000014E8  6100 29EE                560              BSR     PUSH_STACK
000014EC  6100 214C                561              BSR     GET_EA_EA_SRC
000014F0                           562              
000014F0  6000 0088                563              BRA     OP0000_RETURN_BTST
000014F4                           564              
000014F4                           565              
000014F4                           566              *MOVE **** OR **** CMPI
000014F4                           567              
000014F4                           568  OP_BTST_IMMEDIATE              
000014F4                           569   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000014F4  13FC 0000 00004562       570             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014FC  13FC 0082 00004563       571             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001504                           572             
00001504                           573             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001504  13FC 00B9 00004565       574             MOVE.B   #$B9,GET_DST_START_END
0000150C  13FC 0020 00004566       575             MOVE.B   #$20,GET_SRC_START_END
00001514                           576             
00001514                           577              *CLEAR D3
00001514  4283                     578              CLR.L   D3
00001516                           579              *LOAD STACK WITH THIS OPMODE
00001516  6100 29C0                580              BSR     PUSH_STACK
0000151A  163C 0042                581              MOVE.B  #'B',D3
0000151E  6100 29B8                582              BSR     PUSH_STACK
00001522  163C 0054                583              MOVE.B  #'T',D3
00001526  6100 29B0                584              BSR     PUSH_STACK
0000152A  163C 0053                585              MOVE.B  #'S',D3
0000152E  6100 29A8                586              BSR     PUSH_STACK
00001532  163C 0054                587              MOVE.B  #'T',D3
00001536  6100 29A0                588              BSR     PUSH_STACK
0000153A  163C 002E                589              MOVE.B  #'.',D3
0000153E  6100 2998                590              BSR     PUSH_STACK
00001542  163C 0042                591              MOVE.B  #'B',D3
00001546  6100 2990                592              BSR     PUSH_STACK
0000154A                           593  
0000154A                           594  OP0000_BTST_B
0000154A                           595              *GET DATA FROM ADDQ AND PRINT #0-8
0000154A                           596              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000154A  0285 0000F03F            597              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001550  0685 000001C0            598              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001556                           599  
00001556                           600              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001556                           601             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001556                           602             * MOVE.W    (A5)+,D1
00001556                           603             * MOVE.B  #' ',D3
00001556                           604             * BSR     PUSH_STACK
00001556                           605             * MOVE.B  #'#',D3
00001556                           606             * BSR     PUSH_STACK
00001556                           607             * BSR     HEX2ASCII2STACK
00001556                           608             * BSR     PUSH_STACK
00001556                           609              
00001556  163C 0020                610              MOVE.B  #' ',D3
0000155A  6100 297C                611              BSR     PUSH_STACK
0000155E  163C 0023                612              MOVE.B  #'#',D3
00001562  6100 2974                613              BSR     PUSH_STACK
00001566  6100 2502                614              BSR     GET_EA_EA_DEST
0000156A  163C 002C                615              MOVE.B  #',',D3
0000156E  6100 2968                616              BSR     PUSH_STACK
00001572  6100 20C6                617              BSR     GET_EA_EA_SRC
00001576  6000 0002                618              BRA     OP0000_RETURN_BTST
0000157A                           619  OP0000_RETURN_BTST
0000157A                           620              
0000157A  4E75                     621              RTS
0000157C                           622  
0000157C                           623  
0000157C                           624  *---------------------------------------------------------------------------*
0000157C                           625  * OP_EORI: decode and display EORI
0000157C                           626  *---------------------------------------------------------------------------* 
0000157C                           627  OP_EORI
0000157C                           628                         
0000157C                           629  
0000157C                           630   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000157C  13FC 0000 00004562       631             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001584  13FC 0080 00004563       632             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000158C                           633             
0000158C                           634             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000158C  13FC 00B9 00004565       635             MOVE.B   #$B9,GET_DST_START_END
00001594  13FC 0020 00004566       636             MOVE.B   #$20,GET_SRC_START_END
0000159C                           637             
0000159C                           638              *CLEAR D3
0000159C  4283                     639              CLR.L   D3
0000159E                           640              *LOAD STACK WITH THIS OPMODE
0000159E  6100 2938                641              BSR     PUSH_STACK
000015A2  163C 0045                642              MOVE.B  #'E',D3
000015A6  6100 2930                643              BSR     PUSH_STACK
000015AA  163C 004F                644              MOVE.B  #'O',D3
000015AE  6100 2928                645              BSR     PUSH_STACK
000015B2  163C 0052                646              MOVE.B  #'R',D3
000015B6  6100 2920                647              BSR     PUSH_STACK
000015BA  163C 0049                648              MOVE.B  #'I',D3
000015BE  6100 2918                649              BSR     PUSH_STACK
000015C2  163C 002E                650              MOVE.B  #'.',D3
000015C6  6100 2910                651              BSR     PUSH_STACK
000015CA                           652              
000015CA                           653              *FIGURE OUT SIZE*
000015CA                           654              *00 = BYTE
000015CA                           655              *01 = WORD
000015CA                           656              *10 = LONG
000015CA                           657              * BITS 7&6
000015CA                           658              
000015CA                           659              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015CA  2205                     660              MOVE.L  D5,D1
000015CC  EC99                     661              ROR.L   #6,D1
000015CE  0281 00000003            662              ANDI.L  #$03,D1
000015D4  0C01 0000                663              CMPI.B  #%00,D1
000015D8  6700 001E                664              BEQ     OP0000_EOR_B
000015DC  0281 00000003            665              ANDI.L  #$03,D1
000015E2  0C01 0001                666              CMPI.B  #%01,D1
000015E6  6700 0028                667              BEQ     OP0000_EOR_W
000015EA  0281 00000003            668              ANDI.L  #$03,D1
000015F0  0C01 0002                669              CMPI.B  #%10,D1
000015F4  6700 0032                670              BEQ     OP0000_EOR_L
000015F8                           671            
000015F8                           672  OP0000_EOR_B
000015F8                           673              
000015F8  163C 0042                674              MOVE.B  #'B',D3
000015FC  6100 28DA                675              BSR     PUSH_STACK
00001600                           676              
00001600                           677              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001600  0285 0000F03F            678              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001606  0685 000001C0            679              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000160C                           680  
0000160C                           681              
0000160C  6000 002E                682              BRA     OP0000_RETURN_EOR
00001610                           683  OP0000_EOR_W
00001610                           684              
00001610  163C 0057                685              MOVE.B  #'W',D3
00001614  6100 28C2                686              BSR     PUSH_STACK
00001618                           687              
00001618                           688              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001618  0285 0000F03F            689              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000161E  0685 000001C0            690              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001624                           691  
00001624                           692              
00001624  6000 0016                693              BRA     OP0000_RETURN_EOR
00001628                           694  OP0000_EOR_L
00001628                           695              
00001628  163C 004C                696              MOVE.B  #'L',D3
0000162C  6100 28AA                697              BSR     PUSH_STACK
00001630                           698              
00001630                           699              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001630  0285 0000FE3F            700              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001636  0685 000009C0            701              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000163C                           702  
0000163C                           703  
0000163C                           704  OP0000_RETURN_EOR       
0000163C  163C 0020                705              MOVE.B  #' ',D3
00001640  6100 2896                706              BSR     PUSH_STACK
00001644  163C 0023                707              MOVE.B  #'#',D3
00001648  6100 288E                708              BSR     PUSH_STACK
0000164C  6100 241C                709              BSR     GET_EA_EA_DEST
00001650  163C 002C                710              MOVE.B  #',',D3
00001654  6100 2882                711              BSR     PUSH_STACK
00001658  6100 1FE0                712              BSR     GET_EA_EA_SRC
0000165C                           713              
0000165C  4E75                     714              RTS
0000165E                           715  
0000165E                           716  *---------------------------------------------------------------------------*
0000165E                           717  * OP_SUBI: decode SUBI.B/.W/.L
0000165E                           718  *---------------------------------------------------------------------------* 
0000165E                           719  OP_SUBI
0000165E                           720             
0000165E                           721   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000165E  13FC 0000 00004562       722             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001666  13FC 0080 00004563       723             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000166E                           724             
0000166E                           725             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000166E  13FC 00B9 00004565       726             MOVE.B   #$B9,GET_DST_START_END
00001676  13FC 0020 00004566       727             MOVE.B   #$20,GET_SRC_START_END
0000167E                           728             
0000167E                           729              *CLEAR D3
0000167E  4283                     730              CLR.L   D3
00001680                           731              *LOAD STACK WITH THIS OPMODE
00001680  6100 2856                732              BSR     PUSH_STACK
00001684  163C 0053                733              MOVE.B  #'S',D3
00001688  6100 284E                734              BSR     PUSH_STACK
0000168C  163C 0055                735              MOVE.B  #'U',D3
00001690  6100 2846                736              BSR     PUSH_STACK
00001694  163C 0042                737              MOVE.B  #'B',D3
00001698  6100 283E                738              BSR     PUSH_STACK
0000169C  163C 0049                739              MOVE.B  #'I',D3
000016A0  6100 2836                740              BSR     PUSH_STACK
000016A4  163C 002E                741              MOVE.B  #'.',D3
000016A8  6100 282E                742              BSR     PUSH_STACK
000016AC                           743              
000016AC                           744              *FIGURE OUT SIZE*
000016AC                           745              *00 = BYTE
000016AC                           746              *01 = WORD
000016AC                           747              *10 = LONG
000016AC                           748              * BITS 7&6
000016AC                           749              
000016AC                           750              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016AC  2205                     751              MOVE.L  D5,D1
000016AE  EC99                     752              ROR.L   #6,D1
000016B0  0281 00000003            753              ANDI.L  #$03,D1
000016B6  0C01 0000                754              CMPI.B  #%00,D1
000016BA  6700 001E                755              BEQ     OP0000_SUB_B
000016BE  0281 00000003            756              ANDI.L  #$03,D1
000016C4  0C01 0001                757              CMPI.B  #%01,D1
000016C8  6700 0028                758              BEQ     OP0000_SUB_W
000016CC  0281 00000003            759              ANDI.L  #$03,D1
000016D2  0C01 0002                760              CMPI.B  #%10,D1
000016D6  6700 0032                761              BEQ     OP0000_SUB_L
000016DA                           762            
000016DA                           763  OP0000_SUB_B
000016DA                           764              
000016DA  163C 0042                765              MOVE.B  #'B',D3
000016DE  6100 27F8                766              BSR     PUSH_STACK
000016E2                           767              
000016E2                           768              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016E2  0285 0000F03F            769              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016E8  0685 000001C0            770              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000016EE                           771  
000016EE                           772              
000016EE  6000 002E                773              BRA     OP0000_RETURN_SUBI
000016F2                           774  OP0000_SUB_W
000016F2                           775              
000016F2  163C 0057                776              MOVE.B  #'W',D3
000016F6  6100 27E0                777              BSR     PUSH_STACK
000016FA                           778              
000016FA                           779              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016FA  0285 0000F03F            780              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001700  0685 000001C0            781              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001706                           782  
00001706                           783              
00001706  6000 0016                784              BRA     OP0000_RETURN_SUBI
0000170A                           785  OP0000_SUB_L
0000170A                           786              
0000170A  163C 004C                787              MOVE.B  #'L',D3
0000170E  6100 27C8                788              BSR     PUSH_STACK
00001712                           789              
00001712                           790              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001712  0285 0000F03F            791              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001718  0685 000003C0            792              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000171E                           793                      
0000171E                           794  OP0000_RETURN_SUBI            
0000171E  163C 0020                795              MOVE.B  #' ',D3
00001722  6100 27B4                796              BSR     PUSH_STACK
00001726  163C 0023                797              MOVE.B  #'#',D3
0000172A  6100 27AC                798              BSR     PUSH_STACK
0000172E  6100 233A                799              BSR     GET_EA_EA_DEST
00001732  163C 002C                800              MOVE.B  #',',D3
00001736  6100 27A0                801              BSR     PUSH_STACK
0000173A  6100 1EFE                802              BSR     GET_EA_EA_SRC
0000173E                           803              
0000173E  4E75                     804              RTS
00001740                           805  
00001740                           806              
00001740                           807  *---------------------------------------------------------------------------*
00001740                           808  * OP_DATA : unidentified opcode
00001740                           809  *---------------------------------------------------------------------------* 
00001740                           810  OP_DATA
00001740  4280                     811              CLR.L   D0                   
00001742  4281                     812              CLR.L   D1     
00001744  4284                     813              CLR.L   D4                    
00001746  227C 00000000            814              MOVEA.L #0, A1             
0000174C  4287                     815              CLR.L   D7
0000174E  1E3C 0001                816              MOVE.B  #1,D7                   * error flag is true
00001752                           817              
00001752  43F9 00004551            818              LEA     DISP_DATA,A1
00001758  103C 000E                819              MOVE.B  #14,D0
0000175C  4E4F                     820              TRAP    #15
0000175E                           821              
0000175E  4EF9 00001764            822              JMP     EA_DATA
00001764                           823             
00001764                           824             
00001764                           825  *---------------------------------------------------------------------------*
00001764                           826  * EA_DATA
00001764                           827  *---------------------------------------------------------------------------*       
00001764  43F9 00004501            828  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000176A  2205                     829              MOVE.L  D5,D1           * transfer the processing data to D1
0000176C  7404                     830              MOVE.L  #4,D2           * set to word size
0000176E  4EB8 120C                831              JSR     HEX2ASCII       * prepare output in ascii
00001772  43F9 00004559            832              LEA     DISP_HEX,A1     * display $ symbol
00001778  103C 000E                833              MOVE.B  #14,D0      
0000177C  4E4F                     834              TRAP    #15
0000177E  43F9 00004501            835              LEA     TMPOUTPUT,A1    * display with a new line
00001784  103C 000D                836              MOVE.B  #13,D0
00001788  4E4F                     837              TRAP    #15
0000178A                           838  
0000178A  4E75                     839              RTS
0000178C                           840              
0000178C                           841  *---------------------------------------------------------------------------*
0000178C                           842  * OP_CMPI : decode CMPI and its size
0000178C                           843  *---------------------------------------------------------------------------*          
0000178C                           844  OP0000_CMPI
0000178C                           845  
0000178C                           846              
0000178C                           847   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000178C  13FC 0000 00004562       848             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001794  13FC 0082 00004563       849             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000179C                           850             
0000179C                           851             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000179C  13FC 00B9 00004565       852             MOVE.B   #$B9,GET_DST_START_END
000017A4  13FC 0020 00004566       853             MOVE.B   #$20,GET_SRC_START_END
000017AC                           854             
000017AC                           855              *CLEAR D3
000017AC  4283                     856              CLR.L   D3
000017AE                           857              *LOAD STACK WITH THIS OPMODE
000017AE  6100 2728                858              BSR     PUSH_STACK
000017B2  163C 0043                859              MOVE.B  #'C',D3
000017B6  6100 2720                860              BSR     PUSH_STACK
000017BA  163C 004D                861              MOVE.B  #'M',D3
000017BE  6100 2718                862              BSR     PUSH_STACK
000017C2  163C 0050                863              MOVE.B  #'P',D3
000017C6  6100 2710                864              BSR     PUSH_STACK
000017CA  163C 0049                865              MOVE.B  #'I',D3
000017CE  6100 2708                866              BSR     PUSH_STACK
000017D2  163C 002E                867              MOVE.B  #'.',D3
000017D6  6100 2700                868              BSR     PUSH_STACK
000017DA                           869              
000017DA                           870              *FIGURE OUT SIZE*
000017DA                           871              *00 = BYTE
000017DA                           872              *01 = WORD
000017DA                           873              *10 = LONG
000017DA                           874              * BITS 7&6
000017DA                           875              
000017DA                           876              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017DA  2205                     877              MOVE.L  D5,D1
000017DC  EC99                     878              ROR.L   #6,D1
000017DE  0281 00000003            879              ANDI.L  #$03,D1
000017E4  0C01 0000                880              CMPI.B  #%00,D1
000017E8  6700 0018                881              BEQ     OP0000_CMPI_B
000017EC  0C01 0001                882              CMPI.B  #%01,D1
000017F0  6700 0038                883              BEQ     OP0000_CMPI_W
000017F4  0281 00000003            884              ANDI.L  #$03,D1
000017FA  0C01 0002                885              CMPI.B  #%10,D1
000017FE  6700 0052                886              BEQ     OP0000_CMPI_L
00001802                           887  
00001802                           888  OP0000_CMPI_B
00001802  163C 0042                889              MOVE.B  #'B',D3
00001806  6100 26D0                890              BSR     PUSH_STACK
0000180A                           891  *GET DATA FROM ADDQ AND PRINT #0-8
0000180A                           892              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000180A  0285 0000F03F            893              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001810  0685 000001C0            894              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001816  6100 2252                895              BSR     GET_EA_EA_DEST
0000181A  163C 002C                896              MOVE.B  #',',D3
0000181E  6100 26B8                897              BSR     PUSH_STACK
00001822  6100 1E16                898              BSR     GET_EA_EA_SRC
00001826  6000 004E                899              BRA     OP0000_RETURN_CMPI
0000182A                           900  
0000182A                           901  OP0000_CMPI_W
0000182A  163C 0057                902              MOVE.B  #'W',D3
0000182E  6100 26A8                903              BSR     PUSH_STACK
00001832                           904  *GET DATA FROM ADDQ AND PRINT #0-8
00001832                           905              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001832  0285 0000F03F            906              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001838  0685 000001C0            907              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000183E  6100 222A                908              BSR     GET_EA_EA_DEST
00001842  163C 002C                909              MOVE.B  #',',D3
00001846  6100 2690                910              BSR     PUSH_STACK
0000184A  6100 1DEE                911              BSR     GET_EA_EA_SRC
0000184E  6000 0026                912              BRA     OP0000_RETURN_CMPI
00001852                           913  
00001852                           914  OP0000_CMPI_L
00001852  163C 004C                915              MOVE.B  #'L',D3
00001856  6100 2680                916              BSR     PUSH_STACK
0000185A                           917              *GET DATA FROM ADDQ AND PRINT #0-8
0000185A                           918              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000185A  0285 0000F03F            919              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001860  0685 000003C0            920              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001866  6100 2202                921              BSR     GET_EA_EA_DEST
0000186A  163C 002C                922              MOVE.B  #',',D3
0000186E  6100 2668                923              BSR     PUSH_STACK
00001872  6100 1DC6                924              BSR     GET_EA_EA_SRC
00001876                           925              
00001876                           926  OP0000_RETURN_CMPI
00001876                           927  
00001876                           928  
00001876                           929              
00001876  4E75                     930              RTS
00001878                           931   
00001878                           932  *---------------------------------------------------------------------------*
00001878                           933  * OP_ORI : decode ORI and its size
00001878                           934  *---------------------------------------------------------------------------* 
00001878                           935  OP_ORI      
00001878                           936           
00001878                           937   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001878  13FC 0000 00004562       938             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001880  13FC 0082 00004563       939             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001888                           940             
00001888                           941             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001888  13FC 00B9 00004565       942             MOVE.B   #$B9,GET_DST_START_END
00001890  13FC 0020 00004566       943             MOVE.B   #$20,GET_SRC_START_END
00001898                           944             
00001898                           945              *CLEAR D3
00001898  4283                     946              CLR.L   D3
0000189A                           947              *LOAD STACK WITH THIS OPMODE
0000189A  6100 263C                948              BSR     PUSH_STACK
0000189E  163C 004F                949              MOVE.B  #'O',D3
000018A2  6100 2634                950              BSR     PUSH_STACK
000018A6  163C 0052                951              MOVE.B  #'R',D3
000018AA  6100 262C                952              BSR     PUSH_STACK
000018AE  163C 0049                953              MOVE.B  #'I',D3
000018B2  6100 2624                954              BSR     PUSH_STACK
000018B6  163C 002E                955              MOVE.B  #'.',D3
000018BA  6100 261C                956              BSR     PUSH_STACK
000018BE                           957              
000018BE                           958              *FIGURE OUT SIZE*
000018BE                           959              *00 = BYTE
000018BE                           960              *01 = WORD
000018BE                           961              *10 = LONG
000018BE                           962              * BITS 7&6
000018BE                           963              
000018BE                           964              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018BE  2205                     965              MOVE.L  D5,D1
000018C0  EC99                     966              ROR.L   #6,D1
000018C2  0281 00000003            967              ANDI.L  #$03,D1
000018C8  0C01 0000                968              CMPI.B  #%00,D1
000018CC  6700 0018                969              BEQ     OP0000_ORI_B
000018D0  0C01 0001                970              CMPI.B  #%01,D1
000018D4  6700 0038                971              BEQ     OP0000_ORI_W
000018D8  0281 00000003            972              ANDI.L  #$03,D1
000018DE  0C01 0002                973              CMPI.B  #%10,D1
000018E2  6700 0052                974              BEQ     OP0000_ORI_L
000018E6                           975  
000018E6                           976  OP0000_ORI_B
000018E6  163C 0042                977              MOVE.B  #'B',D3
000018EA  6100 25EC                978              BSR     PUSH_STACK
000018EE                           979  *GET DATA FROM ADDQ AND PRINT #0-8
000018EE                           980              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000018EE  0285 0000F03F            981              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000018F4  0685 000001C0            982              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000018FA  6100 216E                983              BSR     GET_EA_EA_DEST
000018FE  163C 002C                984              MOVE.B  #',',D3
00001902  6100 25D4                985              BSR     PUSH_STACK
00001906  6100 1D32                986              BSR     GET_EA_EA_SRC
0000190A  6000 004E                987              BRA     OP0000_RETURN_ORI
0000190E                           988  
0000190E                           989  OP0000_ORI_W
0000190E  163C 0057                990              MOVE.B  #'W',D3
00001912  6100 25C4                991              BSR     PUSH_STACK
00001916                           992  *GET DATA FROM ADDQ AND PRINT #0-8
00001916                           993              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001916  0285 0000F03F            994              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000191C  0685 000001C0            995              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001922  6100 2146                996              BSR     GET_EA_EA_DEST
00001926  163C 002C                997              MOVE.B  #',',D3
0000192A  6100 25AC                998              BSR     PUSH_STACK
0000192E  6100 1D0A                999              BSR     GET_EA_EA_SRC
00001932  6000 0026               1000              BRA     OP0000_RETURN_ORI
00001936                          1001  
00001936                          1002  OP0000_ORI_L
00001936  163C 004C               1003              MOVE.B  #'L',D3
0000193A  6100 259C               1004              BSR     PUSH_STACK
0000193E                          1005              *GET DATA FROM ADDQ AND PRINT #0-8
0000193E                          1006              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000193E  0285 0000F03F           1007              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001944  0685 000003C0           1008              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000194A  6100 211E               1009              BSR     GET_EA_EA_DEST
0000194E  163C 002C               1010              MOVE.B  #',',D3
00001952  6100 2584               1011              BSR     PUSH_STACK
00001956  6100 1CE2               1012              BSR     GET_EA_EA_SRC
0000195A                          1013              
0000195A                          1014  OP0000_RETURN_ORI
0000195A                          1015  
0000195A                          1016  
0000195A                          1017              
0000195A  4E75                    1018              RTS
0000195C                          1019  
0000195C                          1020          
0000195C                          1021  *---------------------------------------------------------------------------*
0000195C                          1022  * OP0001: MOVE.B
0000195C                          1023  *---------------------------------------------------------------------------*
0000195C                          1024  OP0001      
0000195C  4EF9 00001962           1025              JMP     OP_MOVE_B   * display MOVE.B
00001962                          1026              
00001962                          1027  *---------------------------------------------------------------------------*
00001962                          1028  * OP_MOVE_B: display MOVE_B and proceed to EA
00001962                          1029  *---------------------------------------------------------------------------*
00001962                          1030  OP_MOVE_B                                                                       
00001962                          1031             
00001962                          1032             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001962  13FC 0082 00004562      1033             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000196A  13FC 0000 00004563      1034             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001972                          1035             
00001972                          1036             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001972  13FC 00B9 00004565      1037             MOVE.B   #$B9,GET_DST_START_END
0000197A  13FC 0020 00004566      1038             MOVE.B   #$20,GET_SRC_START_END
00001982                          1039             
00001982                          1040              *CLEAR D3
00001982  4283                    1041              CLR.L   D3
00001984                          1042              *LOAD STACK WITH THIS OPMODE
00001984  6100 2552               1043              BSR     PUSH_STACK
00001988  163C 004D               1044              MOVE.B  #'M',D3
0000198C  6100 254A               1045              BSR     PUSH_STACK
00001990  163C 004F               1046              MOVE.B  #'O',D3
00001994  6100 2542               1047              BSR     PUSH_STACK
00001998  163C 0056               1048              MOVE.B  #'V',D3
0000199C  6100 253A               1049              BSR     PUSH_STACK
000019A0  163C 0045               1050              MOVE.B  #'E',D3
000019A4  6100 2532               1051              BSR     PUSH_STACK
000019A8  163C 002E               1052              MOVE.B  #'.',D3
000019AC  6100 252A               1053              BSR     PUSH_STACK
000019B0  163C 0042               1054              MOVE.B  #'B',D3
000019B4  6100 2522               1055              BSR     PUSH_STACK
000019B8                          1056              
000019B8  6100 1C80               1057              BSR     GET_EA_EA_SRC
000019BC  163C 002C               1058              MOVE.B  #',',D3
000019C0  6100 2516               1059              BSR     PUSH_STACK
000019C4  6100 20A4               1060              BSR     GET_EA_EA_DEST
000019C8                          1061              
000019C8  4E75                    1062              RTS
000019CA                          1063              
000019CA                          1064             
000019CA                          1065  *---------------------------------------------------------------------------*
000019CA                          1066  * OP0010: decode MOVE.L/MOVEA.L
000019CA                          1067  *---------------------------------------------------------------------------*
000019CA                          1068  OP0010      
000019CA  183C 0002               1069              MOVE.B  #2,D4
000019CE  4280                    1070              CLR.L   D0                     
000019D0  4281                    1071              CLR.L   D1                      
000019D2  227C 00000000           1072              MOVEA.L #0, A1                 
000019D8                          1073              
000019D8  2205                    1074              MOVE.L  D5,D1
000019DA  EA99                    1075              ROR.L   #5,D1
000019DC  0281 0000000E           1076              ANDI.L  #$E,D1
000019E2  0C01 0002               1077              CMPI.B  #2,D1
000019E6  6700 0070               1078              BEQ     OP_MOVEA_L
000019EA                          1079  
000019EA  4EF9 000019F0           1080              JMP     OP_MOVE_L
000019F0                          1081             
000019F0                          1082  
000019F0                          1083  *---------------------------------------------------------------------------*
000019F0                          1084  * OP_MOVE_L: display MOVE_L and proceed to EA
000019F0                          1085  *---------------------------------------------------------------------------*
000019F0                          1086  OP_MOVE_L   
000019F0                          1087             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019F0  13FC 0082 00004562      1088             MOVE.B   #$82,DEST_REGISTER_FORMAT
000019F8  13FC 0000 00004563      1089             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A00                          1090             
00001A00                          1091             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A00  13FC 00B9 00004565      1092             MOVE.B   #$B9,GET_DST_START_END
00001A08  13FC 0020 00004566      1093             MOVE.B   #$20,GET_SRC_START_END
00001A10                          1094             
00001A10                          1095              *CLEAR D3
00001A10  4283                    1096              CLR.L   D3
00001A12                          1097              *LOAD STACK WITH THIS OPMODE
00001A12  6100 24C4               1098              BSR     PUSH_STACK
00001A16  163C 004D               1099              MOVE.B  #'M',D3
00001A1A  6100 24BC               1100              BSR     PUSH_STACK
00001A1E  163C 004F               1101              MOVE.B  #'O',D3
00001A22  6100 24B4               1102              BSR     PUSH_STACK
00001A26  163C 0056               1103              MOVE.B  #'V',D3
00001A2A  6100 24AC               1104              BSR     PUSH_STACK
00001A2E  163C 0045               1105              MOVE.B  #'E',D3
00001A32  6100 24A4               1106              BSR     PUSH_STACK
00001A36  163C 002E               1107              MOVE.B  #'.',D3
00001A3A  6100 249C               1108              BSR     PUSH_STACK
00001A3E  163C 004C               1109              MOVE.B  #'L',D3
00001A42  6100 2494               1110              BSR     PUSH_STACK
00001A46                          1111              
00001A46  6100 1BF2               1112              BSR     GET_EA_EA_SRC
00001A4A  163C 002C               1113              MOVE.B  #',',D3
00001A4E  6100 2488               1114              BSR     PUSH_STACK
00001A52  6100 2016               1115              BSR     GET_EA_EA_DEST
00001A56                          1116              
00001A56  4E75                    1117              RTS
00001A58                          1118  
00001A58                          1119  
00001A58                          1120  *---------------------------------------------------------------------------*
00001A58                          1121  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A58                          1122  *---------------------------------------------------------------------------*
00001A58                          1123  OP_MOVEA_L 
00001A58                          1124             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A58  13FC 00FD 00004562      1125             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A60  13FC 0000 00004563      1126             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A68                          1127             
00001A68                          1128             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A68  13FC 00B9 00004565      1129             MOVE.B   #$B9,GET_DST_START_END
00001A70  13FC 0020 00004566      1130             MOVE.B   #$20,GET_SRC_START_END
00001A78                          1131             
00001A78                          1132              *CLEAR D3
00001A78  4283                    1133              CLR.L   D3
00001A7A                          1134              *LOAD STACK WITH THIS OPMODE
00001A7A  6100 245C               1135              BSR     PUSH_STACK
00001A7E  163C 004D               1136              MOVE.B  #'M',D3
00001A82  6100 2454               1137              BSR     PUSH_STACK
00001A86  163C 004F               1138              MOVE.B  #'O',D3
00001A8A  6100 244C               1139              BSR     PUSH_STACK
00001A8E  163C 0056               1140              MOVE.B  #'V',D3
00001A92  6100 2444               1141              BSR     PUSH_STACK
00001A96  163C 0045               1142              MOVE.B  #'E',D3
00001A9A  6100 243C               1143              BSR     PUSH_STACK           
00001A9E  163C 0041               1144              MOVE.B  #'A',D3
00001AA2  6100 2434               1145              BSR     PUSH_STACK
00001AA6  163C 002E               1146              MOVE.B  #'.',D3
00001AAA  6100 242C               1147              BSR     PUSH_STACK
00001AAE  163C 004C               1148              MOVE.B  #'L',D3
00001AB2  6100 2424               1149              BSR     PUSH_STACK
00001AB6                          1150              
00001AB6  6100 1B82               1151              BSR     GET_EA_EA_SRC
00001ABA  163C 002C               1152              MOVE.B  #',',D3
00001ABE  6100 2418               1153              BSR     PUSH_STACK
00001AC2  6100 1FA6               1154              BSR     GET_EA_EA_DEST
00001AC6                          1155              
00001AC6  4E75                    1156              RTS
00001AC8                          1157  
00001AC8                          1158              
00001AC8                          1159  *---------------------------------------------------------------------------*
00001AC8                          1160  * OP0011: decode MOVE.W/MOVEA.W
00001AC8                          1161  *---------------------------------------------------------------------------*
00001AC8                          1162  OP0011      
00001AC8  4280                    1163              CLR.L   D0                      
00001ACA  4281                    1164              CLR.L   D1  
00001ACC  4284                    1165              CLR.L   D4                   
00001ACE  227C 00000000           1166              MOVEA.L #0, A1 
00001AD4                          1167                
00001AD4  2205                    1168              MOVE.L  D5,D1
00001AD6  EC99                    1169              ROR.L   #6,D1
00001AD8  0281 00000007           1170              ANDI.L  #$07,D1
00001ADE  0C01 0001               1171              CMPI.B  #1,D1
00001AE2  6700 0070               1172              BEQ     OP_MOVEA_W
00001AE6                          1173              
00001AE6  4EF9 00001AEC           1174              JMP     OP_MOVE_W
00001AEC                          1175            
00001AEC                          1176  *---------------------------------------------------------------------------*
00001AEC                          1177  * OP_MOVE_W: display MOVE_W and proceed to EA
00001AEC                          1178  *---------------------------------------------------------------------------*
00001AEC                          1179  OP_MOVE_W   
00001AEC                          1180             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001AEC  13FC 0082 00004562      1181             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001AF4  13FC 0000 00004563      1182             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001AFC                          1183             
00001AFC                          1184             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001AFC  13FC 00B9 00004565      1185             MOVE.B   #$B9,GET_DST_START_END
00001B04  13FC 0020 00004566      1186             MOVE.B   #$20,GET_SRC_START_END
00001B0C                          1187             
00001B0C                          1188              *CLEAR D3
00001B0C  4283                    1189              CLR.L   D3
00001B0E                          1190              *LOAD STACK WITH THIS OPMODE
00001B0E  6100 23C8               1191              BSR     PUSH_STACK
00001B12  163C 004D               1192              MOVE.B  #'M',D3
00001B16  6100 23C0               1193              BSR     PUSH_STACK
00001B1A  163C 004F               1194              MOVE.B  #'O',D3
00001B1E  6100 23B8               1195              BSR     PUSH_STACK
00001B22  163C 0056               1196              MOVE.B  #'V',D3
00001B26  6100 23B0               1197              BSR     PUSH_STACK
00001B2A  163C 0045               1198              MOVE.B  #'E',D3
00001B2E  6100 23A8               1199              BSR     PUSH_STACK
00001B32  163C 002E               1200              MOVE.B  #'.',D3
00001B36  6100 23A0               1201              BSR     PUSH_STACK
00001B3A  163C 0057               1202              MOVE.B  #'W',D3
00001B3E  6100 2398               1203              BSR     PUSH_STACK
00001B42                          1204              
00001B42  6100 1AF6               1205              BSR     GET_EA_EA_SRC
00001B46  163C 002C               1206              MOVE.B  #',',D3
00001B4A  6100 238C               1207              BSR     PUSH_STACK
00001B4E  6100 1F1A               1208              BSR     GET_EA_EA_DEST
00001B52                          1209              
00001B52  4E75                    1210              RTS
00001B54                          1211  
00001B54                          1212  *---------------------------------------------------------------------------*
00001B54                          1213  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B54                          1214  *---------------------------------------------------------------------------*
00001B54                          1215  OP_MOVEA_W 
00001B54                          1216             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B54  13FC 00FD 00004562      1217             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B5C  13FC 0000 00004563      1218             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B64                          1219             
00001B64                          1220             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B64  13FC 00B9 00004565      1221             MOVE.B   #$B9,GET_DST_START_END
00001B6C  13FC 0020 00004566      1222             MOVE.B   #$20,GET_SRC_START_END
00001B74                          1223             
00001B74                          1224              *CLEAR D3
00001B74  4283                    1225              CLR.L   D3
00001B76                          1226              *LOAD STACK WITH THIS OPMODE
00001B76  6100 2360               1227              BSR     PUSH_STACK
00001B7A  163C 004D               1228              MOVE.B  #'M',D3
00001B7E  6100 2358               1229              BSR     PUSH_STACK
00001B82  163C 004F               1230              MOVE.B  #'O',D3
00001B86  6100 2350               1231              BSR     PUSH_STACK
00001B8A  163C 0056               1232              MOVE.B  #'V',D3
00001B8E  6100 2348               1233              BSR     PUSH_STACK
00001B92  163C 0045               1234              MOVE.B  #'E',D3
00001B96  6100 2340               1235              BSR     PUSH_STACK           
00001B9A  163C 0041               1236              MOVE.B  #'A',D3
00001B9E  6100 2338               1237              BSR     PUSH_STACK
00001BA2  163C 002E               1238              MOVE.B  #'.',D3
00001BA6  6100 2330               1239              BSR     PUSH_STACK
00001BAA  163C 0057               1240              MOVE.B  #'W',D3
00001BAE  6100 2328               1241              BSR     PUSH_STACK
00001BB2                          1242              
00001BB2  6100 1A86               1243              BSR     GET_EA_EA_SRC
00001BB6  163C 002C               1244              MOVE.B  #',',D3
00001BBA  6100 231C               1245              BSR     PUSH_STACK
00001BBE  6100 1EAA               1246              BSR     GET_EA_EA_DEST
00001BC2                          1247            
00001BC2  4E75                    1248              RTS
00001BC4                          1249  *---------------------------------------------------------------------------*
00001BC4                          1250  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BC4                          1251  *---------------------------------------------------------------------------*
00001BC4                          1252  OP0100
00001BC4  4280                    1253              CLR.L   D0                      
00001BC6  4281                    1254              CLR.L   D1  
00001BC8  4284                    1255              CLR.L   D4                      
00001BCA  227C 00000000           1256              MOVEA.L #0, A1                  
00001BD0  2205                    1257              MOVE.L  D5,D1  
00001BD2                          1258              
00001BD2                          1259              * check for RTS
00001BD2  0C41 4E75               1260              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BD6  6700 02FE               1261              BEQ     OP_RTS
00001BDA                          1262  
00001BDA                          1263              
00001BDA                          1264              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BDA  4281                    1265              CLR.L   D1 
00001BDC  2205                    1266              MOVE.L  D5,D1  
00001BDE  0241 0F00               1267              ANDI.W  #$0F00,D1
00001BE2  0C41 0E00               1268              CMPI.W  #$0E00,D1
00001BE6  6700 02D4               1269              BEQ     OP_JSR
00001BEA                          1270  
00001BEA                          1271              
00001BEA                          1272              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001BEA  4281                    1273              CLR.L   D1 
00001BEC  2205                    1274              MOVE.L  D5,D1  
00001BEE  0241 0F00               1275              ANDI.W  #$0F00,D1
00001BF2  0C41 0400               1276              CMPI.W  #$0400,D1
00001BF6  6700 01B8               1277              BEQ     OP_NEG
00001BFA                          1278  
00001BFA                          1279              
00001BFA                          1280              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001BFA  4281                    1281              CLR.L   D1 
00001BFC  2205                    1282              MOVE.L  D5,D1  
00001BFE  0241 0F00               1283              ANDI.W  #$0F00,D1
00001C02  0C41 0600               1284              CMPI.W  #$0600,D1
00001C06  6700 022E               1285              BEQ     OP_NOT
00001C0A                          1286  
00001C0A                          1287              
00001C0A                          1288              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C0A  4281                    1289              CLR.L   D1 
00001C0C  2205                    1290              MOVE.L  D5,D1  
00001C0E  EC99                    1291              ROR.L   #6,D1
00001C10  0281 00000007           1292              ANDI.L  #7,D1
00001C16  0C81 00000007           1293              CMPI.L  #7,D1
00001C1C  6700 0124               1294              BEQ     OP_LEA
00001C20                          1295  
00001C20                          1296              
00001C20                          1297              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C20  4281                    1298              CLR.L   D1 
00001C22  2205                    1299              MOVE.L  D5,D1
00001C24  0281 0000FB80           1300              ANDI.L  #%1111101110000000,D1
00001C2A  0C81 00004B80           1301              CMPI.L  #%0100101110000000,D1
00001C30  6000 0004               1302              BRA     OP_MOVEM
00001C34                          1303              
00001C34                          1304  OP_RETURNOFTHEKING
00001C34  4E75                    1305              RTS
00001C36                          1306  
00001C36                          1307  *---------------------------------------------------------------------------*
00001C36                          1308  * OP_MOVEM_W: display MOVEM_W
00001C36                          1309  *---------------------------------------------------------------------------*    
00001C36                          1310  OP_MOVEM  
00001C36                          1311  
00001C36                          1312             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C36  13FC 008D 00004563      1313             MOVE.B   #$8D,SRC_REGISTER_FORMAT
00001C3E  13FC 0000 00004562      1314             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001C46                          1315             
00001C46                          1316             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C46  13FC 0020 00004566      1317             MOVE.B   #$20,GET_SRC_START_END
00001C4E                          1318             
00001C4E                          1319              *CLEAR D3
00001C4E  4283                    1320              CLR.L   D3
00001C50                          1321              *LOAD STACK WITH THIS OPMODE
00001C50  6100 2286               1322              BSR     PUSH_STACK
00001C54  163C 004D               1323              MOVE.B  #'M',D3
00001C58  6100 227E               1324              BSR     PUSH_STACK
00001C5C  163C 004F               1325              MOVE.B  #'O',D3
00001C60  6100 2276               1326              BSR     PUSH_STACK
00001C64  163C 0056               1327              MOVE.B  #'V',D3
00001C68  6100 226E               1328              BSR     PUSH_STACK
00001C6C  163C 0045               1329              MOVE.B  #'E',D3
00001C70  6100 2266               1330              BSR     PUSH_STACK
00001C74  163C 004D               1331              MOVE.B  #'M',D3
00001C78  6100 225E               1332              BSR     PUSH_STACK
00001C7C  163C 002E               1333              MOVE.B  #'.',D3
00001C80  6100 2256               1334              BSR     PUSH_STACK
00001C84                          1335              
00001C84                          1336             *CHECK SIZE
00001C84  4281                    1337             CLR.L    D1
00001C86  2205                    1338             MOVE.L   D5,D1
00001C88  0281 00000400           1339             ANDI.L   #%0000010000000000,D1
00001C8E  0C81 00000400           1340             CMPI.L   #%0000010000000000,D1
00001C94  6700 000E               1341             BEQ      OP_MOVEM_L
00001C98                          1342             
00001C98                          1343  OP_MOVEM_W
00001C98  163C 0057               1344             MOVE.B  #'W',D3
00001C9C  6100 223A               1345             BSR     PUSH_STACK
00001CA0  6000 000A               1346             BRA      OP_MOVEM_CONTINUE
00001CA4                          1347  OP_MOVEM_L
00001CA4  163C 004C               1348              MOVE.B  #'L',D3
00001CA8  6100 222E               1349              BSR     PUSH_STACK
00001CAC                          1350  
00001CAC                          1351  OP_MOVEM_CONTINUE
00001CAC                          1352                        
00001CAC                          1353             *CHECK DIRECTION
00001CAC  4281                    1354             CLR.L    D1
00001CAE  2205                    1355             MOVE.L   D5,D1
00001CB0  0281 00000040           1356             ANDI.L   #%0000000001000000,D1
00001CB6  0C81 00000040           1357             CMPI.L   #%0000000001000000,D1
00001CBC  6700 0042               1358             BEQ      OP_MOVEM_MR
00001CC0                          1359             
00001CC0                          1360  OP_MOVEM_RM
00001CC0  163C 0020               1361              MOVE.B  #' ',D3
00001CC4  6100 2212               1362              BSR     PUSH_STACK
00001CC8  163C 0045               1363              MOVE.B  #'E',D3
00001CCC  6100 220A               1364              BSR     PUSH_STACK
00001CD0  163C 0041               1365              MOVE.B  #'A',D3
00001CD4  6100 2202               1366              BSR     PUSH_STACK
00001CD8  163C 002C               1367              MOVE.B  #',',D3
00001CDC  6100 21FA               1368              BSR     PUSH_STACK
00001CE0  163C 004C               1369              MOVE.B  #'L',D3
00001CE4  6100 21F2               1370              BSR     PUSH_STACK
00001CE8  163C 0049               1371              MOVE.B  #'I',D3
00001CEC  6100 21EA               1372              BSR     PUSH_STACK
00001CF0  163C 0053               1373              MOVE.B  #'S',D3
00001CF4  6100 21E2               1374              BSR     PUSH_STACK
00001CF8  163C 0054               1375              MOVE.B  #'T',D3
00001CFC  6100 21DA               1376              BSR     PUSH_STACK
00001D00                          1377  
00001D00                          1378            
00001D00                          1379  OP_MOVEM_MR
00001D00  163C 0020               1380              MOVE.B  #' ',D3
00001D04  6100 21D2               1381              BSR     PUSH_STACK
00001D08  163C 004C               1382              MOVE.B  #'L',D3
00001D0C  6100 21CA               1383              BSR     PUSH_STACK
00001D10  163C 0049               1384              MOVE.B  #'I',D3
00001D14  6100 21C2               1385              BSR     PUSH_STACK
00001D18  163C 0053               1386              MOVE.B  #'S',D3
00001D1C  6100 21BA               1387              BSR     PUSH_STACK
00001D20  163C 0054               1388              MOVE.B  #'T',D3
00001D24  6100 21B2               1389              BSR     PUSH_STACK
00001D28  163C 002C               1390              MOVE.B  #',',D3
00001D2C  6100 21AA               1391              BSR     PUSH_STACK
00001D30  163C 0045               1392              MOVE.B  #'E',D3
00001D34  6100 21A2               1393              BSR     PUSH_STACK
00001D38  163C 0041               1394              MOVE.B  #'A',D3
00001D3C  6100 219A               1395              BSR     PUSH_STACK
00001D40                          1396  
00001D40  4E75                    1397              RTS
00001D42                          1398  
00001D42                          1399  
00001D42                          1400     
00001D42                          1401  *---------------------------------------------------------------------------*
00001D42                          1402  * OP_LEA: decode and display LEA
00001D42                          1403  *---------------------------------------------------------------------------*
00001D42                          1404  OP_LEA      
00001D42  4281                    1405               CLR.L   D1       
00001D44  4284                    1406              CLR.L   D4                   
00001D46  227C 00000000           1407              MOVEA.L #0, A1              
00001D4C  2205                    1408              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001D4E                          1409              *CLEAR D3
00001D4E  4283                    1410              CLR.L   D3
00001D50                          1411  
00001D50                          1412  OP_LEA_DN_EA_OR_EA_DN 
00001D50                          1413              *LOAD STACK WITH THIS OPMODE
00001D50  6100 2186               1414              BSR     PUSH_STACK
00001D54  163C 004C               1415              MOVE.B  #'L',D3
00001D58  6100 217E               1416              BSR     PUSH_STACK
00001D5C  163C 0045               1417              MOVE.B  #'E',D3
00001D60  6100 2176               1418              BSR     PUSH_STACK
00001D64  163C 0041               1419              MOVE.B  #'A',D3
00001D68  6100 216E               1420              BSR     PUSH_STACK
00001D6C  2205                    1421              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001D6E                          1422          
00001D6E                          1423  
00001D6E                          1424  OP_PRINT_L_LEA
00001D6E                          1425                          
00001D6E                          1426              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D6E  13FC 0000 00004562      1427              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001D76  13FC 009B 00004563      1428              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001D7E                          1429             
00001D7E                          1430              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D7E  13FC 00B9 00004565      1431              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001D86  13FC 0020 00004566      1432              MOVE.B   #$20,GET_SRC_START_END
00001D8E                          1433  
00001D8E                          1434              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001D8E  0285 0000FE3F           1435              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001D94  0685 00000040           1436              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001D9A                          1437  
00001D9A  6100 189E               1438              BSR     GET_EA_EA_SRC      *GETS <ea>
00001D9E  163C 002C               1439              MOVE.B  #',',D3
00001DA2  6100 2134               1440              BSR     PUSH_STACK           
00001DA6  6100 1CC2               1441              BSR     GET_EA_EA_DEST       *GETS Dn    
00001DAA                          1442  
00001DAA                          1443              
00001DAA  6000 0002               1444              BRA     OP_LEA_RETURN
00001DAE                          1445              
00001DAE                          1446  OP_LEA_RETURN
00001DAE  4E75                    1447              RTS
00001DB0                          1448              
00001DB0                          1449  
00001DB0                          1450  
00001DB0                          1451  *---------------------------------------------------------------------------*
00001DB0                          1452  * OP_NEG: decode and display NEG 
00001DB0                          1453  *---------------------------------------------------------------------------*
00001DB0                          1454  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001DB0  4281                    1455              CLR.L   D1
00001DB2  4284                    1456              CLR.L   D4
00001DB4  2205                    1457              MOVE.L  D5,D1
00001DB6                          1458              
00001DB6                          1459              *CLEAR D3
00001DB6  4283                    1460              CLR.L   D3
00001DB8                          1461              *LOAD STACK WITH THIS OPMODE
00001DB8  6100 211E               1462              BSR     PUSH_STACK
00001DBC  163C 004E               1463              MOVE.B  #'N',D3
00001DC0  6100 2116               1464              BSR     PUSH_STACK
00001DC4  163C 0045               1465              MOVE.B  #'E',D3
00001DC8  6100 210E               1466              BSR     PUSH_STACK
00001DCC  163C 0047               1467              MOVE.B  #'G',D3
00001DD0  6100 2106               1468              BSR     PUSH_STACK
00001DD4  163C 002E               1469              MOVE.B  #'.',D3
00001DD8  6100 20FE               1470              BSR     PUSH_STACK
00001DDC                          1471              
00001DDC                          1472              
00001DDC  EC99                    1473              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DDE  0281 00000007           1474              ANDI.L  #$07,D1
00001DE4                          1475              
00001DE4  0C01 0000               1476              CMPI.B  #0,D1
00001DE8  6700 0012               1477              BEQ     OP_NEG_B    * size is byte
00001DEC  0C01 0001               1478              CMPI.B  #1,D1
00001DF0  6700 0016               1479              BEQ     OP_NEG_W    * size is word
00001DF4  0C01 0002               1480              CMPI.B  #2,D1
00001DF8  6700 001A               1481              BEQ     OP_NEG_L    * size is long
00001DFC                          1482                         
00001DFC                          1483  
00001DFC                          1484  OP_NEG_B    * size is byte   
00001DFC  163C 0042               1485              MOVE.B  #'B',D3
00001E00  6100 20D6               1486              BSR     PUSH_STACK
00001E04  6000 001A               1487              BRA     OP_NEG_PRINT_EA
00001E08                          1488  
00001E08                          1489              
00001E08                          1490  OP_NEG_W    * size is word
00001E08  163C 0057               1491              MOVE.B  #'W',D3
00001E0C  6100 20CA               1492              BSR     PUSH_STACK
00001E10  6000 000E               1493              BRA     OP_NEG_PRINT_EA
00001E14                          1494  
00001E14                          1495              
00001E14                          1496  OP_NEG_L    * size is long
00001E14  163C 004C               1497              MOVE.B  #'L',D3
00001E18  6100 20BE               1498              BSR     PUSH_STACK
00001E1C  6000 0002               1499              BRA     OP_NEG_PRINT_EA
00001E20                          1500  
00001E20                          1501  
00001E20                          1502  OP_NEG_PRINT_EA
00001E20                          1503   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E20  13FC 0082 00004563      1504             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001E28                          1505             
00001E28                          1506             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E28  13FC 0020 00004566      1507             MOVE.B   #$20,GET_SRC_START_END
00001E30                          1508                         
00001E30                          1509  
00001E30  6100 1808               1510              BSR     GET_EA_EA_SRC
00001E34                          1511              
00001E34  4E75                    1512              RTS
00001E36                          1513  
00001E36                          1514  *---------------------------------------------------------------------------*
00001E36                          1515  * OP_NOT: decode and display NOT 
00001E36                          1516  *---------------------------------------------------------------------------*
00001E36                          1517  OP_NOT
00001E36  4281                    1518              CLR.L   D1
00001E38  4284                    1519              CLR.L   D4
00001E3A  2205                    1520              MOVE.L  D5,D1
00001E3C                          1521              
00001E3C                          1522              *CLEAR D3
00001E3C  4283                    1523              CLR.L   D3
00001E3E                          1524              *LOAD STACK WITH THIS OPMODE
00001E3E  6100 2098               1525              BSR     PUSH_STACK
00001E42  163C 004E               1526              MOVE.B  #'N',D3
00001E46  6100 2090               1527              BSR     PUSH_STACK
00001E4A  163C 004F               1528              MOVE.B  #'O',D3
00001E4E  6100 2088               1529              BSR     PUSH_STACK
00001E52  163C 0054               1530              MOVE.B  #'T',D3
00001E56  6100 2080               1531              BSR     PUSH_STACK
00001E5A  163C 002E               1532              MOVE.B  #'.',D3
00001E5E  6100 2078               1533              BSR     PUSH_STACK
00001E62                          1534              
00001E62                          1535              
00001E62  EC99                    1536              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001E64  0281 00000007           1537              ANDI.L  #$07,D1
00001E6A                          1538              
00001E6A  0C01 0000               1539              CMPI.B  #0,D1
00001E6E  6700 0012               1540              BEQ     OP_NOT_B    * size is byte
00001E72  0C01 0001               1541              CMPI.B  #1,D1
00001E76  6700 0016               1542              BEQ     OP_NOT_W    * size is word
00001E7A  0C01 0002               1543              CMPI.B  #2,D1
00001E7E  6700 001A               1544              BEQ     OP_NOT_L    * size is long
00001E82                          1545                         
00001E82                          1546  
00001E82                          1547  OP_NOT_B    * size is byte   
00001E82  163C 0042               1548              MOVE.B  #'B',D3
00001E86  6100 2050               1549              BSR     PUSH_STACK
00001E8A  6000 001A               1550              BRA     OP_NOT_PRINT_EA
00001E8E                          1551  
00001E8E                          1552              
00001E8E                          1553  OP_NOT_W    * size is word
00001E8E  163C 0057               1554              MOVE.B  #'W',D3
00001E92  6100 2044               1555              BSR     PUSH_STACK
00001E96  6000 000E               1556              BRA     OP_NOT_PRINT_EA
00001E9A                          1557  
00001E9A                          1558              
00001E9A                          1559  OP_NOT_L    * size is long
00001E9A  163C 004C               1560              MOVE.B  #'L',D3
00001E9E  6100 2038               1561              BSR     PUSH_STACK
00001EA2  6000 0002               1562              BRA     OP_NOT_PRINT_EA
00001EA6                          1563  
00001EA6                          1564  
00001EA6                          1565  OP_NOT_PRINT_EA
00001EA6                          1566   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001EA6  13FC 0082 00004563      1567             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001EAE                          1568             
00001EAE                          1569             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001EAE  13FC 0020 00004566      1570             MOVE.B   #$20,GET_SRC_START_END
00001EB6  6100 1782               1571              BSR     GET_EA_EA_SRC
00001EBA                          1572              
00001EBA  4E75                    1573              RTS
00001EBC                          1574  
00001EBC                          1575  
00001EBC                          1576  *---------------------------------------------------------------------------*
00001EBC                          1577  * OP_JSR: display JSR     
00001EBC                          1578  *---------------------------------------------------------------------------*
00001EBC  163C 004A               1579  OP_JSR      MOVE.B #'J',D3
00001EC0  6100 2016               1580              BSR     PUSH_STACK
00001EC4  163C 0053               1581              MOVE.B #'S',D3
00001EC8  6100 200E               1582              BSR     PUSH_STACK
00001ECC  163C 0052               1583              MOVE.B #'R',D3
00001ED0  6100 2006               1584              BSR     PUSH_STACK
00001ED4                          1585  
00001ED4  4E75                    1586              RTS
00001ED6                          1587  
00001ED6                          1588  *---------------------------------------------------------------------------*
00001ED6                          1589  * OP_RTS: display RTS     
00001ED6                          1590  *---------------------------------------------------------------------------* 
00001ED6                          1591  OP_RTS      
00001ED6  163C 0052               1592              MOVE.B #'R',D3
00001EDA  6100 1FFC               1593              BSR     PUSH_STACK
00001EDE  163C 0054               1594              MOVE.B #'T',D3
00001EE2  6100 1FF4               1595              BSR     PUSH_STACK
00001EE6  163C 0053               1596              MOVE.B #'S',D3
00001EEA  6100 1FEC               1597              BSR     PUSH_STACK
00001EEE  4E75                    1598              RTS
00001EF0                          1599  
00001EF0                          1600  *---------------------------------------------------------------------------*
00001EF0                          1601  * OP0101: decode ADDQ
00001EF0                          1602  *---------------------------------------------------------------------------* 
00001EF0                          1603  OP0101      
00001EF0                          1604             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001EF0  13FC 0082 00004562      1605             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001EF8  13FC 0080 00004563      1606             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001F00                          1607             
00001F00                          1608             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F00  13FC 00B9 00004565      1609             MOVE.B   #$B9,GET_DST_START_END
00001F08  13FC 0020 00004566      1610             MOVE.B   #$20,GET_SRC_START_END
00001F10                          1611             
00001F10                          1612              *CLEAR D3
00001F10  4283                    1613              CLR.L   D3
00001F12                          1614              *LOAD STACK WITH THIS OPMODE
00001F12  6100 1FC4               1615              BSR     PUSH_STACK
00001F16  163C 0041               1616              MOVE.B  #'A',D3
00001F1A  6100 1FBC               1617              BSR     PUSH_STACK
00001F1E  163C 0044               1618              MOVE.B  #'D',D3
00001F22  6100 1FB4               1619              BSR     PUSH_STACK
00001F26  163C 0044               1620              MOVE.B  #'D',D3
00001F2A  6100 1FAC               1621              BSR     PUSH_STACK
00001F2E  163C 0051               1622              MOVE.B  #'Q',D3
00001F32  6100 1FA4               1623              BSR     PUSH_STACK
00001F36  163C 002E               1624              MOVE.B  #'.',D3
00001F3A  6100 1F9C               1625              BSR     PUSH_STACK
00001F3E                          1626              
00001F3E                          1627              *FIGURE OUT SIZE*
00001F3E                          1628              *00 = BYTE
00001F3E                          1629              *01 = WORD
00001F3E                          1630              *10 = LONG
00001F3E                          1631              * BITS 7&6
00001F3E                          1632              
00001F3E                          1633              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001F3E  2205                    1634              MOVE.L  D5,D1
00001F40  EC99                    1635              ROR.L   #6,D1
00001F42  0281 00000003           1636              ANDI.L  #$03,D1
00001F48  0C01 0000               1637              CMPI.B  #%00,D1
00001F4C  6700 001E               1638              BEQ     OP0101_ADDQ_B
00001F50  0281 00000003           1639              ANDI.L  #$03,D1
00001F56  0C01 0001               1640              CMPI.B  #%01,D1
00001F5A  6700 001C               1641              BEQ     OP0101_ADDQ_W
00001F5E  0281 00000003           1642              ANDI.L  #$03,D1
00001F64  0C01 0002               1643              CMPI.B  #%10,D1
00001F68  6700 001A               1644              BEQ     OP0101_ADDQ_L
00001F6C                          1645            
00001F6C                          1646  OP0101_ADDQ_B
00001F6C                          1647              
00001F6C  163C 0042               1648              MOVE.B  #'B',D3
00001F70  6100 1F66               1649              BSR     PUSH_STACK
00001F74  6000 0016               1650              BRA     OP0101_RETURN
00001F78                          1651  OP0101_ADDQ_W
00001F78                          1652              
00001F78  163C 0057               1653              MOVE.B  #'W',D3
00001F7C  6100 1F5A               1654              BSR     PUSH_STACK
00001F80  6000 000A               1655              BRA     OP0101_RETURN
00001F84                          1656  OP0101_ADDQ_L
00001F84                          1657              
00001F84  163C 004C               1658              MOVE.B  #'L',D3
00001F88  6100 1F4E               1659              BSR     PUSH_STACK
00001F8C                          1660  OP0101_RETURN            
00001F8C                          1661  
00001F8C                          1662              
00001F8C                          1663  *GET DATA FROM ADDQ AND PRINT #0-8
00001F8C  163C 0020               1664              MOVE.B  #' ',D3
00001F90  6100 1F46               1665              BSR     PUSH_STACK
00001F94  163C 0023               1666              MOVE.B  #'#',D3
00001F98  6100 1F3E               1667              BSR     PUSH_STACK 
00001F9C                          1668  
00001F9C                          1669                       
00001F9C                          1670              *GET DATA #   
00001F9C  2205                    1671              MOVE.L  D5,D1
00001F9E  EC99                    1672              ROR.L   #6,D1            
00001FA0  E699                    1673              ROR.L   #3,D1
00001FA2  0281 00000007           1674              ANDI.L  #$07,D1
00001FA8                          1675              
00001FA8  0C01 0000               1676              CMPI.B  #%000,D1
00001FAC  6700 009A               1677              BEQ     OP0101_ADDQ_B_8
00001FB0  0C01 0001               1678              CMPI.B  #%001,D1
00001FB4  6700 003E               1679              BEQ     OP0101_ADDQ_B_1
00001FB8  0C01 0002               1680              CMPI.B  #%010,D1
00001FBC  6700 0042               1681              BEQ     OP0101_ADDQ_B_2
00001FC0  0C01 0003               1682              CMPI.B  #%011,D1
00001FC4  6700 0046               1683              BEQ     OP0101_ADDQ_B_3
00001FC8  0C01 0004               1684              CMPI.B  #%100,D1
00001FCC  6700 004A               1685              BEQ     OP0101_ADDQ_B_4
00001FD0  0C01 0005               1686              CMPI.B  #%101,D1
00001FD4  6700 004E               1687              BEQ     OP0101_ADDQ_B_5
00001FD8  0C01 0006               1688              CMPI.B  #%110,D1
00001FDC  6700 0052               1689              BEQ     OP0101_ADDQ_B_6
00001FE0  0C01 0007               1690              CMPI.B  #%111,D1
00001FE4  6700 0056               1691              BEQ     OP0101_ADDQ_B_7
00001FE8                          1692              
00001FE8                          1693  OP0101_ADDQ_B_0
00001FE8  163C 0030               1694              MOVE.B  #'0',D3
00001FEC  6100 1EEA               1695              BSR     PUSH_STACK
00001FF0  6000 005E               1696              BRA     OP0101_RETURN2            
00001FF4                          1697  OP0101_ADDQ_B_1
00001FF4  163C 0031               1698              MOVE.B  #'1',D3
00001FF8  6100 1EDE               1699              BSR     PUSH_STACK
00001FFC  6000 0052               1700              BRA     OP0101_RETURN2            
00002000                          1701  OP0101_ADDQ_B_2
00002000  163C 0032               1702              MOVE.B  #'2',D3
00002004  6100 1ED2               1703              BSR     PUSH_STACK
00002008  6000 0046               1704              BRA     OP0101_RETURN2            
0000200C                          1705  OP0101_ADDQ_B_3
0000200C  163C 0033               1706              MOVE.B  #'3',D3
00002010  6100 1EC6               1707              BSR     PUSH_STACK
00002014  6000 003A               1708              BRA     OP0101_RETURN2            
00002018                          1709  OP0101_ADDQ_B_4
00002018  163C 0034               1710              MOVE.B  #'4',D3
0000201C  6100 1EBA               1711              BSR     PUSH_STACK
00002020  6000 002E               1712              BRA     OP0101_RETURN2            
00002024                          1713  OP0101_ADDQ_B_5
00002024  163C 0035               1714              MOVE.B  #'5',D3
00002028  6100 1EAE               1715              BSR     PUSH_STACK
0000202C  6000 0022               1716              BRA     OP0101_RETURN2
00002030                          1717  OP0101_ADDQ_B_6
00002030  163C 0036               1718              MOVE.B  #'6',D3
00002034  6100 1EA2               1719              BSR     PUSH_STACK
00002038  6000 0016               1720              BRA     OP0101_RETURN2
0000203C                          1721  OP0101_ADDQ_B_7
0000203C  163C 0037               1722              MOVE.B  #'7',D3
00002040  6100 1E96               1723              BSR     PUSH_STACK
00002044  6000 000A               1724              BRA     OP0101_RETURN2
00002048                          1725  
00002048                          1726  OP0101_ADDQ_B_8
00002048  163C 0038               1727              MOVE.B  #'8',D3
0000204C  6100 1E8A               1728              BSR     PUSH_STACK
00002050                          1729              
00002050                          1730  OP0101_RETURN2            
00002050  163C 002C               1731              MOVE.B  #',',D3
00002054  6100 1E82               1732              BSR     PUSH_STACK
00002058  6100 15E0               1733              BSR     GET_EA_EA_SRC
0000205C                          1734              
0000205C  4E75                    1735              RTS
0000205E                          1736  
0000205E                          1737  
0000205E                          1738              *---------------------------------------------------------------------------*
0000205E                          1739  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
0000205E                          1740  *---------------------------------------------------------------------------*              
0000205E  4280                    1741  OP0110      CLR.L   D0                  
00002060  4281                    1742              CLR.L   D1   
00002062  4284                    1743              CLR.L   D4                 
00002064  227C 00000000           1744              MOVEA.L #0,A1
0000206A  2205                    1745              MOVE.L  D5, D1                
0000206C  0281 000000FF           1746              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00002072  2205                    1747              MOVE.L  D5,D1                  
00002074  0281 00000F00           1748              ANDI.L  #$0F00,D1
0000207A                          1749                 
0000207A  0C41 0000               1750              CMPI.W  #$0000,D1               * Check for BRA
0000207E  6700 0098               1751              BEQ     OP_BRA                  
00002082                          1752                          
00002082  0C41 0D00               1753              CMPI.W  #$0D00,D1               * Check for BLT
00002086  6700 00B6               1754              BEQ     OP_BLT      
0000208A                          1755  
0000208A  0C41 0700               1756              CMPI.W  #$0700,D1               * Check for BEQ
0000208E  6700 0062               1757              BEQ     OP_BEQ      
00002092                          1758  
00002092  0C41 0600               1759              CMPI.W  #$0600,D1               * Check for BNE
00002096  6700 0034               1760              BEQ     OP_BNE  
0000209A                          1761              
0000209A  0C41 0200               1762              CMPI.W  #$0200,D1               * Check for BHI
0000209E  6700 0006               1763              BEQ     OP_BHI
000020A2                          1764  
000020A2  4EF8 1740               1765              JMP     OP_DATA
000020A6                          1766              
000020A6  163C 0042               1767  OP_BHI      MOVE.B  #'B',D3
000020AA  6100 1E2C               1768              BSR     PUSH_STACK
000020AE  163C 0048               1769              MOVE.B  #'H',D3
000020B2  6100 1E24               1770              BSR     PUSH_STACK
000020B6  163C 0049               1771              MOVE.B  #'I',D3
000020BA  6100 1E1C               1772              BSR     PUSH_STACK
000020BE  163C 0009               1773              MOVE.B  #$9,D3
000020C2  6100 1E14               1774              BSR     PUSH_STACK
000020C6  6100 1E8E               1775              BSR     GET_DISPLACEMENT_ADDRESS
000020CA  4E75                    1776              RTS
000020CC                          1777  
000020CC  163C 0042               1778  OP_BNE      MOVE.B  #'B',D3
000020D0  6100 1E06               1779              BSR     PUSH_STACK
000020D4  163C 004E               1780              MOVE.B  #'N',D3
000020D8  6100 1DFE               1781              BSR     PUSH_STACK
000020DC  163C 0045               1782              MOVE.B  #'E',D3
000020E0  6100 1DF6               1783              BSR     PUSH_STACK
000020E4  163C 0009               1784              MOVE.B  #$9,D3
000020E8  6100 1DEE               1785              BSR     PUSH_STACK
000020EC  6100 1E68               1786              BSR     GET_DISPLACEMENT_ADDRESS
000020F0  4E75                    1787              RTS
000020F2                          1788  
000020F2  163C 0042               1789  OP_BEQ      MOVE.B  #'B',D3
000020F6  6100 1DE0               1790              BSR     PUSH_STACK
000020FA  163C 0045               1791              MOVE.B  #'E',D3
000020FE  6100 1DD8               1792              BSR     PUSH_STACK
00002102  163C 0051               1793              MOVE.B  #'Q',D3
00002106  6100 1DD0               1794              BSR     PUSH_STACK
0000210A  163C 0009               1795              MOVE.B  #$9,D3
0000210E  6100 1DC8               1796              BSR     PUSH_STACK
00002112  6100 1E42               1797              BSR     GET_DISPLACEMENT_ADDRESS
00002116  4E75                    1798              RTS          
00002118                          1799                          
00002118                          1800  OP_BRA      
00002118  163C 0042               1801              MOVE.B  #'B',D3
0000211C  6100 1DBA               1802              BSR     PUSH_STACK
00002120  163C 0052               1803              MOVE.B  #'R',D3
00002124  6100 1DB2               1804              BSR     PUSH_STACK
00002128  163C 0041               1805              MOVE.B  #'A',D3
0000212C  6100 1DAA               1806              BSR     PUSH_STACK
00002130  163C 0009               1807              MOVE.B  #$9,D3
00002134  6100 1DA2               1808              BSR     PUSH_STACK
00002138  6100 1E1C               1809              BSR     GET_DISPLACEMENT_ADDRESS
0000213C                          1810              
0000213C  4E75                    1811              RTS
0000213E                          1812              
0000213E  163C 0042               1813  OP_BLT      MOVE.B  #'B',D3
00002142  6100 1D94               1814              BSR     PUSH_STACK
00002146  163C 004C               1815              MOVE.B  #'L',D3
0000214A  6100 1D8C               1816              BSR     PUSH_STACK
0000214E  163C 0054               1817              MOVE.B  #'T',D3
00002152  6100 1D84               1818              BSR     PUSH_STACK
00002156  163C 0009               1819              MOVE.B  #$9,D3
0000215A  6100 1D7C               1820              BSR     PUSH_STACK
0000215E  6100 1DF6               1821              BSR     GET_DISPLACEMENT_ADDRESS
00002162  4E75                    1822              RTS
00002164                          1823     
00002164                          1824  *---------------------------------------------------------------------------*
00002164                          1825  * OP0111 : MOVEQ not required
00002164                          1826  *---------------------------------------------------------------------------*           
00002164  4EF8 1740               1827  OP0111      JMP     OP_DATA
00002168                          1828             
00002168                          1829  *---------------------------------------------------------------------------*
00002168                          1830  * OP1000 : decode DIVS
00002168                          1831  *---------------------------------------------------------------------------*           
00002168                          1832  OP1000                           
00002168  4281                    1833              CLR.L   D1       
0000216A  4284                    1834              CLR.L   D4                   
0000216C  227C 00000000           1835              MOVEA.L #0, A1              
00002172  2205                    1836              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002174                          1837              *CLEAR D3
00002174  4283                    1838              CLR.L   D3
00002176                          1839  
00002176                          1840  OP1000_DIVS_DN_EA_OR_EA_DN 
00002176                          1841              *LOAD STACK WITH THIS OPMODE
00002176  6100 1D60               1842              BSR     PUSH_STACK
0000217A  163C 0044               1843              MOVE.B  #'D',D3
0000217E  6100 1D58               1844              BSR     PUSH_STACK
00002182  163C 0049               1845              MOVE.B  #'I',D3
00002186  6100 1D50               1846              BSR     PUSH_STACK
0000218A  163C 0056               1847              MOVE.B  #'V',D3
0000218E  6100 1D48               1848              BSR     PUSH_STACK
00002192  163C 0053               1849              MOVE.B  #'S',D3
00002196  6100 1D40               1850              BSR     PUSH_STACK
0000219A  163C 002E               1851              MOVE.B  #'.',D3
0000219E  6100 1D38               1852              BSR     PUSH_STACK
000021A2                          1853              
000021A2  2205                    1854              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021A4                          1855              
000021A4                          1856  OP1000_EA_DN_DIVS
000021A4                          1857              *BITS (7 TO 6) 
000021A4                          1858              *00 = .B
000021A4                          1859              *01 = .W
000021A4                          1860              *10 = .L 
000021A4  2205                    1861              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000021A6  EC99                    1862              ROR.L   #6,D1
000021A8  0281 00000003           1863              ANDI.L  #$03,D1
000021AE  0C81 00000003           1864              CMPI.L  #%11,D1 *EQUALS .W
000021B4  6700 0014               1865              BEQ     OP1000_PRINT_W_DIVS
000021B8  0C81 00000000           1866              CMPI.L  #%00,D1 *EQUALS .L
000021BE  6700 0052               1867              BEQ     OP1000_PRINT_L_DIVS
000021C2                          1868              
000021C2  183C 0001               1869              MOVE.B  #1,D4               *ERROR READ
000021C6  6000 0092               1870              BRA     OP1000_DIVS_RETURN
000021CA                          1871  OP1000_PRINT_W_DIVS
000021CA  163C 0057               1872              MOVE.B  #'W',D3
000021CE  6100 1D08               1873              BSR     PUSH_STACK
000021D2                          1874  
000021D2                          1875              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021D2  13FC 0000 00004562      1876              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021DA  13FC 0000 00004563      1877              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021E2                          1878             
000021E2                          1879              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021E2  13FC 00B9 00004565      1880              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021EA  13FC 0020 00004566      1881              MOVE.B   #$20,GET_SRC_START_END
000021F2                          1882  
000021F2                          1883             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021F2  0285 0000FE3F           1884              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021F8  0685 00000000           1885              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021FE                          1886  
000021FE                          1887              
000021FE  6100 143A               1888              BSR     GET_EA_EA_SRC      *GETS <ea>
00002202  163C 002C               1889              MOVE.B  #',',D3
00002206  6100 1CD0               1890              BSR     PUSH_STACK
0000220A  6100 185E               1891              BSR     GET_EA_EA_DEST       *GETS Dn    
0000220E                          1892              
0000220E  6000 004A               1893              BRA     OP1000_DIVS_RETURN
00002212                          1894  OP1000_PRINT_L_DIVS
00002212  163C 004C               1895              MOVE.B  #'L',D3
00002216  6100 1CC0               1896              BSR     PUSH_STACK
0000221A                          1897              
0000221A                          1898              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000221A  13FC 0000 00004562      1899              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002222  13FC 0000 00004563      1900              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000222A                          1901             
0000222A                          1902              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000222A  13FC 00B9 00004565      1903              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002232  13FC 0020 00004566      1904              MOVE.B   #$20,GET_SRC_START_END
0000223A                          1905  
0000223A                          1906              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000223A  0285 0000FE3F           1907              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002240  0685 00000000           1908              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002246                          1909  
00002246                          1910                     
00002246  6100 13F2               1911              BSR     GET_EA_EA_SRC      *GETS <ea>
0000224A  163C 002C               1912              MOVE.B  #',',D3
0000224E  6100 1C88               1913              BSR     PUSH_STACK                  
00002252  6100 1816               1914              BSR     GET_EA_EA_DEST       *GETS Dn    
00002256                          1915  
00002256                          1916              
00002256  6000 0002               1917              BRA     OP1000_DIVS_RETURN
0000225A                          1918              
0000225A                          1919  OP1000_DIVS_RETURN
0000225A  4E75                    1920              RTS
0000225C                          1921              
0000225C                          1922  
0000225C                          1923  *---------------------------------------------------------------------------*
0000225C                          1924  * OP1001: decode SUB/SUBA
0000225C                          1925  *---------------------------------------------------------------------------*      
0000225C                          1926  OP1001      
0000225C  4280                    1927              CLR.L   D0                  
0000225E  4281                    1928              CLR.L   D1       
00002260  4284                    1929              CLR.L   D4                   
00002262  227C 00000000           1930              MOVEA.L #0, A1              
00002268  2205                    1931              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000226A                          1932              
0000226A                          1933              *CLEAR D3
0000226A  4283                    1934              CLR.L   D3
0000226C                          1935              
0000226C                          1936              
0000226C                          1937              
0000226C                          1938              **INTEGRATING SUB.W/.L INTO THIS CODE**
0000226C  2205                    1939              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000226E                          1940              *BITS (INDEX 8) 
0000226E                          1941              *0 = ADD.B/W/L <EA>,Dn
0000226E                          1942              *1 = ADD.B/W/L Dn,<EA> 
0000226E  EC99                    1943              ROR.L   #6,D1
00002270  0281 00000007           1944              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002276  0C81 00000007           1945              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
0000227C  6700 0010               1946              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00002280  0C81 00000003           1947              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002286  6700 0078               1948              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
0000228A  6000 00E6               1949              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000228E                          1950              
0000228E                          1951  OP1001_SUBA_L
0000228E                          1952              *LOAD STACK WITH THIS OPMODE
0000228E  6100 1C48               1953              BSR     PUSH_STACK
00002292  163C 0053               1954              MOVE.B  #'S',D3
00002296  6100 1C40               1955              BSR     PUSH_STACK
0000229A  163C 0055               1956              MOVE.B  #'U',D3
0000229E  6100 1C38               1957              BSR     PUSH_STACK
000022A2  163C 0042               1958              MOVE.B  #'B',D3
000022A6  6100 1C30               1959              BSR     PUSH_STACK
000022AA  163C 0041               1960              MOVE.B  #'A',D3
000022AE  6100 1C28               1961              BSR     PUSH_STACK
000022B2  163C 002E               1962              MOVE.B  #'.',D3
000022B6  6100 1C20               1963              BSR     PUSH_STACK
000022BA  163C 004C               1964              MOVE.B  #'L',D3
000022BE  6100 1C18               1965              BSR     PUSH_STACK
000022C2                          1966              
000022C2                          1967             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022C2  13FC 0000 00004562      1968             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022CA  13FC 0000 00004563      1969             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022D2                          1970             
000022D2                          1971             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022D2  13FC 00B9 00004565      1972             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022DA  13FC 0020 00004566      1973             MOVE.B   #$20,GET_SRC_START_END
000022E2                          1974  
000022E2                          1975              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022E2  0285 0000FE3F           1976              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022E8  0685 00000040           1977              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022EE                          1978       
000022EE                          1979              *PRINT <EA>,AN
000022EE  6100 134A               1980              BSR     GET_EA_EA_SRC       *GETS <ea>
000022F2  163C 002C               1981              MOVE.B  #',',D3
000022F6  6100 1BE0               1982              BSR     PUSH_STACK                     
000022FA  6100 176E               1983              BSR     GET_EA_EA_DEST      *GETS Dn
000022FE                          1984  
000022FE                          1985              
000022FE                          1986              
000022FE  4E75                    1987              RTS
00002300                          1988  OP1001_SUBA_W
00002300                          1989              *LOAD STACK WITH THIS OPMODE
00002300  6100 1BD6               1990              BSR     PUSH_STACK
00002304  163C 0053               1991              MOVE.B  #'S',D3
00002308  6100 1BCE               1992              BSR     PUSH_STACK
0000230C  163C 0055               1993              MOVE.B  #'U',D3
00002310  6100 1BC6               1994              BSR     PUSH_STACK
00002314  163C 0042               1995              MOVE.B  #'B',D3
00002318  6100 1BBE               1996              BSR     PUSH_STACK
0000231C  163C 0041               1997              MOVE.B  #'A',D3
00002320  6100 1BB6               1998              BSR     PUSH_STACK
00002324  163C 002E               1999              MOVE.B  #'.',D3
00002328  6100 1BAE               2000              BSR     PUSH_STACK
0000232C  163C 0057               2001              MOVE.B  #'W',D3
00002330  6100 1BA6               2002              BSR     PUSH_STACK
00002334                          2003              
00002334                          2004             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002334  13FC 0000 00004562      2005             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000233C  13FC 0000 00004563      2006             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002344                          2007             
00002344                          2008             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002344  13FC 00B9 00004565      2009             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000234C  13FC 0020 00004566      2010             MOVE.B   #$20,GET_SRC_START_END
00002354                          2011  
00002354                          2012              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002354  0285 0000FE3F           2013              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000235A  0685 00000040           2014              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002360                          2015       
00002360                          2016              *PRINT <EA>,AN
00002360  6100 12D8               2017              BSR     GET_EA_EA_SRC       *GETS <ea>
00002364  163C 002C               2018              MOVE.B  #',',D3
00002368  6100 1B6E               2019              BSR     PUSH_STACK                     
0000236C  6100 16FC               2020              BSR     GET_EA_EA_DEST      *GETS Dn
00002370                          2021  
00002370  4E75                    2022              RTS
00002372                          2023  
00002372                          2024  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00002372                          2025              *LOAD STACK WITH THIS OPMODE
00002372  6100 1B64               2026              BSR     PUSH_STACK
00002376  163C 0053               2027              MOVE.B  #'S',D3
0000237A  6100 1B5C               2028              BSR     PUSH_STACK
0000237E  163C 0055               2029              MOVE.B  #'U',D3
00002382  6100 1B54               2030              BSR     PUSH_STACK
00002386  163C 0042               2031              MOVE.B  #'B',D3
0000238A  6100 1B4C               2032              BSR     PUSH_STACK
0000238E  163C 002E               2033              MOVE.B  #'.',D3
00002392  6100 1B44               2034              BSR     PUSH_STACK
00002396                          2035              
00002396  2205                    2036              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002398                          2037              
00002398                          2038              *BITS (INDEX 8) 
00002398                          2039              *0 = ADD.B/W/L <EA>,Dn
00002398                          2040              *1 = ADD.B/W/L Dn,<EA> 
00002398  E099                    2041              ROR.L   #8,D1
0000239A  0281 00000001           2042              ANDI.L  #$01,D1     *MASKS WITH 00000001
000023A0  0C81 00000000           2043              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000023A6  6700 0102               2044              BEQ     OP1001_EA_DN
000023AA                          2045              *else procede to Dn_EA
000023AA                          2046              
000023AA                          2047  OP1001_DN_EA
000023AA                          2048              *BITS (7 TO 6) 
000023AA                          2049              *00 = .B
000023AA                          2050              *01 = .W
000023AA                          2051              *10 = .L 
000023AA  2205                    2052              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000023AC  EC99                    2053              ROR.L   #6,D1
000023AE  0281 00000003           2054              ANDI.L  #$03,D1
000023B4  0C81 00000000           2055              CMPI.L  #$00,D1 *EQUALS .B
000023BA  6700 0016               2056              BEQ     OP1001_PRINT_B2
000023BE  0C81 00000001           2057              CMPI.L  #$01,D1 *EQUALS .W
000023C4  6700 0054               2058              BEQ     OP1001_PRINT_W2
000023C8  0C81 00000002           2059              CMPI.L  #$02,D1 *EQUALS .L
000023CE  6700 0092               2060              BEQ     OP1001_PRINT_L2
000023D2                          2061  OP1001_PRINT_B2
000023D2                          2062              *PUSH 'B'
000023D2  163C 0042               2063              MOVE.B  #'B',D3
000023D6  6100 1B00               2064              BSR     PUSH_STACK
000023DA                          2065             
000023DA                          2066              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023DA  13FC 0000 00004562      2067             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023E2  13FC 0083 00004563      2068             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023EA                          2069             
000023EA                          2070             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023EA  13FC 00B9 00004565      2071             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023F2  13FC 0020 00004566      2072             MOVE.B   #$20,GET_SRC_START_END
000023FA                          2073  
000023FA                          2074              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023FA  0285 0000FE3F           2075              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002400  0685 00000040           2076              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002406                          2077       
00002406  6100 1662               2078              BSR     GET_EA_EA_DEST      *GETS Dn
0000240A  163C 002C               2079              MOVE.B  #',',D3
0000240E  6100 1AC8               2080              BSR     PUSH_STACK                     
00002412  6100 1226               2081              BSR     GET_EA_EA_SRC       *GETS <ea>
00002416                          2082  
00002416                          2083              
00002416  6000 0A96               2084              BRA     OP1101_ADD_RETURN
0000241A                          2085  OP1001_PRINT_W2
0000241A  163C 0057               2086              MOVE.B  #'W',D3
0000241E  6100 1AB8               2087              BSR     PUSH_STACK
00002422                          2088  
00002422                          2089              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002422  13FC 0000 00004562      2090              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000242A  13FC 0083 00004563      2091              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002432                          2092             
00002432                          2093              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002432  13FC 00B9 00004565      2094              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000243A  13FC 0020 00004566      2095              MOVE.B   #$20,GET_SRC_START_END
00002442                          2096  
00002442                          2097              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002442  0285 0000FE3F           2098              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002448  0685 00000040           2099              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
0000244E                          2100  
0000244E                          2101        
0000244E  6100 161A               2102              BSR     GET_EA_EA_DEST      *GETS Dn
00002452  163C 002C               2103              MOVE.B  #',',D3
00002456  6100 1A80               2104              BSR     PUSH_STACK               
0000245A  6100 11DE               2105              BSR     GET_EA_EA_SRC       *GETS <ea>       
0000245E                          2106  
0000245E                          2107  
0000245E                          2108  
0000245E  6000 0A4E               2109              BRA     OP1101_ADD_RETURN
00002462                          2110  OP1001_PRINT_L2 
00002462  163C 004C               2111              MOVE.B  #'L',D3
00002466  6100 1A70               2112              BSR     PUSH_STACK
0000246A                          2113              
0000246A                          2114              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000246A  13FC 0000 00004562      2115              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002472  13FC 0083 00004563      2116              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000247A                          2117             
0000247A                          2118              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000247A  13FC 00B9 00004565      2119              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002482  13FC 0020 00004566      2120              MOVE.B   #$20,GET_SRC_START_END
0000248A                          2121  
0000248A                          2122             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000248A  0285 0000FE3F           2123              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002490  0685 00000040           2124              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002496                          2125  
00002496                          2126               
00002496  6100 15D2               2127              BSR     GET_EA_EA_DEST       *GETS Dn
0000249A  163C 002C               2128              MOVE.B  #',',D3
0000249E  6100 1A38               2129              BSR     PUSH_STACK          
000024A2  6100 1196               2130              BSR     GET_EA_EA_SRC        *GETS <ea>
000024A6                          2131  
000024A6  6000 0A06               2132              BRA     OP1101_ADD_RETURN
000024AA                          2133              
000024AA                          2134  OP1001_EA_DN           
000024AA                          2135              *BITS (7 TO 6) 
000024AA                          2136              *00 = .B
000024AA                          2137              *01 = .W
000024AA                          2138              *10 = .L 
000024AA  2205                    2139              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000024AC  EC99                    2140              ROR.L   #6,D1
000024AE  0281 00000003           2141              ANDI.L  #$03,D1
000024B4  0C81 00000000           2142              CMPI.L  #$00,D1 *EQUALS .B
000024BA  6700 0016               2143              BEQ     OP1001_PRINT_B
000024BE  0C81 00000001           2144              CMPI.L  #$01,D1 *EQUALS .W
000024C4  6700 0054               2145              BEQ     OP1001_PRINT_W
000024C8  0C81 00000002           2146              CMPI.L  #$02,D1 *EQUALS .L
000024CE  6700 0092               2147              BEQ     OP1001_PRINT_L
000024D2                          2148  OP1001_PRINT_B
000024D2  163C 0042               2149              MOVE.B  #'B',D3
000024D6  6100 1A00               2150              BSR     PUSH_STACK
000024DA                          2151                
000024DA                          2152              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024DA  13FC 0000 00004562      2153              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024E2  13FC 0002 00004563      2154              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024EA                          2155             
000024EA                          2156              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024EA  13FC 00B9 00004565      2157              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024F2  13FC 0020 00004566      2158              MOVE.B   #$20,GET_SRC_START_END
000024FA                          2159  
000024FA                          2160             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024FA  0285 0000FE3F           2161              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002500  0685 00000040           2162              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002506                          2163  
00002506                          2164              
00002506  6100 1132               2165              BSR     GET_EA_EA_SRC      *GETS <ea>
0000250A  163C 002C               2166              MOVE.B  #',',D3
0000250E  6100 19C8               2167              BSR     PUSH_STACK          
00002512  6100 1556               2168              BSR     GET_EA_EA_DEST       *GETS Dn
00002516                          2169              
00002516  6000 0996               2170              BRA     OP1101_ADD_RETURN
0000251A                          2171  OP1001_PRINT_W
0000251A  163C 0057               2172              MOVE.B  #'W',D3
0000251E  6100 19B8               2173              BSR     PUSH_STACK
00002522                          2174  
00002522                          2175              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002522  13FC 0000 00004562      2176              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000252A  13FC 0000 00004563      2177              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002532                          2178             
00002532                          2179              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002532  13FC 00B9 00004565      2180              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000253A  13FC 0020 00004566      2181              MOVE.B   #$20,GET_SRC_START_END
00002542                          2182  
00002542                          2183             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002542  0285 0000FE3F           2184              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002548  0685 00000040           2185              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000254E                          2186  
0000254E                          2187              
0000254E  6100 10EA               2188              BSR     GET_EA_EA_SRC      *GETS <ea>
00002552  163C 002C               2189              MOVE.B  #',',D3
00002556  6100 1980               2190              BSR     PUSH_STACK
0000255A  6100 150E               2191              BSR     GET_EA_EA_DEST       *GETS Dn    
0000255E                          2192              
0000255E  6000 004A               2193              BRA     OP1001_ADD_RETURN
00002562                          2194  OP1001_PRINT_L 
00002562  163C 004C               2195              MOVE.B  #'L',D3
00002566  6100 1970               2196              BSR     PUSH_STACK
0000256A                          2197              
0000256A                          2198              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000256A  13FC 0000 00004562      2199              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002572  13FC 0000 00004563      2200              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000257A                          2201             
0000257A                          2202              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000257A  13FC 00B9 00004565      2203              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002582  13FC 0020 00004566      2204              MOVE.B   #$20,GET_SRC_START_END
0000258A                          2205  
0000258A                          2206              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000258A  0285 0000FE3F           2207              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002590  0685 00000040           2208              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002596                          2209  
00002596                          2210                     
00002596  6100 10A2               2211              BSR     GET_EA_EA_SRC      *GETS <ea>
0000259A  163C 002C               2212              MOVE.B  #',',D3
0000259E  6100 1938               2213              BSR     PUSH_STACK                  
000025A2  6100 14C6               2214              BSR     GET_EA_EA_DEST       *GETS Dn    
000025A6                          2215  
000025A6                          2216              
000025A6  6000 0002               2217              BRA     OP1001_ADD_RETURN
000025AA                          2218              
000025AA                          2219  OP1001_ADD_RETURN
000025AA  4E75                    2220              RTS
000025AC                          2221  
000025AC                          2222    *---------------------------------------------------------------------------*
000025AC                          2223  * OP1010 : unassigned
000025AC                          2224  *---------------------------------------------------------------------------*           
000025AC  4EF8 1740               2225  OP1010      JMP     OP_DATA
000025B0                          2226              
000025B0                          2227  *---------------------------------------------------------------------------*
000025B0                          2228  * OP1011 : decode CMP/EOR/CMPA
000025B0                          2229  *---------------------------------------------------------------------------*           
000025B0  4280                    2230  OP1011      CLR.L   D0                
000025B2  4281                    2231              CLR.L   D1            
000025B4  4284                    2232              CLR.L   D4                   
000025B6  227C 00000000           2233              MOVEA.L #0, A1               
000025BC  2205                    2234              MOVE.L  D5,D1
000025BE  EA99                    2235              ROR.L   #5,D1
000025C0  0281 0000000E           2236              ANDI.L  #$E,D1
000025C6  0C01 0000               2237              CMPI.B  #$0,D1
000025CA  6700 003E               2238              BEQ     OP1011_CMP
000025CE  0C01 0002               2239              CMPI.B  #$2,D1
000025D2  6700 0036               2240              BEQ     OP1011_CMP
000025D6  0C01 0004               2241              CMPI.B  #$4,D1
000025DA  6700 002E               2242              BEQ     OP1011_CMP
000025DE  0C01 0008               2243              CMPI.B  #$8,D1
000025E2  6700 0178               2244              BEQ     OP1011_EOR
000025E6  0C01 000A               2245              CMPI.B  #$A,D1
000025EA  6700 0170               2246              BEQ     OP1011_EOR
000025EE  0C01 000C               2247              CMPI.B  #$C,D1
000025F2  6700 0168               2248              BEQ     OP1011_EOR  
000025F6  0C01 0006               2249              CMPI.B  #$6,D1
000025FA  6700 00C0               2250              BEQ     OP1011_CMPA
000025FE  0C01 000E               2251              CMPI.B  #$E,D1
00002602  6700 00B8               2252              BEQ     OP1011_CMPA 
00002606                          2253  
00002606  4EF8 1740               2254              JMP     OP_DATA          
0000260A                          2255  
0000260A                          2256  
0000260A                          2257  
0000260A                          2258  
0000260A                          2259  OP1011_CMP
0000260A                          2260             
0000260A                          2261   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000260A  13FC 0082 00004562      2262             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002612  13FC 0000 00004563      2263             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000261A                          2264             
0000261A                          2265             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000261A  13FC 00B9 00004565      2266             MOVE.B   #$B9,GET_DST_START_END
00002622  13FC 0020 00004566      2267             MOVE.B   #$20,GET_SRC_START_END
0000262A                          2268             
0000262A                          2269              *CLEAR D3
0000262A  4283                    2270              CLR.L   D3
0000262C                          2271              *LOAD STACK WITH THIS OPMODE
0000262C  6100 18AA               2272              BSR     PUSH_STACK
00002630  163C 0043               2273              MOVE.B  #'C',D3
00002634  6100 18A2               2274              BSR     PUSH_STACK
00002638  163C 004D               2275              MOVE.B  #'M',D3
0000263C  6100 189A               2276              BSR     PUSH_STACK
00002640  163C 0050               2277              MOVE.B  #'P',D3
00002644  6100 1892               2278              BSR     PUSH_STACK
00002648  163C 002E               2279              MOVE.B  #'.',D3
0000264C  6100 188A               2280              BSR     PUSH_STACK
00002650                          2281              
00002650                          2282              *FIGURE OUT SIZE*
00002650                          2283              *00 = BYTE
00002650                          2284              *01 = WORD
00002650                          2285              *10 = LONG
00002650                          2286              * BITS 7&6
00002650                          2287              
00002650                          2288              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002650  2205                    2289              MOVE.L  D5,D1
00002652  EC99                    2290              ROR.L   #6,D1
00002654  0281 00000003           2291              ANDI.L  #$03,D1
0000265A  0C01 0000               2292              CMPI.B  #%00,D1
0000265E  6700 001E               2293              BEQ     OP1011_CMP_B
00002662  0281 00000003           2294              ANDI.L  #$03,D1
00002668  0C01 0001               2295              CMPI.B  #%01,D1
0000266C  6700 001C               2296              BEQ     OP1011_CMP_W
00002670  0281 00000003           2297              ANDI.L  #$03,D1
00002676  0C01 0002               2298              CMPI.B  #%10,D1
0000267A  6700 001A               2299              BEQ     OP1011_CMP_L
0000267E                          2300            
0000267E                          2301  OP1011_CMP_B
0000267E                          2302              
0000267E  163C 0042               2303              MOVE.B  #'B',D3
00002682  6100 1854               2304              BSR     PUSH_STACK
00002686  6000 0016               2305              BRA     OP1011_RETURN_CMP  
0000268A                          2306  OP1011_CMP_W
0000268A                          2307              
0000268A  163C 0057               2308              MOVE.B  #'W',D3
0000268E  6100 1848               2309              BSR     PUSH_STACK
00002692  6000 000A               2310              BRA     OP1011_RETURN_CMP  
00002696                          2311  OP1011_CMP_L
00002696                          2312              
00002696  163C 004C               2313              MOVE.B  #'L',D3
0000269A  6100 183C               2314              BSR     PUSH_STACK
0000269E                          2315  OP1011_RETURN_CMP            
0000269E                          2316  
0000269E                          2317              
0000269E                          2318  *GET DATA FROM ADDQ AND PRINT #0-8
0000269E                          2319       
0000269E                          2320              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000269E  0285 0000FE3F           2321              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026A4  0685 00000000           2322              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026AA                          2323  
000026AA  6100 0F8E               2324              BSR     GET_EA_EA_SRC
000026AE  163C 002C               2325              MOVE.B  #',',D3
000026B2  6100 1824               2326              BSR     PUSH_STACK
000026B6  6100 13B2               2327              BSR     GET_EA_EA_DEST
000026BA                          2328              
000026BA  4E75                    2329              RTS
000026BC                          2330              
000026BC                          2331  
000026BC                          2332  
000026BC                          2333  OP1011_CMPA
000026BC                          2334              
000026BC                          2335   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026BC  13FC 0080 00004562      2336             MOVE.B   #$80,DEST_REGISTER_FORMAT
000026C4  13FC 0000 00004563      2337             MOVE.B   #$00,SRC_REGISTER_FORMAT
000026CC                          2338             
000026CC                          2339             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026CC  13FC 00B9 00004565      2340             MOVE.B   #$B9,GET_DST_START_END
000026D4  13FC 0020 00004566      2341             MOVE.B   #$20,GET_SRC_START_END
000026DC                          2342             
000026DC                          2343              *CLEAR D3
000026DC  4283                    2344              CLR.L   D3
000026DE                          2345              *LOAD STACK WITH THIS OPMODE
000026DE  6100 17F8               2346              BSR     PUSH_STACK
000026E2  163C 0043               2347              MOVE.B  #'C',D3
000026E6  6100 17F0               2348              BSR     PUSH_STACK
000026EA  163C 004D               2349              MOVE.B  #'M',D3
000026EE  6100 17E8               2350              BSR     PUSH_STACK
000026F2  163C 0050               2351              MOVE.B  #'P',D3
000026F6  6100 17E0               2352              BSR     PUSH_STACK
000026FA  163C 0041               2353              MOVE.B  #'A',D3
000026FE  6100 17D8               2354              BSR     PUSH_STACK
00002702  163C 002E               2355              MOVE.B  #'.',D3
00002706  6100 17D0               2356              BSR     PUSH_STACK
0000270A                          2357              
0000270A                          2358              *FIGURE OUT SIZE*
0000270A                          2359              *00 = BYTE
0000270A                          2360              *01 = WORD
0000270A                          2361              *10 = LONG
0000270A                          2362              * BITS 7&6
0000270A                          2363              
0000270A                          2364              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000270A  2205                    2365              MOVE.L  D5,D1
0000270C  EC99                    2366              ROR.L   #6,D1
0000270E  0281 00000003           2367              ANDI.L  #$03,D1
00002714  0C01 0001               2368              CMPI.B  #%01,D1
00002718  6700 0010               2369              BEQ     OP1011_CMPA_W
0000271C  0281 00000003           2370              ANDI.L  #$03,D1
00002722  0C01 0002               2371              CMPI.B  #%10,D1
00002726  6700 000E               2372              BEQ     OP1011_CMPA_L
0000272A                          2373  OP1011_CMPA_W
0000272A                          2374              
0000272A  163C 0057               2375              MOVE.B  #'W',D3
0000272E  6100 17A8               2376              BSR     PUSH_STACK
00002732  6000 000A               2377              BRA     OP1011_RETURN_CMPA 
00002736                          2378  OP1011_CMPA_L
00002736                          2379              
00002736  163C 004C               2380              MOVE.B  #'L',D3
0000273A  6100 179C               2381              BSR     PUSH_STACK
0000273E                          2382  OP1011_RETURN_CMPA            
0000273E                          2383  
0000273E                          2384              
0000273E                          2385  *GET DATA FROM ADDQ AND PRINT #0-8
0000273E                          2386       
0000273E                          2387              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000273E  0285 0000FE3F           2388              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002744  0685 00000040           2389              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000274A                          2390  
0000274A  6100 0EEE               2391              BSR     GET_EA_EA_SRC
0000274E  163C 002C               2392              MOVE.B  #',',D3
00002752  6100 1784               2393              BSR     PUSH_STACK
00002756  6100 1312               2394              BSR     GET_EA_EA_DEST
0000275A                          2395              
0000275A  4E75                    2396              RTS
0000275C                          2397  
0000275C                          2398  OP1011_EOR
0000275C                          2399  
0000275C                          2400   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000275C  13FC 0082 00004562      2401             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002764  13FC 0080 00004563      2402             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000276C                          2403             
0000276C                          2404             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000276C  13FC 00B9 00004565      2405             MOVE.B   #$B9,GET_DST_START_END
00002774  13FC 0020 00004566      2406             MOVE.B   #$20,GET_SRC_START_END
0000277C                          2407             
0000277C                          2408              *CLEAR D3
0000277C  4283                    2409              CLR.L   D3
0000277E                          2410              *LOAD STACK WITH THIS OPMODE
0000277E  6100 1758               2411              BSR     PUSH_STACK
00002782  163C 0045               2412              MOVE.B  #'E',D3
00002786  6100 1750               2413              BSR     PUSH_STACK
0000278A  163C 004F               2414              MOVE.B  #'O',D3
0000278E  6100 1748               2415              BSR     PUSH_STACK
00002792  163C 0052               2416              MOVE.B  #'R',D3
00002796  6100 1740               2417              BSR     PUSH_STACK
0000279A  163C 002E               2418              MOVE.B  #'.',D3
0000279E  6100 1738               2419              BSR     PUSH_STACK
000027A2                          2420              
000027A2                          2421              *FIGURE OUT SIZE*
000027A2                          2422              *00 = BYTE
000027A2                          2423              *01 = WORD
000027A2                          2424              *10 = LONG
000027A2                          2425              * BITS 7&6
000027A2                          2426              
000027A2                          2427              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000027A2  2205                    2428              MOVE.L  D5,D1
000027A4  EC99                    2429              ROR.L   #6,D1
000027A6  0281 00000003           2430              ANDI.L  #$03,D1
000027AC  0C01 0000               2431              CMPI.B  #%00,D1
000027B0  6700 001E               2432              BEQ     OP1011_EOR_B
000027B4  0281 00000003           2433              ANDI.L  #$03,D1
000027BA  0C01 0001               2434              CMPI.B  #%01,D1
000027BE  6700 001C               2435              BEQ     OP1011_EOR_W
000027C2  0281 00000003           2436              ANDI.L  #$03,D1
000027C8  0C01 0002               2437              CMPI.B  #%10,D1
000027CC  6700 001A               2438              BEQ     OP1011_EOR_L
000027D0                          2439            
000027D0                          2440  OP1011_EOR_B
000027D0                          2441              
000027D0  163C 0042               2442              MOVE.B  #'B',D3
000027D4  6100 1702               2443              BSR     PUSH_STACK
000027D8  6000 0016               2444              BRA     OP1011_RETURN
000027DC                          2445  OP1011_EOR_W
000027DC                          2446              
000027DC  163C 0057               2447              MOVE.B  #'W',D3
000027E0  6100 16F6               2448              BSR     PUSH_STACK
000027E4  6000 000A               2449              BRA     OP1011_RETURN
000027E8                          2450  OP1011_EOR_L
000027E8                          2451              
000027E8  163C 004C               2452              MOVE.B  #'L',D3
000027EC  6100 16EA               2453              BSR     PUSH_STACK
000027F0                          2454  OP1011_RETURN            
000027F0                          2455  
000027F0                          2456              
000027F0                          2457  *GET DATA FROM ADDQ AND PRINT #0-8
000027F0                          2458       
000027F0                          2459              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027F0  0285 0000FE3F           2460              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027F6  0685 00000000           2461              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027FC                          2462  
000027FC  6100 126C               2463              BSR     GET_EA_EA_DEST
00002800  163C 002C               2464              MOVE.B  #',',D3
00002804  6100 16D2               2465              BSR     PUSH_STACK
00002808  6100 0E30               2466              BSR     GET_EA_EA_SRC
0000280C                          2467              
0000280C  4E75                    2468              RTS
0000280E                          2469              
0000280E                          2470              *---------------------------------------------------------------------------*
0000280E                          2471  * OP1100: Decode and display MULS/AND and proceed to EA
0000280E                          2472  *---------------------------------------------------------------------------* 
0000280E  4280                    2473  OP1100      CLR.L   D0                 
00002810  4281                    2474              CLR.L   D1    
00002812  4284                    2475              CLR.L   D4                
00002814  227C 00000000           2476              MOVEA.L #0, A1        
0000281A  2205                    2477              MOVE.L  D5,D1
0000281C  EA89                    2478              LSR.L   #5,D1
0000281E  0281 0000000E           2479              ANDI.L  #$E,D1
00002824  0C41 000E               2480              CMPI.W  #$E,D1
00002828  6700 0006               2481              BEQ     OP_MULS
0000282C  6000 00F6               2482              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002830                          2483  
00002830                          2484  OP_MULS                      
00002830  4281                    2485              CLR.L   D1       
00002832  4284                    2486              CLR.L   D4                   
00002834  227C 00000000           2487              MOVEA.L #0, A1              
0000283A  2205                    2488              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
0000283C                          2489              *CLEAR D3
0000283C  4283                    2490              CLR.L   D3
0000283E                          2491  
0000283E                          2492  OP1100_MULS_DN_EA_OR_EA_DN 
0000283E                          2493              *LOAD STACK WITH THIS OPMODE
0000283E  6100 1698               2494              BSR     PUSH_STACK
00002842  163C 004D               2495              MOVE.B  #'M',D3
00002846  6100 1690               2496              BSR     PUSH_STACK
0000284A  163C 0055               2497              MOVE.B  #'U',D3
0000284E  6100 1688               2498              BSR     PUSH_STACK
00002852  163C 004C               2499              MOVE.B  #'L',D3
00002856  6100 1680               2500              BSR     PUSH_STACK
0000285A  163C 0053               2501              MOVE.B  #'S',D3
0000285E  6100 1678               2502              BSR     PUSH_STACK
00002862  163C 002E               2503              MOVE.B  #'.',D3
00002866  6100 1670               2504              BSR     PUSH_STACK
0000286A                          2505              
0000286A  2205                    2506              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000286C                          2507              
0000286C                          2508  OP1100_EA_DN_MULS           
0000286C                          2509              *BITS (7 TO 6) 
0000286C                          2510              *00 = .B
0000286C                          2511              *01 = .W
0000286C                          2512              *10 = .L 
0000286C  2205                    2513              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000286E  EC99                    2514              ROR.L   #6,D1
00002870  0281 00000003           2515              ANDI.L  #$03,D1
00002876  0C81 00000003           2516              CMPI.L  #%11,D1 *EQUALS .W
0000287C  6700 0014               2517              BEQ     OP1100_PRINT_W_MULS
00002880  0C81 00000000           2518              CMPI.L  #%00,D1 *EQUALS .L
00002886  6700 0052               2519              BEQ     OP1100_PRINT_L_MULS
0000288A                          2520              
0000288A  183C 0001               2521              MOVE.B  #1,D4               *ERROR READ
0000288E  6000 0092               2522              BRA     OP1100_MULS_RETURN
00002892                          2523  OP1100_PRINT_W_MULS
00002892  163C 0057               2524              MOVE.B  #'W',D3
00002896  6100 1640               2525              BSR     PUSH_STACK
0000289A                          2526  
0000289A                          2527              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000289A  13FC 0000 00004562      2528              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028A2  13FC 0000 00004563      2529              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028AA                          2530             
000028AA                          2531              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028AA  13FC 00B9 00004565      2532              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028B2  13FC 0020 00004566      2533              MOVE.B   #$20,GET_SRC_START_END
000028BA                          2534  
000028BA                          2535             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028BA  0285 0000FE3F           2536              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028C0  0685 00000000           2537              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000028C6                          2538  
000028C6                          2539              
000028C6  6100 0D72               2540              BSR     GET_EA_EA_SRC      *GETS <ea>
000028CA  163C 002C               2541              MOVE.B  #',',D3
000028CE  6100 1608               2542              BSR     PUSH_STACK
000028D2  6100 1196               2543              BSR     GET_EA_EA_DEST       *GETS Dn    
000028D6                          2544              
000028D6  6000 004A               2545              BRA     OP1100_MULS_RETURN
000028DA                          2546  OP1100_PRINT_L_MULS 
000028DA  163C 004C               2547              MOVE.B  #'L',D3
000028DE  6100 15F8               2548              BSR     PUSH_STACK
000028E2                          2549              
000028E2                          2550              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028E2  13FC 0000 00004562      2551              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028EA  13FC 0000 00004563      2552              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028F2                          2553             
000028F2                          2554              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028F2  13FC 00B9 00004565      2555              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028FA  13FC 0020 00004566      2556              MOVE.B   #$20,GET_SRC_START_END
00002902                          2557  
00002902                          2558              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002902  0285 0000FE3F           2559              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002908  0685 00000000           2560              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000290E                          2561  
0000290E                          2562                     
0000290E  6100 0D2A               2563              BSR     GET_EA_EA_SRC      *GETS <ea>
00002912  163C 002C               2564              MOVE.B  #',',D3
00002916  6100 15C0               2565              BSR     PUSH_STACK                  
0000291A  6100 114E               2566              BSR     GET_EA_EA_DEST       *GETS Dn    
0000291E                          2567  
0000291E                          2568              
0000291E  6000 0002               2569              BRA     OP1100_MULS_RETURN
00002922                          2570              
00002922                          2571  OP1100_MULS_RETURN
00002922  4E75                    2572              RTS
00002924                          2573              
00002924                          2574  
00002924                          2575  
00002924                          2576  
00002924                          2577  
00002924                          2578  
00002924                          2579  
00002924                          2580  
00002924                          2581  
00002924                          2582  
00002924                          2583  
00002924                          2584  
00002924                          2585  
00002924                          2586  OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002924                          2587              *LOAD STACK WITH THIS OPMODE
00002924  4283                    2588              CLR.L   D3
00002926  6100 15B0               2589              BSR     PUSH_STACK
0000292A  163C 0041               2590              MOVE.B  #'A',D3
0000292E  6100 15A8               2591              BSR     PUSH_STACK
00002932  163C 004E               2592              MOVE.B  #'N',D3
00002936  6100 15A0               2593              BSR     PUSH_STACK
0000293A  163C 0044               2594              MOVE.B  #'D',D3
0000293E  6100 1598               2595              BSR     PUSH_STACK
00002942  163C 002E               2596              MOVE.B  #'.',D3
00002946  6100 1590               2597              BSR     PUSH_STACK
0000294A                          2598              
0000294A  2205                    2599              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000294C                          2600              
0000294C                          2601              *BITS (INDEX 8) 
0000294C                          2602              *0 = ADD.B/W/L <EA>,Dn
0000294C                          2603              *1 = ADD.B/W/L Dn,<EA> 
0000294C  E099                    2604              ROR.L   #8,D1
0000294E  0281 00000001           2605              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002954  0C81 00000000           2606              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000295A  6700 0102               2607              BEQ     OP1100_EA_DN
0000295E                          2608              *else procede to Dn_EA
0000295E                          2609              
0000295E                          2610  OP1100_DN_EA
0000295E                          2611              *BITS (7 TO 6) 
0000295E                          2612              *00 = .B
0000295E                          2613              *01 = .W
0000295E                          2614              *10 = .L 
0000295E  2205                    2615              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002960  EC99                    2616              ROR.L   #6,D1
00002962  0281 00000003           2617              ANDI.L  #$03,D1
00002968  0C81 00000000           2618              CMPI.L  #$00,D1 *EQUALS .B
0000296E  6700 0016               2619              BEQ     OP1100_PRINT_B2
00002972  0C81 00000001           2620              CMPI.L  #$01,D1 *EQUALS .W
00002978  6700 0054               2621              BEQ     OP1100_PRINT_W2
0000297C  0C81 00000002           2622              CMPI.L  #$02,D1 *EQUALS .L
00002982  6700 0092               2623              BEQ     OP1100_PRINT_L2
00002986                          2624  OP1100_PRINT_B2
00002986                          2625              *PUSH 'B'
00002986  163C 0042               2626              MOVE.B  #'B',D3
0000298A  6100 154C               2627              BSR     PUSH_STACK
0000298E                          2628             
0000298E                          2629              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000298E  13FC 0000 00004562      2630             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002996  13FC 0083 00004563      2631             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000299E                          2632             
0000299E                          2633             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000299E  13FC 00B9 00004565      2634             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029A6  13FC 0020 00004566      2635             MOVE.B   #$20,GET_SRC_START_END
000029AE                          2636  
000029AE                          2637              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029AE  0285 0000FE3F           2638              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029B4  0685 00000000           2639              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029BA                          2640       
000029BA  6100 10AE               2641              BSR     GET_EA_EA_DEST      *GETS Dn
000029BE  163C 002C               2642              MOVE.B  #',',D3
000029C2  6100 1514               2643              BSR     PUSH_STACK                     
000029C6  6100 0C72               2644              BSR     GET_EA_EA_SRC       *GETS <ea>
000029CA                          2645  
000029CA                          2646              
000029CA  6000 0192               2647              BRA     OP1100_AND_RETURN
000029CE                          2648  OP1100_PRINT_W2
000029CE  163C 0057               2649              MOVE.B  #'W',D3
000029D2  6100 1504               2650              BSR     PUSH_STACK
000029D6                          2651  
000029D6                          2652              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000029D6  13FC 0000 00004562      2653              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000029DE  13FC 0083 00004563      2654              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000029E6                          2655             
000029E6                          2656              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000029E6  13FC 00B9 00004565      2657              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029EE  13FC 0020 00004566      2658              MOVE.B   #$20,GET_SRC_START_END
000029F6                          2659  
000029F6                          2660              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029F6  0285 0000FE3F           2661              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029FC  0685 00000000           2662              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002A02                          2663  
00002A02                          2664        
00002A02  6100 1066               2665              BSR     GET_EA_EA_DEST      *GETS Dn
00002A06  163C 002C               2666              MOVE.B  #',',D3
00002A0A  6100 14CC               2667              BSR     PUSH_STACK               
00002A0E  6100 0C2A               2668              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002A12                          2669  
00002A12                          2670  
00002A12                          2671  
00002A12  6000 049A               2672              BRA     OP1101_ADD_RETURN
00002A16                          2673  OP1100_PRINT_L2 
00002A16  163C 004C               2674              MOVE.B  #'L',D3
00002A1A  6100 14BC               2675              BSR     PUSH_STACK
00002A1E                          2676              
00002A1E                          2677              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A1E  13FC 0000 00004562      2678              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A26  13FC 0083 00004563      2679              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A2E                          2680             
00002A2E                          2681              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A2E  13FC 00B9 00004565      2682              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A36  13FC 0020 00004566      2683              MOVE.B   #$20,GET_SRC_START_END
00002A3E                          2684  
00002A3E                          2685             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A3E  0285 0000FE3F           2686              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A44  0685 00000000           2687              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A4A                          2688  
00002A4A                          2689               
00002A4A  6100 101E               2690              BSR     GET_EA_EA_DEST       *GETS Dn
00002A4E  163C 002C               2691              MOVE.B  #',',D3
00002A52  6100 1484               2692              BSR     PUSH_STACK          
00002A56  6100 0BE2               2693              BSR     GET_EA_EA_SRC        *GETS <ea>
00002A5A                          2694  
00002A5A  6000 0102               2695              BRA     OP1100_AND_RETURN
00002A5E                          2696              
00002A5E                          2697  OP1100_EA_DN           
00002A5E                          2698              *BITS (7 TO 6) 
00002A5E                          2699              *00 = .B
00002A5E                          2700              *01 = .W
00002A5E                          2701              *10 = .L 
00002A5E  2205                    2702              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002A60  EC99                    2703              ROR.L   #6,D1
00002A62  0281 00000003           2704              ANDI.L  #$03,D1
00002A68  0C81 00000000           2705              CMPI.L  #$00,D1 *EQUALS .B
00002A6E  6700 0016               2706              BEQ     OP1100_PRINT_B
00002A72  0C81 00000001           2707              CMPI.L  #$01,D1 *EQUALS .W
00002A78  6700 0054               2708              BEQ     OP1100_PRINT_W
00002A7C  0C81 00000002           2709              CMPI.L  #$02,D1 *EQUALS .L
00002A82  6700 0092               2710              BEQ     OP1100_PRINT_L
00002A86                          2711  OP1100_PRINT_B
00002A86  163C 0042               2712              MOVE.B  #'B',D3
00002A8A  6100 144C               2713              BSR     PUSH_STACK
00002A8E                          2714                
00002A8E                          2715              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A8E  13FC 0000 00004562      2716              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A96  13FC 0002 00004563      2717              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A9E                          2718             
00002A9E                          2719              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A9E  13FC 00B9 00004565      2720              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AA6  13FC 0020 00004566      2721              MOVE.B   #$20,GET_SRC_START_END
00002AAE                          2722  
00002AAE                          2723             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AAE  0285 0000FE3F           2724              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AB4  0685 00000000           2725              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002ABA                          2726  
00002ABA                          2727              
00002ABA  6100 0B7E               2728              BSR     GET_EA_EA_SRC      *GETS <ea>
00002ABE  163C 002C               2729              MOVE.B  #',',D3
00002AC2  6100 1414               2730              BSR     PUSH_STACK          
00002AC6  6100 0FA2               2731              BSR     GET_EA_EA_DEST       *GETS Dn
00002ACA                          2732              
00002ACA  6000 03E2               2733              BRA     OP1101_ADD_RETURN
00002ACE                          2734  OP1100_PRINT_W
00002ACE  163C 0057               2735              MOVE.B  #'W',D3
00002AD2  6100 1404               2736              BSR     PUSH_STACK
00002AD6                          2737  
00002AD6                          2738              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AD6  13FC 0000 00004562      2739              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002ADE  13FC 0002 00004563      2740              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AE6                          2741             
00002AE6                          2742              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AE6  13FC 00B9 00004565      2743              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AEE  13FC 0020 00004566      2744              MOVE.B   #$20,GET_SRC_START_END
00002AF6                          2745  
00002AF6                          2746             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AF6  0285 0000FE3F           2747              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AFC  0685 00000000           2748              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B02                          2749  
00002B02                          2750              
00002B02  6100 0B36               2751              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B06  163C 002C               2752              MOVE.B  #',',D3
00002B0A  6100 13CC               2753              BSR     PUSH_STACK
00002B0E  6100 0F5A               2754              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B12                          2755              
00002B12  6000 FA96               2756              BRA     OP1001_ADD_RETURN
00002B16                          2757  OP1100_PRINT_L 
00002B16  163C 004C               2758              MOVE.B  #'L',D3
00002B1A  6100 13BC               2759              BSR     PUSH_STACK
00002B1E                          2760              
00002B1E                          2761              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B1E  13FC 0000 00004562      2762              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B26  13FC 0002 00004563      2763              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B2E                          2764             
00002B2E                          2765              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B2E  13FC 00B9 00004565      2766              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B36  13FC 0020 00004566      2767              MOVE.B   #$20,GET_SRC_START_END
00002B3E                          2768  
00002B3E                          2769              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B3E  0285 0000FE3F           2770              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B44  0685 00000000           2771              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B4A                          2772  
00002B4A                          2773                     
00002B4A  6100 0AEE               2774              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B4E  163C 002C               2775              MOVE.B  #',',D3
00002B52  6100 1384               2776              BSR     PUSH_STACK                  
00002B56  6100 0F12               2777              BSR     GET_EA_EA_DEST       *GETS Dn    
00002B5A                          2778  
00002B5A                          2779              
00002B5A  6000 0002               2780              BRA     OP1100_AND_RETURN
00002B5E                          2781              
00002B5E                          2782  OP1100_AND_RETURN
00002B5E  4E75                    2783              RTS
00002B60                          2784  
00002B60                          2785  
00002B60                          2786  *---------------------------------------------------------------------------*
00002B60                          2787  * OP1101: Decode ADD/ADDA
00002B60                          2788  *---------------------------------------------------------------------------* 
00002B60  4280                    2789  OP1101      CLR.L   D0                  
00002B62  4281                    2790              CLR.L   D1       
00002B64  4284                    2791              CLR.L   D4                   
00002B66  227C 00000000           2792              MOVEA.L #0, A1              
00002B6C  2205                    2793              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002B6E                          2794              
00002B6E                          2795              *CLEAR D3
00002B6E  4283                    2796              CLR.L   D3
00002B70                          2797              
00002B70                          2798              
00002B70                          2799              
00002B70                          2800              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002B70  2205                    2801              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002B72                          2802              *BITS (INDEX 8) 
00002B72                          2803              *0 = ADD.B/W/L <EA>,Dn
00002B72                          2804              *1 = ADD.B/W/L Dn,<EA> 
00002B72  EC99                    2805              ROR.L   #6,D1
00002B74  0281 00000007           2806              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002B7A  0C81 00000007           2807              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002B80  6700 0010               2808              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002B84  0C81 00000003           2809              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002B8A  6700 0078               2810              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002B8E  6000 00E6               2811              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002B92                          2812              
00002B92                          2813  OP1101_ADDA_L
00002B92                          2814              *LOAD STACK WITH THIS OPMODE
00002B92  6100 1344               2815              BSR     PUSH_STACK
00002B96  163C 0041               2816              MOVE.B  #'A',D3
00002B9A  6100 133C               2817              BSR     PUSH_STACK
00002B9E  163C 0044               2818              MOVE.B  #'D',D3
00002BA2  6100 1334               2819              BSR     PUSH_STACK
00002BA6  163C 0044               2820              MOVE.B  #'D',D3
00002BAA  6100 132C               2821              BSR     PUSH_STACK
00002BAE  163C 0041               2822              MOVE.B  #'A',D3
00002BB2  6100 1324               2823              BSR     PUSH_STACK
00002BB6  163C 002E               2824              MOVE.B  #'.',D3
00002BBA  6100 131C               2825              BSR     PUSH_STACK
00002BBE  163C 004C               2826              MOVE.B  #'L',D3
00002BC2  6100 1314               2827              BSR     PUSH_STACK
00002BC6                          2828              
00002BC6                          2829             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BC6  13FC 0000 00004562      2830             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BCE  13FC 0000 00004563      2831             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BD6                          2832             
00002BD6                          2833             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BD6  13FC 00B9 00004565      2834             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BDE  13FC 0020 00004566      2835             MOVE.B   #$20,GET_SRC_START_END
00002BE6                          2836  
00002BE6                          2837              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BE6  0285 0000FE3F           2838              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BEC  0685 00000040           2839              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BF2                          2840       
00002BF2                          2841              *PRINT <EA>,AN
00002BF2  6100 0A46               2842              BSR     GET_EA_EA_SRC       *GETS <ea>
00002BF6  163C 002C               2843              MOVE.B  #',',D3
00002BFA  6100 12DC               2844              BSR     PUSH_STACK                     
00002BFE  6100 0E6A               2845              BSR     GET_EA_EA_DEST      *GETS Dn
00002C02                          2846  
00002C02                          2847              
00002C02                          2848              
00002C02  4E75                    2849              RTS
00002C04                          2850  OP1101_ADDA_W
00002C04                          2851              *LOAD STACK WITH THIS OPMODE
00002C04  6100 12D2               2852              BSR     PUSH_STACK
00002C08  163C 0041               2853              MOVE.B  #'A',D3
00002C0C  6100 12CA               2854              BSR     PUSH_STACK
00002C10  163C 0044               2855              MOVE.B  #'D',D3
00002C14  6100 12C2               2856              BSR     PUSH_STACK
00002C18  163C 0044               2857              MOVE.B  #'D',D3
00002C1C  6100 12BA               2858              BSR     PUSH_STACK
00002C20  163C 0041               2859              MOVE.B  #'A',D3
00002C24  6100 12B2               2860              BSR     PUSH_STACK
00002C28  163C 002E               2861              MOVE.B  #'.',D3
00002C2C  6100 12AA               2862              BSR     PUSH_STACK
00002C30  163C 0057               2863              MOVE.B  #'W',D3
00002C34  6100 12A2               2864              BSR     PUSH_STACK
00002C38                          2865              
00002C38                          2866             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C38  13FC 0000 00004562      2867             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C40  13FC 0000 00004563      2868             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C48                          2869             
00002C48                          2870             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C48  13FC 00B9 00004565      2871             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C50  13FC 0020 00004566      2872             MOVE.B   #$20,GET_SRC_START_END
00002C58                          2873  
00002C58                          2874              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C58  0285 0000FE3F           2875              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C5E  0685 00000040           2876              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C64                          2877       
00002C64                          2878              *PRINT <EA>,AN
00002C64  6100 09D4               2879              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C68  163C 002C               2880              MOVE.B  #',',D3
00002C6C  6100 126A               2881              BSR     PUSH_STACK                     
00002C70  6100 0DF8               2882              BSR     GET_EA_EA_DEST      *GETS Dn
00002C74                          2883  
00002C74  4E75                    2884              RTS
00002C76                          2885  
00002C76                          2886  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002C76                          2887              *LOAD STACK WITH THIS OPMODE
00002C76  6100 1260               2888              BSR     PUSH_STACK
00002C7A  163C 0041               2889              MOVE.B  #'A',D3
00002C7E  6100 1258               2890              BSR     PUSH_STACK
00002C82  163C 0044               2891              MOVE.B  #'D',D3
00002C86  6100 1250               2892              BSR     PUSH_STACK
00002C8A  163C 0044               2893              MOVE.B  #'D',D3
00002C8E  6100 1248               2894              BSR     PUSH_STACK
00002C92  163C 002E               2895              MOVE.B  #'.',D3
00002C96  6100 1240               2896              BSR     PUSH_STACK
00002C9A                          2897              
00002C9A  2205                    2898              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C9C                          2899              
00002C9C                          2900              *BITS (INDEX 8) 
00002C9C                          2901              *0 = ADD.B/W/L <EA>,Dn
00002C9C                          2902              *1 = ADD.B/W/L Dn,<EA> 
00002C9C  E099                    2903              ROR.L   #8,D1
00002C9E  0281 00000001           2904              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002CA4  0C81 00000000           2905              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002CAA  6700 0102               2906              BEQ     OP1101_EA_DN
00002CAE                          2907              *else procede to Dn_EA
00002CAE                          2908              
00002CAE                          2909  OP1101_DN_EA
00002CAE                          2910              *BITS (7 TO 6) 
00002CAE                          2911              *00 = .B
00002CAE                          2912              *01 = .W
00002CAE                          2913              *10 = .L 
00002CAE  2205                    2914              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002CB0  EC99                    2915              ROR.L   #6,D1
00002CB2  0281 00000003           2916              ANDI.L  #$03,D1
00002CB8  0C81 00000000           2917              CMPI.L  #$00,D1 *EQUALS .B
00002CBE  6700 0016               2918              BEQ     OP1101_PRINT_B2
00002CC2  0C81 00000001           2919              CMPI.L  #$01,D1 *EQUALS .W
00002CC8  6700 0054               2920              BEQ     OP1101_PRINT_W2
00002CCC  0C81 00000002           2921              CMPI.L  #$02,D1 *EQUALS .L
00002CD2  6700 0092               2922              BEQ     OP1101_PRINT_L2
00002CD6                          2923  OP1101_PRINT_B2
00002CD6                          2924              *PUSH 'B'
00002CD6  163C 0042               2925              MOVE.B  #'B',D3
00002CDA  6100 11FC               2926              BSR     PUSH_STACK
00002CDE                          2927             
00002CDE                          2928              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CDE  13FC 0002 00004562      2929             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CE6  13FC 0083 00004563      2930             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CEE                          2931             
00002CEE                          2932             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CEE  13FC 00B9 00004565      2933             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CF6  13FC 0020 00004566      2934             MOVE.B   #$20,GET_SRC_START_END
00002CFE                          2935  
00002CFE                          2936              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CFE  0285 0000FE3F           2937              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D04  0685 00000000           2938              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D0A                          2939       
00002D0A  6100 0D5E               2940              BSR     GET_EA_EA_DEST      *GETS Dn
00002D0E  163C 002C               2941              MOVE.B  #',',D3
00002D12  6100 11C4               2942              BSR     PUSH_STACK                     
00002D16  6100 0922               2943              BSR     GET_EA_EA_SRC       *GETS <ea>
00002D1A                          2944  
00002D1A                          2945              
00002D1A  6000 0192               2946              BRA     OP1101_ADD_RETURN
00002D1E                          2947  OP1101_PRINT_W2
00002D1E  163C 0057               2948              MOVE.B  #'W',D3
00002D22  6100 11B4               2949              BSR     PUSH_STACK
00002D26                          2950  
00002D26                          2951              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D26  13FC 0000 00004562      2952              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D2E  13FC 0083 00004563      2953              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D36                          2954             
00002D36                          2955              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D36  13FC 00B9 00004565      2956              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D3E  13FC 0020 00004566      2957              MOVE.B   #$20,GET_SRC_START_END
00002D46                          2958  
00002D46                          2959              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D46  0285 0000FE3F           2960              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D4C  0685 00000000           2961              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D52                          2962  
00002D52                          2963        
00002D52  6100 0D16               2964              BSR     GET_EA_EA_DEST      *GETS Dn
00002D56  163C 002C               2965              MOVE.B  #',',D3
00002D5A  6100 117C               2966              BSR     PUSH_STACK               
00002D5E  6100 08DA               2967              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002D62                          2968  
00002D62                          2969  
00002D62                          2970  
00002D62  6000 014A               2971              BRA     OP1101_ADD_RETURN
00002D66                          2972  OP1101_PRINT_L2 
00002D66  163C 004C               2973              MOVE.B  #'L',D3
00002D6A  6100 116C               2974              BSR     PUSH_STACK
00002D6E                          2975              
00002D6E                          2976              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D6E  13FC 0000 00004562      2977              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D76  13FC 0083 00004563      2978              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D7E                          2979             
00002D7E                          2980              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D7E  13FC 00B9 00004565      2981              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D86  13FC 0020 00004566      2982              MOVE.B   #$20,GET_SRC_START_END
00002D8E                          2983  
00002D8E                          2984             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D8E  0285 0000FE3F           2985              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D94  0685 00000000           2986              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D9A                          2987  
00002D9A                          2988               
00002D9A  6100 0CCE               2989              BSR     GET_EA_EA_DEST       *GETS Dn
00002D9E  163C 002C               2990              MOVE.B  #',',D3
00002DA2  6100 1134               2991              BSR     PUSH_STACK          
00002DA6  6100 0892               2992              BSR     GET_EA_EA_SRC        *GETS <ea>
00002DAA                          2993  
00002DAA  6000 0102               2994              BRA     OP1101_ADD_RETURN
00002DAE                          2995              
00002DAE                          2996  OP1101_EA_DN           
00002DAE                          2997              *BITS (7 TO 6) 
00002DAE                          2998              *00 = .B
00002DAE                          2999              *01 = .W
00002DAE                          3000              *10 = .L 
00002DAE  2205                    3001              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002DB0  EC99                    3002              ROR.L   #6,D1
00002DB2  0281 00000003           3003              ANDI.L  #$03,D1
00002DB8  0C81 00000000           3004              CMPI.L  #$00,D1 *EQUALS .B
00002DBE  6700 0016               3005              BEQ     OP1101_PRINT_B
00002DC2  0C81 00000001           3006              CMPI.L  #$01,D1 *EQUALS .W
00002DC8  6700 0054               3007              BEQ     OP1101_PRINT_W
00002DCC  0C81 00000002           3008              CMPI.L  #$02,D1 *EQUALS .L
00002DD2  6700 0092               3009              BEQ     OP1101_PRINT_L
00002DD6                          3010  OP1101_PRINT_B
00002DD6  163C 0042               3011              MOVE.B  #'B',D3
00002DDA  6100 10FC               3012              BSR     PUSH_STACK
00002DDE                          3013                
00002DDE                          3014              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DDE  13FC 0002 00004562      3015              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DE6  13FC 0002 00004563      3016              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DEE                          3017             
00002DEE                          3018              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DEE  13FC 00B9 00004565      3019              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DF6  13FC 0020 00004566      3020              MOVE.B   #$20,GET_SRC_START_END
00002DFE                          3021  
00002DFE                          3022             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DFE  0285 0000FE3F           3023              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E04  0685 00000000           3024              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E0A                          3025  
00002E0A                          3026              
00002E0A  6100 082E               3027              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E0E  163C 002C               3028              MOVE.B  #',',D3
00002E12  6100 10C4               3029              BSR     PUSH_STACK          
00002E16  6100 0C52               3030              BSR     GET_EA_EA_DEST       *GETS Dn
00002E1A                          3031              
00002E1A  6000 0092               3032              BRA     OP1101_ADD_RETURN
00002E1E                          3033  OP1101_PRINT_W
00002E1E  163C 0057               3034              MOVE.B  #'W',D3
00002E22  6100 10B4               3035              BSR     PUSH_STACK
00002E26                          3036  
00002E26                          3037              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E26  13FC 0000 00004562      3038              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E2E  13FC 0000 00004563      3039              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E36                          3040             
00002E36                          3041              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E36  13FC 00B9 00004565      3042              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E3E  13FC 0020 00004566      3043              MOVE.B   #$20,GET_SRC_START_END
00002E46                          3044  
00002E46                          3045             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E46  0285 0000FE3F           3046              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E4C  0685 00000000           3047              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E52                          3048  
00002E52                          3049              
00002E52  6100 07E6               3050              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E56  163C 002C               3051              MOVE.B  #',',D3
00002E5A  6100 107C               3052              BSR     PUSH_STACK
00002E5E  6100 0C0A               3053              BSR     GET_EA_EA_DEST       *GETS Dn    
00002E62                          3054              
00002E62  6000 004A               3055              BRA     OP1101_ADD_RETURN
00002E66                          3056  OP1101_PRINT_L 
00002E66  163C 004C               3057              MOVE.B  #'L',D3
00002E6A  6100 106C               3058              BSR     PUSH_STACK
00002E6E                          3059              
00002E6E                          3060              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E6E  13FC 0000 00004562      3061              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E76  13FC 0000 00004563      3062              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E7E                          3063             
00002E7E                          3064              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E7E  13FC 00B9 00004565      3065              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E86  13FC 0020 00004566      3066              MOVE.B   #$20,GET_SRC_START_END
00002E8E                          3067  
00002E8E                          3068              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E8E  0285 0000FE3F           3069              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E94  0685 00000000           3070              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E9A                          3071  
00002E9A                          3072                     
00002E9A  6100 079E               3073              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E9E  163C 002C               3074              MOVE.B  #',',D3
00002EA2  6100 1034               3075              BSR     PUSH_STACK                  
00002EA6  6100 0BC2               3076              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EAA                          3077  
00002EAA                          3078              
00002EAA  6000 0002               3079              BRA     OP1101_ADD_RETURN
00002EAE                          3080              
00002EAE                          3081  OP1101_ADD_RETURN
00002EAE  4E75                    3082              RTS
00002EB0                          3083              
00002EB0                          3084           
00002EB0                          3085  *---------------------------------------------------------------------------*
00002EB0                          3086  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002EB0                          3087  *---------------------------------------------------------------------------* 
00002EB0  4280                    3088  OP1110      CLR.L   D0                  
00002EB2  4281                    3089              CLR.L   D1   
00002EB4  4284                    3090              CLR.L   D4                   
00002EB6  227C 00000000           3091              MOVEA.L #0, A1                 
00002EBC  2205                    3092              MOVE.L  D5,D1
00002EBE                          3093              
00002EBE                          3094              *1)CHECK FOR MEMORY ROTATE/SHIFT FIRST
00002EBE  2205                    3095              MOVE.L  D5,D1                   *RESET
00002EC0  0281 0000FEC0           3096              ANDI.L  #%1111111011000000,D1
00002EC6  0C81 0000E0C0           3097              CMPI.L  #%1110000011000000,D1
00002ECC  6700 0276               3098              BEQ     OP_ASX                  *ASX
00002ED0                          3099  
00002ED0                          3100              
00002ED0  0281 0000FEC0           3101              ANDI.L  #%1111111011000000,D1
00002ED6  0C81 0000E6C0           3102              CMPI.L  #%1110011011000000,D1
00002EDC  6700 0480               3103              BEQ     OP_ROX                  *ROX
00002EE0                          3104  
00002EE0  2205                    3105              MOVE.L  D5,D1                   *RESET
00002EE2  0281 0000FEC0           3106              ANDI.L  #%1111111011000000,D1
00002EE8  0C81 0000E2C0           3107              CMPI.L  #%1110001011000000,D1
00002EEE  6700 003A               3108              BEQ     OP_LSX                  *LSX
00002EF2                          3109  
00002EF2                          3110    
00002EF2                          3111              *2) CHECK FOR REGISTER SHIFTS
00002EF2  2205                    3112              MOVE.L  D5,D1                   *RESET
00002EF4  0281 0000F018           3113              ANDI.L  #%1111000000011000,D1
00002EFA  0C81 0000E008           3114              CMPI.L  #%1110000000001000,D1
00002F00  6700 0028               3115              BEQ     OP_LSX                  *LSX
00002F04                          3116  
00002F04                          3117              
00002F04  2205                    3118              MOVE.L  D5,D1                   *RESET
00002F06  0281 0000F018           3119              ANDI.L  #%1111000000011000,D1
00002F0C  0C81 0000E000           3120              CMPI.L  #%1110000000000000,D1
00002F12  6700 0230               3121              BEQ     OP_ASX                  *ASX
00002F16                          3122  
00002F16                          3123              
00002F16  2205                    3124              MOVE.L  D5,D1                   *RESET
00002F18  0281 0000F018           3125              ANDI.L  #%1111000000011000,D1
00002F1E  0C81 0000E018           3126              CMPI.L  #%1110000000011000,D1
00002F24  6700 0438               3127              BEQ     OP_ROX                  *ROX
00002F28                          3128  
00002F28                          3129  
00002F28                          3130                          
00002F28                          3131  OP1110_RETURN       
00002F28  4E75                    3132              RTS
00002F2A                          3133  
00002F2A                          3134  
00002F2A                          3135  *---------------------------------------------------------------------------*
00002F2A                          3136  * OP_LSR: decode and display LSR
00002F2A                          3137  *---------------------------------------------------------------------------*        
00002F2A                          3138  OP_LSX     
00002F2A  163C 004C               3139              MOVE.B  #'L',D3
00002F2E  6100 0FA8               3140              BSR     PUSH_STACK
00002F32  163C 0053               3141              MOVE.B  #'S',D3
00002F36  6100 0FA0               3142              BSR     PUSH_STACK
00002F3A                          3143              
00002F3A                          3144              *FIND IF ITS RIGHT OR LEFT DIR
00002F3A  2205                    3145              MOVE.L  D5,D1                   *RESET
00002F3C  0281 00000100           3146              ANDI.L  #%0000000100000000,D1
00002F42  0C81 00000000           3147              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
00002F48  6700 000E               3148              BEQ     OP_LSX_R      
00002F4C  163C 004C               3149              MOVE.B  #'L',D3
00002F50  6100 0F86               3150              BSR     PUSH_STACK
00002F54  6000 000A               3151              BRA     OP_LSX_DIR
00002F58                          3152  OP_LSX_R           
00002F58  163C 0052               3153              MOVE.B  #'R',D3
00002F5C  6100 0F7A               3154              BSR     PUSH_STACK
00002F60                          3155              
00002F60                          3156  OP_LSX_DIR
00002F60  163C 002E               3157              MOVE.B  #'.',D3
00002F64  6100 0F72               3158              BSR     PUSH_STACK
00002F68                          3159  
00002F68                          3160              *FIND SIZE OF OPCODE
00002F68  2205                    3161              MOVE.L  D5,D1                   *RESET
00002F6A  0281 000000C0           3162              ANDI.L  #%0000000011000000,D1
00002F70  0C81 00000080           3163              CMPI.L  #%0000000010000000,D1            *L
00002F76  6700 0016               3164              BEQ     OP_LSX_L
00002F7A  0C81 00000040           3165              CMPI.L  #%0000000001000000,D1            *W
00002F80  6700 0018               3166              BEQ     OP_LSX_W  
00002F84  0C81 00000000           3167              CMPI.L  #%0000000000000000,D1            *W
00002F8A  6700 001A               3168              BEQ     OP_LSX_B       
00002F8E                          3169                                      *OTHERWISE B    
00002F8E                          3170              
00002F8E                          3171  OP_LSX_L
00002F8E  163C 004C               3172              MOVE.B  #'L',D3
00002F92  6100 0F44               3173              BSR     PUSH_STACK
00002F96  6000 001A               3174              BRA     OP_LSX_CHECK_FORMAT 
00002F9A                          3175  OP_LSX_W
00002F9A  163C 0057               3176              MOVE.B  #'W',D3
00002F9E  6100 0F38               3177              BSR     PUSH_STACK
00002FA2  6000 000E               3178              BRA     OP_LSX_CHECK_FORMAT 
00002FA6                          3179  OP_LSX_B
00002FA6  163C 0042               3180              MOVE.B  #'B',D3
00002FAA  6100 0F2C               3181              BSR     PUSH_STACK
00002FAE  6000 0002               3182              BRA     OP_LSX_CHECK_FORMAT 
00002FB2                          3183                        
00002FB2                          3184  OP_LSX_CHECK_FORMAT              
00002FB2                          3185              * CHECKS IF ITS A MEMORY SHIFT FORMAT
00002FB2  2205                    3186              MOVE.L  D5,D1                   *RESET
00002FB4  0281 0000FEC0           3187              ANDI.L  #%1111111011000000,D1
00002FBA  0C81 0000E2C0           3188              CMPI.L  #%1110001011000000,D1
00002FC0  6700 0156               3189              BEQ     OP_LSX_MEMORY           
00002FC4                          3190              
00002FC4                          3191              *ELSE ITS REGISTER
00002FC4                          3192  OP_LSX_REGISTER
00002FC4                          3193             *TODO
00002FC4                          3194             *CHECK IF ITS INTERMEDIATE OR REGISTER
00002FC4  2205                    3195             MOVE.L  D5,D1                   *RESET
00002FC6  EA99                    3196             ROR.L   #5,D1 
00002FC8  0281 00000001           3197             ANDI.L  #1,D1
00002FCE  0C81 00000000           3198             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
00002FD4  6700 003E               3199             BEQ     OP_LSX_INTERMEDIATE
00002FD8                          3200             *ELSE ITS DATA REGISTER
00002FD8                          3201  
00002FD8                          3202             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002FD8  13FC 0082 00004562      3203             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002FE0  13FC 0000 00004563      3204             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002FE8                          3205             
00002FE8                          3206             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002FE8  13FC 00B9 00004565      3207             MOVE.B   #$B9,GET_DST_START_END
00002FF0  13FC 0020 00004566      3208             MOVE.B   #$20,GET_SRC_START_END
00002FF8                          3209             
00002FF8                          3210             *SETS BOTH SRC/DEST MODES TO "Dn"
00002FF8  0285 0000FE07           3211             ANDI.L   #%1111111000000111,D5
00002FFE  0685 00000000           3212             ADDI.L   #%0000000000000000,D5
00003004                          3213             
00003004                          3214              *CLEAR D3
00003004  4283                    3215              CLR.L   D3
00003006                          3216           
00003006  163C 002C               3217              MOVE.B  #',',D3
0000300A  6100 0ECC               3218              BSR     PUSH_STACK
0000300E  6100 062A               3219              BSR     GET_EA_EA_SRC
00003012                          3220              
00003012  4E75                    3221              RTS
00003014                          3222  
00003014                          3223  OP_LSX_INTERMEDIATE
00003014                          3224             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003014  13FC 0082 00004562      3225             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000301C  13FC 0000 00004563      3226             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003024                          3227             
00003024                          3228             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003024  13FC 00B9 00004565      3229             MOVE.B   #$B9,GET_DST_START_END
0000302C  13FC 0020 00004566      3230             MOVE.B   #$20,GET_SRC_START_END
00003034                          3231             
00003034                          3232             *SETS BOTH SRC/DEST MODES TO "Dn"
00003034  0285 0000FE07           3233             ANDI.L   #%1111111000000111,D5
0000303A  0685 00000000           3234             ADDI.L   #%0000000000000000,D5
00003040                          3235             
00003040                          3236              *CLEAR D3
00003040  4283                    3237              CLR.L   D3
00003042                          3238             
00003042                          3239  *-------------------------grabbing #immediate data-----------------------*
00003042                          3240  
00003042                          3241  *GET DATA FROM ADDQ AND PRINT #0-8
00003042  163C 0020               3242              MOVE.B  #' ',D3
00003046  6100 0E90               3243              BSR     PUSH_STACK
0000304A  163C 0023               3244              MOVE.B  #'#',D3
0000304E  6100 0E88               3245              BSR     PUSH_STACK 
00003052                          3246  
00003052                          3247                       
00003052                          3248              *GET DATA #   
00003052  2205                    3249              MOVE.L  D5,D1
00003054  EC99                    3250              ROR.L   #6,D1            
00003056  E699                    3251              ROR.L   #3,D1
00003058  0281 00000007           3252              ANDI.L  #$07,D1
0000305E                          3253              
0000305E  0C01 0000               3254              CMPI.B  #%000,D1
00003062  6700 003A               3255              BEQ     OP_LSX_0
00003066  0C01 0001               3256              CMPI.B  #%001,D1
0000306A  6700 003E               3257              BEQ     OP_LSX_1
0000306E  0C01 0002               3258              CMPI.B  #%010,D1
00003072  6700 0042               3259              BEQ     OP_LSX_2
00003076  0C01 0003               3260              CMPI.B  #%011,D1
0000307A  6700 0046               3261              BEQ     OP_LSX_3
0000307E  0C01 0004               3262              CMPI.B  #%100,D1
00003082  6700 004A               3263              BEQ     OP_LSX_4
00003086  0C01 0005               3264              CMPI.B  #%101,D1
0000308A  6700 004E               3265              BEQ     OP_LSX_5
0000308E  0C01 0006               3266              CMPI.B  #%110,D1
00003092  6700 0052               3267              BEQ     OP_LSX_6
00003096  0C01 0007               3268              CMPI.B  #%111,D1
0000309A  6700 0056               3269              BEQ     OP_LSX_7
0000309E                          3270              
0000309E                          3271  OP_LSX_0
0000309E  163C 0030               3272              MOVE.B  #'0',D3
000030A2  6100 0E34               3273              BSR     PUSH_STACK
000030A6  6000 005E               3274              BRA     OP_LSX_AFTER_IMMEDIATE            
000030AA                          3275  OP_LSX_1
000030AA  163C 0031               3276              MOVE.B  #'1',D3
000030AE  6100 0E28               3277              BSR     PUSH_STACK
000030B2  6000 0052               3278              BRA     OP_LSX_AFTER_IMMEDIATE            
000030B6                          3279  OP_LSX_2
000030B6  163C 0032               3280              MOVE.B  #'2',D3
000030BA  6100 0E1C               3281              BSR     PUSH_STACK
000030BE  6000 0046               3282              BRA     OP_LSX_AFTER_IMMEDIATE            
000030C2                          3283  OP_LSX_3
000030C2  163C 0033               3284              MOVE.B  #'3',D3
000030C6  6100 0E10               3285              BSR     PUSH_STACK
000030CA  6000 003A               3286              BRA     OP_LSX_AFTER_IMMEDIATE            
000030CE                          3287  OP_LSX_4
000030CE  163C 0034               3288              MOVE.B  #'4',D3
000030D2  6100 0E04               3289              BSR     PUSH_STACK
000030D6  6000 002E               3290              BRA     OP_LSX_AFTER_IMMEDIATE           
000030DA                          3291  OP_LSX_5
000030DA  163C 0035               3292              MOVE.B  #'5',D3
000030DE  6100 0DF8               3293              BSR     PUSH_STACK
000030E2  6000 0022               3294              BRA     OP_LSX_AFTER_IMMEDIATE
000030E6                          3295  OP_LSX_6
000030E6  163C 0036               3296              MOVE.B  #'6',D3
000030EA  6100 0DEC               3297              BSR     PUSH_STACK
000030EE  6000 0016               3298              BRA     OP_LSX_AFTER_IMMEDIATE
000030F2                          3299  OP_LSX_7
000030F2  163C 0037               3300              MOVE.B  #'7',D3
000030F6  6100 0DE0               3301              BSR     PUSH_STACK
000030FA  6000 000A               3302              BRA     OP_LSX_AFTER_IMMEDIATE
000030FE                          3303  
000030FE                          3304  OP_LSX_8
000030FE  163C 0038               3305              MOVE.B  #'8',D3
00003102  6100 0DD4               3306              BSR     PUSH_STACK
00003106                          3307              
00003106                          3308  OP_LSX_AFTER_IMMEDIATE            
00003106                          3309  
00003106                          3310  *-------------------------grabbing #immediate data-----------------------*
00003106                          3311  
00003106  163C 002C               3312              MOVE.B  #',',D3
0000310A  6100 0DCC               3313              BSR     PUSH_STACK
0000310E  6100 052A               3314              BSR     GET_EA_EA_SRC
00003112                          3315              
00003112  4E75                    3316              RTS
00003114                          3317  
00003114  6000 002A               3318              BRA     OP_LSX_RETURN
00003118                          3319              
00003118                          3320              
00003118                          3321  OP_LSX_MEMORY
00003118                          3322             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003118  13FC 0083 00004563      3323             MOVE.B   #$83,SRC_REGISTER_FORMAT
00003120                          3324             
00003120                          3325             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003120  13FC 00B9 00004565      3326             MOVE.B   #$B9,GET_DST_START_END
00003128  13FC 0020 00004566      3327             MOVE.B   #$20,GET_SRC_START_END
00003130                          3328             
00003130                          3329             *pop previous thing out
00003130  6100 0DAE               3330             BSR      POP_STACK
00003134                          3331             
00003134                          3332             *print w
00003134  163C 0057               3333             MOVE.B  #'W',D3
00003138  6100 0D9E               3334             BSR     PUSH_STACK
0000313C  6100 04FC               3335             BSR     GET_EA_EA_SRC
00003140                          3336  
00003140                          3337  OP_LSX_RETURN
00003140  6000 FDE6               3338              BRA     OP1110_RETURN  
00003144                          3339              
00003144                          3340  *---------------------------------------------------------------------------*
00003144                          3341  * OP_LSR: decode and display LSR IMMEDIATE/REGISTER
00003144                          3342  *---------------------------------------------------------------------------*        
00003144                          3343  OP_ASX
00003144  163C 0041               3344              MOVE.B  #'A',D3
00003148  6100 0D8E               3345              BSR     PUSH_STACK
0000314C  163C 0053               3346              MOVE.B  #'S',D3
00003150  6100 0D86               3347              BSR     PUSH_STACK
00003154                          3348              
00003154                          3349              *FIND IF ITS RIGHT OR LEFT DIR
00003154  2205                    3350              MOVE.L  D5,D1                   *RESET
00003156  0281 00000100           3351              ANDI.L  #%0000000100000000,D1
0000315C  0C81 00000000           3352              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
00003162  6700 000E               3353              BEQ     OP_ASX_R      
00003166  163C 004C               3354              MOVE.B  #'L',D3
0000316A  6100 0D6C               3355              BSR     PUSH_STACK
0000316E  6000 000A               3356              BRA     OP_ASX_DIR
00003172                          3357  OP_ASX_R           
00003172  163C 0052               3358              MOVE.B  #'R',D3
00003176  6100 0D60               3359              BSR     PUSH_STACK
0000317A                          3360              
0000317A                          3361  OP_ASX_DIR
0000317A  163C 002E               3362              MOVE.B  #'.',D3
0000317E  6100 0D58               3363              BSR     PUSH_STACK
00003182                          3364  
00003182                          3365              *FIND SIZE OF OPCODE
00003182  2205                    3366              MOVE.L  D5,D1                   *RESET
00003184  0281 000000C0           3367              ANDI.L  #%0000000011000000,D1
0000318A  0C81 00000080           3368              CMPI.L  #%0000000010000000,D1            *L
00003190  6700 0016               3369              BEQ     OP_ASX_L
00003194  0C81 00000040           3370              CMPI.L  #%0000000001000000,D1            *W
0000319A  6700 0018               3371              BEQ     OP_ASX_W  
0000319E  0C81 00000000           3372              CMPI.L  #%0000000000000000,D1            *W
000031A4  6700 001A               3373              BEQ     OP_ASX_B       
000031A8                          3374                                      *OTHERWISE B    
000031A8                          3375              
000031A8                          3376  OP_ASX_L
000031A8  163C 004C               3377              MOVE.B  #'L',D3
000031AC  6100 0D2A               3378              BSR     PUSH_STACK
000031B0  6000 001A               3379              BRA     OP_ASX_CHECK_FORMAT 
000031B4                          3380  OP_ASX_W
000031B4  163C 0057               3381              MOVE.B  #'W',D3
000031B8  6100 0D1E               3382              BSR     PUSH_STACK
000031BC  6000 000E               3383              BRA     OP_ASX_CHECK_FORMAT 
000031C0                          3384  OP_ASX_B
000031C0  163C 0042               3385              MOVE.B  #'B',D3
000031C4  6100 0D12               3386              BSR     PUSH_STACK
000031C8  6000 0002               3387              BRA     OP_ASX_CHECK_FORMAT 
000031CC                          3388                        
000031CC                          3389  OP_ASX_CHECK_FORMAT              
000031CC                          3390              * CHECKS IF ITS A MEMORY SHIFT FORMAT
000031CC  2205                    3391              MOVE.L  D5,D1                   *RESET
000031CE  0281 0000FEC0           3392              ANDI.L  #%1111111011000000,D1
000031D4  0C81 0000E0C0           3393              CMPI.L  #%1110000011000000,D1
000031DA  6700 0156               3394              BEQ     OP_ASX_MEMORY           
000031DE                          3395              
000031DE                          3396              *ELSE ITS REGISTER
000031DE                          3397  OP_ASX_REGISTER
000031DE                          3398             *TODO
000031DE                          3399             *CHECK IF ITS INTERMEDIATE OR REGISTER
000031DE  2205                    3400             MOVE.L  D5,D1                   *RESET
000031E0  EA99                    3401             ROR.L   #5,D1 
000031E2  0281 00000001           3402             ANDI.L  #1,D1
000031E8  0C81 00000000           3403             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
000031EE  6700 003E               3404             BEQ     OP_ASX_INTERMEDIATE
000031F2                          3405             *ELSE ITS DATA REGISTER
000031F2                          3406  
000031F2                          3407             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000031F2  13FC 0082 00004562      3408             MOVE.B   #$82,DEST_REGISTER_FORMAT
000031FA  13FC 0000 00004563      3409             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003202                          3410             
00003202                          3411             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003202  13FC 00B9 00004565      3412             MOVE.B   #$B9,GET_DST_START_END
0000320A  13FC 0020 00004566      3413             MOVE.B   #$20,GET_SRC_START_END
00003212                          3414             
00003212                          3415             *SETS BOTH SRC/DEST MODES TO "Dn"
00003212  0285 0000FE07           3416             ANDI.L   #%1111111000000111,D5
00003218  0685 00000000           3417             ADDI.L   #%0000000000000000,D5
0000321E                          3418             
0000321E                          3419              *CLEAR D3
0000321E  4283                    3420              CLR.L   D3
00003220                          3421           
00003220  163C 002C               3422              MOVE.B  #',',D3
00003224  6100 0CB2               3423              BSR     PUSH_STACK
00003228  6100 0410               3424              BSR     GET_EA_EA_SRC
0000322C                          3425              
0000322C  4E75                    3426              RTS
0000322E                          3427  
0000322E                          3428  OP_ASX_INTERMEDIATE
0000322E                          3429             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000322E  13FC 0082 00004562      3430             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003236  13FC 0000 00004563      3431             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000323E                          3432             
0000323E                          3433             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000323E  13FC 00B9 00004565      3434             MOVE.B   #$B9,GET_DST_START_END
00003246  13FC 0020 00004566      3435             MOVE.B   #$20,GET_SRC_START_END
0000324E                          3436             
0000324E                          3437             *SETS BOTH SRC/DEST MODES TO "Dn"
0000324E  0285 0000FE07           3438             ANDI.L   #%1111111000000111,D5
00003254  0685 00000000           3439             ADDI.L   #%0000000000000000,D5
0000325A                          3440             
0000325A                          3441              *CLEAR D3
0000325A  4283                    3442              CLR.L   D3
0000325C                          3443             
0000325C                          3444  *-------------------------grabbing #immediate data-----------------------*
0000325C                          3445  
0000325C                          3446  *GET DATA FROM ADDQ AND PRINT #0-8
0000325C  163C 0020               3447              MOVE.B  #' ',D3
00003260  6100 0C76               3448              BSR     PUSH_STACK
00003264  163C 0023               3449              MOVE.B  #'#',D3
00003268  6100 0C6E               3450              BSR     PUSH_STACK 
0000326C                          3451  
0000326C                          3452                       
0000326C                          3453              *GET DATA #   
0000326C  2205                    3454              MOVE.L  D5,D1
0000326E  EC99                    3455              ROR.L   #6,D1            
00003270  E699                    3456              ROR.L   #3,D1
00003272  0281 00000007           3457              ANDI.L  #$07,D1
00003278                          3458              
00003278  0C01 0000               3459              CMPI.B  #%000,D1
0000327C  6700 003A               3460              BEQ     OP_ASX_0
00003280  0C01 0001               3461              CMPI.B  #%001,D1
00003284  6700 003E               3462              BEQ     OP_ASX_1
00003288  0C01 0002               3463              CMPI.B  #%010,D1
0000328C  6700 0042               3464              BEQ     OP_ASX_2
00003290  0C01 0003               3465              CMPI.B  #%011,D1
00003294  6700 0046               3466              BEQ     OP_ASX_3
00003298  0C01 0004               3467              CMPI.B  #%100,D1
0000329C  6700 004A               3468              BEQ     OP_ASX_4
000032A0  0C01 0005               3469              CMPI.B  #%101,D1
000032A4  6700 004E               3470              BEQ     OP_ASX_5
000032A8  0C01 0006               3471              CMPI.B  #%110,D1
000032AC  6700 0052               3472              BEQ     OP_ASX_6
000032B0  0C01 0007               3473              CMPI.B  #%111,D1
000032B4  6700 0056               3474              BEQ     OP_ASX_7
000032B8                          3475              
000032B8                          3476  OP_ASX_0
000032B8  163C 0030               3477              MOVE.B  #'0',D3
000032BC  6100 0C1A               3478              BSR     PUSH_STACK
000032C0  6000 005E               3479              BRA     OP_ASX_AFTER_IMMEDIATE            
000032C4                          3480  OP_ASX_1
000032C4  163C 0031               3481              MOVE.B  #'1',D3
000032C8  6100 0C0E               3482              BSR     PUSH_STACK
000032CC  6000 0052               3483              BRA     OP_ASX_AFTER_IMMEDIATE            
000032D0                          3484  OP_ASX_2
000032D0  163C 0032               3485              MOVE.B  #'2',D3
000032D4  6100 0C02               3486              BSR     PUSH_STACK
000032D8  6000 0046               3487              BRA     OP_ASX_AFTER_IMMEDIATE            
000032DC                          3488  OP_ASX_3
000032DC  163C 0033               3489              MOVE.B  #'3',D3
000032E0  6100 0BF6               3490              BSR     PUSH_STACK
000032E4  6000 003A               3491              BRA     OP_ASX_AFTER_IMMEDIATE            
000032E8                          3492  OP_ASX_4
000032E8  163C 0034               3493              MOVE.B  #'4',D3
000032EC  6100 0BEA               3494              BSR     PUSH_STACK
000032F0  6000 002E               3495              BRA     OP_ASX_AFTER_IMMEDIATE           
000032F4                          3496  OP_ASX_5
000032F4  163C 0035               3497              MOVE.B  #'5',D3
000032F8  6100 0BDE               3498              BSR     PUSH_STACK
000032FC  6000 0022               3499              BRA     OP_ASX_AFTER_IMMEDIATE
00003300                          3500  OP_ASX_6
00003300  163C 0036               3501              MOVE.B  #'6',D3
00003304  6100 0BD2               3502              BSR     PUSH_STACK
00003308  6000 0016               3503              BRA     OP_ASX_AFTER_IMMEDIATE
0000330C                          3504  OP_ASX_7
0000330C  163C 0037               3505              MOVE.B  #'7',D3
00003310  6100 0BC6               3506              BSR     PUSH_STACK
00003314  6000 000A               3507              BRA     OP_ASX_AFTER_IMMEDIATE
00003318                          3508  
00003318                          3509  OP_ASX_8
00003318  163C 0038               3510              MOVE.B  #'8',D3
0000331C  6100 0BBA               3511              BSR     PUSH_STACK
00003320                          3512              
00003320                          3513  OP_ASX_AFTER_IMMEDIATE            
00003320                          3514  
00003320                          3515  *-------------------------grabbing #immediate data-----------------------*
00003320                          3516  
00003320  163C 002C               3517              MOVE.B  #',',D3
00003324  6100 0BB2               3518              BSR     PUSH_STACK
00003328  6100 0310               3519              BSR     GET_EA_EA_SRC
0000332C                          3520              
0000332C  4E75                    3521              RTS
0000332E                          3522  
0000332E  6000 002A               3523              BRA     OP_ASX_RETURN
00003332                          3524              
00003332                          3525              
00003332                          3526  OP_ASX_MEMORY
00003332                          3527             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003332  13FC 0083 00004563      3528             MOVE.B   #$83,SRC_REGISTER_FORMAT
0000333A                          3529             
0000333A                          3530             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000333A  13FC 00B9 00004565      3531             MOVE.B   #$B9,GET_DST_START_END
00003342  13FC 0020 00004566      3532             MOVE.B   #$20,GET_SRC_START_END
0000334A                          3533             
0000334A                          3534             *pop previous thing out
0000334A  6100 0B94               3535             BSR      POP_STACK
0000334E                          3536             
0000334E                          3537             *print w
0000334E  163C 0057               3538             MOVE.B  #'W',D3
00003352  6100 0B84               3539             BSR     PUSH_STACK
00003356  6100 02E2               3540             BSR     GET_EA_EA_SRC
0000335A                          3541  
0000335A                          3542  OP_ASX_RETURN
0000335A  6000 FBCC               3543              BRA     OP1110_RETURN 
0000335E                          3544      
0000335E                          3545  *---------------------------------------------------------------------------*
0000335E                          3546  * OP_ROX: decode and display LSR IMMEDIATE/REGISTER
0000335E                          3547  *---------------------------------------------------------------------------*        
0000335E                          3548  OP_ROX
0000335E                          3549  
0000335E  163C 0052               3550              MOVE.B  #'R',D3
00003362  6100 0B74               3551              BSR     PUSH_STACK
00003366  163C 004F               3552              MOVE.B  #'O',D3
0000336A  6100 0B6C               3553              BSR     PUSH_STACK
0000336E                          3554              
0000336E                          3555              *FIND IF ITS RIGHT OR LEFT DIR
0000336E  2205                    3556              MOVE.L  D5,D1                   *RESET
00003370  0281 00000100           3557              ANDI.L  #%0000000100000000,D1
00003376  0C81 00000000           3558              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
0000337C  6700 000E               3559              BEQ     OP_ROX_R      
00003380  163C 004C               3560              MOVE.B  #'L',D3
00003384  6100 0B52               3561              BSR     PUSH_STACK
00003388  6000 000A               3562              BRA     OP_ROX_DIR
0000338C                          3563  OP_ROX_R           
0000338C  163C 0052               3564              MOVE.B  #'R',D3
00003390  6100 0B46               3565              BSR     PUSH_STACK
00003394                          3566              
00003394                          3567  OP_ROX_DIR
00003394  163C 002E               3568              MOVE.B  #'.',D3
00003398  6100 0B3E               3569              BSR     PUSH_STACK
0000339C                          3570  
0000339C                          3571              *FIND SIZE OF OPCODE
0000339C  2205                    3572              MOVE.L  D5,D1                   *RESET
0000339E  0281 000000C0           3573              ANDI.L  #%0000000011000000,D1
000033A4  0C81 00000080           3574              CMPI.L  #%0000000010000000,D1            *L
000033AA  6700 0016               3575              BEQ     OP_ROX_L
000033AE  0C81 00000040           3576              CMPI.L  #%0000000001000000,D1            *W
000033B4  6700 0018               3577              BEQ     OP_ROX_W  
000033B8  0C81 00000000           3578              CMPI.L  #%0000000000000000,D1            *W
000033BE  6700 001A               3579              BEQ     OP_ROX_B       
000033C2                          3580                                      *OTHERWISE B    
000033C2                          3581              
000033C2                          3582  OP_ROX_L
000033C2  163C 004C               3583              MOVE.B  #'L',D3
000033C6  6100 0B10               3584              BSR     PUSH_STACK
000033CA  6000 001A               3585              BRA     OP_ROX_CHECK_FORMAT 
000033CE                          3586  OP_ROX_W
000033CE  163C 0057               3587              MOVE.B  #'W',D3
000033D2  6100 0B04               3588              BSR     PUSH_STACK
000033D6  6000 000E               3589              BRA     OP_ROX_CHECK_FORMAT 
000033DA                          3590  OP_ROX_B
000033DA  163C 0042               3591              MOVE.B  #'B',D3
000033DE  6100 0AF8               3592              BSR     PUSH_STACK
000033E2  6000 0002               3593              BRA     OP_ROX_CHECK_FORMAT 
000033E6                          3594                        
000033E6                          3595  OP_ROX_CHECK_FORMAT              
000033E6                          3596              * CHECKS IF ITS A MEMORY SHIFT FORMAT
000033E6  2205                    3597              MOVE.L  D5,D1                   *RESET
000033E8  0281 0000FEC0           3598              ANDI.L  #%1111111011000000,D1
000033EE  0C81 0000E6C0           3599              CMPI.L  #%1110011011000000,D1
000033F4  6700 0156               3600              BEQ     OP_ROX_MEMORY           
000033F8                          3601              
000033F8                          3602              *ELSE ITS REGISTER
000033F8                          3603  OP_ROX_REGISTER
000033F8                          3604             *TODO
000033F8                          3605             *CHECK IF ITS INTERMEDIATE OR REGISTER
000033F8  2205                    3606             MOVE.L  D5,D1                   *RESET
000033FA  EA99                    3607             ROR.L   #5,D1 
000033FC  0281 00000001           3608             ANDI.L  #1,D1
00003402  0C81 00000000           3609             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
00003408  6700 003E               3610             BEQ     OP_ROX_INTERMEDIATE
0000340C                          3611             *ELSE ITS DATA REGISTER
0000340C                          3612  
0000340C                          3613             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000340C  13FC 0082 00004562      3614             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003414  13FC 0000 00004563      3615             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000341C                          3616             
0000341C                          3617             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000341C  13FC 00B9 00004565      3618             MOVE.B   #$B9,GET_DST_START_END
00003424  13FC 0020 00004566      3619             MOVE.B   #$20,GET_SRC_START_END
0000342C                          3620             
0000342C                          3621             *SETS BOTH SRC/DEST MODES TO "Dn"
0000342C  0285 0000FE07           3622             ANDI.L   #%1111111000000111,D5
00003432  0685 00000000           3623             ADDI.L   #%0000000000000000,D5
00003438                          3624             
00003438                          3625              *CLEAR D3
00003438  4283                    3626              CLR.L   D3
0000343A                          3627           
0000343A  163C 002C               3628              MOVE.B  #',',D3
0000343E  6100 0A98               3629              BSR     PUSH_STACK
00003442  6100 01F6               3630              BSR     GET_EA_EA_SRC
00003446                          3631              
00003446  4E75                    3632              RTS
00003448                          3633  
00003448                          3634  OP_ROX_INTERMEDIATE
00003448                          3635             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003448  13FC 0082 00004562      3636             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003450  13FC 0000 00004563      3637             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003458                          3638             
00003458                          3639             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003458  13FC 00B9 00004565      3640             MOVE.B   #$B9,GET_DST_START_END
00003460  13FC 0020 00004566      3641             MOVE.B   #$20,GET_SRC_START_END
00003468                          3642             
00003468                          3643             *SETS BOTH SRC/DEST MODES TO "Dn"
00003468  0285 0000FE07           3644             ANDI.L   #%1111111000000111,D5
0000346E  0685 00000000           3645             ADDI.L   #%0000000000000000,D5
00003474                          3646             
00003474                          3647              *CLEAR D3
00003474  4283                    3648              CLR.L   D3
00003476                          3649             
00003476                          3650  *-------------------------grabbing #immediate data-----------------------*
00003476                          3651  
00003476                          3652  *GET DATA FROM ADDQ AND PRINT #0-8
00003476  163C 0020               3653              MOVE.B  #' ',D3
0000347A  6100 0A5C               3654              BSR     PUSH_STACK
0000347E  163C 0023               3655              MOVE.B  #'#',D3
00003482  6100 0A54               3656              BSR     PUSH_STACK 
00003486                          3657  
00003486                          3658                       
00003486                          3659              *GET DATA #   
00003486  2205                    3660              MOVE.L  D5,D1
00003488  EC99                    3661              ROR.L   #6,D1            
0000348A  E699                    3662              ROR.L   #3,D1
0000348C  0281 00000007           3663              ANDI.L  #$07,D1
00003492                          3664              
00003492  0C01 0000               3665              CMPI.B  #%000,D1
00003496  6700 003A               3666              BEQ     OP_ROX_0
0000349A  0C01 0001               3667              CMPI.B  #%001,D1
0000349E  6700 003E               3668              BEQ     OP_ROX_1
000034A2  0C01 0002               3669              CMPI.B  #%010,D1
000034A6  6700 0042               3670              BEQ     OP_ROX_2
000034AA  0C01 0003               3671              CMPI.B  #%011,D1
000034AE  6700 0046               3672              BEQ     OP_ROX_3
000034B2  0C01 0004               3673              CMPI.B  #%100,D1
000034B6  6700 004A               3674              BEQ     OP_ROX_4
000034BA  0C01 0005               3675              CMPI.B  #%101,D1
000034BE  6700 004E               3676              BEQ     OP_ROX_5
000034C2  0C01 0006               3677              CMPI.B  #%110,D1
000034C6  6700 0052               3678              BEQ     OP_ROX_6
000034CA  0C01 0007               3679              CMPI.B  #%111,D1
000034CE  6700 0056               3680              BEQ     OP_ROX_7
000034D2                          3681              
000034D2                          3682  OP_ROX_0
000034D2  163C 0030               3683              MOVE.B  #'0',D3
000034D6  6100 0A00               3684              BSR     PUSH_STACK
000034DA  6000 005E               3685              BRA     OP_ROX_AFTER_IMMEDIATE            
000034DE                          3686  OP_ROX_1
000034DE  163C 0031               3687              MOVE.B  #'1',D3
000034E2  6100 09F4               3688              BSR     PUSH_STACK
000034E6  6000 0052               3689              BRA     OP_ROX_AFTER_IMMEDIATE            
000034EA                          3690  OP_ROX_2
000034EA  163C 0032               3691              MOVE.B  #'2',D3
000034EE  6100 09E8               3692              BSR     PUSH_STACK
000034F2  6000 0046               3693              BRA     OP_ROX_AFTER_IMMEDIATE            
000034F6                          3694  OP_ROX_3
000034F6  163C 0033               3695              MOVE.B  #'3',D3
000034FA  6100 09DC               3696              BSR     PUSH_STACK
000034FE  6000 003A               3697              BRA     OP_ROX_AFTER_IMMEDIATE            
00003502                          3698  OP_ROX_4
00003502  163C 0034               3699              MOVE.B  #'4',D3
00003506  6100 09D0               3700              BSR     PUSH_STACK
0000350A  6000 002E               3701              BRA     OP_ROX_AFTER_IMMEDIATE           
0000350E                          3702  OP_ROX_5
0000350E  163C 0035               3703              MOVE.B  #'5',D3
00003512  6100 09C4               3704              BSR     PUSH_STACK
00003516  6000 0022               3705              BRA     OP_ROX_AFTER_IMMEDIATE
0000351A                          3706  OP_ROX_6
0000351A  163C 0036               3707              MOVE.B  #'6',D3
0000351E  6100 09B8               3708              BSR     PUSH_STACK
00003522  6000 0016               3709              BRA     OP_ROX_AFTER_IMMEDIATE
00003526                          3710  OP_ROX_7
00003526  163C 0037               3711              MOVE.B  #'7',D3
0000352A  6100 09AC               3712              BSR     PUSH_STACK
0000352E  6000 000A               3713              BRA     OP_ROX_AFTER_IMMEDIATE
00003532                          3714  
00003532                          3715  OP_ROX_8
00003532  163C 0038               3716              MOVE.B  #'8',D3
00003536  6100 09A0               3717              BSR     PUSH_STACK
0000353A                          3718              
0000353A                          3719  OP_ROX_AFTER_IMMEDIATE            
0000353A                          3720  
0000353A                          3721  *-------------------------grabbing #immediate data-----------------------*
0000353A                          3722  
0000353A  163C 002C               3723              MOVE.B  #',',D3
0000353E  6100 0998               3724              BSR     PUSH_STACK
00003542  6100 00F6               3725              BSR     GET_EA_EA_SRC
00003546                          3726              
00003546  4E75                    3727              RTS
00003548                          3728  
00003548  6000 0022               3729              BRA     OP_ROX_RETURN
0000354C                          3730              
0000354C                          3731              
0000354C                          3732  OP_ROX_MEMORY
0000354C                          3733             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000354C  13FC 0083 00004563      3734             MOVE.B   #$83,SRC_REGISTER_FORMAT
00003554                          3735             
00003554                          3736             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003554  13FC 0020 00004566      3737             MOVE.B   #$20,GET_SRC_START_END
0000355C                          3738             
0000355C                          3739             *pop previous thing out
0000355C  6100 0982               3740             BSR      POP_STACK
00003560                          3741             
00003560                          3742             *print w
00003560  163C 0057               3743             MOVE.B  #'W',D3
00003564  6100 0972               3744             BSR     PUSH_STACK
00003568  6100 00D0               3745             BSR     GET_EA_EA_SRC
0000356C                          3746  
0000356C                          3747  OP_ROX_RETURN
0000356C  6000 F9BA               3748              BRA     OP1110_RETURN 
00003570                          3749  
00003570                          3750  
00003570                          3751  
00003570                          3752  
00003570                          3753  
00003570                          3754  
00003570                          3755  
00003570                          3756  
00003570                          3757  
00003570                          3758  
00003570                          3759  
00003570                          3760  
00003570                          3761  
00003570                          3762  
00003570                          3763  
00003570                          3764  
00003570                          3765  
00003570                          3766  
00003570                          3767  
00003570                          3768  
00003570                          3769  
00003570                          3770  
00003570                          3771  
00003570                          3772  
00003570                          3773              
00003570                          3774  *---------------------------------------------------------------------------*
00003570                          3775  * OP1111 : Special reserved
00003570                          3776  *---------------------------------------------------------------------------*           
00003570  4EF8 1740               3777  OP1111      JMP     OP_DATA
00003574                          3778  
00003574                          3779  
00003574                          3780             
00003574                          3781  *---------------------------------------------------------------------------*
00003574                          3782  * D_MODE111: decode and display dest mode absolute/immediate
00003574                          3783  *---------------------------------------------------------------------------*           
00003574                          3784  D_MODE111   * abs
00003574                          3785              * clear registers to store temp data
00003574  4280                    3786              CLR.L   D0                      
00003576  4281                    3787              CLR.L   D1                      
00003578  207C 00000000           3788              MOVEA.L #0, A0                  
0000357E  227C 00000000           3789              MOVEA.L #0, A1                  
00003584  2205                    3790              MOVE.L  D5,D1
00003586                          3791              
00003586                          3792              * retrieve dest register for MODE 111
00003586  EC89                    3793              LSR.L   #6,D1   * shift the bits to right by 6
00003588  E689                    3794              LSR.L   #3,D1   * shift the bits to right by extra 3
0000358A  0201 0001               3795              ANDI.B  #1,D1   * mask the first 2 bits 
0000358E  0C01 0000               3796              CMPI.B  #0, D1  * if it's 000, absolute word address
00003592  6700 000C               3797              BEQ     WORDMODE
00003596  0C01 0001               3798              CMPI.B  #1, D1  * if it's 001, absolute long address
0000359A  6700 0030               3799              BEQ     LONGMODE
0000359E                          3800              *JSR     OP_DATA *not sure..
0000359E  4E75                    3801              RTS
000035A0                          3802  
000035A0                          3803  
000035A0                          3804  *---------------------------------------------------------------------------*
000035A0                          3805  * WORDMODE: absolute word address
000035A0                          3806  *---------------------------------------------------------------------------*
000035A0  43F9 00004559           3807  WORDMODE    LEA     DISP_HEX,A1
000035A6  103C 000E               3808              MOVE.B  #14,D0
000035AA  4E4F                    3809              TRAP    #15
000035AC                          3810              
000035AC  4285                    3811              CLR.L   D5
000035AE  3A1D                    3812              MOVE.W  (A5)+,D5
000035B0                          3813              
000035B0  43F9 00004501           3814              LEA     TMPOUTPUT,A1
000035B6  2205                    3815              MOVE.L  D5,D1
000035B8  7404                    3816              MOVE.L  #4,D2       *move word size 4
000035BA  4EB8 120C               3817              JSR     HEX2ASCII
000035BE  43F9 00004501           3818              LEA     TMPOUTPUT,A1
000035C4  103C 000E               3819              MOVE.B  #14,D0
000035C8  4E4F                    3820              TRAP    #15
000035CA                          3821              
000035CA  4E75                    3822              RTS
000035CC                          3823  
000035CC                          3824  *---------------------------------------------------------------------------*
000035CC                          3825  * LONGMODE: absolute long address
000035CC                          3826  *---------------------------------------------------------------------------*
000035CC  43F9 00004559           3827  LONGMODE    LEA     DISP_HEX,A1
000035D2  103C 000E               3828              MOVE.B  #14,D0
000035D6  4E4F                    3829              TRAP    #15
000035D8                          3830              
000035D8  4285                    3831              CLR.L   D5
000035DA  2A1D                    3832              MOVE.L  (A5)+,D5
000035DC                          3833              
000035DC  43F9 00004501           3834              LEA     TMPOUTPUT,A1
000035E2  2205                    3835              MOVE.L  D5,D1
000035E4  7408                    3836              MOVE.L  #8,D2           *move longword size 8
000035E6  4EB8 120C               3837              JSR     HEX2ASCII
000035EA  43F9 00004501           3838              LEA     TMPOUTPUT,A1
000035F0  103C 000E               3839              MOVE.B  #14,D0
000035F4  4E4F                    3840              TRAP    #15
000035F6                          3841              
000035F6  4E75                    3842              RTS
000035F8                          3843  
000035F8                          3844              
000035F8                          3845  *---------------------------------------------------------------------------*
000035F8                          3846  * REPEAT : Ask user whether they wish to run the program again
000035F8                          3847  *---------------------------------------------------------------------------*           
000035F8  4246                    3848  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
000035FA  43F9 00004327           3849              LEA     REPEATMSG,A1
00003600  103C 000E               3850              MOVE.B  #14,D0
00003604  4E4F                    3851              TRAP    #15
00003606                          3852              
00003606  43F9 000044B1           3853              LEA     TMPINPUT,A1             * allocate space to temp store user input
0000360C  103C 0002               3854              MOVE.B  #2,D0
00003610  4E4F                    3855              TRAP    #15
00003612                          3856  
00003612  0C01 0001               3857              CMPI.B  #1,D1                   * check for length of user input
00003616  66E0                    3858              BNE     REPEAT                  * return to the beginning of the function if unequal
00003618                          3859              
00003618  0C11 0059               3860              CMPI.B  #$59,(A1)               * compare the input with Y    
0000361C  6700 D9EC               3861              BEQ     PROGLP                  * repeat the program
00003620                          3862              
00003620  0C11 0079               3863              CMPI.B  #$79,(A1)               * compare the input with y    
00003624  6700 D9E4               3864              BEQ     PROGLP                  * repeat the program
00003628                          3865              
00003628  0C11 004E               3866              CMPI.B  #$4E,(A1)               * compare the input with N    
0000362C  6700 098C               3867              BEQ     TERMINATE               * finish program
00003630                          3868              
00003630  0C11 006E               3869              CMPI.B  #$6E,(A1)               * compare the input with n    
00003634  6700 0984               3870              BEQ     TERMINATE               * finish program
00003638                          3871              
00003638  60BE                    3872              BRA     REPEAT                  * invalid input/repeat the function
0000363A                          3873  
0000363A                          3874  *---------------------------------------------------------------------------*
0000363A                          3875  * EA DECODING INTERFACE
0000363A                          3876  * [A0] - RESERVED FOR USE
0000363A                          3877  * [D2] - RESERVED FOR USE
0000363A                          3878  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
0000363A                          3879  *---------------------------------------------------------------------------*
0000363A                          3880  GET_EA_EA_SRC
0000363A                          3881      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
0000363A                          3882      
0000363A                          3883      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
0000363A  2405                    3884      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000363C  E68A                    3885      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
0000363E  23C2 00004574           3886      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003644  7407                    3887      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003646  C5B9 00004574           3888      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000364C                          3889                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000364C                          3890      
0000364C                          3891      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000364C                          3892      *DESTINATION REGISTER FORMAT STANDARD         *
0000364C                          3893      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000364C                          3894      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000364C                          3895      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000364C                          3896      *0 - Dn                                       *
0000364C                          3897      *1 - An                                       *
0000364C                          3898      *2 - (An)                                     *
0000364C                          3899      *3 - (An)+                                    *
0000364C                          3900      *4 - -(An)                                    *
0000364C                          3901      *5 - (XXX).W                                  *
0000364C                          3902      *6 - (XXX).L                                  *
0000364C                          3903      *7 - #<data>                                  *
0000364C                          3904      ***********************************************
0000364C                          3905      
0000364C                          3906      *** Check if source ...  <ea> = Dn
0000364C                          3907  CHECK0    
0000364C  41F9 00004564           3908            LEA     TEMP_REGISTER_FORMAT,A0
00003652  1439 00004563           3909            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003658  1082                    3910            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000365A  0239 0001 00004564      3911            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003662  0C39 0001 00004564      3912            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
0000366A  6700 006A               3913            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000366E  0CB9 00000000 00004574  3914            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003678  6600 005C               3915            BNE     CHECK1
0000367C                          3916            
0000367C                          3917            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000367C  163C 0020               3918            MOVE.B    #' ',D3
00003680  6100 0856               3919            BSR       PUSH_STACK
00003684  163C 0044               3920            MOVE.B    #'D',D3
00003688  6100 084E               3921            BSR       PUSH_STACK
0000368C                          3922  
0000368C                          3923            *FIND REGISTER NUMBER END LOCATION*  
0000368C  13F9 00004566 0000456C  3924            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003696  0239 000F 0000456C      3925            AND.B   #$0F,VAR_BYTE_END
0000369E                          3926            
0000369E                          3927            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000369E  23C5 00004570           3928            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000036A4  1439 0000456C           3929            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000036AA                          3930            
000036AA                          3931            *INTITIALIZE FOR BIT SHIFTING
000036AA  41F9 00004570           3932            LEA     VAR_TEMP_CLEANCOPY,A0
000036B0  2639 00004570           3933            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000036B6                          3934  LOOP_SHIFTING
000036B6  0C02 0000               3935            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000036BA  6700 0008               3936            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000036BE  E24B                    3937            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000036C0  5302                    3938            SUB.B   #1,D2                     *DECREMENT COUNTER
000036C2  60F2                    3939            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000036C4                          3940  MASKING_NEXT
000036C4  C6BC 00000007           3941            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000036CA  0603 0030               3942            ADD.B   #$30,D3                   *CONVERT TO CHAR
000036CE  6100 0808               3943            BSR     PUSH_STACK                *PUSH TO STACK
000036D2                          3944            
000036D2  6000 0394               3945            BRA     GET_SRC_SUCCESS           *RETURN          
000036D6                          3946            
000036D6                          3947            
000036D6                          3948            *** Check if source ...  <ea> = An
000036D6  41F9 00004564           3949  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000036DC  1439 00004563           3950            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036E2  1082                    3951            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036E4  0239 0002 00004564      3952            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000036EC  0C39 0002 00004564      3953            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000036F4  6700 006A               3954            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000036F8  0CB9 00000001 00004574  3955            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003702  6600 005C               3956            BNE     CHECK2
00003706                          3957            
00003706                          3958            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003706  163C 0020               3959            MOVE.B    #' ',D3
0000370A  6100 07CC               3960            BSR       PUSH_STACK
0000370E  163C 0041               3961            MOVE.B    #'A',D3
00003712  6100 07C4               3962            BSR       PUSH_STACK
00003716                          3963  
00003716                          3964            
00003716                          3965            *FIND REGISTER NUMBER END LOCATION*  
00003716  13F9 00004566 0000456C  3966            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003720  0239 000F 0000456C      3967            AND.B   #$0F,VAR_BYTE_END
00003728                          3968            
00003728                          3969            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003728  23C5 00004570           3970            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000372E  1439 0000456C           3971            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003734                          3972            
00003734                          3973            *INTITIALIZE FOR BIT SHIFTING
00003734  41F9 00004570           3974            LEA     VAR_TEMP_CLEANCOPY,A0
0000373A  2639 00004570           3975            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003740                          3976  LOOP_SHIFTING1
00003740  0C02 0000               3977            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003744  6700 0008               3978            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003748  E24B                    3979            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000374A  5302                    3980            SUB.B   #1,D2                     *DECREMENT COUNTER
0000374C  60F2                    3981            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
0000374E                          3982  MASKING_NEXT1
0000374E  C6BC 00000007           3983            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003754  0603 0030               3984            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003758  6100 077E               3985            BSR     PUSH_STACK                *PUSH TO STACK
0000375C                          3986            
0000375C  6000 030A               3987            BRA     GET_SRC_SUCCESS                   *RETURN 
00003760                          3988            
00003760                          3989            
00003760                          3990            
00003760                          3991            
00003760                          3992            *** Check if source ...  <ea> = (An)       
00003760  41F9 00004564           3993  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003766  1439 00004563           3994            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000376C  1082                    3995            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000376E  0239 0004 00004564      3996            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003776  0C39 0004 00004564      3997            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
0000377E  6700 007A               3998            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003782  0CB9 00000002 00004574  3999            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000378C  6600 006C               4000            BNE     CHECK3
00003790                          4001            
00003790                          4002            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003790  163C 0020               4003            MOVE.B    #' ',D3
00003794  6100 0742               4004            BSR       PUSH_STACK
00003798  163C 0028               4005            MOVE.B    #'(',D3
0000379C  6100 073A               4006            BSR       PUSH_STACK
000037A0  163C 0041               4007            MOVE.B    #'A',D3
000037A4  6100 0732               4008            BSR       PUSH_STACK
000037A8                          4009  
000037A8                          4010            
000037A8                          4011            *FIND REGISTER NUMBER END LOCATION*  
000037A8  13F9 00004566 0000456C  4012            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000037B2  0239 000F 0000456C      4013            AND.B   #$0F,VAR_BYTE_END
000037BA                          4014            
000037BA                          4015            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037BA  23C5 00004570           4016            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037C0  1439 0000456C           4017            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000037C6                          4018            
000037C6                          4019            *INTITIALIZE FOR BIT SHIFTING
000037C6  41F9 00004570           4020            LEA     VAR_TEMP_CLEANCOPY,A0
000037CC  2639 00004570           4021            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037D2                          4022  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000037D2  0C02 0000               4023            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037D6  6700 0008               4024            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000037DA  E24B                    4025            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037DC  5302                    4026            SUB.B   #1,D2                     *DECREMENT COUNTER
000037DE  60F2                    4027            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000037E0                          4028  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000037E0  0283 00000007           4029            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037E6  0603 0030               4030            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000037EA  6100 06EC               4031            BSR     PUSH_STACK                *PUSH TO STACK
000037EE                          4032            
000037EE  163C 0029               4033            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000037F2  6100 06E4               4034            BSR       PUSH_STACK
000037F6                          4035            
000037F6  6000 0270               4036            BRA     GET_SRC_SUCCESS                   *RETURN 
000037FA                          4037  
000037FA                          4038            
000037FA                          4039            
000037FA                          4040                      
000037FA                          4041  *** Check if source ...  <ea> = (An)+       
000037FA  41F9 00004564           4042  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003800  1439 00004563           4043            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003806  1082                    4044            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003808  0239 0008 00004564      4045            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003810  0C39 0008 00004564      4046            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003818  6700 0082               4047            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000381C  0CB9 00000003 00004574  4048            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003826  6600 0074               4049            BNE     CHECK4
0000382A                          4050            
0000382A                          4051            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000382A  163C 0020               4052            MOVE.B    #' ',D3
0000382E  6100 06A8               4053            BSR       PUSH_STACK
00003832  163C 0028               4054            MOVE.B    #'(',D3
00003836  6100 06A0               4055            BSR       PUSH_STACK
0000383A  163C 0041               4056            MOVE.B    #'A',D3
0000383E  6100 0698               4057            BSR       PUSH_STACK
00003842                          4058  
00003842                          4059            
00003842                          4060            *FIND REGISTER NUMBER END LOCATION*  
00003842  13F9 00004566 0000456C  4061            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000384C  0239 000F 0000456C      4062            ANDI.B   #$0F,VAR_BYTE_END
00003854                          4063            
00003854                          4064            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003854  23C5 00004570           4065            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000385A  1439 0000456C           4066            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003860                          4067            
00003860                          4068            *INTITIALIZE FOR BIT SHIFTING
00003860  41F9 00004570           4069            LEA     VAR_TEMP_CLEANCOPY,A0
00003866  2639 00004570           4070            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000386C                          4071            
0000386C                          4072  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000386C  0C02 0000               4073            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003870  6700 0008               4074            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003874  E24B                    4075            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003876  5302                    4076            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003878  60F2                    4077            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
0000387A                          4078                                               *change: NAME OF LABEL*
0000387A                          4079  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
0000387A  0283 00000007           4080            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003880  0603 0030               4081            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003884  6100 0652               4082            BSR     PUSH_STACK                *PUSH TO STACK
00003888                          4083            
00003888  163C 0029               4084            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000388C  6100 064A               4085            BSR       PUSH_STACK
00003890  163C 002B               4086            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003894  6100 0642               4087            BSR       PUSH_STACK
00003898                          4088            
00003898  6000 01CE               4089            BRA       GET_SRC_SUCCESS                   *RETURN 
0000389C                          4090  
0000389C                          4091            
0000389C                          4092            
0000389C                          4093                      
0000389C                          4094            *** Check if source ...  <ea> = -(An)       
0000389C  41F9 00004564           4095  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
000038A2  1439 00004563           4096            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000038A8  1082                    4097            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000038AA  0239 0010 00004564      4098            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000038B2  0C39 0010 00004564      4099            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000038BA  6700 0082               4100            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000038BE  0CB9 00000004 00004574  4101            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000038C8  6600 0074               4102            BNE     CHECK7
000038CC                          4103            
000038CC                          4104            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000038CC  163C 0020               4105            MOVE.B    #' ',D3
000038D0  6100 0606               4106            BSR       PUSH_STACK
000038D4  163C 002D               4107            MOVE.B    #'-',D3
000038D8  6100 05FE               4108            BSR       PUSH_STACK
000038DC  163C 0028               4109            MOVE.B    #'(',D3
000038E0  6100 05F6               4110            BSR       PUSH_STACK
000038E4  163C 0041               4111            MOVE.B    #'A',D3
000038E8  6100 05EE               4112            BSR       PUSH_STACK
000038EC                          4113  
000038EC                          4114            
000038EC                          4115            *FIND REGISTER NUMBER END LOCATION*  
000038EC  13F9 00004566 0000456C  4116            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038F6  0239 000F 0000456C      4117            AND.B   #$0F,VAR_BYTE_END
000038FE                          4118            
000038FE                          4119            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038FE  23C5 00004570           4120            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003904  1439 0000456C           4121            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000390A                          4122            
0000390A                          4123            *INTITIALIZE FOR BIT SHIFTING
0000390A  41F9 00004570           4124            LEA     VAR_TEMP_CLEANCOPY,A0
00003910  2639 00004570           4125            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003916                          4126            
00003916                          4127  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003916  0C02 0000               4128            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000391A  6700 0008               4129            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000391E  E24B                    4130            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003920  5302                    4131            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003922  60F2                    4132            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003924                          4133                                               *change: NAME OF LABEL*
00003924                          4134  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003924  0283 00000007           4135            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000392A  0603 0030               4136            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000392E  6100 05A8               4137            BSR     PUSH_STACK                *PUSH TO STACK
00003932                          4138            
00003932  163C 0029               4139            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003936  6100 05A0               4140            BSR       PUSH_STACK
0000393A                          4141            
0000393A  6000 012C               4142            BRA     GET_SRC_SUCCESS                   *RETURN
0000393E                          4143            
0000393E                          4144                      
0000393E                          4145            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000393E  0CB9 00000007 00004574  4146  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003948  6600 011A               4147            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
0000394C                          4148                   
0000394C                          4149            *NEXT: (MODE == 111) 
0000394C                          4150            *NOW: CHECK FOR SRC REGISTER 
0000394C                          4151                  *(000 = (xxx).W)
0000394C                          4152                  *(001 = (xxx).L)
0000394C                          4153                  *(010 = #<data>)
0000394C                          4154                  
0000394C                          4155            *FIND REGISTER NUMBER END LOCATION*  
0000394C  13F9 00004566 0000456C  4156            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003956  0239 000F 0000456C      4157            AND.B   #$0F,VAR_BYTE_END
0000395E                          4158            
0000395E                          4159            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000395E  23C5 00004570           4160            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003964  1439 0000456C           4161            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000396A                          4162            
0000396A                          4163            *INTITIALIZE FOR BIT SHIFTING
0000396A  41F9 00004570           4164            LEA     VAR_TEMP_CLEANCOPY,A0
00003970  2C39 00004570           4165            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003976                          4166  SRC_LOOP_SHIFTING
00003976  0C02 0000               4167            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000397A  6700 0008               4168            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000397E  E24E                    4169            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003980  5302                    4170            SUB.B   #1,D2                     *DECREMENT COUNTER
00003982  60F2                    4171            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003984                          4172  SRC_MASKING_NEXT
00003984  CCBC 00000007           4173            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
0000398A                          4174           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
0000398A                          4175           
0000398A                          4176  CHECK_WORD  
0000398A  41F9 00004564           4177            LEA     TEMP_REGISTER_FORMAT,A0
00003990  1439 00004563           4178            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003996  1082                    4179            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003998  0239 0020 00004564      4180            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000039A0  0C39 0020 00004564      4181            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039A8  6700 0026               4182            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000039AC  0C06 0000               4183            CMPI.B  #0,D6                          
000039B0  6600 001E               4184            BNE     CHECK_LONG 
000039B4                          4185            
000039B4                          4186            *IT IS A WORD AT THIS POINT*
000039B4                          4187            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000039B4  163C 0020               4188            MOVE.B    #' ',D3
000039B8  6100 051E               4189            BSR       PUSH_STACK
000039BC  163C 0024               4190            MOVE.B    #'$',D3
000039C0  6100 0516               4191            BSR       PUSH_STACK
000039C4  321D                    4192            MOVE.W    (A5)+,D1
000039C6  7404                    4193            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000039C8  6100 D884               4194            BSR       HEX2ASCII2STACK
000039CC  6000 009A               4195            BRA     GET_SRC_SUCCESS
000039D0                          4196  
000039D0                          4197  CHECK_LONG
000039D0  41F9 00004564           4198            LEA     TEMP_REGISTER_FORMAT,A0
000039D6  1439 00004563           4199            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039DC  1082                    4200            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039DE  0239 0040 00004564      4201            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000039E6  0C39 0040 00004564      4202            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039EE  6700 002E               4203            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000039F2  0C06 0001               4204            CMPI.B  #1,D6                          
000039F6  6600 0026               4205            BNE     CHECK_IMMEDIATE  
000039FA                          4206  
000039FA                          4207            *IT IS A WORD AT THIS POINT*
000039FA                          4208            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000039FA  163C 0020               4209            MOVE.B    #' ',D3
000039FE  6100 04D8               4210            BSR       PUSH_STACK
00003A02  163C 0024               4211            MOVE.B    #'$',D3
00003A06  6100 04D0               4212            BSR       PUSH_STACK
00003A0A  321D                    4213            MOVE.W    (A5)+,D1
00003A0C  7404                    4214            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A0E  6100 D83E               4215            BSR       HEX2ASCII2STACK
00003A12  321D                    4216            MOVE.W    (A5)+,D1
00003A14  7404                    4217            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A16  6100 D836               4218            BSR       HEX2ASCII2STACK
00003A1A  6000 004C               4219            BRA     GET_SRC_SUCCESS
00003A1E                          4220            
00003A1E                          4221  CHECK_IMMEDIATE
00003A1E  41F9 00004564           4222            LEA     TEMP_REGISTER_FORMAT,A0
00003A24  1439 00004563           4223            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A2A  1082                    4224            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A2C  0239 0080 00004564      4225            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003A34  0C39 0080 00004564      4226            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A3C  6700 0026               4227            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A40  0C06 0004               4228            CMPI.B  #4,D6                          
00003A44  6600 001E               4229            BNE     GET_SRC_FAILED 
00003A48                          4230  
00003A48                          4231            *IT IS A WORD AT THIS POINT*
00003A48                          4232            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A48  163C 0020               4233            MOVE.B    #' ',D3
00003A4C  6100 048A               4234            BSR       PUSH_STACK
00003A50  163C 0023               4235            MOVE.B    #'#',D3
00003A54  6100 0482               4236            BSR       PUSH_STACK
00003A58  321D                    4237            MOVE.W    (A5)+,D1
00003A5A  7404                    4238            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A5C  6100 D7F0               4239            BSR       HEX2ASCII2STACK
00003A60  6000 0006               4240            BRA     GET_SRC_SUCCESS
00003A64                          4241            
00003A64                          4242  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003A64  7801                    4243            MOVE.L #1,D4
00003A66  4E75                    4244            RTS
00003A68                          4245  GET_SRC_SUCCESS 
00003A68  4E75                    4246            RTS
00003A6A                          4247                                 
00003A6A                          4248      
00003A6A                          4249  
00003A6A                          4250  
00003A6A                          4251  
00003A6A                          4252  
00003A6A                          4253  
00003A6A                          4254  
00003A6A                          4255  GET_EA_EA_DEST
00003A6A                          4256  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003A6A                          4257      
00003A6A                          4258      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003A6A  2405                    4259      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003A6C  EC8A                    4260      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003A6E  23C2 00004574           4261      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003A74  7407                    4262      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003A76  C5B9 00004574           4263      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003A7C                          4264                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003A7C                          4265      
00003A7C                          4266      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003A7C                          4267      *DESTINATION REGISTER FORMAT STANDARD         *
00003A7C                          4268      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003A7C                          4269      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003A7C                          4270      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003A7C                          4271      *0 - Dn                                       *
00003A7C                          4272      *1 - An                                       *
00003A7C                          4273      *2 - (An)                                     *
00003A7C                          4274      *3 - (An)+                                    *
00003A7C                          4275      *4 - -(An)                                    *
00003A7C                          4276      *5 - (XXX).W                                  *
00003A7C                          4277      *6 - (XXX).L                                  *
00003A7C                          4278      *7 - #<data>                                  *
00003A7C                          4279      ***********************************************
00003A7C                          4280      
00003A7C                          4281      *** Check if source ...  <ea> = Dn
00003A7C                          4282  DEST_CHECK0    
00003A7C  41F9 00004564           4283            LEA     TEMP_REGISTER_FORMAT,A0
00003A82  1439 00004562           4284            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A88  1082                    4285            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A8A  0239 0001 00004564      4286            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003A92  0C39 0001 00004564      4287            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003A9A  6700 006A               4288            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003A9E  0CB9 00000000 00004574  4289            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003AA8  6600 005C               4290            BNE     DEST_CHECK1
00003AAC                          4291            
00003AAC                          4292            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003AAC  163C 0020               4293            MOVE.B    #' ',D3
00003AB0  6100 0426               4294            BSR       PUSH_STACK
00003AB4  163C 0044               4295            MOVE.B    #'D',D3
00003AB8  6100 041E               4296            BSR       PUSH_STACK
00003ABC                          4297  
00003ABC                          4298            *FIND REGISTER NUMBER END LOCATION*  
00003ABC  13F9 00004565 0000456C  4299            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003AC6  0239 000F 0000456C      4300            AND.B   #$0F,VAR_BYTE_END
00003ACE                          4301            
00003ACE                          4302            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003ACE  23C5 00004570           4303            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003AD4  1439 0000456C           4304            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003ADA                          4305            
00003ADA                          4306            *INTITIALIZE FOR BIT SHIFTING
00003ADA  41F9 00004570           4307            LEA     VAR_TEMP_CLEANCOPY,A0
00003AE0  2639 00004570           4308            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003AE6                          4309  DEST_LOOP_SHIFTING
00003AE6  0C02 0000               4310            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003AEA  6700 0008               4311            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003AEE  E24B                    4312            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003AF0  5302                    4313            SUB.B   #1,D2                     *DECREMENT COUNTER
00003AF2  60F2                    4314            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003AF4                          4315  DEST_MASKING_NEXT
00003AF4  C6BC 00000007           4316            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003AFA  0603 0030               4317            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003AFE  6100 03D8               4318            BSR     PUSH_STACK                *PUSH TO STACK
00003B02                          4319            
00003B02  6000 0394               4320            BRA     GET_DST_SUCCESS           *RETURN          
00003B06                          4321            
00003B06                          4322            
00003B06                          4323            *** Check if source ...  <ea> = An
00003B06                          4324  DEST_CHECK1    
00003B06  41F9 00004564           4325            LEA     TEMP_REGISTER_FORMAT,A0
00003B0C  1439 00004562           4326            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B12  1082                    4327            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B14  0239 0002 00004564      4328            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003B1C  0C39 0002 00004564      4329            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003B24  6700 006A               4330            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003B28  0CB9 00000001 00004574  4331            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B32  6600 005C               4332            BNE     DEST_CHECK2
00003B36                          4333            
00003B36                          4334            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B36  163C 0020               4335            MOVE.B    #' ',D3
00003B3A  6100 039C               4336            BSR       PUSH_STACK
00003B3E  163C 0041               4337            MOVE.B    #'A',D3
00003B42  6100 0394               4338            BSR       PUSH_STACK
00003B46                          4339  
00003B46                          4340            
00003B46                          4341            *FIND REGISTER NUMBER END LOCATION*  
00003B46  13F9 00004565 0000456C  4342            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B50  0239 000F 0000456C      4343            AND.B   #$0F,VAR_BYTE_END
00003B58                          4344            
00003B58                          4345            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B58  23C5 00004570           4346            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B5E  1439 0000456C           4347            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003B64                          4348            
00003B64                          4349            *INTITIALIZE FOR BIT SHIFTING
00003B64  41F9 00004570           4350            LEA     VAR_TEMP_CLEANCOPY,A0
00003B6A  2639 00004570           4351            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B70                          4352  DEST_LOOP_SHIFTING1
00003B70  0C02 0000               4353            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B74  6700 0008               4354            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003B78  E24B                    4355            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B7A  5302                    4356            SUB.B   #1,D2                     *DECREMENT COUNTER
00003B7C  60F2                    4357            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003B7E                          4358  DEST_MASKING_NEXT1
00003B7E  C6BC 00000007           4359            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B84  0603 0030               4360            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003B88  6100 034E               4361            BSR     PUSH_STACK                *PUSH TO STACK
00003B8C                          4362            
00003B8C  6000 030A               4363            BRA     GET_DST_SUCCESS                   *RETURN 
00003B90                          4364            
00003B90                          4365            
00003B90                          4366            
00003B90                          4367            
00003B90                          4368            *** Check if source ...  <ea> = (An)       
00003B90                          4369  DEST_CHECK2    
00003B90  41F9 00004564           4370            LEA     TEMP_REGISTER_FORMAT,A0
00003B96  1439 00004562           4371            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B9C  1082                    4372            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B9E  0239 0004 00004564      4373            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003BA6  0C39 0004 00004564      4374            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003BAE  6700 007A               4375            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003BB2  0CB9 00000002 00004574  4376            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003BBC  6600 006C               4377            BNE     DEST_CHECK3
00003BC0                          4378            
00003BC0                          4379            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003BC0  163C 0020               4380            MOVE.B    #' ',D3
00003BC4  6100 0312               4381            BSR       PUSH_STACK
00003BC8  163C 0028               4382            MOVE.B    #'(',D3
00003BCC  6100 030A               4383            BSR       PUSH_STACK
00003BD0  163C 0041               4384            MOVE.B    #'A',D3
00003BD4  6100 0302               4385            BSR       PUSH_STACK
00003BD8                          4386  
00003BD8                          4387            
00003BD8                          4388            *FIND REGISTER NUMBER END LOCATION*  
00003BD8  13F9 00004565 0000456C  4389            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BE2  0239 000F 0000456C      4390            AND.B   #$0F,VAR_BYTE_END
00003BEA                          4391            
00003BEA                          4392            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BEA  23C5 00004570           4393            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BF0  1439 0000456C           4394            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003BF6                          4395            
00003BF6                          4396            *INTITIALIZE FOR BIT SHIFTING
00003BF6  41F9 00004570           4397            LEA     VAR_TEMP_CLEANCOPY,A0
00003BFC  2639 00004570           4398            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C02                          4399  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003C02  0C02 0000               4400            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C06  6700 0008               4401            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003C0A  E24B                    4402            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C0C  5302                    4403            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C0E  60F2                    4404            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003C10                          4405  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003C10  0283 00000007           4406            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C16  0603 0030               4407            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003C1A  6100 02BC               4408            BSR     PUSH_STACK                *PUSH TO STACK
00003C1E                          4409            
00003C1E  163C 0029               4410            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C22  6100 02B4               4411            BSR       PUSH_STACK
00003C26                          4412            
00003C26  6000 0270               4413            BRA     GET_DST_SUCCESS                   *RETURN 
00003C2A                          4414  
00003C2A                          4415            
00003C2A                          4416            
00003C2A                          4417                      
00003C2A                          4418  *** Check if source ...  <ea> = (An)+       
00003C2A  41F9 00004564           4419  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003C30  1439 00004562           4420            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C36  1082                    4421            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C38  0239 0008 00004564      4422            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003C40  0C39 0008 00004564      4423            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003C48  6700 0082               4424            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003C4C  0CB9 00000003 00004574  4425            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003C56  6600 0074               4426            BNE     DEST_CHECK4
00003C5A                          4427            
00003C5A                          4428            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003C5A  163C 0020               4429            MOVE.B    #' ',D3
00003C5E  6100 0278               4430            BSR       PUSH_STACK
00003C62  163C 0028               4431            MOVE.B    #'(',D3
00003C66  6100 0270               4432            BSR       PUSH_STACK
00003C6A  163C 0041               4433            MOVE.B    #'A',D3
00003C6E  6100 0268               4434            BSR       PUSH_STACK
00003C72                          4435  
00003C72                          4436            
00003C72                          4437            *FIND REGISTER NUMBER END LOCATION*  
00003C72  13F9 00004565 0000456C  4438            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C7C  0239 000F 0000456C      4439            ANDI.B   #$0F,VAR_BYTE_END
00003C84                          4440            
00003C84                          4441            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C84  23C5 00004570           4442            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C8A  1439 0000456C           4443            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C90                          4444            
00003C90                          4445            *INTITIALIZE FOR BIT SHIFTING
00003C90  41F9 00004570           4446            LEA     VAR_TEMP_CLEANCOPY,A0
00003C96  2639 00004570           4447            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C9C                          4448            
00003C9C                          4449  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003C9C  0C02 0000               4450            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003CA0  6700 0008               4451            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003CA4  E24B                    4452            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003CA6  5302                    4453            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003CA8  60F2                    4454            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003CAA                          4455                                               *change: NAME OF LABEL*
00003CAA                          4456  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003CAA  0283 00000007           4457            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003CB0  0603 0030               4458            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003CB4  6100 0222               4459            BSR     PUSH_STACK                *PUSH TO STACK
00003CB8                          4460            
00003CB8  163C 0029               4461            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003CBC  6100 021A               4462            BSR       PUSH_STACK
00003CC0  163C 002B               4463            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003CC4  6100 0212               4464            BSR       PUSH_STACK
00003CC8                          4465            
00003CC8  6000 01CE               4466            BRA       GET_DST_SUCCESS                   *RETURN 
00003CCC                          4467  
00003CCC                          4468            
00003CCC                          4469            
00003CCC                          4470                      
00003CCC                          4471            *** Check if source ...  <ea> = -(An)       
00003CCC                          4472  DEST_CHECK4    
00003CCC  41F9 00004564           4473            LEA     TEMP_REGISTER_FORMAT,A0
00003CD2  1439 00004562           4474            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CD8  1082                    4475            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CDA  0239 0010 00004564      4476            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003CE2  0C39 0010 00004564      4477            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CEA  6700 0082               4478            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CEE  0CB9 00000004 00004574  4479            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003CF8  6600 0074               4480            BNE     DEST_CHECK7
00003CFC                          4481            
00003CFC                          4482            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CFC  163C 0020               4483            MOVE.B    #' ',D3
00003D00  6100 01D6               4484            BSR       PUSH_STACK
00003D04  163C 002D               4485            MOVE.B    #'-',D3
00003D08  6100 01CE               4486            BSR       PUSH_STACK
00003D0C  163C 0028               4487            MOVE.B    #'(',D3
00003D10  6100 01C6               4488            BSR       PUSH_STACK
00003D14  163C 0041               4489            MOVE.B    #'A',D3
00003D18  6100 01BE               4490            BSR       PUSH_STACK
00003D1C                          4491  
00003D1C                          4492            
00003D1C                          4493            *FIND REGISTER NUMBER END LOCATION*  
00003D1C  13F9 00004565 0000456C  4494            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D26  0239 000F 0000456C      4495            AND.B   #$0F,VAR_BYTE_END
00003D2E                          4496            
00003D2E                          4497            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D2E  23C5 00004570           4498            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D34  1439 0000456C           4499            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D3A                          4500            
00003D3A                          4501            *INTITIALIZE FOR BIT SHIFTING
00003D3A  41F9 00004570           4502            LEA     VAR_TEMP_CLEANCOPY,A0
00003D40  2639 00004570           4503            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D46                          4504            
00003D46                          4505  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003D46  0C02 0000               4506            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D4A  6700 0008               4507            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D4E  E24B                    4508            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D50  5302                    4509            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003D52  60F2                    4510            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003D54                          4511                                               *change: NAME OF LABEL*
00003D54                          4512  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003D54  0283 00000007           4513            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D5A  0603 0030               4514            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D5E  6100 0178               4515            BSR     PUSH_STACK                *PUSH TO STACK
00003D62                          4516            
00003D62  163C 0029               4517            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D66  6100 0170               4518            BSR       PUSH_STACK
00003D6A                          4519            
00003D6A  6000 012C               4520            BRA     GET_DST_SUCCESS                   *RETURN
00003D6E                          4521            
00003D6E                          4522                      
00003D6E                          4523            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003D6E                          4524  DEST_CHECK7    
00003D6E  0CB9 00000007 00004574  4525            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003D78  6600 011A               4526            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003D7C                          4527                   
00003D7C                          4528            *NEXT: (MODE == 111) 
00003D7C                          4529            *NOW: CHECK FOR SRC REGISTER 
00003D7C                          4530                  *(000 = (xxx).W)
00003D7C                          4531                  *(001 = (xxx).L)
00003D7C                          4532                  *(010 = #<data>)
00003D7C                          4533                  
00003D7C                          4534            *FIND REGISTER NUMBER END LOCATION*  
00003D7C  13F9 00004565 0000456C  4535            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D86  0239 000F 0000456C      4536            AND.B   #$0F,VAR_BYTE_END
00003D8E                          4537            
00003D8E                          4538            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D8E  23C5 00004570           4539            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D94  1439 0000456C           4540            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D9A                          4541            
00003D9A                          4542            *INTITIALIZE FOR BIT SHIFTING
00003D9A  41F9 00004570           4543            LEA     VAR_TEMP_CLEANCOPY,A0
00003DA0  2C39 00004570           4544            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003DA6                          4545  DEST_LOOP_SHIFTING7
00003DA6  0C02 0000               4546            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DAA  6700 0008               4547            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003DAE  E24E                    4548            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DB0  5302                    4549            SUB.B   #1,D2                     *DECREMENT COUNTER
00003DB2  60F2                    4550            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003DB4                          4551  DEST_MASKING_NEXT7
00003DB4  CCBC 00000007           4552            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003DBA                          4553           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003DBA                          4554            
00003DBA                          4555  DEST_CHECK_WORD  
00003DBA  41F9 00004564           4556            LEA     TEMP_REGISTER_FORMAT,A0
00003DC0  1439 00004562           4557            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003DC6  1082                    4558            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003DC8  0239 0020 00004564      4559            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003DD0  0C39 0020 00004564      4560            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003DD8  6700 0026               4561            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003DDC  0C06 0000               4562            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003DE0  6600 001E               4563            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003DE4                          4564            *IT IS A WORD AT THIS POINT*
00003DE4                          4565            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003DE4  163C 0020               4566            MOVE.B    #' ',D3
00003DE8  6100 00EE               4567            BSR       PUSH_STACK
00003DEC  163C 0024               4568            MOVE.B    #'$',D3
00003DF0  6100 00E6               4569            BSR       PUSH_STACK
00003DF4  321D                    4570            MOVE.W    (A5)+,D1
00003DF6  7404                    4571            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003DF8  6100 D454               4572            BSR       HEX2ASCII2STACK
00003DFC  6000 009A               4573            BRA       GET_DST_SUCCESS
00003E00                          4574  
00003E00                          4575  DEST_CHECK_LONG
00003E00  41F9 00004564           4576            LEA     TEMP_REGISTER_FORMAT,A0
00003E06  1439 00004562           4577            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E0C  1082                    4578            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E0E  0239 0040 00004564      4579            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003E16  0C39 0040 00004564      4580            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E1E  6700 002E               4581            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E22  0C06 0001               4582            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003E26  6600 0026               4583            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003E2A                          4584            *IT IS A WORD AT THIS POINT*
00003E2A                          4585            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E2A  163C 0020               4586            MOVE.B    #' ',D3
00003E2E  6100 00A8               4587            BSR       PUSH_STACK
00003E32  163C 0024               4588            MOVE.B    #'$',D3
00003E36  6100 00A0               4589            BSR       PUSH_STACK
00003E3A  321D                    4590            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003E3C  7404                    4591            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003E3E  6100 D40E               4592            BSR       HEX2ASCII2STACK
00003E42  321D                    4593            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003E44  7404                    4594            MOVE.L    #4,D2          
00003E46  6100 D406               4595            BSR       HEX2ASCII2STACK
00003E4A  6000 004C               4596            BRA     GET_DST_SUCCESS
00003E4E                          4597            
00003E4E                          4598  DEST_CHECK_IMMEDIATE
00003E4E  41F9 00004564           4599            LEA     TEMP_REGISTER_FORMAT,A0
00003E54  1439 00004562           4600            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E5A  1082                    4601            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E5C  0239 0080 00004564      4602            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003E64  0C39 0080 00004564      4603            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E6C  6700 0026               4604            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E70  0C06 0004               4605            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003E74  6600 001E               4606            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003E78                          4607            
00003E78                          4608            *IT IS A WORD AT THIS POINT*
00003E78                          4609            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E78  163C 0020               4610            MOVE.B    #' ',D3
00003E7C  6100 005A               4611            BSR       PUSH_STACK
00003E80  163C 0023               4612            MOVE.B    #'#',D3
00003E84  6100 0052               4613            BSR       PUSH_STACK
00003E88  321D                    4614            MOVE.W    (A5)+,D1
00003E8A  7404                    4615            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003E8C  6100 D3C0               4616            BSR       HEX2ASCII2STACK
00003E90  6000 0006               4617            BRA       GET_DST_SUCCESS
00003E94                          4618            
00003E94                          4619  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003E94  7801                    4620            MOVE.L #1,D4
00003E96  4E75                    4621            RTS
00003E98                          4622  GET_DST_SUCCESS 
00003E98  4E75                    4623            RTS
00003E9A                          4624  
00003E9A                          4625  
00003E9A                          4626  *---------------------------------------------------------------------------*
00003E9A                          4627  * STACK/QUEUE INTERFACE
00003E9A                          4628  *---------------------------------------------------------------------------*
00003E9A                          4629  PRINT_STACK
00003E9A  0C39 0000 0000455E      4630            CMP.B     #0,COUNTER
00003EA2  6700 000E               4631            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003EA6                          4632            
00003EA6                          4633  PRINT_STACK_HELPER
00003EA6  6100 0038               4634            BSR      POP_STACK          *PRINTS ADDRESS
00003EAA  103C 0006               4635            MOVE.B   #6,D0              *Display single character in D1.B. 
00003EAE  4E4F                    4636            TRAP     #15             *ACTIVATES PRINT
00003EB0                          4637  
00003EB0  60E8                    4638            BRA       PRINT_STACK
00003EB2                          4639  PRINT_STACK_RETURN
00003EB2  4E75                    4640            RTS
00003EB4                          4641            
00003EB4                          4642            
00003EB4                          4643  PRINT_QUEUE
00003EB4  0C39 0000 0000455E      4644            CMP.B     #0,COUNTER
00003EBC  6700 0018               4645            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003EC0                          4646            
00003EC0                          4647  PRINT_QUEUE_HELPER
00003EC0  33F9 0000455E 00004560  4648            MOVE.W   COUNTER,QUEUE_COUNTER
00003ECA  6100 0022               4649            BSR      POP_FRONT          *PRINTS ADDRESS
00003ECE  103C 0006               4650            MOVE.B   #6,D0              *Display single character in D1.B. 
00003ED2  4E4F                    4651            TRAP     #15             *ACTIVATES PRINT
00003ED4                          4652  
00003ED4  60DE                    4653            BRA       PRINT_QUEUE
00003ED6                          4654  PRINT_QUEUE_RETURN
00003ED6  4E75                    4655            RTS
00003ED8                          4656            
00003ED8                          4657  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003ED8                          4658  PUSH_STACK
00003ED8  1503                    4659              MOVE.B  D3,-(A2)
00003EDA  6100 0058               4660              BSR     INCREMENT
00003EDE  4E75                    4661              RTS
00003EE0                          4662  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003EE0                          4663  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003EE0                          4664  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003EE0                          4665  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003EE0                          4666  *         TRAP        #15             *ACTIVATES PRINT
00003EE0                          4667  POP_STACK
00003EE0  BECA                    4668              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003EE2  6700 0008               4669              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003EE6  121A                    4670              MOVE.B  (A2)+,D1 
00003EE8  6100 0052               4671              BSR     DECREMENT
00003EEC                          4672  POP_RETURN
00003EEC  4E75                    4673              RTS 
00003EEE                          4674        
00003EEE                          4675  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003EEE  0C39 0000 00004560      4676  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003EF6  6700 0030               4677              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003EFA                          4678              
00003EFA                          4679              
00003EFA                          4680              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003EFA  347C 7000               4681              MOVEA.W #STACK,A2   *START A2 AT STACK
00003EFE  0622 0000               4682              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003F02  384A                    4683              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003F04  0624 0000               4684              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003F08  1212                    4685              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003F0A                          4686  POP_SHIFT_LOOP
00003F0A  0C39 0000 00004560      4687              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003F12  6700 0014               4688              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003F16  1494                    4689              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003F18  0624 0000               4690              ADD.B   #0,-(A4)
00003F1C  0622 0000               4691              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003F20  5339 00004560           4692              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003F26                          4693              
00003F26  60E2                    4694              BRA     POP_SHIFT_LOOP
00003F28                          4695                          
00003F28                          4696  POP_FRONT_RETURN 
00003F28                          4697              *RESET A2 BACK TO SP
00003F28  347C 7000               4698              MOVEA.W #STACK,A2    
00003F2C  5339 0000455E           4699              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003F32  4E75                    4700              RTS   
00003F34                          4701  
00003F34                          4702  INCREMENT
00003F34  5239 0000455E           4703              ADD.B   #1, COUNTER
00003F3A  4E75                    4704              RTS           
00003F3C                          4705  DECREMENT
00003F3C  5339 0000455E           4706              SUB.B   #1, COUNTER
00003F42  4E75                    4707              RTS           
00003F44                          4708  CLEAR_STACK
00003F44  0C39 0000 0000455E      4709              CMP.B     #0,COUNTER
00003F4C  6700 0006               4710              BEQ       CLEAR_RETURN
00003F50  618E                    4711              BSR       POP_STACK
00003F52  60F0                    4712              BRA       CLEAR_STACK
00003F54                          4713   
00003F54                          4714  CLEAR_RETURN
00003F54  4E75                    4715              RTS    
00003F56                          4716              
00003F56                          4717  *---------------------------------------------------------------------------*
00003F56                          4718  * 8/16/32-bit Address getter
00003F56                          4719  *---------------------------------------------------------------------------*
00003F56                          4720  *get displacement value from bits 0 to 8
00003F56                          4721  *if displacement is not $00, than it is 8 otherwise check for word
00003F56                          4722  *if displacement is not $FF, than it is a long
00003F56                          4723  *add the displacement to the current address being processed + a word
00003F56                          4724  *place results into D3, so that it can be pushed to stack
00003F56                          4725  GET_DISPLACEMENT_ADDRESS
00003F56  2805                    4726              MOVE.L  D5,D4                   * COPIES DATA INTO D6
00003F58  0286 000000FF           4727              ANDI.L  #$00FF,D6               * MASKS DATA
00003F5E  0C84 00000000           4728              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
00003F64  6700 0022               4729              BEQ     GET_DISPLACEMENT_WORD
00003F68  0C84 000000FF           4730              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00003F6E  6700 0030               4731              BEQ     GET_DISPLACEMENT_LONG
00003F72                          4732              
00003F72  2E3C 00000100           4733              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00003F78  9E04                    4734              SUB.B   D4,D7
00003F7A                          4735              
00003F7A  280D                    4736              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00003F7C  9807                    4737              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00003F7E  7404                    4738              MOVE.L  #4,D2
00003F80  2204                    4739              MOVE.L  D4,D1  
00003F82  6100 D2CA               4740              BSR     HEX2ASCII2STACK
00003F86  4E75                    4741              RTS
00003F88                          4742              
00003F88                          4743  GET_DISPLACEMENT_WORD
00003F88  2E3C 000000FF           4744              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00003F8E  9E04                    4745              SUB.B   D4,D7
00003F90                          4746              
00003F90  280D                    4747              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00003F92  9807                    4748              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00003F94  7404                    4749              MOVE.L  #4,D2
00003F96  2604                    4750              MOVE.L  D4,D3
00003F98  2204                    4751              MOVE.L  D4,D1
00003F9A  6100 D2B2               4752              BSR     HEX2ASCII2STACK
00003F9E  4E75                    4753              RTS     
00003FA0                          4754  GET_DISPLACEMENT_LONG   
00003FA0  2E3C 000000FF           4755              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00003FA6  9E04                    4756              SUB.B   D4,D7
00003FA8                          4757              
00003FA8  280D                    4758              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00003FAA  9807                    4759              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00003FAC  7408                    4760              MOVE.L  #8,D2
00003FAE  2604                    4761              MOVE.L  D4,D3                   * PREPARE TO PUSH
00003FB0  2204                    4762              MOVE.L  D4,D1
00003FB2  6100 D29A               4763              BSR     HEX2ASCII2STACK
00003FB6                          4764  
00003FB6  4284                    4765              CLR.L   D4
00003FB8  4E75                    4766              RTS
00003FBA                          4767  
00003FBA                          4768  *---------------------------------------------------------------------------*
00003FBA                          4769  * TERMINATE
00003FBA                          4770  *---------------------------------------------------------------------------*
00003FBA                          4771  TERMINATE   
00003FBA  43F9 0000436A           4772              LEA     FINMSG,A1
00003FC0  103C 000E               4773              MOVE.B  #14,D0
00003FC4  4E4F                    4774              TRAP    #15
00003FC6                          4775  
00003FC6  103C 0009               4776              MOVE.B  #9,D0
00003FCA  4E4F                    4777              TRAP    #15
00003FCC                          4778  
00003FCC                          4779  *---------------------------------------------------------------------------*
00003FCC                          4780  * Data storage                                                 
00003FCC                          4781  *---------------------------------------------------------------------------*  
00003FCC                          4782  WELCOME
00003FCC= 20 20 20 20 20 20 ...   4783              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
0000401C= 3D 3D 3D 3D 3D 20 ...   4784              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
0000406C= 3D 3D 3D 3D 3D 20 ...   4785              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000040BC                          4786      
000040BC= 20 20 20 20 20 20 ...   4787              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
0000410C= 20 20 20 20 20 20 ...   4788              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
0000415C= 20 20 20 20 20 20 ...   4789              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000041AC                          4790      
000041AC= 20 20 20 20 20 20 ...   4791              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
000041FC= 3D 3D 3D 3D 3D 20 ...   4792              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
0000424C= 3D 3D 3D 3D 3D 20 ...   4793              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
000042A1                          4794  
000042A1                          4795  PROMPT_START
000042A1= 50 6C 65 61 73 65 ...   4796              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000042D0                          4797      
000042D0                          4798  PROMPT_END
000042D0= 50 6C 65 61 73 65 ...   4799              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
000042FD= 0D 0A 48 69 74 20 ...   4800  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00004327= 57 6F 75 6C 64 20 ...   4801  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
0000436A= 54 68 61 6E 6B 20 ...   4802  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00004395= 45 72 72 6F 72 3A ...   4803  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000043B4= 45 72 72 6F 72 3A ...   4804  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
000043D9= 45 72 72 6F 72 3A ...   4805  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00004406                          4806  
00004406                          4807  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00004456                          4808  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
000044A6                          4809  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000044AA                          4810  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000044AE= 0D 0A 00                4811  ENDLINE_M   DC.B    CR,LF,0
000044B1                          4812  TMPINPUT    DS.B    80                      * temp store user input
00004501                          4813  TMPOUTPUT   DS.B    80                      * temp store prog output
00004551= 20 20 20 44 41 54 ...   4814  DISP_DATA   DC.B    '   DATA',0
00004559                          4815  
00004559= 20 20 20 24 00          4816  DISP_HEX     DC.B    '   $',0
0000455E                          4817  *STACK INTERFACE VARIABLES*
0000455E                          4818  COUNTER         DS.W    1
00004560                          4819  QUEUE_COUNTER   DS.W    1
00004562                          4820  
00004562                          4821  *EA DECODING INTERFACE VARIABLES* 
00004562                          4822  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004563                          4823  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004564                          4824  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004565                          4825  
00004565                          4826  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004565                          4827  * WORD + WORD = LONG
00004565                          4828  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004565                          4829  * A              + F            = AF         <= EXAMPLE
00004565                          4830  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004565                          4831  GET_DST_START_END    DS.B    1
00004566                          4832  GET_SRC_START_END    DS.B    1
00004567                          4833  
00004567                          4834  *STORES THE START + END BITS HERE (FROM ABOVE)
00004568                          4835  VAR_BYTE_START      DS.L    1
0000456C                          4836  VAR_BYTE_END        DS.L    1
00004570                          4837  VAR_TEMP_CLEANCOPY  DS.L    1
00004574                          4838  
00004574                          4839  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004578                          4840  
00004578                          4841  *MORE FOR STACK USAGE*
00004578= 2C 00                   4842  DISP_COMMA  DC.B    ',',0
0000457A= 20 20 20 00             4843  DISP_INDENT  DC.B    '   ',0
0000457E                          4844  
0000457E                          4845  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
0000457E                          4846  POINTER_WORD    DS.W       1
00004580                          4847  
00004580                          4848  
00004580                          4849  
00004580                          4850  *---------------------------------------------------------------------------*
00004580                          4851  * Ends program
00004580                          4852  *---------------------------------------------------------------------------*
00004580                          4853              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1142
ASC2HXLP2STACK      11AA
ASCII2HEX           113C
ASCII2HEX2STACK     11A4
ASC_ERR             119E
ASC_ERR2STACK       1206
ASC_LOW             1180
ASC_LOW2STACK       11E8
ASC_NUM             1190
ASC_NUM2STACK       11F8
ASC_SFT             1198
ASC_SFT2STACK       1200
ASC_UPP             1188
ASC_UPP2STACK       11F0
CHECK0              364C
CHECK1              36D6
CHECK2              3760
CHECK3              37FA
CHECK4              389C
CHECK7              393E
CHECK_IMMEDIATE     3A1E
CHECK_LONG          39D0
CHECK_WORD          398A
CLEAR_RETURN        3F54
CLEAR_STACK         3F44
COUNTER             455E
CR                  D
DECREMENT           3F3C
DEST_CHECK0         3A7C
DEST_CHECK1         3B06
DEST_CHECK2         3B90
DEST_CHECK3         3C2A
DEST_CHECK4         3CCC
DEST_CHECK7         3D6E
DEST_CHECK_IMMEDIATE  3E4E
DEST_CHECK_LONG     3E00
DEST_CHECK_WORD     3DBA
DEST_LOOP_SHIFTING  3AE6
DEST_LOOP_SHIFTING1  3B70
DEST_LOOP_SHIFTING2  3C02
DEST_LOOP_SHIFTING3  3C9C
DEST_LOOP_SHIFTING4  3D46
DEST_LOOP_SHIFTING7  3DA6
DEST_MASKING_NEXT   3AF4
DEST_MASKING_NEXT1  3B7E
DEST_MASKING_NEXT2  3C10
DEST_MASKING_NEXT3  3CAA
DEST_MASKING_NEXT4  3D54
DEST_MASKING_NEXT7  3DB4
DEST_REGISTER_FORMAT  4562
DISPLAY_30_LINES    1352
DISP_COMMA          4578
DISP_DATA           4551
DISP_HEX            4559
DISP_INDENT         457A
DISP_NEXT           42FD
D_MODE111           3574
EA_DATA             1764
ENDLINE_M           44AE
END_ADDR            1088
ERRMSG_1            4395
ERRMSG_3            43B4
ERRMSG_5            43D9
ERROR_1             10EC
ERROR_2             10FC
ERROR_3             110C
ERROR_4             111C
ERROR_5             112C
E_ADDR_HX           44AA
FINMSG              436A
GET_DISPLACEMENT_ADDRESS  3F56
GET_DISPLACEMENT_LONG  3FA0
GET_DISPLACEMENT_WORD  3F88
GET_DST_FAILED      3E94
GET_DST_START_END   4565
GET_DST_SUCCESS     3E98
GET_EA_EA_DEST      3A6A
GET_EA_EA_SRC       363A
GET_SRC_FAILED      3A64
GET_SRC_START_END   4566
GET_SRC_SUCCESS     3A68
HEX2ASCII           120C
HEX2ASCII2STACK     124E
HEX_CHAR            123A
HEX_CONT            123E
HEX_LOOP            1220
INCREMENT           3F34
INTRO               1028
IS_ODD              1292
IS_ODD_ERR          12A8
JMPTABLE            1380
LF                  A
LONGMODE            35CC
LOOP_SHIFTING       36B6
LOOP_SHIFTING1      3740
LOOP_SHIFTING2      37D2
LOOP_SHIFTING3      386C
LOOP_SHIFTING4      3916
MAIN                12AE
MASKING_NEXT        36C4
MASKING_NEXT1       374E
MASKING_NEXT2       37E0
MASKING_NEXT3       387A
MASKING_NEXT4       3924
NEXTLINES           1362
OP0000              13E0
OP0000_BTST_B       154A
OP0000_CMPI         178C
OP0000_CMPI_B       1802
OP0000_CMPI_L       1852
OP0000_CMPI_W       182A
OP0000_EOR_B        15F8
OP0000_EOR_L        1628
OP0000_EOR_W        1610
OP0000_ORI_B        18E6
OP0000_ORI_L        1936
OP0000_ORI_W        190E
OP0000_RETURN_BTST  157A
OP0000_RETURN_CMPI  1876
OP0000_RETURN_EOR   163C
OP0000_RETURN_ORI   195A
OP0000_RETURN_SUBI  171E
OP0000_SUB_B        16DA
OP0000_SUB_L        170A
OP0000_SUB_W        16F2
OP0001              195C
OP0010              19CA
OP0011              1AC8
OP0100              1BC4
OP0101              1EF0
OP0101_ADDQ_B       1F6C
OP0101_ADDQ_B_0     1FE8
OP0101_ADDQ_B_1     1FF4
OP0101_ADDQ_B_2     2000
OP0101_ADDQ_B_3     200C
OP0101_ADDQ_B_4     2018
OP0101_ADDQ_B_5     2024
OP0101_ADDQ_B_6     2030
OP0101_ADDQ_B_7     203C
OP0101_ADDQ_B_8     2048
OP0101_ADDQ_L       1F84
OP0101_ADDQ_W       1F78
OP0101_RETURN       1F8C
OP0101_RETURN2      2050
OP0110              205E
OP0111              2164
OP1000              2168
OP1000_DIVS_DN_EA_OR_EA_DN  2176
OP1000_DIVS_RETURN  225A
OP1000_EA_DN_DIVS   21A4
OP1000_PRINT_L_DIVS  2212
OP1000_PRINT_W_DIVS  21CA
OP1001              225C
OP1001_ADD_RETURN   25AA
OP1001_DETERMINE_DN_EA_OR_EA_DN  2372
OP1001_DN_EA        23AA
OP1001_EA_DN        24AA
OP1001_PRINT_B      24D2
OP1001_PRINT_B2     23D2
OP1001_PRINT_L      2562
OP1001_PRINT_L2     2462
OP1001_PRINT_W      251A
OP1001_PRINT_W2     241A
OP1001_SUBA_L       228E
OP1001_SUBA_W       2300
OP1010              25AC
OP1011              25B0
OP1011_CMP          260A
OP1011_CMPA         26BC
OP1011_CMPA_L       2736
OP1011_CMPA_W       272A
OP1011_CMP_B        267E
OP1011_CMP_L        2696
OP1011_CMP_W        268A
OP1011_EOR          275C
OP1011_EOR_B        27D0
OP1011_EOR_L        27E8
OP1011_EOR_W        27DC
OP1011_RETURN       27F0
OP1011_RETURN_CMP   269E
OP1011_RETURN_CMPA  273E
OP1100              280E
OP1100_AND_RETURN   2B5E
OP1100_DETERMINE_DN_EA_OR_EA_DN  2924
OP1100_DN_EA        295E
OP1100_EA_DN        2A5E
OP1100_EA_DN_MULS   286C
OP1100_MULS_DN_EA_OR_EA_DN  283E
OP1100_MULS_RETURN  2922
OP1100_PRINT_B      2A86
OP1100_PRINT_B2     2986
OP1100_PRINT_L      2B16
OP1100_PRINT_L2     2A16
OP1100_PRINT_L_MULS  28DA
OP1100_PRINT_W      2ACE
OP1100_PRINT_W2     29CE
OP1100_PRINT_W_MULS  2892
OP1101              2B60
OP1101_ADDA_L       2B92
OP1101_ADDA_W       2C04
OP1101_ADD_RETURN   2EAE
OP1101_DETERMINE_DN_EA_OR_EA_DN  2C76
OP1101_DN_EA        2CAE
OP1101_EA_DN        2DAE
OP1101_PRINT_B      2DD6
OP1101_PRINT_B2     2CD6
OP1101_PRINT_L      2E66
OP1101_PRINT_L2     2D66
OP1101_PRINT_W      2E1E
OP1101_PRINT_W2     2D1E
OP1110              2EB0
OP1110_RETURN       2F28
OP1111              3570
OP_ASX              3144
OP_ASX_0            32B8
OP_ASX_1            32C4
OP_ASX_2            32D0
OP_ASX_3            32DC
OP_ASX_4            32E8
OP_ASX_5            32F4
OP_ASX_6            3300
OP_ASX_7            330C
OP_ASX_8            3318
OP_ASX_AFTER_IMMEDIATE  3320
OP_ASX_B            31C0
OP_ASX_CHECK_FORMAT  31CC
OP_ASX_DIR          317A
OP_ASX_INTERMEDIATE  322E
OP_ASX_L            31A8
OP_ASX_MEMORY       3332
OP_ASX_R            3172
OP_ASX_REGISTER     31DE
OP_ASX_RETURN       335A
OP_ASX_W            31B4
OP_BEQ              20F2
OP_BHI              20A6
OP_BLT              213E
OP_BNE              20CC
OP_BRA              2118
OP_BTST             146A
OP_BTST_IMMEDIATE   14F4
OP_DATA             1740
OP_EORI             157C
OP_JSR              1EBC
OP_LEA              1D42
OP_LEA_DN_EA_OR_EA_DN  1D50
OP_LEA_RETURN       1DAE
OP_LSX              2F2A
OP_LSX_0            309E
OP_LSX_1            30AA
OP_LSX_2            30B6
OP_LSX_3            30C2
OP_LSX_4            30CE
OP_LSX_5            30DA
OP_LSX_6            30E6
OP_LSX_7            30F2
OP_LSX_8            30FE
OP_LSX_AFTER_IMMEDIATE  3106
OP_LSX_B            2FA6
OP_LSX_CHECK_FORMAT  2FB2
OP_LSX_DIR          2F60
OP_LSX_INTERMEDIATE  3014
OP_LSX_L            2F8E
OP_LSX_MEMORY       3118
OP_LSX_R            2F58
OP_LSX_REGISTER     2FC4
OP_LSX_RETURN       3140
OP_LSX_W            2F9A
OP_MOVEA_L          1A58
OP_MOVEA_W          1B54
OP_MOVEM            1C36
OP_MOVEM_CONTINUE   1CAC
OP_MOVEM_L          1CA4
OP_MOVEM_MR         1D00
OP_MOVEM_RM         1CC0
OP_MOVEM_W          1C98
OP_MOVE_B           1962
OP_MOVE_L           19F0
OP_MOVE_W           1AEC
OP_MULS             2830
OP_NEG              1DB0
OP_NEG_B            1DFC
OP_NEG_L            1E14
OP_NEG_PRINT_EA     1E20
OP_NEG_W            1E08
OP_NOT              1E36
OP_NOT_B            1E82
OP_NOT_L            1E9A
OP_NOT_PRINT_EA     1EA6
OP_NOT_W            1E8E
OP_ORI              1878
OP_PRINT_L_LEA      1D6E
OP_RETURNOFTHEKING  1C34
OP_ROX              335E
OP_ROX_0            34D2
OP_ROX_1            34DE
OP_ROX_2            34EA
OP_ROX_3            34F6
OP_ROX_4            3502
OP_ROX_5            350E
OP_ROX_6            351A
OP_ROX_7            3526
OP_ROX_8            3532
OP_ROX_AFTER_IMMEDIATE  353A
OP_ROX_B            33DA
OP_ROX_CHECK_FORMAT  33E6
OP_ROX_DIR          3394
OP_ROX_INTERMEDIATE  3448
OP_ROX_L            33C2
OP_ROX_MEMORY       354C
OP_ROX_R            338C
OP_ROX_REGISTER     33F8
OP_ROX_RETURN       356C
OP_ROX_W            33CE
OP_RTS              1ED6
OP_SUBI             165E
OUTPUT_PROCESSED_DATA  1332
POINTER_WORD        457E
POP_FRONT           3EEE
POP_FRONT_RETURN    3F28
POP_RETURN          3EEC
POP_SHIFT_LOOP      3F0A
POP_STACK           3EE0
PRINT_QUEUE         3EB4
PRINT_QUEUE_HELPER  3EC0
PRINT_QUEUE_RETURN  3ED6
PRINT_STACK         3E9A
PRINT_STACK_HELPER  3EA6
PRINT_STACK_RETURN  3EB2
PROGLP              100A
PROMPT_END          42D0
PROMPT_START        42A1
PUSH_STACK          3ED8
QUEUE_COUNTER       4560
REPEAT              35F8
REPEATMSG           4327
RETURN              11A2
RETURN2STACK        120A
SRC_LOOP_SHIFTING   3976
SRC_MASKING_NEXT    3984
SRC_REGISTER_FORMAT  4563
STACK               7000
STACK_HEX_CHAR      127C
STACK_HEX_CONT      1280
STACK_HEX_LOOP      1262
START               1004
START_ADDR          1036
S_ADDR_HX           44A6
TEMP_REGISTER_FORMAT  4564
TERMINATE           3FBA
TMPINPUT            44B1
TMPOUTPUT           4501
VAR_BYTE_END        456C
VAR_BYTE_START      4568
VAR_LONG_ADDRESS_MODE_CHECK  4574
VAR_TEMP_CLEANCOPY  4570
VR_E_ADDR           4456
VR_S_ADDR           4406
WELCOME             3FCC
WORDMODE            35A0
