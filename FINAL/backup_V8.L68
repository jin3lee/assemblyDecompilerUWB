00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 8:39:47 AM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 0000105A             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010AC             38              JSR     END_ADDR
00001016  43F9 0000435A             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 0000126A             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003E78             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  0813 0011                 53              BTST.B  #$11111111,(A3)
0000103A  081C 006F                 54              BTST.B  #111,(A4)+
0000103E  0825 0003                 55              BTST.B  #%11,-(A5)
00001042  0838 0001 3331            56              BTST.B  #1,$3331
00001048                            57              
00001048  0113                      58              BTST.B  D0,(A3)
0000104A  031C                      59              BTST.B  D1,(A4)+
0000104C  0525                      60              BTST.B  D2,-(A5)
0000104E  0738 3331                 61              BTST.B  D3,$3331
00001052  0939 44444441             62              BTST.B  D4,$44444441
00001058                            63              
00001058                            64              
00001058                            65  
00001058                            66  
00001058                            67  
00001058  4E75                      68              RTS
0000105A                            69  *---------------------------------------------------------------------------*
0000105A                            70  * START_ADDR: Compute the starting address
0000105A                            71  *---------------------------------------------------------------------------*
0000105A                            72  START_ADDR
0000105A                            73              * Output
0000105A  43F9 0000414D             74              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001060  103C 000E                 75              MOVE.B  #14,D0                  * Display PROMPT_START
00001064  4E4F                      76              TRAP    #15
00001066                            77      
00001066                            78              * Input
00001066  43F9 000042B2             79              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000106C  103C 0002                 80              MOVE.B  #2,D0                   * Ask user for input
00001070  4E4F                      81              TRAP    #15
00001072                            82              
00001072                            83              * Error Checking (length)
00001072  0C01 0000                 84              CMPI.B  #0, D1                  * Check if input length <= 0
00001076  6F00 0098                 85              BLE     ERROR_1
0000107A  0C01 0008                 86              CMPI.B  #8, D1                  * Check if input length > 8
0000107E  6E00 0090                 87              BGT     ERROR_1
00001082                            88              
00001082                            89              * Conversion & Storage
00001082  4EB9 00001160             90              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001088  0C07 0001                 91              CMPI.B  #1, D7                  * Check for error
0000108C  6700 0082                 92              BEQ     ERROR_1                 
00001090  23C1 00004352             93              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001096                            94              
00001096                            95              * Error Checking (Odd)
00001096  43F9 00004352             96              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000109C  4EB9 0000124E             97              JSR     IS_ODD                  * Check if the input address is odd
000010A2  0C07 0001                 98              CMPI.B  #1, D7                  * Check for error
000010A6  6700 0088                 99              BEQ     ERROR_3
000010AA                           100              
000010AA                           101              * Return
000010AA  4E75                     102              RTS     
000010AC                           103  *---------------------------------------------------------------------------*
000010AC                           104  * END_ADDR: Compute the ending address
000010AC                           105  *---------------------------------------------------------------------------*
000010AC                           106  END_ADDR
000010AC                           107              * Output
000010AC  43F9 0000417C            108              LEA     PROMPT_END,A1           * Load PROMPT_END
000010B2  103C 000E                109              MOVE.B  #14,D0                  * Display PROMPT_END
000010B6  4E4F                     110              TRAP    #15
000010B8                           111  
000010B8                           112              * Input
000010B8  43F9 00004302            113              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010BE  103C 0002                114              MOVE.B  #2,D0                   * Ask user for input
000010C2  4E4F                     115              TRAP    #15
000010C4                           116              
000010C4                           117              * Error Checking (length)
000010C4  0C01 0000                118              CMPI.B  #0, D1                  * Check if input length <= 0
000010C8  6F00 0056                119              BLE     ERROR_2
000010CC  0C01 0008                120              CMPI.B  #8, D1                  * Check if input length > 8
000010D0  6E00 004E                121              BGT     ERROR_2
000010D4                           122              
000010D4                           123              * Conversion & Storage
000010D4  4EB9 00001160            124              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010DA  0C07 0001                125              CMPI.B  #1, D7                  * Check for error
000010DE  6700 0040                126              BEQ     ERROR_2
000010E2  23C1 00004356            127              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010E8                           128              
000010E8                           129              * Error Checking (start > end case)
000010E8  2439 00004352            130              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010EE  B282                     131              CMP.L   D2, D1                  * Compare starting and ending address
000010F0  6300 005E                132              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010F4                           133              
000010F4                           134              * Error Checking (Odd case)
000010F4  43F9 00004356            135              LEA     E_ADDR_HX, A1           * Move the ending address
000010FA  4EB9 0000124E            136              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
00001100  0C07 0001                137              CMPI.B  #1, D7                  * Check for an error flag
00001104  6700 003A                138              BEQ     ERROR_4
00001108                           139              
00001108                           140              * Inputs are valid
00001108  2A79 00004352            141              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
0000110E                           142              
0000110E  4E75                     143              RTS
00001110                           144              
00001110                           145  *---------------------------------------------------------------------------*
00001110                           146  * ERROR_1: Address error (Invalid starting address)
00001110                           147  *---------------------------------------------------------------------------*
00001110                           148  ERROR_1
00001110  43F9 00004241            149              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001116  103C 000E                150              MOVE.B  #14, D0                 * Display ERRMSG_1
0000111A  4E4F                     151              TRAP    #15
0000111C  4EF8 105A                152              JMP     START_ADDR              * Jump to START_ADDR
00001120                           153      
00001120                           154  *---------------------------------------------------------------------------*
00001120                           155  * ERROR_2: Address error (Invalid ending address)
00001120                           156  *---------------------------------------------------------------------------*
00001120                           157  ERROR_2
00001120  43F9 00004241            158              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001126  103C 000E                159              MOVE.B  #14, D0                 * Display ERRMSG_1
0000112A  4E4F                     160              TRAP    #15
0000112C  4EF8 10AC                161              JMP     END_ADDR                * Jump to END_ADDR
00001130                           162  
00001130                           163  *---------------------------------------------------------------------------*
00001130                           164  * ERROR_3: Address error (Odd starting address)
00001130                           165  *---------------------------------------------------------------------------*
00001130                           166  ERROR_3
00001130  43F9 00004260            167              LEA     ERRMSG_3, A1
00001136  103C 000E                168              MOVE.B  #14, D0
0000113A  4E4F                     169              TRAP    #15
0000113C  4EF8 105A                170              JMP     START_ADDR
00001140                           171     
00001140                           172  *---------------------------------------------------------------------------*
00001140                           173  * ERROR_4: Address error (Odd ending address)
00001140                           174  *---------------------------------------------------------------------------*         
00001140                           175  ERROR_4
00001140  43F9 00004260            176              LEA     ERRMSG_3, A1
00001146  103C 000E                177              MOVE.B  #14, D0
0000114A  4E4F                     178              TRAP    #15
0000114C  4EF8 10AC                179              JMP     END_ADDR
00001150                           180            
00001150                           181  *---------------------------------------------------------------------------*
00001150                           182  * ERROR_3: Address error (Ending address is less than starting address)
00001150                           183  *---------------------------------------------------------------------------*
00001150                           184  ERROR_5
00001150  43F9 00004285            185              LEA     ERRMSG_5, A1
00001156  103C 000E                186              MOVE.B  #14, D0
0000115A  4E4F                     187              TRAP    #15
0000115C  4EF8 10AC                188              JMP     END_ADDR
00001160                           189    
00001160                           190  *---------------------------------------------------------------------------*
00001160                           191  * ASCII2HEX: Convert ASCii to Hexadecimal
00001160                           192  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001160                           193  *---------------------------------------------------------------------------*
00001160  4281                     194  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001162  4287                     195              CLR.L   D7                      * Set the error flag to 0
00001164  4282                     196              CLR.L   D2                      * Clear D2 for temp storage
00001166                           197              
00001166  1419                     198  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001168  0C02 0000                199              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000116C  6700 0058                200              BEQ     RETURN                  * If it's NULL, go to return
00001170  0C02 0066                201              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001174  6E00 004C                202              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001178  0C02 0061                203              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000117C  6C00 0026                204              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001180  0C02 0046                205              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001184  6E00 003C                206              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001188  0C02 0041                207              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000118C  6C00 001E                208              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001190  0C02 0039                209              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001194  6E00 002C                210              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001198  0C02 0030                211              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000119C  6C00 0016                212              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
000011A0  6000 0020                213              BRA     ASC_ERR                 * Invalid input
000011A4                           214  
000011A4  0442 0057                215  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011A8  6000 0012                216              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AC                           217              
000011AC  0442 0037                218  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011B0  6000 000A                219              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011B4                           220              
000011B4  0442 0030                221  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011B8  6000 0002                222              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011BC                           223              
000011BC  E981                     224  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011BE  D202                     225              ADD.B   D2, D1                  * Add the converted input to D1
000011C0  60A4                     226              BRA     ASC2HXLP                * Loop
000011C2                           227  
000011C2  1E3C 0001                228  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011C6  4E75                     229  RETURN      RTS     
000011C8                           230  
000011C8                           231  *---------------------------------------------------------------------------*
000011C8                           232  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011C8                           233  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011C8                           234  *---------------------------------------------------------------------------*
000011C8  0C02 0008                235  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
000011CC  6700 000E                236              BEQ     HEX_LOOP
000011D0  4841                     237              SWAP    D1
000011D2  0C02 0002                238              CMPI.B  #2,D2
000011D6  6600 0004                239              BNE     HEX_LOOP
000011DA  E189                     240              LSL.L   #8,D1
000011DC                           241             
000011DC  E999                     242  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
000011DE  2601                     243              MOVE.L  D1, D3                  * Move D1 to D3
000011E0  0283 0000000F            244              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
000011E6  0C03 0009                245              CMPI.B  #9, D3                  * Compare te digit
000011EA  6E00 000A                246              BGT     HEX_CHAR              
000011EE  0603 0030                247              ADDI.B  #48,D3                  * Add 48 for numerical output
000011F2  6000 0006                248              BRA     HEX_CONT
000011F6                           249              
000011F6  0603 0037                250  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
000011FA                           251  
000011FA  12C3                     252  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
000011FC  5342                     253              SUBI    #1, D2                  * Decrement the size
000011FE  0C02 0000                254              CMPI.B  #0, D2                  * Check if D2 is 0
00001202  66D8                     255              BNE     HEX_LOOP                * Loop
00001204  12BC 0000                256              MOVE.B  #$0,(A1)                * Null terminator
00001208  4E75                     257              RTS
0000120A                           258  *---------------------------------------------------------------------------*
0000120A                           259  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
0000120A                           260  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
0000120A                           261  *---------------------------------------------------------------------------*
0000120A                           262  HEX2ASCII2STACK
0000120A  0C02 0008                263              CMPI.B  #8, D2                  * Check to see if the size is long
0000120E  6700 000E                264              BEQ     STACK_HEX_LOOP
00001212  4841                     265              SWAP    D1
00001214  0C02 0002                266              CMPI.B  #2,D2
00001218  6600 0004                267              BNE     STACK_HEX_LOOP
0000121C  E189                     268              LSL.L   #8,D1
0000121E                           269             
0000121E                           270  STACK_HEX_LOOP    
0000121E  E999                     271              ROL.L   #4, D1                  * Roll D1 to left
00001220  2601                     272              MOVE.L  D1, D3                  * Move D1 to D3
00001222  0283 0000000F            273              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001228  0C03 0009                274              CMPI.B  #9, D3                  * Compare te digit
0000122C  6E00 000A                275              BGT     STACK_HEX_CHAR              
00001230  0603 0030                276              ADDI.B  #48,D3                  * Add 48 for numerical output
00001234  6000 0006                277              BRA     STACK_HEX_CONT
00001238                           278              
00001238                           279  STACK_HEX_CHAR    
00001238  0603 0037                280              ADDI.B  #55,D3                  * Add 55 for character output
0000123C                           281  
0000123C                           282  STACK_HEX_CONT    
0000123C  6100 2BAA                283              BSR     PUSH_STACK              *PLACE INTO STACK
00001240  5342                     284              SUBI    #1, D2                  * Decrement the size
00001242  0C02 0000                285              CMPI.B  #0, D2                  * Check if D2 is 0
00001246  66D6                     286              BNE     STACK_HEX_LOOP                * Loop
00001248  12BC 0000                287              MOVE.B  #$0,(A1)                * Null terminator
0000124C  4E75                     288              RTS
0000124E                           289  
0000124E                           290  
0000124E                           291  *---------------------------------------------------------------------------*
0000124E                           292  * IS_ODD: Check whether the source address is odd
0000124E                           293  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
0000124E                           294  *---------------------------------------------------------------------------*
0000124E  4281                     295  IS_ODD      CLR.L   D1                      * Clear the result
00001250  4287                     296              CLR.L   D7                      * Set the error flag to 0
00001252  2211                     297              MOVE.L  (A1),D1                * Temp store the checking address to D1
00001254  82FC 0002                298              DIVU    #2, D1                  * Divide the result by 2
00001258  4841                     299              SWAP    D1                      * Swap remainder with quotient
0000125A  0C01 0001                300              CMPI.B  #1, D1                  * Check for error
0000125E  6700 0004                301              BEQ     IS_ODD_ERR
00001262  4E75                     302              RTS
00001264                           303              
00001264  1E3C 0001                304  IS_ODD_ERR  MOVE.B  #1, D7
00001268  4E75                     305              RTS
0000126A                           306  
0000126A                           307  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
0000126A                           308  * MAINDEBUG                    
0000126A                           309  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
0000126A                           310  * A5: Processing address
0000126A                           311  *
0000126A                           312  * D3: USED FOR PUSHING INTO STACK
0000126A                           313  *     To push into stack => MOVE.W #DATA,D3 
0000126A                           314  *                           BSR    PUSH_STACK
0000126A                           315  *     To print stack     => BSR    PRINT_STACK 
0000126A                           316  *     To clear stack     => BSR    CLEAR_STACK
0000126A                           317  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
0000126A                           318  MAIN        
0000126A                           319              *initialize stack pointer
0000126A  33FC 0000 0000470A       320              MOVE.W  #0,COUNTER
00001272  347C 7000                321              MOVEA.W #STACK,A2
00001276  163C 0020                322              MOVE.B  #' ',D3
0000127A  6100 2B6C                323              BSR     PUSH_STACK
0000127E  6100 2B68                324              BSR     PUSH_STACK
00001282  6100 2B64                325              BSR     PUSH_STACK
00001286                           326              
00001286                           327              * clear registers for temp storage
00001286  4280                     328              CLR.L   D0                   
00001288  4281                     329              CLR.L   D1                   
0000128A  227C 00000000            330              MOVEA.L #0, A1                
00001290                           331              
00001290  220D                     332              MOVE.L  A5,D1                   * check to see if the address is fully read
00001292  23CD 00004352            333              MOVE.L  A5,S_ADDR_HX
00001298  B2B9 00004356            334              CMP.L   E_ADDR_HX,D1
0000129E  6C00 2268                335              BGE     REPEAT                  * go to repeat for user action
000012A2                           336  
000012A2  43F9 000043AD            337              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012A8  143C 0008                338              MOVE.B  #8,D2                   * set the output size
000012AC  4EB8 11C8                339              JSR     HEX2ASCII               
000012B0  43F9 000043AD            340              LEA     TMPOUTPUT,A1
000012B6  103C 000E                341              MOVE.B  #14,D0
000012BA  4E4F                     342              TRAP    #15
000012BC                           343              
000012BC  4285                     344              CLR.L    D5                      * clear the processing data
000012BE  3A1D                     345              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012C0                           346                                               * advance the current instruction pointer to the next
000012C0                           347                                               * instruction in memory
000012C0                           348  *----------------------------------------*
000012C0                           349  * Registers          
000012C0                           350  * [D1] - COPY OF D5
000012C0                           351  * [D5] - DATA TO BE PROCESSED
000012C0                           352  * [D6] - COUNTER FOR LINES PROCESSED
000012C0                           353  *
000012C0                           354  * [D4]      - ERROR FLAG BEFORE PRINTING
000012C0                           355  * [STACK]   - PRINTS PROCESS DATA
000012C0                           356  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012C0                           357  *
000012C0                           358  * [A1] - USED FOR JUMPING/PRINTING
000012C0                           359  *
000012C0                           360  *----------------------------------------*
000012C0                           361  
000012C0                           362              
000012C0                           363              *Processing the first 4 most significant bits 
000012C0  2205                     364              MOVE.L  D5,D1                    * copy the current processing data to D1
000012C2  143C 000C                365              MOVE.B  #12,D2                   * shift to right by 12 bits
000012C6  E469                     366              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012C8  C2FC 0006                367              MULU    #6,D1                    * form offset
000012CC  43F9 0000133A            368              LEA     JMPTABLE,A1              * index into table
000012D2  4EB1 1000                369              JSR     0(A1,D1)                 * jump indirect with index
000012D6                           370              
000012D6                           371              *SECURED EA*
000012D6  B83C 0001                372              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
000012DA  6600 0012                373              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
000012DE  6100 0302                374              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
000012E2  6100 2B70                375              BSR     CLEAR_STACK              * CLEARS THE STACK 
000012E6  183C 0000                376              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
000012EA  6000 0022                377              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
000012EE                           378             
000012EE                           379  OUTPUT_PROCESSED_DATA       
000012EE  163C 000D                380              MOVE.B  #$D,D3                  *carriage return
000012F2  6100 2AF4                381              BSR     PUSH_STACK
000012F6  163C 000A                382              MOVE.B  #$A,D3                  *new line feed
000012FA  6100 2AEC                383              BSR     PUSH_STACK
000012FE  163C 0000                384              MOVE.B  #$0,D3                  *null
00001302  6100 2AE4                385              BSR     PUSH_STACK
00001306                           386       
00001306  6100 2ABC                387              BSR     PRINT_QUEUE
0000130A  183C 0000                388              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000130E                           389  DISPLAY_30_LINES
0000130E                           390              * display 30 lines per page
0000130E  5206                     391              ADDI.B  #1,D6
00001310  0C06 001E                392              CMPI.B  #30,D6
00001314  6C00 0006                393              BGE     NEXTLINES
00001318  6000 FF50                394              BRA     MAIN
0000131C                           395            
0000131C                           396  *---------------------------------------------------------------------------*
0000131C                           397  * NEXTLINES: receive input from user to print the next 30 lines
0000131C                           398  *---------------------------------------------------------------------------*  
0000131C  4206                     399  NEXTLINES   CLR.B   D6
0000131E  43F9 000041A9            400              LEA     DISP_NEXT,A1
00001324  103C 000E                401              MOVE.B  #14,D0
00001328  4E4F                     402              TRAP    #15
0000132A  43F9 0000435D            403              LEA     TMPINPUT,A1
00001330  103C 0002                404              MOVE.B  #2,D0
00001334  4E4F                     405              TRAP    #15
00001336  4EF8 126A                406              JMP     MAIN
0000133A                           407    
0000133A                           408  *---------------------------------------------------------------------------*
0000133A                           409  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
0000133A                           410  *---------------------------------------------------------------------------*  
0000133A  4EF9 0000139A            411  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI/BTST                  *CMPI/ORI/ -
00001340  4EF9 000017FE            412              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
00001346  4EF9 0000186C            413              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
0000134C  4EF9 0000196A            414              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
00001352  4EF9 00001A66            415              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
00001358  4EF9 00001CBC            416              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
0000135E  4EF9 00001E60            417              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *NOT FINISHED - LYN
00001364  4EF9 00001EEE            418              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
0000136A  4EF9 00001EF2            419              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
00001370  4EF9 00001FFA            420              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
00001376  4EF9 000023B6            421              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
0000137C  4EF9 000023BA            422              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - JOSEPH
00001382  4EF9 000026BA            423              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
00001388  4EF9 00002A0C            424              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
0000138E  4EF9 00002DE8            425              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001394  4EF9 00003096            426              JMP     OP1111  * Special/Reserved
0000139A                           427              
0000139A                           428  *---------------------------------------------------------------------------*
0000139A                           429  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
0000139A                           430  *---------------------------------------------------------------------------*           
0000139A                           431  OP0000                                                                                  
0000139A  4281                     432              CLR.L   D1          * to temporarily store the address to process
0000139C  4280                     433              CLR.L   D0  
0000139E  4284                     434              CLR.L   D4                 
000013A0  227C 00000000            435              MOVEA.L #0, A1                
000013A6                           436              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013A6                           437              * Check if bit 11,10,9,8 are 0000)
000013A6  2205                     438              MOVE.L  D5,D1
000013A8  0281 00000F00            439              ANDI.L  #$0F00,D1
000013AE  0C81 00000000            440              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013B4  6700 0364                441              BEQ     OP_ORI
000013B8                           442  
000013B8                           443              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013B8                           444              * check if bit 11,10,9,8 are 1100
000013B8  4281                     445              CLR.L   D1
000013BA  2205                     446              MOVE.L  D5,D1
000013BC  0281 00000F00            447              ANDI.L  #$0F00,D1
000013C2  0C81 00000C00            448              CMPI.L  #$0C00,D1
000013C8  6700 0264                449              BEQ     OP0000_CMPI
000013CC                           450              
000013CC                           451              * check for SUBI
000013CC  4281                     452              CLR.L   D1
000013CE  2205                     453              MOVE.L  D5,D1
000013D0  0281 00000F00            454              ANDI.L  #$0F00,D1
000013D6  0C81 00000400            455              CMPI.L  #$0400,D1
000013DC  6700 01AE                456              BEQ     OP_SUBI
000013E0                           457              
000013E0                           458              * check for EORI
000013E0  4281                     459              CLR.L   D1
000013E2  2205                     460              MOVE.L  D5,D1
000013E4  0281 00000F00            461              ANDI.L  #$0F00,D1
000013EA  0C81 00000A00            462              CMPI.L  #$0A00,D1
000013F0  6700 0144                463              BEQ     OP_EORI
000013F4                           464              
000013F4                           465              * check for BTST
000013F4  4281                     466              CLR.L   D1
000013F6  2205                     467              MOVE.L  D5,D1
000013F8  E099                     468              ROR.L   #8,D1
000013FA  0281 00000001            469              ANDI.L  #$1,D1
00001400  0C01 0001                470              CMPI.B  #$1,D1
00001404  6700 001E                471              BEQ     OP_BTST
00001408  4281                     472              CLR.L   D1
0000140A  2205                     473              MOVE.L  D5,D1
0000140C  EC99                     474              ROR.L   #6,D1
0000140E  0281 000003FF            475              ANDI.L  #$03FF,D1
00001414  0C81 00000020            476              CMPI.L  #%000100000,D1
0000141A  6700 0008                477              BEQ     OP_BTST
0000141E                           478  
0000141E                           479  
0000141E                           480              * OP0000 series other than ORI/CMPI/BTST/EORI
0000141E  4EF9 000015E2            481              JMP     OP_DATA
00001424                           482              
00001424                           483  *---------------------------------------------------------------------------*
00001424                           484  * OP_BTST: display BTST
00001424                           485  *---------------------------------------------------------------------------* 
00001424                           486  OP_BTST       
00001424                           487              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
00001424                           488              *bits #8 indicates which
00001424                           489              *0 - #immediate format
00001424                           490              *1 - Dn format
00001424  4281                     491              CLR.L   D1
00001426  2205                     492              MOVE.L  D5,D1
00001428  E099                     493              ROR.L   #8,D1
0000142A  0281 00000001            494              ANDI.L  #1,D1
00001430  0C01 0001                495              CMPI.B  #1,D1
00001434  6600 0078                496              BNE     OP_BTST_IMMEDIATE
00001438                           497  
00001438                           498             
00001438                           499             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001438  13FC 0000 0000470E       500             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001440  13FC 0002 0000470F       501             MOVE.B   #$02,SRC_REGISTER_FORMAT
00001448                           502             
00001448                           503             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001448  13FC 00B9 00004711       504             MOVE.B   #$B9,GET_DST_START_END
00001450  13FC 0020 00004712       505             MOVE.B   #$20,GET_SRC_START_END
00001458                           506             
00001458  0285 0000FE3F            507             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000145E  0685 00000000            508             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001464                           509              
00001464                           510              *CLEAR D3
00001464  4283                     511              CLR.L   D3
00001466                           512              *LOAD STACK WITH THIS OPMODE
00001466  6100 2980                513              BSR     PUSH_STACK
0000146A  163C 0042                514              MOVE.B  #'B',D3
0000146E  6100 2978                515              BSR     PUSH_STACK
00001472  163C 0054                516              MOVE.B  #'T',D3
00001476  6100 2970                517              BSR     PUSH_STACK
0000147A  163C 0053                518              MOVE.B  #'S',D3
0000147E  6100 2968                519              BSR     PUSH_STACK
00001482  163C 0054                520              MOVE.B  #'T',D3
00001486  6100 2960                521              BSR     PUSH_STACK
0000148A  163C 002E                522              MOVE.B  #'.',D3
0000148E  6100 2958                523              BSR     PUSH_STACK
00001492  163C 0042                524              MOVE.B  #'B',D3
00001496  6100 2950                525              BSR     PUSH_STACK
0000149A                           526              
0000149A  6100 24DE                527              BSR     GET_EA_EA_DEST
0000149E  163C 002C                528              MOVE.B  #',',D3
000014A2  6100 2944                529              BSR     PUSH_STACK
000014A6  6100 20A2                530              BSR     GET_EA_EA_SRC
000014AA                           531              
000014AA  6000 0088                532              BRA     OP0000_RETURN_BTST
000014AE                           533              
000014AE                           534              
000014AE                           535              *MOVE **** OR **** CMPI
000014AE                           536              
000014AE                           537  OP_BTST_IMMEDIATE              
000014AE                           538   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000014AE  13FC 0000 0000470E       539             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014B6  13FC 0082 0000470F       540             MOVE.B   #$82,SRC_REGISTER_FORMAT
000014BE                           541             
000014BE                           542             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014BE  13FC 00B9 00004711       543             MOVE.B   #$B9,GET_DST_START_END
000014C6  13FC 0020 00004712       544             MOVE.B   #$20,GET_SRC_START_END
000014CE                           545             
000014CE                           546              *CLEAR D3
000014CE  4283                     547              CLR.L   D3
000014D0                           548              *LOAD STACK WITH THIS OPMODE
000014D0  6100 2916                549              BSR     PUSH_STACK
000014D4  163C 0042                550              MOVE.B  #'B',D3
000014D8  6100 290E                551              BSR     PUSH_STACK
000014DC  163C 0054                552              MOVE.B  #'T',D3
000014E0  6100 2906                553              BSR     PUSH_STACK
000014E4  163C 0053                554              MOVE.B  #'S',D3
000014E8  6100 28FE                555              BSR     PUSH_STACK
000014EC  163C 0054                556              MOVE.B  #'T',D3
000014F0  6100 28F6                557              BSR     PUSH_STACK
000014F4  163C 002E                558              MOVE.B  #'.',D3
000014F8  6100 28EE                559              BSR     PUSH_STACK
000014FC  163C 0042                560              MOVE.B  #'B',D3
00001500  6100 28E6                561              BSR     PUSH_STACK
00001504                           562  
00001504                           563  OP0000_BTST_B
00001504                           564              *GET DATA FROM ADDQ AND PRINT #0-8
00001504                           565              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001504  0285 0000F03F            566              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000150A  0685 000001C0            567              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001510                           568  
00001510                           569              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001510                           570             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001510                           571             * MOVE.W    (A5)+,D1
00001510                           572             * MOVE.B  #' ',D3
00001510                           573             * BSR     PUSH_STACK
00001510                           574             * MOVE.B  #'#',D3
00001510                           575             * BSR     PUSH_STACK
00001510                           576             * BSR     HEX2ASCII2STACK
00001510                           577             * BSR     PUSH_STACK
00001510                           578              
00001510  163C 0020                579              MOVE.B  #' ',D3
00001514  6100 28D2                580              BSR     PUSH_STACK
00001518  163C 0023                581              MOVE.B  #'#',D3
0000151C  6100 28CA                582              BSR     PUSH_STACK
00001520  6100 2458                583              BSR     GET_EA_EA_DEST
00001524  163C 002C                584              MOVE.B  #',',D3
00001528  6100 28BE                585              BSR     PUSH_STACK
0000152C  6100 201C                586              BSR     GET_EA_EA_SRC
00001530  6000 0002                587              BRA     OP0000_RETURN_BTST
00001534                           588  OP0000_RETURN_BTST
00001534                           589              
00001534  4E75                     590              RTS
00001536                           591  
00001536                           592  
00001536                           593  *---------------------------------------------------------------------------*
00001536                           594  * OP_EORI: decode and display EORI
00001536                           595  *---------------------------------------------------------------------------* 
00001536                           596  OP_EORI
00001536  4281                     597              CLR.L   D1
00001538  4284                     598              CLR.L   D4
0000153A  2205                     599              MOVE.L  D5,D1
0000153C  EC99                     600              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
0000153E  0C01 0000                601              CMPI.B  #0,D1
00001542  6700 0012                602              BEQ     OP_EORI_B    * size is byte
00001546  0C01 0001                603              CMPI.B  #1,D1
0000154A  6700 001C                604              BEQ     OP_EORI_W    * size is word
0000154E  0C01 0002                605              CMPI.B  #2,D1
00001552  6700 0026                606              BEQ     OP_EORI_L    * size is long
00001556                           607  
00001556                           608  OP_EORI_B    * size is byte    
00001556  183C 0000                609              MOVE.B  #0,D4
0000155A  43F9 00004418            610              LEA     DISP_EORI_B,A1
00001560  103C 000E                611              MOVE.B  #14,D0
00001564  4E4F                     612              TRAP    #15
00001566  4E75                     613              RTS
00001568                           614              
00001568                           615  OP_EORI_W    * size is word
00001568  183C 0001                616              MOVE.B  #1,D4
0000156C  43F9 00004422            617              LEA     DISP_EORI_W,A1
00001572  103C 000E                618              MOVE.B  #14,D0
00001576  4E4F                     619              TRAP    #15
00001578  4E75                     620              RTS
0000157A                           621              
0000157A                           622  OP_EORI_L    * size is long
0000157A  183C 0002                623              MOVE.B  #2,D4
0000157E  43F9 0000442C            624              LEA     DISP_EORI_L,A1
00001584  103C 000E                625              MOVE.B  #14,D0
00001588  4E4F                     626              TRAP    #15
0000158A  4E75                     627              RTS
0000158C                           628              
0000158C                           629  *---------------------------------------------------------------------------*
0000158C                           630  * OP_SUBI: decode SUBI.B/.W/.L
0000158C                           631  *---------------------------------------------------------------------------* 
0000158C                           632  OP_SUBI
0000158C  4281                     633              CLR.L   D1
0000158E  4284                     634              CLR.L   D4
00001590  2205                     635              MOVE.L  D5,D1
00001592  EC99                     636              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001594  0C01 0000                637              CMPI.B  #0,D1
00001598  6700 0012                638              BEQ     OP_SUBI_B    * size is byte
0000159C  0C01 0001                639              CMPI.B  #1,D1
000015A0  6700 001C                640              BEQ     OP_SUBI_W    * size is word
000015A4  0C01 0002                641              CMPI.B  #2,D1
000015A8  6700 0026                642              BEQ     OP_SUBI_L    * size is long
000015AC                           643  
000015AC                           644  OP_SUBI_B    * size is byte    
000015AC  183C 0000                645              MOVE.B  #0,D4
000015B0  43F9 00004524            646              LEA     DISP_SUBI_B,A1
000015B6  103C 000E                647              MOVE.B  #14,D0
000015BA  4E4F                     648              TRAP    #15
000015BC  4E75                     649              RTS
000015BE                           650              
000015BE                           651  OP_SUBI_W    * size is word
000015BE  183C 0001                652              MOVE.B  #1,D4
000015C2  43F9 0000452E            653              LEA     DISP_SUBI_W,A1
000015C8  103C 000E                654              MOVE.B  #14,D0
000015CC  4E4F                     655              TRAP    #15
000015CE  4E75                     656              RTS
000015D0                           657              
000015D0                           658  OP_SUBI_L    * size is long
000015D0  183C 0002                659              MOVE.B  #2,D4
000015D4  43F9 00004538            660              LEA     DISP_SUBI_L,A1
000015DA  103C 000E                661              MOVE.B  #14,D0
000015DE  4E4F                     662              TRAP    #15
000015E0  4E75                     663              RTS
000015E2                           664              
000015E2                           665  *---------------------------------------------------------------------------*
000015E2                           666  * OP_DATA : unidentified opcode
000015E2                           667  *---------------------------------------------------------------------------* 
000015E2                           668  OP_DATA
000015E2  4280                     669              CLR.L   D0                   
000015E4  4281                     670              CLR.L   D1     
000015E6  4284                     671              CLR.L   D4                    
000015E8  227C 00000000            672              MOVEA.L #0, A1             
000015EE  4287                     673              CLR.L   D7
000015F0  1E3C 0001                674              MOVE.B  #1,D7                   * error flag is true
000015F4                           675              
000015F4  43F9 0000445C            676              LEA     DISP_DATA,A1
000015FA  103C 000E                677              MOVE.B  #14,D0
000015FE  4E4F                     678              TRAP    #15
00001600                           679              
00001600  4EF9 00001606            680              JMP     EA_DATA
00001606                           681             
00001606                           682             
00001606                           683  *---------------------------------------------------------------------------*
00001606                           684  * EA_DATA
00001606                           685  *---------------------------------------------------------------------------*       
00001606  43F9 000043AD            686  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000160C  2205                     687              MOVE.L  D5,D1           * transfer the processing data to D1
0000160E  7404                     688              MOVE.L  #4,D2           * set to word size
00001610  4EB8 11C8                689              JSR     HEX2ASCII       * prepare output in ascii
00001614  43F9 000046CF            690              LEA     DISP_HEX,A1     * display $ symbol
0000161A  103C 000E                691              MOVE.B  #14,D0      
0000161E  4E4F                     692              TRAP    #15
00001620  43F9 000043AD            693              LEA     TMPOUTPUT,A1    * display with a new line
00001626  103C 000D                694              MOVE.B  #13,D0
0000162A  4E4F                     695              TRAP    #15
0000162C                           696  
0000162C  4E75                     697              RTS
0000162E                           698              
0000162E                           699  *---------------------------------------------------------------------------*
0000162E                           700  * OP_CMPI : decode CMPI and its size
0000162E                           701  *---------------------------------------------------------------------------*          
0000162E                           702  OP0000_CMPI
0000162E                           703  
0000162E                           704              
0000162E                           705   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000162E  13FC 0000 0000470E       706             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001636  13FC 0082 0000470F       707             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000163E                           708             
0000163E                           709             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000163E  13FC 00B9 00004711       710             MOVE.B   #$B9,GET_DST_START_END
00001646  13FC 0020 00004712       711             MOVE.B   #$20,GET_SRC_START_END
0000164E                           712             
0000164E                           713              *CLEAR D3
0000164E  4283                     714              CLR.L   D3
00001650                           715              *LOAD STACK WITH THIS OPMODE
00001650  6100 2796                716              BSR     PUSH_STACK
00001654  163C 0043                717              MOVE.B  #'C',D3
00001658  6100 278E                718              BSR     PUSH_STACK
0000165C  163C 004D                719              MOVE.B  #'M',D3
00001660  6100 2786                720              BSR     PUSH_STACK
00001664  163C 0050                721              MOVE.B  #'P',D3
00001668  6100 277E                722              BSR     PUSH_STACK
0000166C  163C 0049                723              MOVE.B  #'I',D3
00001670  6100 2776                724              BSR     PUSH_STACK
00001674  163C 002E                725              MOVE.B  #'.',D3
00001678  6100 276E                726              BSR     PUSH_STACK
0000167C                           727              
0000167C                           728              *FIGURE OUT SIZE*
0000167C                           729              *00 = BYTE
0000167C                           730              *01 = WORD
0000167C                           731              *10 = LONG
0000167C                           732              * BITS 7&6
0000167C                           733              
0000167C                           734              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000167C  2205                     735              MOVE.L  D5,D1
0000167E  EC99                     736              ROR.L   #6,D1
00001680  0281 00000003            737              ANDI.L  #$03,D1
00001686  0C01 0000                738              CMPI.B  #%00,D1
0000168A  6700 0018                739              BEQ     OP0000_CMPI_B
0000168E  0C01 0001                740              CMPI.B  #%01,D1
00001692  6700 0038                741              BEQ     OP0000_CMPI_W
00001696  0281 00000003            742              ANDI.L  #$03,D1
0000169C  0C01 0002                743              CMPI.B  #%10,D1
000016A0  6700 0052                744              BEQ     OP0000_CMPI_L
000016A4                           745  
000016A4                           746  OP0000_CMPI_B
000016A4  163C 0042                747              MOVE.B  #'B',D3
000016A8  6100 273E                748              BSR     PUSH_STACK
000016AC                           749  *GET DATA FROM ADDQ AND PRINT #0-8
000016AC                           750              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016AC  0285 0000F03F            751              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016B2  0685 000001C0            752              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000016B8  6100 22C0                753              BSR     GET_EA_EA_DEST
000016BC  163C 002C                754              MOVE.B  #',',D3
000016C0  6100 2726                755              BSR     PUSH_STACK
000016C4  6100 1E84                756              BSR     GET_EA_EA_SRC
000016C8  6000 004E                757              BRA     OP0000_RETURN_CMPI
000016CC                           758  
000016CC                           759  OP0000_CMPI_W
000016CC  163C 0057                760              MOVE.B  #'W',D3
000016D0  6100 2716                761              BSR     PUSH_STACK
000016D4                           762  *GET DATA FROM ADDQ AND PRINT #0-8
000016D4                           763              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016D4  0285 0000F03F            764              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016DA  0685 000001C0            765              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000016E0  6100 2298                766              BSR     GET_EA_EA_DEST
000016E4  163C 002C                767              MOVE.B  #',',D3
000016E8  6100 26FE                768              BSR     PUSH_STACK
000016EC  6100 1E5C                769              BSR     GET_EA_EA_SRC
000016F0  6000 0026                770              BRA     OP0000_RETURN_CMPI
000016F4                           771  
000016F4                           772  OP0000_CMPI_L
000016F4  163C 004C                773              MOVE.B  #'L',D3
000016F8  6100 26EE                774              BSR     PUSH_STACK
000016FC                           775              *GET DATA FROM ADDQ AND PRINT #0-8
000016FC                           776              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016FC  0285 0000F03F            777              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001702  0685 000003C0            778              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001708  6100 2270                779              BSR     GET_EA_EA_DEST
0000170C  163C 002C                780              MOVE.B  #',',D3
00001710  6100 26D6                781              BSR     PUSH_STACK
00001714  6100 1E34                782              BSR     GET_EA_EA_SRC
00001718                           783              
00001718                           784  OP0000_RETURN_CMPI
00001718                           785  
00001718                           786  
00001718                           787              
00001718  4E75                     788              RTS
0000171A                           789   
0000171A                           790  *---------------------------------------------------------------------------*
0000171A                           791  * OP_ORI : decode ORI and its size
0000171A                           792  *---------------------------------------------------------------------------* 
0000171A                           793  OP_ORI      
0000171A                           794           
0000171A                           795   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000171A  13FC 0000 0000470E       796             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001722  13FC 0082 0000470F       797             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000172A                           798             
0000172A                           799             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000172A  13FC 00B9 00004711       800             MOVE.B   #$B9,GET_DST_START_END
00001732  13FC 0020 00004712       801             MOVE.B   #$20,GET_SRC_START_END
0000173A                           802             
0000173A                           803              *CLEAR D3
0000173A  4283                     804              CLR.L   D3
0000173C                           805              *LOAD STACK WITH THIS OPMODE
0000173C  6100 26AA                806              BSR     PUSH_STACK
00001740  163C 004F                807              MOVE.B  #'O',D3
00001744  6100 26A2                808              BSR     PUSH_STACK
00001748  163C 0052                809              MOVE.B  #'R',D3
0000174C  6100 269A                810              BSR     PUSH_STACK
00001750  163C 0049                811              MOVE.B  #'I',D3
00001754  6100 2692                812              BSR     PUSH_STACK
00001758  163C 002E                813              MOVE.B  #'.',D3
0000175C  6100 268A                814              BSR     PUSH_STACK
00001760                           815              
00001760                           816              *FIGURE OUT SIZE*
00001760                           817              *00 = BYTE
00001760                           818              *01 = WORD
00001760                           819              *10 = LONG
00001760                           820              * BITS 7&6
00001760                           821              
00001760                           822              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001760  2205                     823              MOVE.L  D5,D1
00001762  EC99                     824              ROR.L   #6,D1
00001764  0281 00000003            825              ANDI.L  #$03,D1
0000176A  0C01 0000                826              CMPI.B  #%00,D1
0000176E  6700 0018                827              BEQ     OP0000_ORI_B
00001772  0C01 0001                828              CMPI.B  #%01,D1
00001776  6700 0038                829              BEQ     OP0000_ORI_W
0000177A  0281 00000003            830              ANDI.L  #$03,D1
00001780  0C01 0002                831              CMPI.B  #%10,D1
00001784  6700 0052                832              BEQ     OP0000_ORI_L
00001788                           833  
00001788                           834  OP0000_ORI_B
00001788  163C 0042                835              MOVE.B  #'B',D3
0000178C  6100 265A                836              BSR     PUSH_STACK
00001790                           837  *GET DATA FROM ADDQ AND PRINT #0-8
00001790                           838              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001790  0285 0000F03F            839              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001796  0685 000001C0            840              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000179C  6100 21DC                841              BSR     GET_EA_EA_DEST
000017A0  163C 002C                842              MOVE.B  #',',D3
000017A4  6100 2642                843              BSR     PUSH_STACK
000017A8  6100 1DA0                844              BSR     GET_EA_EA_SRC
000017AC  6000 004E                845              BRA     OP0000_RETURN_ORI
000017B0                           846  
000017B0                           847  OP0000_ORI_W
000017B0  163C 0057                848              MOVE.B  #'W',D3
000017B4  6100 2632                849              BSR     PUSH_STACK
000017B8                           850  *GET DATA FROM ADDQ AND PRINT #0-8
000017B8                           851              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000017B8  0285 0000F03F            852              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000017BE  0685 000001C0            853              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000017C4  6100 21B4                854              BSR     GET_EA_EA_DEST
000017C8  163C 002C                855              MOVE.B  #',',D3
000017CC  6100 261A                856              BSR     PUSH_STACK
000017D0  6100 1D78                857              BSR     GET_EA_EA_SRC
000017D4  6000 0026                858              BRA     OP0000_RETURN_ORI
000017D8                           859  
000017D8                           860  OP0000_ORI_L
000017D8  163C 004C                861              MOVE.B  #'L',D3
000017DC  6100 260A                862              BSR     PUSH_STACK
000017E0                           863              *GET DATA FROM ADDQ AND PRINT #0-8
000017E0                           864              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000017E0  0285 0000F03F            865              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000017E6  0685 000003C0            866              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000017EC  6100 218C                867              BSR     GET_EA_EA_DEST
000017F0  163C 002C                868              MOVE.B  #',',D3
000017F4  6100 25F2                869              BSR     PUSH_STACK
000017F8  6100 1D50                870              BSR     GET_EA_EA_SRC
000017FC                           871              
000017FC                           872  OP0000_RETURN_ORI
000017FC                           873  
000017FC                           874  
000017FC                           875              
000017FC  4E75                     876              RTS
000017FE                           877  
000017FE                           878          
000017FE                           879  *---------------------------------------------------------------------------*
000017FE                           880  * OP0001: MOVE.B
000017FE                           881  *---------------------------------------------------------------------------*
000017FE                           882  OP0001      
000017FE  4EF9 00001804            883              JMP     OP_MOVE_B   * display MOVE.B
00001804                           884              
00001804                           885  *---------------------------------------------------------------------------*
00001804                           886  * OP_MOVE_B: display MOVE_B and proceed to EA
00001804                           887  *---------------------------------------------------------------------------*
00001804                           888  OP_MOVE_B                                                                       
00001804                           889             
00001804                           890             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001804  13FC 0082 0000470E       891             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000180C  13FC 0000 0000470F       892             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001814                           893             
00001814                           894             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001814  13FC 00B9 00004711       895             MOVE.B   #$B9,GET_DST_START_END
0000181C  13FC 0020 00004712       896             MOVE.B   #$20,GET_SRC_START_END
00001824                           897             
00001824                           898              *CLEAR D3
00001824  4283                     899              CLR.L   D3
00001826                           900              *LOAD STACK WITH THIS OPMODE
00001826  6100 25C0                901              BSR     PUSH_STACK
0000182A  163C 004D                902              MOVE.B  #'M',D3
0000182E  6100 25B8                903              BSR     PUSH_STACK
00001832  163C 004F                904              MOVE.B  #'O',D3
00001836  6100 25B0                905              BSR     PUSH_STACK
0000183A  163C 0056                906              MOVE.B  #'V',D3
0000183E  6100 25A8                907              BSR     PUSH_STACK
00001842  163C 0045                908              MOVE.B  #'E',D3
00001846  6100 25A0                909              BSR     PUSH_STACK
0000184A  163C 002E                910              MOVE.B  #'.',D3
0000184E  6100 2598                911              BSR     PUSH_STACK
00001852  163C 0042                912              MOVE.B  #'B',D3
00001856  6100 2590                913              BSR     PUSH_STACK
0000185A                           914              
0000185A  6100 1CEE                915              BSR     GET_EA_EA_SRC
0000185E  163C 002C                916              MOVE.B  #',',D3
00001862  6100 2584                917              BSR     PUSH_STACK
00001866  6100 2112                918              BSR     GET_EA_EA_DEST
0000186A                           919              
0000186A  4E75                     920              RTS
0000186C                           921              
0000186C                           922             
0000186C                           923  *---------------------------------------------------------------------------*
0000186C                           924  * OP0010: decode MOVE.L/MOVEA.L
0000186C                           925  *---------------------------------------------------------------------------*
0000186C                           926  OP0010      
0000186C  183C 0002                927              MOVE.B  #2,D4
00001870  4280                     928              CLR.L   D0                     
00001872  4281                     929              CLR.L   D1                      
00001874  227C 00000000            930              MOVEA.L #0, A1                 
0000187A                           931              
0000187A  2205                     932              MOVE.L  D5,D1
0000187C  EA99                     933              ROR.L   #5,D1
0000187E  0281 0000000E            934              ANDI.L  #$E,D1
00001884  0C01 0002                935              CMPI.B  #2,D1
00001888  6700 0070                936              BEQ     OP_MOVEA_L
0000188C                           937  
0000188C  4EF9 00001892            938              JMP     OP_MOVE_L
00001892                           939             
00001892                           940  
00001892                           941  *---------------------------------------------------------------------------*
00001892                           942  * OP_MOVE_L: display MOVE_L and proceed to EA
00001892                           943  *---------------------------------------------------------------------------*
00001892                           944  OP_MOVE_L   
00001892                           945             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001892  13FC 0082 0000470E       946             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000189A  13FC 0000 0000470F       947             MOVE.B   #$00,SRC_REGISTER_FORMAT
000018A2                           948             
000018A2                           949             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000018A2  13FC 00B9 00004711       950             MOVE.B   #$B9,GET_DST_START_END
000018AA  13FC 0020 00004712       951             MOVE.B   #$20,GET_SRC_START_END
000018B2                           952             
000018B2                           953              *CLEAR D3
000018B2  4283                     954              CLR.L   D3
000018B4                           955              *LOAD STACK WITH THIS OPMODE
000018B4  6100 2532                956              BSR     PUSH_STACK
000018B8  163C 004D                957              MOVE.B  #'M',D3
000018BC  6100 252A                958              BSR     PUSH_STACK
000018C0  163C 004F                959              MOVE.B  #'O',D3
000018C4  6100 2522                960              BSR     PUSH_STACK
000018C8  163C 0056                961              MOVE.B  #'V',D3
000018CC  6100 251A                962              BSR     PUSH_STACK
000018D0  163C 0045                963              MOVE.B  #'E',D3
000018D4  6100 2512                964              BSR     PUSH_STACK
000018D8  163C 002E                965              MOVE.B  #'.',D3
000018DC  6100 250A                966              BSR     PUSH_STACK
000018E0  163C 004C                967              MOVE.B  #'L',D3
000018E4  6100 2502                968              BSR     PUSH_STACK
000018E8                           969              
000018E8  6100 1C60                970              BSR     GET_EA_EA_SRC
000018EC  163C 002C                971              MOVE.B  #',',D3
000018F0  6100 24F6                972              BSR     PUSH_STACK
000018F4  6100 2084                973              BSR     GET_EA_EA_DEST
000018F8                           974              
000018F8  4E75                     975              RTS
000018FA                           976  
000018FA                           977  
000018FA                           978  *---------------------------------------------------------------------------*
000018FA                           979  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000018FA                           980  *---------------------------------------------------------------------------*
000018FA                           981  OP_MOVEA_L 
000018FA                           982             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018FA  13FC 00FD 0000470E       983             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001902  13FC 0000 0000470F       984             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000190A                           985             
0000190A                           986             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000190A  13FC 00B9 00004711       987             MOVE.B   #$B9,GET_DST_START_END
00001912  13FC 0020 00004712       988             MOVE.B   #$20,GET_SRC_START_END
0000191A                           989             
0000191A                           990              *CLEAR D3
0000191A  4283                     991              CLR.L   D3
0000191C                           992              *LOAD STACK WITH THIS OPMODE
0000191C  6100 24CA                993              BSR     PUSH_STACK
00001920  163C 004D                994              MOVE.B  #'M',D3
00001924  6100 24C2                995              BSR     PUSH_STACK
00001928  163C 004F                996              MOVE.B  #'O',D3
0000192C  6100 24BA                997              BSR     PUSH_STACK
00001930  163C 0056                998              MOVE.B  #'V',D3
00001934  6100 24B2                999              BSR     PUSH_STACK
00001938  163C 0045               1000              MOVE.B  #'E',D3
0000193C  6100 24AA               1001              BSR     PUSH_STACK           
00001940  163C 0041               1002              MOVE.B  #'A',D3
00001944  6100 24A2               1003              BSR     PUSH_STACK
00001948  163C 002E               1004              MOVE.B  #'.',D3
0000194C  6100 249A               1005              BSR     PUSH_STACK
00001950  163C 004C               1006              MOVE.B  #'L',D3
00001954  6100 2492               1007              BSR     PUSH_STACK
00001958                          1008              
00001958  6100 1BF0               1009              BSR     GET_EA_EA_SRC
0000195C  163C 002C               1010              MOVE.B  #',',D3
00001960  6100 2486               1011              BSR     PUSH_STACK
00001964  6100 2014               1012              BSR     GET_EA_EA_DEST
00001968                          1013              
00001968  4E75                    1014              RTS
0000196A                          1015  
0000196A                          1016              
0000196A                          1017  *---------------------------------------------------------------------------*
0000196A                          1018  * OP0011: decode MOVE.W/MOVEA.W
0000196A                          1019  *---------------------------------------------------------------------------*
0000196A                          1020  OP0011      
0000196A  4280                    1021              CLR.L   D0                      
0000196C  4281                    1022              CLR.L   D1  
0000196E  4284                    1023              CLR.L   D4                   
00001970  227C 00000000           1024              MOVEA.L #0, A1 
00001976                          1025                
00001976  2205                    1026              MOVE.L  D5,D1
00001978  EC99                    1027              ROR.L   #6,D1
0000197A  0281 00000007           1028              ANDI.L  #$07,D1
00001980  0C01 0001               1029              CMPI.B  #1,D1
00001984  6700 0070               1030              BEQ     OP_MOVEA_W
00001988                          1031              
00001988  4EF9 0000198E           1032              JMP     OP_MOVE_W
0000198E                          1033            
0000198E                          1034  *---------------------------------------------------------------------------*
0000198E                          1035  * OP_MOVE_W: display MOVE_W and proceed to EA
0000198E                          1036  *---------------------------------------------------------------------------*
0000198E                          1037  OP_MOVE_W   
0000198E                          1038             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000198E  13FC 0082 0000470E      1039             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001996  13FC 0000 0000470F      1040             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000199E                          1041             
0000199E                          1042             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000199E  13FC 00B9 00004711      1043             MOVE.B   #$B9,GET_DST_START_END
000019A6  13FC 0020 00004712      1044             MOVE.B   #$20,GET_SRC_START_END
000019AE                          1045             
000019AE                          1046              *CLEAR D3
000019AE  4283                    1047              CLR.L   D3
000019B0                          1048              *LOAD STACK WITH THIS OPMODE
000019B0  6100 2436               1049              BSR     PUSH_STACK
000019B4  163C 004D               1050              MOVE.B  #'M',D3
000019B8  6100 242E               1051              BSR     PUSH_STACK
000019BC  163C 004F               1052              MOVE.B  #'O',D3
000019C0  6100 2426               1053              BSR     PUSH_STACK
000019C4  163C 0056               1054              MOVE.B  #'V',D3
000019C8  6100 241E               1055              BSR     PUSH_STACK
000019CC  163C 0045               1056              MOVE.B  #'E',D3
000019D0  6100 2416               1057              BSR     PUSH_STACK
000019D4  163C 002E               1058              MOVE.B  #'.',D3
000019D8  6100 240E               1059              BSR     PUSH_STACK
000019DC  163C 0057               1060              MOVE.B  #'W',D3
000019E0  6100 2406               1061              BSR     PUSH_STACK
000019E4                          1062              
000019E4  6100 1B64               1063              BSR     GET_EA_EA_SRC
000019E8  163C 002C               1064              MOVE.B  #',',D3
000019EC  6100 23FA               1065              BSR     PUSH_STACK
000019F0  6100 1F88               1066              BSR     GET_EA_EA_DEST
000019F4                          1067              
000019F4  4E75                    1068              RTS
000019F6                          1069  
000019F6                          1070  *---------------------------------------------------------------------------*
000019F6                          1071  * OP_MOVEA_W: display MOVEA and proceed to EA
000019F6                          1072  *---------------------------------------------------------------------------*
000019F6                          1073  OP_MOVEA_W 
000019F6                          1074             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019F6  13FC 00FD 0000470E      1075             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000019FE  13FC 0000 0000470F      1076             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A06                          1077             
00001A06                          1078             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A06  13FC 00B9 00004711      1079             MOVE.B   #$B9,GET_DST_START_END
00001A0E  13FC 0020 00004712      1080             MOVE.B   #$20,GET_SRC_START_END
00001A16                          1081             
00001A16                          1082              *CLEAR D3
00001A16  4283                    1083              CLR.L   D3
00001A18                          1084              *LOAD STACK WITH THIS OPMODE
00001A18  6100 23CE               1085              BSR     PUSH_STACK
00001A1C  163C 004D               1086              MOVE.B  #'M',D3
00001A20  6100 23C6               1087              BSR     PUSH_STACK
00001A24  163C 004F               1088              MOVE.B  #'O',D3
00001A28  6100 23BE               1089              BSR     PUSH_STACK
00001A2C  163C 0056               1090              MOVE.B  #'V',D3
00001A30  6100 23B6               1091              BSR     PUSH_STACK
00001A34  163C 0045               1092              MOVE.B  #'E',D3
00001A38  6100 23AE               1093              BSR     PUSH_STACK           
00001A3C  163C 0041               1094              MOVE.B  #'A',D3
00001A40  6100 23A6               1095              BSR     PUSH_STACK
00001A44  163C 002E               1096              MOVE.B  #'.',D3
00001A48  6100 239E               1097              BSR     PUSH_STACK
00001A4C  163C 0057               1098              MOVE.B  #'W',D3
00001A50  6100 2396               1099              BSR     PUSH_STACK
00001A54                          1100              
00001A54  6100 1AF4               1101              BSR     GET_EA_EA_SRC
00001A58  163C 002C               1102              MOVE.B  #',',D3
00001A5C  6100 238A               1103              BSR     PUSH_STACK
00001A60  6100 1F18               1104              BSR     GET_EA_EA_DEST
00001A64                          1105            
00001A64  4E75                    1106              RTS
00001A66                          1107  *---------------------------------------------------------------------------*
00001A66                          1108  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001A66                          1109  *---------------------------------------------------------------------------*
00001A66                          1110  OP0100
00001A66  4280                    1111              CLR.L   D0                      
00001A68  4281                    1112              CLR.L   D1  
00001A6A  4284                    1113              CLR.L   D4                      
00001A6C  227C 00000000           1114              MOVEA.L #0, A1                  
00001A72  2205                    1115              MOVE.L  D5,D1  
00001A74                          1116              
00001A74                          1117              * check for RTS
00001A74  0C41 4E75               1118              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001A78  6700 0228               1119              BEQ     OP_RTS
00001A7C                          1120              
00001A7C                          1121              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001A7C  4281                    1122              CLR.L   D1 
00001A7E  2205                    1123              MOVE.L  D5,D1  
00001A80  0241 0F00               1124              ANDI.W  #$0F00,D1
00001A84  0C41 0E00               1125              CMPI.W  #$0E00,D1
00001A88  6700 0204               1126              BEQ     OP_JSR
00001A8C                          1127  
00001A8C                          1128              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001A8C  4281                    1129              CLR.L   D1 
00001A8E  2205                    1130              MOVE.L  D5,D1  
00001A90  0241 0F00               1131              ANDI.W  #$0F00,D1
00001A94  0C41 0400               1132              CMPI.W  #$0400,D1
00001A98  6700 00E8               1133              BEQ     OP_NEG
00001A9C                          1134              
00001A9C                          1135              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001A9C  4281                    1136              CLR.L   D1 
00001A9E  2205                    1137              MOVE.L  D5,D1  
00001AA0  0241 0F00               1138              ANDI.W  #$0F00,D1
00001AA4  0C41 0600               1139              CMPI.W  #$0600,D1
00001AA8  6700 015E               1140              BEQ     OP_NOT
00001AAC                          1141              
00001AAC                          1142              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001AAC  4281                    1143              CLR.L   D1 
00001AAE  2205                    1144              MOVE.L  D5,D1  
00001AB0  EC99                    1145              ROR.L   #6,D1
00001AB2  0281 00000007           1146              ANDI.L  #7,D1
00001AB8  0C81 00000007           1147              CMPI.L  #7,D1
00001ABE  6700 0054               1148              BEQ     OP_LEA
00001AC2                          1149              
00001AC2                          1150              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001AC2  4281                    1151              CLR.L   D1 
00001AC4  2205                    1152              MOVE.L  D5,D1  
00001AC6  EB59                    1153              ROL.W   #5,D1
00001AC8  0C01 0001               1154              CMPI.B  #1,D1
00001ACC  6600 FB14               1155              BNE     OP_DATA
00001AD0  E959                    1156              ROL.W   #4,D1
00001AD2  0C01 0001               1157              CMPI.B  #1,D1
00001AD6  6600 FB0A               1158              BNE     OP_DATA
00001ADA  E359                    1159              ROL.W   #1,D1
00001ADC  0C01 0000               1160              CMPI.B  #0,D1
00001AE0  6700 000E               1161              BEQ     OP_MOVEM_W
00001AE4  0C01 0001               1162              CMPI.B  #1,D1
00001AE8  6700 0018               1163              BEQ     OP_MOVEM_L
00001AEC  4EF8 15E2               1164              JMP     OP_DATA
00001AF0                          1165  
00001AF0                          1166  *---------------------------------------------------------------------------*
00001AF0                          1167  * OP_MOVEM_W: display MOVEM_W
00001AF0                          1168  *---------------------------------------------------------------------------*    
00001AF0                          1169  OP_MOVEM_W  
00001AF0  183C 0001               1170              MOVE.B  #1,D4
00001AF4  43F9 000044CD           1171              LEA     DISP_MOVEM_W,A1
00001AFA  103C 000E               1172              MOVE.B  #14,D0
00001AFE  4E4F                    1173              TRAP    #15
00001B00  4E75                    1174              RTS
00001B02                          1175  
00001B02                          1176  *---------------------------------------------------------------------------*
00001B02                          1177  * OP_MOVEM_L: display MOVEM_L
00001B02                          1178  *---------------------------------------------------------------------------*
00001B02                          1179  OP_MOVEM_L  
00001B02  183C 0002               1180              MOVE.B  #2,D4
00001B06  43F9 000044D8           1181              LEA     DISP_MOVEM_L,A1
00001B0C  103C 000E               1182              MOVE.B  #14,D0
00001B10  4E4F                    1183              TRAP    #15
00001B12  4E75                    1184              RTS
00001B14                          1185     
00001B14                          1186  *---------------------------------------------------------------------------*
00001B14                          1187  * OP_LEA: decode and display LEA
00001B14                          1188  *---------------------------------------------------------------------------*
00001B14                          1189  OP_LEA      
00001B14  4281                    1190               CLR.L   D1       
00001B16  4284                    1191              CLR.L   D4                   
00001B18  227C 00000000           1192              MOVEA.L #0, A1              
00001B1E  2205                    1193              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001B20                          1194              *CLEAR D3
00001B20  4283                    1195              CLR.L   D3
00001B22                          1196  
00001B22                          1197  OP_LEA_DN_EA_OR_EA_DN 
00001B22                          1198              *LOAD STACK WITH THIS OPMODE
00001B22  6100 22C4               1199              BSR     PUSH_STACK
00001B26  163C 004C               1200              MOVE.B  #'L',D3
00001B2A  6100 22BC               1201              BSR     PUSH_STACK
00001B2E  163C 0045               1202              MOVE.B  #'E',D3
00001B32  6100 22B4               1203              BSR     PUSH_STACK
00001B36  163C 0041               1204              MOVE.B  #'A',D3
00001B3A  6100 22AC               1205              BSR     PUSH_STACK
00001B3E  2205                    1206              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001B40                          1207          
00001B40                          1208  
00001B40                          1209  OP_PRINT_L_LEA
00001B40                          1210                          
00001B40                          1211              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B40  13FC 0000 0000470E      1212              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001B48  13FC 009B 0000470F      1213              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001B50                          1214             
00001B50                          1215              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B50  13FC 00B9 00004711      1216              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001B58  13FC 0020 00004712      1217              MOVE.B   #$20,GET_SRC_START_END
00001B60                          1218  
00001B60                          1219              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001B60  0285 0000FE3F           1220              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001B66  0685 00000040           1221              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001B6C                          1222  
00001B6C  6100 19DC               1223              BSR     GET_EA_EA_SRC      *GETS <ea>
00001B70  163C 002C               1224              MOVE.B  #',',D3
00001B74  6100 2272               1225              BSR     PUSH_STACK           
00001B78  6100 1E00               1226              BSR     GET_EA_EA_DEST       *GETS Dn    
00001B7C                          1227  
00001B7C                          1228              
00001B7C  6000 0002               1229              BRA     OP_LEA_RETURN
00001B80                          1230              
00001B80                          1231  OP_LEA_RETURN
00001B80  4E75                    1232              RTS
00001B82                          1233              
00001B82                          1234  
00001B82                          1235  
00001B82                          1236  *---------------------------------------------------------------------------*
00001B82                          1237  * OP_NEG: decode and display NEG 
00001B82                          1238  *---------------------------------------------------------------------------*
00001B82                          1239  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001B82  4281                    1240              CLR.L   D1
00001B84  4284                    1241              CLR.L   D4
00001B86  2205                    1242              MOVE.L  D5,D1
00001B88                          1243              
00001B88                          1244              *CLEAR D3
00001B88  4283                    1245              CLR.L   D3
00001B8A                          1246              *LOAD STACK WITH THIS OPMODE
00001B8A  6100 225C               1247              BSR     PUSH_STACK
00001B8E  163C 004E               1248              MOVE.B  #'N',D3
00001B92  6100 2254               1249              BSR     PUSH_STACK
00001B96  163C 0045               1250              MOVE.B  #'E',D3
00001B9A  6100 224C               1251              BSR     PUSH_STACK
00001B9E  163C 0047               1252              MOVE.B  #'G',D3
00001BA2  6100 2244               1253              BSR     PUSH_STACK
00001BA6  163C 002E               1254              MOVE.B  #'.',D3
00001BAA  6100 223C               1255              BSR     PUSH_STACK
00001BAE                          1256              
00001BAE                          1257              
00001BAE  EC99                    1258              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001BB0  0281 00000007           1259              ANDI.L  #$07,D1
00001BB6                          1260              
00001BB6  0C01 0000               1261              CMPI.B  #0,D1
00001BBA  6700 0012               1262              BEQ     OP_NEG_B    * size is byte
00001BBE  0C01 0001               1263              CMPI.B  #1,D1
00001BC2  6700 0016               1264              BEQ     OP_NEG_W    * size is word
00001BC6  0C01 0002               1265              CMPI.B  #2,D1
00001BCA  6700 001A               1266              BEQ     OP_NEG_L    * size is long
00001BCE                          1267                         
00001BCE                          1268  
00001BCE                          1269  OP_NEG_B    * size is byte   
00001BCE  163C 0042               1270              MOVE.B  #'B',D3
00001BD2  6100 2214               1271              BSR     PUSH_STACK
00001BD6  6000 001A               1272              BRA     OP_NEG_PRINT_EA
00001BDA                          1273  
00001BDA                          1274              
00001BDA                          1275  OP_NEG_W    * size is word
00001BDA  163C 0057               1276              MOVE.B  #'W',D3
00001BDE  6100 2208               1277              BSR     PUSH_STACK
00001BE2  6000 000E               1278              BRA     OP_NEG_PRINT_EA
00001BE6                          1279  
00001BE6                          1280              
00001BE6                          1281  OP_NEG_L    * size is long
00001BE6  163C 004C               1282              MOVE.B  #'L',D3
00001BEA  6100 21FC               1283              BSR     PUSH_STACK
00001BEE  6000 0002               1284              BRA     OP_NEG_PRINT_EA
00001BF2                          1285  
00001BF2                          1286  
00001BF2                          1287  OP_NEG_PRINT_EA
00001BF2                          1288   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001BF2  13FC 0082 0000470F      1289             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001BFA                          1290             
00001BFA                          1291             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001BFA  13FC 0020 00004712      1292             MOVE.B   #$20,GET_SRC_START_END
00001C02                          1293                         
00001C02                          1294  
00001C02  6100 1946               1295              BSR     GET_EA_EA_SRC
00001C06                          1296              
00001C06  4E75                    1297              RTS
00001C08                          1298  
00001C08                          1299  *---------------------------------------------------------------------------*
00001C08                          1300  * OP_NOT: decode and display NOT 
00001C08                          1301  *---------------------------------------------------------------------------*
00001C08                          1302  OP_NOT
00001C08  4281                    1303              CLR.L   D1
00001C0A  4284                    1304              CLR.L   D4
00001C0C  2205                    1305              MOVE.L  D5,D1
00001C0E                          1306              
00001C0E                          1307              *CLEAR D3
00001C0E  4283                    1308              CLR.L   D3
00001C10                          1309              *LOAD STACK WITH THIS OPMODE
00001C10  6100 21D6               1310              BSR     PUSH_STACK
00001C14  163C 004E               1311              MOVE.B  #'N',D3
00001C18  6100 21CE               1312              BSR     PUSH_STACK
00001C1C  163C 004F               1313              MOVE.B  #'O',D3
00001C20  6100 21C6               1314              BSR     PUSH_STACK
00001C24  163C 0054               1315              MOVE.B  #'T',D3
00001C28  6100 21BE               1316              BSR     PUSH_STACK
00001C2C  163C 002E               1317              MOVE.B  #'.',D3
00001C30  6100 21B6               1318              BSR     PUSH_STACK
00001C34                          1319              
00001C34                          1320              
00001C34  EC99                    1321              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001C36  0281 00000007           1322              ANDI.L  #$07,D1
00001C3C                          1323              
00001C3C  0C01 0000               1324              CMPI.B  #0,D1
00001C40  6700 0012               1325              BEQ     OP_NOT_B    * size is byte
00001C44  0C01 0001               1326              CMPI.B  #1,D1
00001C48  6700 0016               1327              BEQ     OP_NOT_W    * size is word
00001C4C  0C01 0002               1328              CMPI.B  #2,D1
00001C50  6700 001A               1329              BEQ     OP_NOT_L    * size is long
00001C54                          1330                         
00001C54                          1331  
00001C54                          1332  OP_NOT_B    * size is byte   
00001C54  163C 0042               1333              MOVE.B  #'B',D3
00001C58  6100 218E               1334              BSR     PUSH_STACK
00001C5C  6000 001A               1335              BRA     OP_NOT_PRINT_EA
00001C60                          1336  
00001C60                          1337              
00001C60                          1338  OP_NOT_W    * size is word
00001C60  163C 0057               1339              MOVE.B  #'W',D3
00001C64  6100 2182               1340              BSR     PUSH_STACK
00001C68  6000 000E               1341              BRA     OP_NOT_PRINT_EA
00001C6C                          1342  
00001C6C                          1343              
00001C6C                          1344  OP_NOT_L    * size is long
00001C6C  163C 004C               1345              MOVE.B  #'L',D3
00001C70  6100 2176               1346              BSR     PUSH_STACK
00001C74  6000 0002               1347              BRA     OP_NOT_PRINT_EA
00001C78                          1348  
00001C78                          1349  
00001C78                          1350  OP_NOT_PRINT_EA
00001C78                          1351   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C78  13FC 0082 0000470F      1352             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001C80                          1353             
00001C80                          1354             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C80  13FC 0020 00004712      1355             MOVE.B   #$20,GET_SRC_START_END
00001C88  6100 18C0               1356              BSR     GET_EA_EA_SRC
00001C8C                          1357              
00001C8C  4E75                    1358              RTS
00001C8E                          1359  
00001C8E                          1360  
00001C8E                          1361  *---------------------------------------------------------------------------*
00001C8E                          1362  * OP_JSR: display JSR     
00001C8E                          1363  *---------------------------------------------------------------------------*
00001C8E  43F9 00004489           1364  OP_JSR      LEA     DISP_JSR,A1
00001C94  103C 000E               1365              MOVE.B  #14,D0
00001C98  4E4F                    1366              TRAP    #15
00001C9A  4EB9 0000309A           1367              JSR     EA_NOSRC
00001CA0                          1368  
00001CA0  4E75                    1369              RTS
00001CA2                          1370  
00001CA2                          1371  *---------------------------------------------------------------------------*
00001CA2                          1372  * OP_RTS: display RTS     
00001CA2                          1373  *---------------------------------------------------------------------------* 
00001CA2                          1374  OP_RTS      
00001CA2  163C 0052               1375              MOVE.B #'R',D3
00001CA6  6100 2140               1376              BSR     PUSH_STACK
00001CAA  163C 0054               1377              MOVE.B #'T',D3
00001CAE  6100 2138               1378              BSR     PUSH_STACK
00001CB2  163C 0053               1379              MOVE.B #'S',D3
00001CB6  6100 2130               1380              BSR     PUSH_STACK
00001CBA  4E75                    1381              RTS
00001CBC                          1382  
00001CBC                          1383  *---------------------------------------------------------------------------*
00001CBC                          1384  * OP0101: decode ADDQ
00001CBC                          1385  *---------------------------------------------------------------------------* 
00001CBC                          1386  OP0101      
00001CBC                          1387             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CBC  13FC 0082 0000470E      1388             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001CC4  13FC 0080 0000470F      1389             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001CCC                          1390             
00001CCC                          1391             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CCC  13FC 00B9 00004711      1392             MOVE.B   #$B9,GET_DST_START_END
00001CD4  13FC 0020 00004712      1393             MOVE.B   #$20,GET_SRC_START_END
00001CDC                          1394             
00001CDC                          1395              *CLEAR D3
00001CDC  4283                    1396              CLR.L   D3
00001CDE                          1397              *LOAD STACK WITH THIS OPMODE
00001CDE  6100 2108               1398              BSR     PUSH_STACK
00001CE2  163C 0041               1399              MOVE.B  #'A',D3
00001CE6  6100 2100               1400              BSR     PUSH_STACK
00001CEA  163C 0044               1401              MOVE.B  #'D',D3
00001CEE  6100 20F8               1402              BSR     PUSH_STACK
00001CF2  163C 0044               1403              MOVE.B  #'D',D3
00001CF6  6100 20F0               1404              BSR     PUSH_STACK
00001CFA  163C 0051               1405              MOVE.B  #'Q',D3
00001CFE  6100 20E8               1406              BSR     PUSH_STACK
00001D02  163C 002E               1407              MOVE.B  #'.',D3
00001D06  6100 20E0               1408              BSR     PUSH_STACK
00001D0A                          1409              
00001D0A                          1410              *FIGURE OUT SIZE*
00001D0A                          1411              *00 = BYTE
00001D0A                          1412              *01 = WORD
00001D0A                          1413              *10 = LONG
00001D0A                          1414              * BITS 7&6
00001D0A                          1415              
00001D0A                          1416              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001D0A  2205                    1417              MOVE.L  D5,D1
00001D0C  EC99                    1418              ROR.L   #6,D1
00001D0E  0281 00000003           1419              ANDI.L  #$03,D1
00001D14  0C01 0000               1420              CMPI.B  #%00,D1
00001D18  6700 001E               1421              BEQ     OP0101_ADDQ_B
00001D1C  0281 00000003           1422              ANDI.L  #$03,D1
00001D22  0C01 0001               1423              CMPI.B  #%01,D1
00001D26  6700 001C               1424              BEQ     OP0101_ADDQ_W
00001D2A  0281 00000003           1425              ANDI.L  #$03,D1
00001D30  0C01 0002               1426              CMPI.B  #%10,D1
00001D34  6700 001A               1427              BEQ     OP0101_ADDQ_L
00001D38                          1428            
00001D38                          1429  OP0101_ADDQ_B
00001D38                          1430              
00001D38  163C 0042               1431              MOVE.B  #'B',D3
00001D3C  6100 20AA               1432              BSR     PUSH_STACK
00001D40  6000 0016               1433              BRA     OP0101_RETURN
00001D44                          1434  OP0101_ADDQ_W
00001D44                          1435              
00001D44  163C 0057               1436              MOVE.B  #'W',D3
00001D48  6100 209E               1437              BSR     PUSH_STACK
00001D4C  6000 000A               1438              BRA     OP0101_RETURN
00001D50                          1439  OP0101_ADDQ_L
00001D50                          1440              
00001D50  163C 004C               1441              MOVE.B  #'L',D3
00001D54  6100 2092               1442              BSR     PUSH_STACK
00001D58                          1443  OP0101_RETURN            
00001D58                          1444  
00001D58                          1445              
00001D58                          1446  *GET DATA FROM ADDQ AND PRINT #0-8
00001D58  163C 0020               1447              MOVE.B  #' ',D3
00001D5C  6100 208A               1448              BSR     PUSH_STACK
00001D60  163C 0023               1449              MOVE.B  #'#',D3
00001D64  6100 2082               1450              BSR     PUSH_STACK 
00001D68                          1451  
00001D68                          1452                       
00001D68                          1453              *GET DATA #   
00001D68  2205                    1454              MOVE.L  D5,D1
00001D6A  EC99                    1455              ROR.L   #6,D1            
00001D6C  E699                    1456              ROR.L   #3,D1
00001D6E  0281 00000007           1457              ANDI.L  #$07,D1
00001D74                          1458              
00001D74  0C01 0000               1459              CMPI.B  #%000,D1
00001D78  6700 009A               1460              BEQ     OP0101_ADDQ_B_8
00001D7C  0C01 0001               1461              CMPI.B  #%001,D1
00001D80  6700 003E               1462              BEQ     OP0101_ADDQ_B_1
00001D84  0C01 0002               1463              CMPI.B  #%010,D1
00001D88  6700 0042               1464              BEQ     OP0101_ADDQ_B_2
00001D8C  0C01 0003               1465              CMPI.B  #%011,D1
00001D90  6700 0046               1466              BEQ     OP0101_ADDQ_B_3
00001D94  0C01 0004               1467              CMPI.B  #%100,D1
00001D98  6700 004A               1468              BEQ     OP0101_ADDQ_B_4
00001D9C  0C01 0005               1469              CMPI.B  #%101,D1
00001DA0  6700 004E               1470              BEQ     OP0101_ADDQ_B_5
00001DA4  0C01 0006               1471              CMPI.B  #%110,D1
00001DA8  6700 0052               1472              BEQ     OP0101_ADDQ_B_6
00001DAC  0C01 0007               1473              CMPI.B  #%111,D1
00001DB0  6700 0056               1474              BEQ     OP0101_ADDQ_B_7
00001DB4                          1475              
00001DB4                          1476  OP0101_ADDQ_B_0
00001DB4  163C 0030               1477              MOVE.B  #'0',D3
00001DB8  6100 202E               1478              BSR     PUSH_STACK
00001DBC  6000 005E               1479              BRA     OP0101_RETURN2            
00001DC0                          1480  OP0101_ADDQ_B_1
00001DC0  163C 0031               1481              MOVE.B  #'1',D3
00001DC4  6100 2022               1482              BSR     PUSH_STACK
00001DC8  6000 0052               1483              BRA     OP0101_RETURN2            
00001DCC                          1484  OP0101_ADDQ_B_2
00001DCC  163C 0032               1485              MOVE.B  #'2',D3
00001DD0  6100 2016               1486              BSR     PUSH_STACK
00001DD4  6000 0046               1487              BRA     OP0101_RETURN2            
00001DD8                          1488  OP0101_ADDQ_B_3
00001DD8  163C 0033               1489              MOVE.B  #'3',D3
00001DDC  6100 200A               1490              BSR     PUSH_STACK
00001DE0  6000 003A               1491              BRA     OP0101_RETURN2            
00001DE4                          1492  OP0101_ADDQ_B_4
00001DE4  163C 0034               1493              MOVE.B  #'4',D3
00001DE8  6100 1FFE               1494              BSR     PUSH_STACK
00001DEC  6000 002E               1495              BRA     OP0101_RETURN2            
00001DF0                          1496  OP0101_ADDQ_B_5
00001DF0  163C 0035               1497              MOVE.B  #'5',D3
00001DF4  6100 1FF2               1498              BSR     PUSH_STACK
00001DF8  6000 0022               1499              BRA     OP0101_RETURN2
00001DFC                          1500  OP0101_ADDQ_B_6
00001DFC  163C 0036               1501              MOVE.B  #'6',D3
00001E00  6100 1FE6               1502              BSR     PUSH_STACK
00001E04  6000 0016               1503              BRA     OP0101_RETURN2
00001E08                          1504  OP0101_ADDQ_B_7
00001E08  163C 0037               1505              MOVE.B  #'7',D3
00001E0C  6100 1FDA               1506              BSR     PUSH_STACK
00001E10  6000 000A               1507              BRA     OP0101_RETURN2
00001E14                          1508  
00001E14                          1509  OP0101_ADDQ_B_8
00001E14  163C 0038               1510              MOVE.B  #'8',D3
00001E18  6100 1FCE               1511              BSR     PUSH_STACK
00001E1C                          1512              
00001E1C                          1513  OP0101_RETURN2            
00001E1C  163C 002C               1514              MOVE.B  #',',D3
00001E20  6100 1FC6               1515              BSR     PUSH_STACK
00001E24  6100 1724               1516              BSR     GET_EA_EA_SRC
00001E28                          1517              
00001E28  4E75                    1518              RTS
00001E2A                          1519  
00001E2A                          1520  
00001E2A                          1521              
00001E2A                          1522  *---------------------------------------------------------------------------*
00001E2A                          1523  * OP_ADDQ: display ADDQ
00001E2A                          1524  *---------------------------------------------------------------------------*              
00001E2A                          1525  OP_ADDQ_B    * size is byte   
00001E2A  183C 0000               1526              MOVE.B  #0,D4 
00001E2E  43F9 000044E3           1527              LEA     DISP_ADDQ_B,A1
00001E34  103C 000E               1528              MOVE.B  #14,D0
00001E38  4E4F                    1529              TRAP    #15
00001E3A  4E75                    1530              RTS
00001E3C                          1531              
00001E3C                          1532  OP_ADDQ_W    * size is word
00001E3C  183C 0001               1533              MOVE.B  #1,D4
00001E40  43F9 000044ED           1534              LEA     DISP_ADDQ_W,A1
00001E46  103C 000E               1535              MOVE.B  #14,D0
00001E4A  4E4F                    1536              TRAP    #15
00001E4C  4E75                    1537              RTS
00001E4E                          1538              
00001E4E                          1539  OP_ADDQ_L    * size is long
00001E4E  183C 0002               1540              MOVE.B  #2,D4
00001E52  43F9 000044F7           1541              LEA     DISP_ADDQ_L,A1
00001E58  103C 000E               1542              MOVE.B  #14,D0
00001E5C  4E4F                    1543              TRAP    #15
00001E5E  4E75                    1544              RTS
00001E60                          1545  
00001E60                          1546  *---------------------------------------------------------------------------*
00001E60                          1547  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001E60                          1548  *---------------------------------------------------------------------------*              
00001E60  4280                    1549  OP0110      CLR.L   D0                  
00001E62  4281                    1550              CLR.L   D1   
00001E64  4284                    1551              CLR.L   D4                 
00001E66  227C 00000000           1552              MOVEA.L #0,A1
00001E6C  2205                    1553              MOVE.L  D5, D1                
00001E6E  0281 000000FF           1554              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001E74  2205                    1555              MOVE.L  D5,D1                  
00001E76  0281 00000F00           1556              ANDI.L  #$0F00,D1
00001E7C                          1557                 
00001E7C  0C41 0000               1558              CMPI.W  #$0000,D1               * Check for BRA
00001E80  6700 0050               1559              BEQ     OP_BRA                  
00001E84                          1560                          
00001E84  0C41 0D00               1561              CMPI.W  #$0D00,D1               * Check for BLT
00001E88  6700 0056               1562              BEQ     OP_BLT      
00001E8C                          1563  
00001E8C  0C41 0700               1564              CMPI.W  #$0700,D1               * Check for BEQ
00001E90  6700 0032               1565              BEQ     OP_BEQ      
00001E94                          1566  
00001E94  0C41 0600               1567              CMPI.W  #$0600,D1               * Check for BNE
00001E98  6700 001C               1568              BEQ     OP_BNE  
00001E9C                          1569              
00001E9C  0C41 0200               1570              CMPI.W  #$0200,D1               * Check for BHI
00001EA0  6700 0006               1571              BEQ     OP_BHI
00001EA4                          1572  
00001EA4  4EF8 15E2               1573              JMP     OP_DATA
00001EA8                          1574              
00001EA8  43F9 000046B2           1575  OP_BHI      LEA     DISP_BHI,A1             
00001EAE  103C 000E               1576              MOVE.B  #14,D0
00001EB2  4E4F                    1577              TRAP    #15
00001EB4  4E75                    1578              RTS
00001EB6                          1579  
00001EB6  43F9 000046AB           1580  OP_BNE      LEA     DISP_BNE,A1             
00001EBC  103C 000E               1581              MOVE.B  #14,D0
00001EC0  4E4F                    1582              TRAP    #15
00001EC2  4E75                    1583              RTS
00001EC4                          1584  
00001EC4  43F9 000046A4           1585  OP_BEQ      LEA     DISP_BEQ,A1             
00001ECA  103C 000E               1586              MOVE.B  #14,D0
00001ECE  4E4F                    1587              TRAP    #15
00001ED0  4E75                    1588              RTS          
00001ED2                          1589                          
00001ED2  43F9 00004696           1590  OP_BRA      LEA     DISP_BRA,A1             
00001ED8  103C 000E               1591              MOVE.B  #14,D0
00001EDC  4E4F                    1592              TRAP    #15
00001EDE  4E75                    1593              RTS
00001EE0                          1594              
00001EE0  43F9 0000469D           1595  OP_BLT      LEA     DISP_BLT,A1          
00001EE6  103C 000E               1596              MOVE.B  #14,D0
00001EEA  4E4F                    1597              TRAP    #15
00001EEC  4E75                    1598              RTS
00001EEE                          1599     
00001EEE                          1600  *---------------------------------------------------------------------------*
00001EEE                          1601  * OP0111 : MOVEQ not required
00001EEE                          1602  *---------------------------------------------------------------------------*           
00001EEE  4EF8 15E2               1603  OP0111      JMP     OP_DATA
00001EF2                          1604             
00001EF2                          1605  *---------------------------------------------------------------------------*
00001EF2                          1606  * OP1000 : decode DIVS
00001EF2                          1607  *---------------------------------------------------------------------------*           
00001EF2                          1608  OP1000                           
00001EF2  4281                    1609              CLR.L   D1       
00001EF4  4284                    1610              CLR.L   D4                   
00001EF6  227C 00000000           1611              MOVEA.L #0, A1              
00001EFC  2205                    1612              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001EFE                          1613              *CLEAR D3
00001EFE  4283                    1614              CLR.L   D3
00001F00                          1615  
00001F00                          1616  OP1000_DIVS_DN_EA_OR_EA_DN 
00001F00                          1617              *LOAD STACK WITH THIS OPMODE
00001F00  6100 1EE6               1618              BSR     PUSH_STACK
00001F04  163C 0044               1619              MOVE.B  #'D',D3
00001F08  6100 1EDE               1620              BSR     PUSH_STACK
00001F0C  163C 0049               1621              MOVE.B  #'I',D3
00001F10  6100 1ED6               1622              BSR     PUSH_STACK
00001F14  163C 0056               1623              MOVE.B  #'V',D3
00001F18  6100 1ECE               1624              BSR     PUSH_STACK
00001F1C  163C 0053               1625              MOVE.B  #'S',D3
00001F20  6100 1EC6               1626              BSR     PUSH_STACK
00001F24  163C 002E               1627              MOVE.B  #'.',D3
00001F28  6100 1EBE               1628              BSR     PUSH_STACK
00001F2C                          1629              
00001F2C  2205                    1630              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001F2E                          1631              
00001F2E                          1632  OP1000_EA_DN_DIVS
00001F2E                          1633              *BITS (7 TO 6) 
00001F2E                          1634              *00 = .B
00001F2E                          1635              *01 = .W
00001F2E                          1636              *10 = .L 
00001F2E  2205                    1637              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001F30  EC99                    1638              ROR.L   #6,D1
00001F32  0281 00000003           1639              ANDI.L  #$03,D1
00001F38  0C81 00000003           1640              CMPI.L  #%11,D1 *EQUALS .W
00001F3E  6700 0014               1641              BEQ     OP1000_PRINT_W_DIVS
00001F42  0C81 00000000           1642              CMPI.L  #%00,D1 *EQUALS .L
00001F48  6700 0052               1643              BEQ     OP1000_PRINT_L_DIVS
00001F4C                          1644              
00001F4C  183C 0001               1645              MOVE.B  #1,D4               *ERROR READ
00001F50  6000 0092               1646              BRA     OP1000_DIVS_RETURN
00001F54                          1647  OP1000_PRINT_W_DIVS
00001F54  163C 0057               1648              MOVE.B  #'W',D3
00001F58  6100 1E8E               1649              BSR     PUSH_STACK
00001F5C                          1650  
00001F5C                          1651              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001F5C  13FC 0000 0000470E      1652              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001F64  13FC 0000 0000470F      1653              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001F6C                          1654             
00001F6C                          1655              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001F6C  13FC 00B9 00004711      1656              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001F74  13FC 0020 00004712      1657              MOVE.B   #$20,GET_SRC_START_END
00001F7C                          1658  
00001F7C                          1659             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001F7C  0285 0000FE3F           1660              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001F82  0685 00000000           1661              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001F88                          1662  
00001F88                          1663              
00001F88  6100 15C0               1664              BSR     GET_EA_EA_SRC      *GETS <ea>
00001F8C  163C 002C               1665              MOVE.B  #',',D3
00001F90  6100 1E56               1666              BSR     PUSH_STACK
00001F94  6100 19E4               1667              BSR     GET_EA_EA_DEST       *GETS Dn    
00001F98                          1668              
00001F98  6000 004A               1669              BRA     OP1000_DIVS_RETURN
00001F9C                          1670  OP1000_PRINT_L_DIVS
00001F9C  163C 004C               1671              MOVE.B  #'L',D3
00001FA0  6100 1E46               1672              BSR     PUSH_STACK
00001FA4                          1673              
00001FA4                          1674              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001FA4  13FC 0000 0000470E      1675              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001FAC  13FC 0000 0000470F      1676              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001FB4                          1677             
00001FB4                          1678              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001FB4  13FC 00B9 00004711      1679              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001FBC  13FC 0020 00004712      1680              MOVE.B   #$20,GET_SRC_START_END
00001FC4                          1681  
00001FC4                          1682              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001FC4  0285 0000FE3F           1683              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001FCA  0685 00000000           1684              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001FD0                          1685  
00001FD0                          1686                     
00001FD0  6100 1578               1687              BSR     GET_EA_EA_SRC      *GETS <ea>
00001FD4  163C 002C               1688              MOVE.B  #',',D3
00001FD8  6100 1E0E               1689              BSR     PUSH_STACK                  
00001FDC  6100 199C               1690              BSR     GET_EA_EA_DEST       *GETS Dn    
00001FE0                          1691  
00001FE0                          1692              
00001FE0  6000 0002               1693              BRA     OP1000_DIVS_RETURN
00001FE4                          1694              
00001FE4                          1695  OP1000_DIVS_RETURN
00001FE4  4E75                    1696              RTS
00001FE6                          1697              
00001FE6                          1698  
00001FE6                          1699  
00001FE6                          1700  *---------------------------------------------------------------------------*
00001FE6                          1701  * OP_DIVS: display DIVS and proceed to EA
00001FE6                          1702  *---------------------------------------------------------------------------*  
00001FE6  43F9 00004501           1703  OP_DIVS     LEA     DISP_DIVS,A1
00001FEC  103C 000E               1704              MOVE.B  #14,D0
00001FF0  4E4F                    1705              TRAP    #15
00001FF2  4EF9 000030AE           1706              JMP     EA_ARITH
00001FF8                          1707  
00001FF8  4E75                    1708              RTS
00001FFA                          1709              
00001FFA                          1710  *---------------------------------------------------------------------------*
00001FFA                          1711  * OP1001: decode SUB/SUBA
00001FFA                          1712  *---------------------------------------------------------------------------*      
00001FFA                          1713  OP1001      
00001FFA  4280                    1714              CLR.L   D0                  
00001FFC  4281                    1715              CLR.L   D1       
00001FFE  4284                    1716              CLR.L   D4                   
00002000  227C 00000000           1717              MOVEA.L #0, A1              
00002006  2205                    1718              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002008                          1719              
00002008                          1720              *CLEAR D3
00002008  4283                    1721              CLR.L   D3
0000200A                          1722              
0000200A                          1723              
0000200A                          1724              
0000200A                          1725              **INTEGRATING SUB.W/.L INTO THIS CODE**
0000200A  2205                    1726              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000200C                          1727              *BITS (INDEX 8) 
0000200C                          1728              *0 = ADD.B/W/L <EA>,Dn
0000200C                          1729              *1 = ADD.B/W/L Dn,<EA> 
0000200C  EC99                    1730              ROR.L   #6,D1
0000200E  0281 00000007           1731              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002014  0C81 00000007           1732              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
0000201A  6700 0010               1733              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
0000201E  0C81 00000003           1734              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002024  6700 0078               1735              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00002028  6000 00E6               1736              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000202C                          1737              
0000202C                          1738  OP1001_SUBA_L
0000202C                          1739              *LOAD STACK WITH THIS OPMODE
0000202C  6100 1DBA               1740              BSR     PUSH_STACK
00002030  163C 0053               1741              MOVE.B  #'S',D3
00002034  6100 1DB2               1742              BSR     PUSH_STACK
00002038  163C 0055               1743              MOVE.B  #'U',D3
0000203C  6100 1DAA               1744              BSR     PUSH_STACK
00002040  163C 0042               1745              MOVE.B  #'B',D3
00002044  6100 1DA2               1746              BSR     PUSH_STACK
00002048  163C 0041               1747              MOVE.B  #'A',D3
0000204C  6100 1D9A               1748              BSR     PUSH_STACK
00002050  163C 002E               1749              MOVE.B  #'.',D3
00002054  6100 1D92               1750              BSR     PUSH_STACK
00002058  163C 004C               1751              MOVE.B  #'L',D3
0000205C  6100 1D8A               1752              BSR     PUSH_STACK
00002060                          1753              
00002060                          1754             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002060  13FC 0000 0000470E      1755             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002068  13FC 0000 0000470F      1756             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002070                          1757             
00002070                          1758             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002070  13FC 00B9 00004711      1759             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002078  13FC 0020 00004712      1760             MOVE.B   #$20,GET_SRC_START_END
00002080                          1761  
00002080                          1762              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002080  0285 0000FE3F           1763              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002086  0685 00000040           1764              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000208C                          1765       
0000208C                          1766              *PRINT <EA>,AN
0000208C  6100 14BC               1767              BSR     GET_EA_EA_SRC       *GETS <ea>
00002090  163C 002C               1768              MOVE.B  #',',D3
00002094  6100 1D52               1769              BSR     PUSH_STACK                     
00002098  6100 18E0               1770              BSR     GET_EA_EA_DEST      *GETS Dn
0000209C                          1771  
0000209C                          1772              
0000209C                          1773              
0000209C  4E75                    1774              RTS
0000209E                          1775  OP1001_SUBA_W
0000209E                          1776              *LOAD STACK WITH THIS OPMODE
0000209E  6100 1D48               1777              BSR     PUSH_STACK
000020A2  163C 0053               1778              MOVE.B  #'S',D3
000020A6  6100 1D40               1779              BSR     PUSH_STACK
000020AA  163C 0055               1780              MOVE.B  #'U',D3
000020AE  6100 1D38               1781              BSR     PUSH_STACK
000020B2  163C 0042               1782              MOVE.B  #'B',D3
000020B6  6100 1D30               1783              BSR     PUSH_STACK
000020BA  163C 0041               1784              MOVE.B  #'A',D3
000020BE  6100 1D28               1785              BSR     PUSH_STACK
000020C2  163C 002E               1786              MOVE.B  #'.',D3
000020C6  6100 1D20               1787              BSR     PUSH_STACK
000020CA  163C 0057               1788              MOVE.B  #'W',D3
000020CE  6100 1D18               1789              BSR     PUSH_STACK
000020D2                          1790              
000020D2                          1791             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000020D2  13FC 0000 0000470E      1792             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000020DA  13FC 0000 0000470F      1793             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000020E2                          1794             
000020E2                          1795             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000020E2  13FC 00B9 00004711      1796             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000020EA  13FC 0020 00004712      1797             MOVE.B   #$20,GET_SRC_START_END
000020F2                          1798  
000020F2                          1799              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000020F2  0285 0000FE3F           1800              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000020F8  0685 00000040           1801              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000020FE                          1802       
000020FE                          1803              *PRINT <EA>,AN
000020FE  6100 144A               1804              BSR     GET_EA_EA_SRC       *GETS <ea>
00002102  163C 002C               1805              MOVE.B  #',',D3
00002106  6100 1CE0               1806              BSR     PUSH_STACK                     
0000210A  6100 186E               1807              BSR     GET_EA_EA_DEST      *GETS Dn
0000210E                          1808  
0000210E  4E75                    1809              RTS
00002110                          1810  
00002110                          1811  OP1001_DETERMINE_DN_EA_OR_EA_DN 
00002110                          1812              *LOAD STACK WITH THIS OPMODE
00002110  6100 1CD6               1813              BSR     PUSH_STACK
00002114  163C 0053               1814              MOVE.B  #'S',D3
00002118  6100 1CCE               1815              BSR     PUSH_STACK
0000211C  163C 0055               1816              MOVE.B  #'U',D3
00002120  6100 1CC6               1817              BSR     PUSH_STACK
00002124  163C 0042               1818              MOVE.B  #'B',D3
00002128  6100 1CBE               1819              BSR     PUSH_STACK
0000212C  163C 002E               1820              MOVE.B  #'.',D3
00002130  6100 1CB6               1821              BSR     PUSH_STACK
00002134                          1822              
00002134  2205                    1823              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002136                          1824              
00002136                          1825              *BITS (INDEX 8) 
00002136                          1826              *0 = ADD.B/W/L <EA>,Dn
00002136                          1827              *1 = ADD.B/W/L Dn,<EA> 
00002136  E099                    1828              ROR.L   #8,D1
00002138  0281 00000001           1829              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000213E  0C81 00000000           1830              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002144  6700 0102               1831              BEQ     OP1001_EA_DN
00002148                          1832              *else procede to Dn_EA
00002148                          1833              
00002148                          1834  OP1001_DN_EA
00002148                          1835              *BITS (7 TO 6) 
00002148                          1836              *00 = .B
00002148                          1837              *01 = .W
00002148                          1838              *10 = .L 
00002148  2205                    1839              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000214A  EC99                    1840              ROR.L   #6,D1
0000214C  0281 00000003           1841              ANDI.L  #$03,D1
00002152  0C81 00000000           1842              CMPI.L  #$00,D1 *EQUALS .B
00002158  6700 0016               1843              BEQ     OP1001_PRINT_B2
0000215C  0C81 00000001           1844              CMPI.L  #$01,D1 *EQUALS .W
00002162  6700 0054               1845              BEQ     OP1001_PRINT_W2
00002166  0C81 00000002           1846              CMPI.L  #$02,D1 *EQUALS .L
0000216C  6700 0092               1847              BEQ     OP1001_PRINT_L2
00002170                          1848  OP1001_PRINT_B2
00002170                          1849              *PUSH 'B'
00002170  163C 0042               1850              MOVE.B  #'B',D3
00002174  6100 1C72               1851              BSR     PUSH_STACK
00002178                          1852             
00002178                          1853              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002178  13FC 0000 0000470E      1854             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002180  13FC 0083 0000470F      1855             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002188                          1856             
00002188                          1857             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002188  13FC 00B9 00004711      1858             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002190  13FC 0020 00004712      1859             MOVE.B   #$20,GET_SRC_START_END
00002198                          1860  
00002198                          1861              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002198  0285 0000FE3F           1862              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000219E  0685 00000040           1863              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000021A4                          1864       
000021A4  6100 17D4               1865              BSR     GET_EA_EA_DEST      *GETS Dn
000021A8  163C 002C               1866              MOVE.B  #',',D3
000021AC  6100 1C3A               1867              BSR     PUSH_STACK                     
000021B0  6100 1398               1868              BSR     GET_EA_EA_SRC       *GETS <ea>
000021B4                          1869  
000021B4                          1870              
000021B4  6000 0BA4               1871              BRA     OP1101_ADD_RETURN
000021B8                          1872  OP1001_PRINT_W2
000021B8  163C 0057               1873              MOVE.B  #'W',D3
000021BC  6100 1C2A               1874              BSR     PUSH_STACK
000021C0                          1875  
000021C0                          1876              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021C0  13FC 0000 0000470E      1877              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021C8  13FC 0083 0000470F      1878              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021D0                          1879             
000021D0                          1880              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021D0  13FC 00B9 00004711      1881              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021D8  13FC 0020 00004712      1882              MOVE.B   #$20,GET_SRC_START_END
000021E0                          1883  
000021E0                          1884              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021E0  0285 0000FE3F           1885              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021E6  0685 00000040           1886              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000021EC                          1887  
000021EC                          1888        
000021EC  6100 178C               1889              BSR     GET_EA_EA_DEST      *GETS Dn
000021F0  163C 002C               1890              MOVE.B  #',',D3
000021F4  6100 1BF2               1891              BSR     PUSH_STACK               
000021F8  6100 1350               1892              BSR     GET_EA_EA_SRC       *GETS <ea>       
000021FC                          1893  
000021FC                          1894  
000021FC                          1895  
000021FC  6000 0B5C               1896              BRA     OP1101_ADD_RETURN
00002200                          1897  OP1001_PRINT_L2 
00002200  163C 004C               1898              MOVE.B  #'L',D3
00002204  6100 1BE2               1899              BSR     PUSH_STACK
00002208                          1900              
00002208                          1901              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002208  13FC 0000 0000470E      1902              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002210  13FC 0083 0000470F      1903              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002218                          1904             
00002218                          1905              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002218  13FC 00B9 00004711      1906              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002220  13FC 0020 00004712      1907              MOVE.B   #$20,GET_SRC_START_END
00002228                          1908  
00002228                          1909             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002228  0285 0000FE3F           1910              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000222E  0685 00000040           1911              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002234                          1912  
00002234                          1913               
00002234  6100 1744               1914              BSR     GET_EA_EA_DEST       *GETS Dn
00002238  163C 002C               1915              MOVE.B  #',',D3
0000223C  6100 1BAA               1916              BSR     PUSH_STACK          
00002240  6100 1308               1917              BSR     GET_EA_EA_SRC        *GETS <ea>
00002244                          1918  
00002244  6000 0B14               1919              BRA     OP1101_ADD_RETURN
00002248                          1920              
00002248                          1921  OP1001_EA_DN           
00002248                          1922              *BITS (7 TO 6) 
00002248                          1923              *00 = .B
00002248                          1924              *01 = .W
00002248                          1925              *10 = .L 
00002248  2205                    1926              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000224A  EC99                    1927              ROR.L   #6,D1
0000224C  0281 00000003           1928              ANDI.L  #$03,D1
00002252  0C81 00000000           1929              CMPI.L  #$00,D1 *EQUALS .B
00002258  6700 0016               1930              BEQ     OP1001_PRINT_B
0000225C  0C81 00000001           1931              CMPI.L  #$01,D1 *EQUALS .W
00002262  6700 0054               1932              BEQ     OP1001_PRINT_W
00002266  0C81 00000002           1933              CMPI.L  #$02,D1 *EQUALS .L
0000226C  6700 0092               1934              BEQ     OP1001_PRINT_L
00002270                          1935  OP1001_PRINT_B
00002270  163C 0042               1936              MOVE.B  #'B',D3
00002274  6100 1B72               1937              BSR     PUSH_STACK
00002278                          1938                
00002278                          1939              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002278  13FC 0000 0000470E      1940              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002280  13FC 0002 0000470F      1941              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002288                          1942             
00002288                          1943              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002288  13FC 00B9 00004711      1944              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002290  13FC 0020 00004712      1945              MOVE.B   #$20,GET_SRC_START_END
00002298                          1946  
00002298                          1947             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002298  0285 0000FE3F           1948              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000229E  0685 00000040           1949              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
000022A4                          1950  
000022A4                          1951              
000022A4  6100 12A4               1952              BSR     GET_EA_EA_SRC      *GETS <ea>
000022A8  163C 002C               1953              MOVE.B  #',',D3
000022AC  6100 1B3A               1954              BSR     PUSH_STACK          
000022B0  6100 16C8               1955              BSR     GET_EA_EA_DEST       *GETS Dn
000022B4                          1956              
000022B4  6000 0AA4               1957              BRA     OP1101_ADD_RETURN
000022B8                          1958  OP1001_PRINT_W
000022B8  163C 0057               1959              MOVE.B  #'W',D3
000022BC  6100 1B2A               1960              BSR     PUSH_STACK
000022C0                          1961  
000022C0                          1962              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022C0  13FC 0000 0000470E      1963              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022C8  13FC 0000 0000470F      1964              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022D0                          1965             
000022D0                          1966              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022D0  13FC 00B9 00004711      1967              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022D8  13FC 0020 00004712      1968              MOVE.B   #$20,GET_SRC_START_END
000022E0                          1969  
000022E0                          1970             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022E0  0285 0000FE3F           1971              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022E6  0685 00000040           1972              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022EC                          1973  
000022EC                          1974              
000022EC  6100 125C               1975              BSR     GET_EA_EA_SRC      *GETS <ea>
000022F0  163C 002C               1976              MOVE.B  #',',D3
000022F4  6100 1AF2               1977              BSR     PUSH_STACK
000022F8  6100 1680               1978              BSR     GET_EA_EA_DEST       *GETS Dn    
000022FC                          1979              
000022FC  6000 004A               1980              BRA     OP1001_ADD_RETURN
00002300                          1981  OP1001_PRINT_L 
00002300  163C 004C               1982              MOVE.B  #'L',D3
00002304  6100 1AE2               1983              BSR     PUSH_STACK
00002308                          1984              
00002308                          1985              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002308  13FC 0000 0000470E      1986              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002310  13FC 0000 0000470F      1987              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002318                          1988             
00002318                          1989              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002318  13FC 00B9 00004711      1990              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002320  13FC 0020 00004712      1991              MOVE.B   #$20,GET_SRC_START_END
00002328                          1992  
00002328                          1993              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002328  0285 0000FE3F           1994              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000232E  0685 00000040           1995              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002334                          1996  
00002334                          1997                     
00002334  6100 1214               1998              BSR     GET_EA_EA_SRC      *GETS <ea>
00002338  163C 002C               1999              MOVE.B  #',',D3
0000233C  6100 1AAA               2000              BSR     PUSH_STACK                  
00002340  6100 1638               2001              BSR     GET_EA_EA_DEST       *GETS Dn    
00002344                          2002  
00002344                          2003              
00002344  6000 0002               2004              BRA     OP1001_ADD_RETURN
00002348                          2005              
00002348                          2006  OP1001_ADD_RETURN
00002348  4E75                    2007              RTS
0000234A                          2008  
0000234A                          2009    
0000234A                          2010  *---------------------------------------------------------------------------*
0000234A                          2011  * OP_SUB: display SUB and proceed to EA
0000234A                          2012  *---------------------------------------------------------------------------*            
0000234A  43F9 00004509           2013  OP_SUB_B    LEA     DISP_SUB_B,A1
00002350  103C 000E               2014              MOVE.B  #14,D0
00002354  4E4F                    2015              TRAP    #15
00002356  183C 0000               2016              MOVE.B  #0,D4
0000235A  4EF9 000030FA           2017              JMP     EA_GEN
00002360                          2018  
00002360  4E75                    2019              RTS
00002362                          2020  
00002362  43F9 00004512           2021  OP_SUB_W    LEA     DISP_SUB_W,A1
00002368  103C 000E               2022              MOVE.B  #14,D0
0000236C  4E4F                    2023              TRAP    #15
0000236E  183C 0001               2024              MOVE.B  #1,D4
00002372  4EF9 000030FA           2025              JMP     EA_GEN
00002378                          2026  
00002378  4E75                    2027              RTS
0000237A                          2028  
0000237A  43F9 0000451B           2029  OP_SUB_L    LEA     DISP_SUB_L,A1
00002380  103C 000E               2030              MOVE.B  #14,D0
00002384  4E4F                    2031              TRAP    #15
00002386  183C 0002               2032              MOVE.B  #2,D4
0000238A  4EF9 000030FA           2033              JMP     EA_GEN
00002390                          2034  
00002390  4E75                    2035              RTS
00002392                          2036  
00002392                          2037  *---------------------------------------------------------------------------*
00002392                          2038  * OP_SUBA: display SUBA
00002392                          2039  *---------------------------------------------------------------------------*  
00002392  43F9 00004542           2040  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00002398  103C 000E               2041              MOVE.B  #14,D0
0000239C  4E4F                    2042              TRAP    #15
0000239E  183C 0001               2043              MOVE.B  #1,D4
000023A2  4E75                    2044              RTS
000023A4                          2045  
000023A4  43F9 0000454C           2046  OP_SUBA_L   LEA     DISP_SUBA_L,A1
000023AA  103C 000E               2047              MOVE.B  #14,D0
000023AE  4E4F                    2048              TRAP    #15
000023B0  183C 0002               2049              MOVE.B  #2,D4
000023B4  4E75                    2050              RTS         
000023B6                          2051  *---------------------------------------------------------------------------*
000023B6                          2052  * OP1010 : unassigned
000023B6                          2053  *---------------------------------------------------------------------------*           
000023B6  4EF8 15E2               2054  OP1010      JMP     OP_DATA
000023BA                          2055              
000023BA                          2056  *---------------------------------------------------------------------------*
000023BA                          2057  * OP1011 : decode CMP/EOR/CMPA
000023BA                          2058  *---------------------------------------------------------------------------*           
000023BA  4280                    2059  OP1011      CLR.L   D0                
000023BC  4281                    2060              CLR.L   D1            
000023BE  4284                    2061              CLR.L   D4                   
000023C0  227C 00000000           2062              MOVEA.L #0, A1               
000023C6  2205                    2063              MOVE.L  D5,D1
000023C8  EA99                    2064              ROR.L   #5,D1
000023CA  0281 0000000E           2065              ANDI.L  #$E,D1
000023D0  0C01 0000               2066              CMPI.B  #$0,D1
000023D4  6700 003E               2067              BEQ     OP1011_CMP
000023D8  0C01 0002               2068              CMPI.B  #$2,D1
000023DC  6700 0036               2069              BEQ     OP1011_CMP
000023E0  0C01 0004               2070              CMPI.B  #$4,D1
000023E4  6700 002E               2071              BEQ     OP1011_CMP
000023E8  0C01 0008               2072              CMPI.B  #$8,D1
000023EC  6700 0178               2073              BEQ     OP1011_EOR
000023F0  0C01 000A               2074              CMPI.B  #$A,D1
000023F4  6700 0170               2075              BEQ     OP1011_EOR
000023F8  0C01 000C               2076              CMPI.B  #$C,D1
000023FC  6700 0168               2077              BEQ     OP1011_EOR  
00002400  0C01 0006               2078              CMPI.B  #$6,D1
00002404  6700 00C0               2079              BEQ     OP1011_CMPA
00002408  0C01 000E               2080              CMPI.B  #$E,D1
0000240C  6700 00B8               2081              BEQ     OP1011_CMPA 
00002410                          2082  
00002410  4EF8 15E2               2083              JMP     OP_DATA          
00002414                          2084  
00002414                          2085  
00002414                          2086  
00002414                          2087  
00002414                          2088  OP1011_CMP
00002414                          2089             
00002414                          2090   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002414  13FC 0082 0000470E      2091             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000241C  13FC 0000 0000470F      2092             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002424                          2093             
00002424                          2094             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002424  13FC 00B9 00004711      2095             MOVE.B   #$B9,GET_DST_START_END
0000242C  13FC 0020 00004712      2096             MOVE.B   #$20,GET_SRC_START_END
00002434                          2097             
00002434                          2098              *CLEAR D3
00002434  4283                    2099              CLR.L   D3
00002436                          2100              *LOAD STACK WITH THIS OPMODE
00002436  6100 19B0               2101              BSR     PUSH_STACK
0000243A  163C 0043               2102              MOVE.B  #'C',D3
0000243E  6100 19A8               2103              BSR     PUSH_STACK
00002442  163C 004D               2104              MOVE.B  #'M',D3
00002446  6100 19A0               2105              BSR     PUSH_STACK
0000244A  163C 0050               2106              MOVE.B  #'P',D3
0000244E  6100 1998               2107              BSR     PUSH_STACK
00002452  163C 002E               2108              MOVE.B  #'.',D3
00002456  6100 1990               2109              BSR     PUSH_STACK
0000245A                          2110              
0000245A                          2111              *FIGURE OUT SIZE*
0000245A                          2112              *00 = BYTE
0000245A                          2113              *01 = WORD
0000245A                          2114              *10 = LONG
0000245A                          2115              * BITS 7&6
0000245A                          2116              
0000245A                          2117              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000245A  2205                    2118              MOVE.L  D5,D1
0000245C  EC99                    2119              ROR.L   #6,D1
0000245E  0281 00000003           2120              ANDI.L  #$03,D1
00002464  0C01 0000               2121              CMPI.B  #%00,D1
00002468  6700 001E               2122              BEQ     OP1011_CMP_B
0000246C  0281 00000003           2123              ANDI.L  #$03,D1
00002472  0C01 0001               2124              CMPI.B  #%01,D1
00002476  6700 001C               2125              BEQ     OP1011_CMP_W
0000247A  0281 00000003           2126              ANDI.L  #$03,D1
00002480  0C01 0002               2127              CMPI.B  #%10,D1
00002484  6700 001A               2128              BEQ     OP1011_CMP_L
00002488                          2129            
00002488                          2130  OP1011_CMP_B
00002488                          2131              
00002488  163C 0042               2132              MOVE.B  #'B',D3
0000248C  6100 195A               2133              BSR     PUSH_STACK
00002490  6000 0016               2134              BRA     OP1011_RETURN_CMP  
00002494                          2135  OP1011_CMP_W
00002494                          2136              
00002494  163C 0057               2137              MOVE.B  #'W',D3
00002498  6100 194E               2138              BSR     PUSH_STACK
0000249C  6000 000A               2139              BRA     OP1011_RETURN_CMP  
000024A0                          2140  OP1011_CMP_L
000024A0                          2141              
000024A0  163C 004C               2142              MOVE.B  #'L',D3
000024A4  6100 1942               2143              BSR     PUSH_STACK
000024A8                          2144  OP1011_RETURN_CMP            
000024A8                          2145  
000024A8                          2146              
000024A8                          2147  *GET DATA FROM ADDQ AND PRINT #0-8
000024A8                          2148       
000024A8                          2149              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024A8  0285 0000FE3F           2150              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024AE  0685 00000000           2151              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000024B4                          2152  
000024B4  6100 1094               2153              BSR     GET_EA_EA_SRC
000024B8  163C 002C               2154              MOVE.B  #',',D3
000024BC  6100 192A               2155              BSR     PUSH_STACK
000024C0  6100 14B8               2156              BSR     GET_EA_EA_DEST
000024C4                          2157              
000024C4  4E75                    2158              RTS
000024C6                          2159              
000024C6                          2160  
000024C6                          2161  
000024C6                          2162  OP1011_CMPA
000024C6                          2163              
000024C6                          2164   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024C6  13FC 0080 0000470E      2165             MOVE.B   #$80,DEST_REGISTER_FORMAT
000024CE  13FC 0000 0000470F      2166             MOVE.B   #$00,SRC_REGISTER_FORMAT
000024D6                          2167             
000024D6                          2168             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024D6  13FC 00B9 00004711      2169             MOVE.B   #$B9,GET_DST_START_END
000024DE  13FC 0020 00004712      2170             MOVE.B   #$20,GET_SRC_START_END
000024E6                          2171             
000024E6                          2172              *CLEAR D3
000024E6  4283                    2173              CLR.L   D3
000024E8                          2174              *LOAD STACK WITH THIS OPMODE
000024E8  6100 18FE               2175              BSR     PUSH_STACK
000024EC  163C 0043               2176              MOVE.B  #'C',D3
000024F0  6100 18F6               2177              BSR     PUSH_STACK
000024F4  163C 004D               2178              MOVE.B  #'M',D3
000024F8  6100 18EE               2179              BSR     PUSH_STACK
000024FC  163C 0050               2180              MOVE.B  #'P',D3
00002500  6100 18E6               2181              BSR     PUSH_STACK
00002504  163C 0041               2182              MOVE.B  #'A',D3
00002508  6100 18DE               2183              BSR     PUSH_STACK
0000250C  163C 002E               2184              MOVE.B  #'.',D3
00002510  6100 18D6               2185              BSR     PUSH_STACK
00002514                          2186              
00002514                          2187              *FIGURE OUT SIZE*
00002514                          2188              *00 = BYTE
00002514                          2189              *01 = WORD
00002514                          2190              *10 = LONG
00002514                          2191              * BITS 7&6
00002514                          2192              
00002514                          2193              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002514  2205                    2194              MOVE.L  D5,D1
00002516  EC99                    2195              ROR.L   #6,D1
00002518  0281 00000003           2196              ANDI.L  #$03,D1
0000251E  0C01 0001               2197              CMPI.B  #%01,D1
00002522  6700 0010               2198              BEQ     OP1011_CMPA_W
00002526  0281 00000003           2199              ANDI.L  #$03,D1
0000252C  0C01 0002               2200              CMPI.B  #%10,D1
00002530  6700 000E               2201              BEQ     OP1011_CMPA_L
00002534                          2202  OP1011_CMPA_W
00002534                          2203              
00002534  163C 0057               2204              MOVE.B  #'W',D3
00002538  6100 18AE               2205              BSR     PUSH_STACK
0000253C  6000 000A               2206              BRA     OP1011_RETURN_CMPA 
00002540                          2207  OP1011_CMPA_L
00002540                          2208              
00002540  163C 004C               2209              MOVE.B  #'L',D3
00002544  6100 18A2               2210              BSR     PUSH_STACK
00002548                          2211  OP1011_RETURN_CMPA            
00002548                          2212  
00002548                          2213              
00002548                          2214  *GET DATA FROM ADDQ AND PRINT #0-8
00002548                          2215       
00002548                          2216              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002548  0285 0000FE3F           2217              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000254E  0685 00000040           2218              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00002554                          2219  
00002554  6100 0FF4               2220              BSR     GET_EA_EA_SRC
00002558  163C 002C               2221              MOVE.B  #',',D3
0000255C  6100 188A               2222              BSR     PUSH_STACK
00002560  6100 1418               2223              BSR     GET_EA_EA_DEST
00002564                          2224              
00002564  4E75                    2225              RTS
00002566                          2226  
00002566                          2227  OP1011_EOR
00002566                          2228  
00002566                          2229   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002566  13FC 0082 0000470E      2230             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000256E  13FC 0080 0000470F      2231             MOVE.B   #$80,SRC_REGISTER_FORMAT
00002576                          2232             
00002576                          2233             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002576  13FC 00B9 00004711      2234             MOVE.B   #$B9,GET_DST_START_END
0000257E  13FC 0020 00004712      2235             MOVE.B   #$20,GET_SRC_START_END
00002586                          2236             
00002586                          2237              *CLEAR D3
00002586  4283                    2238              CLR.L   D3
00002588                          2239              *LOAD STACK WITH THIS OPMODE
00002588  6100 185E               2240              BSR     PUSH_STACK
0000258C  163C 0045               2241              MOVE.B  #'E',D3
00002590  6100 1856               2242              BSR     PUSH_STACK
00002594  163C 004F               2243              MOVE.B  #'O',D3
00002598  6100 184E               2244              BSR     PUSH_STACK
0000259C  163C 0052               2245              MOVE.B  #'R',D3
000025A0  6100 1846               2246              BSR     PUSH_STACK
000025A4  163C 002E               2247              MOVE.B  #'.',D3
000025A8  6100 183E               2248              BSR     PUSH_STACK
000025AC                          2249              
000025AC                          2250              *FIGURE OUT SIZE*
000025AC                          2251              *00 = BYTE
000025AC                          2252              *01 = WORD
000025AC                          2253              *10 = LONG
000025AC                          2254              * BITS 7&6
000025AC                          2255              
000025AC                          2256              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000025AC  2205                    2257              MOVE.L  D5,D1
000025AE  EC99                    2258              ROR.L   #6,D1
000025B0  0281 00000003           2259              ANDI.L  #$03,D1
000025B6  0C01 0000               2260              CMPI.B  #%00,D1
000025BA  6700 001E               2261              BEQ     OP1011_EOR_B
000025BE  0281 00000003           2262              ANDI.L  #$03,D1
000025C4  0C01 0001               2263              CMPI.B  #%01,D1
000025C8  6700 001C               2264              BEQ     OP1011_EOR_W
000025CC  0281 00000003           2265              ANDI.L  #$03,D1
000025D2  0C01 0002               2266              CMPI.B  #%10,D1
000025D6  6700 001A               2267              BEQ     OP1011_EOR_L
000025DA                          2268            
000025DA                          2269  OP1011_EOR_B
000025DA                          2270              
000025DA  163C 0042               2271              MOVE.B  #'B',D3
000025DE  6100 1808               2272              BSR     PUSH_STACK
000025E2  6000 0016               2273              BRA     OP1011_RETURN
000025E6                          2274  OP1011_EOR_W
000025E6                          2275              
000025E6  163C 0057               2276              MOVE.B  #'W',D3
000025EA  6100 17FC               2277              BSR     PUSH_STACK
000025EE  6000 000A               2278              BRA     OP1011_RETURN
000025F2                          2279  OP1011_EOR_L
000025F2                          2280              
000025F2  163C 004C               2281              MOVE.B  #'L',D3
000025F6  6100 17F0               2282              BSR     PUSH_STACK
000025FA                          2283  OP1011_RETURN            
000025FA                          2284  
000025FA                          2285              
000025FA                          2286  *GET DATA FROM ADDQ AND PRINT #0-8
000025FA                          2287       
000025FA                          2288              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000025FA  0285 0000FE3F           2289              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002600  0685 00000000           2290              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002606                          2291  
00002606  6100 1372               2292              BSR     GET_EA_EA_DEST
0000260A  163C 002C               2293              MOVE.B  #',',D3
0000260E  6100 17D8               2294              BSR     PUSH_STACK
00002612  6100 0F36               2295              BSR     GET_EA_EA_SRC
00002616                          2296              
00002616  4E75                    2297              RTS
00002618                          2298              
00002618                          2299              
00002618                          2300              
00002618                          2301              
00002618                          2302  
00002618                          2303  *---------------------------------------------------------------------------*
00002618                          2304  * OP_CMPA: display CMPA 
00002618                          2305  *---------------------------------------------------------------------------
00002618  43F9 0000458C           2306  OP_CMPA_W   LEA     DISP_CMPA_W,A1
0000261E  103C 000E               2307              MOVE.B  #14,D0
00002622  4E4F                    2308              TRAP    #15
00002624  183C 0001               2309              MOVE.B  #1,D4
00002628  4E75                    2310              RTS
0000262A                          2311  
0000262A  43F9 00004596           2312  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002630  103C 000E               2313              MOVE.B  #14,D0
00002634  4E4F                    2314              TRAP    #15
00002636  183C 0002               2315              MOVE.B  #2,D4
0000263A  4E75                    2316              RTS
0000263C                          2317  
0000263C                          2318  *---------------------------------------------------------------------------*
0000263C                          2319  * OP_CMP: display CMP and proceed to EA
0000263C                          2320  *---------------------------------------------------------------------------*  
0000263C  43F9 00004571           2321  OP_CMP_B    LEA     DISP_CMP_B,A1
00002642  103C 000E               2322              MOVE.B  #14,D0
00002646  4E4F                    2323              TRAP    #15
00002648  183C 0000               2324              MOVE.B  #0,D4
0000264C  4EF9 000030FA           2325              JMP     EA_GEN
00002652                          2326  
00002652  4E75                    2327              RTS
00002654                          2328              
00002654  43F9 0000457A           2329  OP_CMP_W    LEA     DISP_CMP_W,A1
0000265A  103C 000E               2330              MOVE.B  #14,D0
0000265E  4E4F                    2331              TRAP    #15
00002660  183C 0001               2332              MOVE.B  #1,D4
00002664  4EF9 000030FA           2333              JMP     EA_GEN
0000266A                          2334  
0000266A  4E75                    2335              RTS
0000266C                          2336              
0000266C  43F9 00004583           2337  OP_CMP_L    LEA     DISP_CMP_L,A1
00002672  103C 000E               2338              MOVE.B  #14,D0
00002676  4E4F                    2339              TRAP    #15
00002678  183C 0002               2340              MOVE.B  #2,D4
0000267C  4EF9 000030FA           2341              JMP     EA_GEN
00002682                          2342  
00002682  4E75                    2343              RTS
00002684                          2344              
00002684                          2345  *---------------------------------------------------------------------------*
00002684                          2346  * OP_EOR: display EOR
00002684                          2347  *---------------------------------------------------------------------------*  
00002684  43F9 00004556           2348  OP_EOR_B    LEA     DISP_EOR_B,A1
0000268A  103C 000E               2349              MOVE.B  #14,D0
0000268E  4E4F                    2350              TRAP    #15
00002690  183C 0000               2351              MOVE.B  #0,D4
00002694  4E75                    2352              RTS
00002696                          2353              
00002696  43F9 0000455F           2354  OP_EOR_W    LEA     DISP_EOR_W,A1
0000269C  103C 000E               2355              MOVE.B  #14,D0
000026A0  4E4F                    2356              TRAP    #15
000026A2  183C 0001               2357              MOVE.B  #1,D4
000026A6  4E75                    2358              RTS
000026A8                          2359              
000026A8  43F9 00004568           2360  OP_EOR_L    LEA     DISP_EOR_L,A1
000026AE  103C 000E               2361              MOVE.B  #14,D0
000026B2  4E4F                    2362              TRAP    #15
000026B4  183C 0002               2363              MOVE.B  #2,D4
000026B8  4E75                    2364              RTS    
000026BA                          2365  
000026BA                          2366  *---------------------------------------------------------------------------*
000026BA                          2367  * OP1100: Decode and display MULS/AND and proceed to EA
000026BA                          2368  *---------------------------------------------------------------------------* 
000026BA  4280                    2369  OP1100      CLR.L   D0                 
000026BC  4281                    2370              CLR.L   D1    
000026BE  4284                    2371              CLR.L   D4                
000026C0  227C 00000000           2372              MOVEA.L #0, A1        
000026C6  2205                    2373              MOVE.L  D5,D1
000026C8  EA89                    2374              LSR.L   #5,D1
000026CA  0281 0000000E           2375              ANDI.L  #$E,D1
000026D0  0C41 000E               2376              CMPI.W  #$E,D1
000026D4  6700 0006               2377              BEQ     OP_MULS
000026D8  6000 00F6               2378              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000026DC                          2379  
000026DC                          2380  OP_MULS                      
000026DC  4281                    2381              CLR.L   D1       
000026DE  4284                    2382              CLR.L   D4                   
000026E0  227C 00000000           2383              MOVEA.L #0, A1              
000026E6  2205                    2384              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000026E8                          2385              *CLEAR D3
000026E8  4283                    2386              CLR.L   D3
000026EA                          2387  
000026EA                          2388  OP1100_MULS_DN_EA_OR_EA_DN 
000026EA                          2389              *LOAD STACK WITH THIS OPMODE
000026EA  6100 16FC               2390              BSR     PUSH_STACK
000026EE  163C 004D               2391              MOVE.B  #'M',D3
000026F2  6100 16F4               2392              BSR     PUSH_STACK
000026F6  163C 0055               2393              MOVE.B  #'U',D3
000026FA  6100 16EC               2394              BSR     PUSH_STACK
000026FE  163C 004C               2395              MOVE.B  #'L',D3
00002702  6100 16E4               2396              BSR     PUSH_STACK
00002706  163C 0053               2397              MOVE.B  #'S',D3
0000270A  6100 16DC               2398              BSR     PUSH_STACK
0000270E  163C 002E               2399              MOVE.B  #'.',D3
00002712  6100 16D4               2400              BSR     PUSH_STACK
00002716                          2401              
00002716  2205                    2402              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002718                          2403              
00002718                          2404  OP1100_EA_DN_MULS           
00002718                          2405              *BITS (7 TO 6) 
00002718                          2406              *00 = .B
00002718                          2407              *01 = .W
00002718                          2408              *10 = .L 
00002718  2205                    2409              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000271A  EC99                    2410              ROR.L   #6,D1
0000271C  0281 00000003           2411              ANDI.L  #$03,D1
00002722  0C81 00000003           2412              CMPI.L  #%11,D1 *EQUALS .W
00002728  6700 0014               2413              BEQ     OP1100_PRINT_W_MULS
0000272C  0C81 00000000           2414              CMPI.L  #%00,D1 *EQUALS .L
00002732  6700 0052               2415              BEQ     OP1100_PRINT_L_MULS
00002736                          2416              
00002736  183C 0001               2417              MOVE.B  #1,D4               *ERROR READ
0000273A  6000 0092               2418              BRA     OP1100_MULS_RETURN
0000273E                          2419  OP1100_PRINT_W_MULS
0000273E  163C 0057               2420              MOVE.B  #'W',D3
00002742  6100 16A4               2421              BSR     PUSH_STACK
00002746                          2422  
00002746                          2423              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002746  13FC 0000 0000470E      2424              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000274E  13FC 0000 0000470F      2425              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002756                          2426             
00002756                          2427              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002756  13FC 00B9 00004711      2428              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000275E  13FC 0020 00004712      2429              MOVE.B   #$20,GET_SRC_START_END
00002766                          2430  
00002766                          2431             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002766  0285 0000FE3F           2432              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000276C  0685 00000000           2433              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002772                          2434  
00002772                          2435              
00002772  6100 0DD6               2436              BSR     GET_EA_EA_SRC      *GETS <ea>
00002776  163C 002C               2437              MOVE.B  #',',D3
0000277A  6100 166C               2438              BSR     PUSH_STACK
0000277E  6100 11FA               2439              BSR     GET_EA_EA_DEST       *GETS Dn    
00002782                          2440              
00002782  6000 004A               2441              BRA     OP1100_MULS_RETURN
00002786                          2442  OP1100_PRINT_L_MULS 
00002786  163C 004C               2443              MOVE.B  #'L',D3
0000278A  6100 165C               2444              BSR     PUSH_STACK
0000278E                          2445              
0000278E                          2446              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000278E  13FC 0000 0000470E      2447              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002796  13FC 0000 0000470F      2448              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000279E                          2449             
0000279E                          2450              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000279E  13FC 00B9 00004711      2451              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000027A6  13FC 0020 00004712      2452              MOVE.B   #$20,GET_SRC_START_END
000027AE                          2453  
000027AE                          2454              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027AE  0285 0000FE3F           2455              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027B4  0685 00000000           2456              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027BA                          2457  
000027BA                          2458                     
000027BA  6100 0D8E               2459              BSR     GET_EA_EA_SRC      *GETS <ea>
000027BE  163C 002C               2460              MOVE.B  #',',D3
000027C2  6100 1624               2461              BSR     PUSH_STACK                  
000027C6  6100 11B2               2462              BSR     GET_EA_EA_DEST       *GETS Dn    
000027CA                          2463  
000027CA                          2464              
000027CA  6000 0002               2465              BRA     OP1100_MULS_RETURN
000027CE                          2466              
000027CE                          2467  OP1100_MULS_RETURN
000027CE  4E75                    2468              RTS
000027D0                          2469              
000027D0                          2470  
000027D0                          2471  
000027D0                          2472  
000027D0                          2473  
000027D0                          2474  
000027D0                          2475  
000027D0                          2476  
000027D0                          2477  
000027D0                          2478  
000027D0                          2479  
000027D0                          2480  
000027D0                          2481  
000027D0                          2482  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000027D0                          2483              *LOAD STACK WITH THIS OPMODE
000027D0  4283                    2484              CLR.L   D3
000027D2  6100 1614               2485              BSR     PUSH_STACK
000027D6  163C 0041               2486              MOVE.B  #'A',D3
000027DA  6100 160C               2487              BSR     PUSH_STACK
000027DE  163C 004E               2488              MOVE.B  #'N',D3
000027E2  6100 1604               2489              BSR     PUSH_STACK
000027E6  163C 0044               2490              MOVE.B  #'D',D3
000027EA  6100 15FC               2491              BSR     PUSH_STACK
000027EE  163C 002E               2492              MOVE.B  #'.',D3
000027F2  6100 15F4               2493              BSR     PUSH_STACK
000027F6                          2494              
000027F6  2205                    2495              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000027F8                          2496              
000027F8                          2497              *BITS (INDEX 8) 
000027F8                          2498              *0 = ADD.B/W/L <EA>,Dn
000027F8                          2499              *1 = ADD.B/W/L Dn,<EA> 
000027F8  E099                    2500              ROR.L   #8,D1
000027FA  0281 00000001           2501              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002800  0C81 00000000           2502              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002806  6700 0102               2503              BEQ     OP1100_EA_DN
0000280A                          2504              *else procede to Dn_EA
0000280A                          2505              
0000280A                          2506  OP1100_DN_EA
0000280A                          2507              *BITS (7 TO 6) 
0000280A                          2508              *00 = .B
0000280A                          2509              *01 = .W
0000280A                          2510              *10 = .L 
0000280A  2205                    2511              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000280C  EC99                    2512              ROR.L   #6,D1
0000280E  0281 00000003           2513              ANDI.L  #$03,D1
00002814  0C81 00000000           2514              CMPI.L  #$00,D1 *EQUALS .B
0000281A  6700 0016               2515              BEQ     OP1100_PRINT_B2
0000281E  0C81 00000001           2516              CMPI.L  #$01,D1 *EQUALS .W
00002824  6700 0054               2517              BEQ     OP1100_PRINT_W2
00002828  0C81 00000002           2518              CMPI.L  #$02,D1 *EQUALS .L
0000282E  6700 0092               2519              BEQ     OP1100_PRINT_L2
00002832                          2520  OP1100_PRINT_B2
00002832                          2521              *PUSH 'B'
00002832  163C 0042               2522              MOVE.B  #'B',D3
00002836  6100 15B0               2523              BSR     PUSH_STACK
0000283A                          2524             
0000283A                          2525              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000283A  13FC 0000 0000470E      2526             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002842  13FC 0083 0000470F      2527             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000284A                          2528             
0000284A                          2529             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000284A  13FC 00B9 00004711      2530             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002852  13FC 0020 00004712      2531             MOVE.B   #$20,GET_SRC_START_END
0000285A                          2532  
0000285A                          2533              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000285A  0285 0000FE3F           2534              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002860  0685 00000000           2535              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002866                          2536       
00002866  6100 1112               2537              BSR     GET_EA_EA_DEST      *GETS Dn
0000286A  163C 002C               2538              MOVE.B  #',',D3
0000286E  6100 1578               2539              BSR     PUSH_STACK                     
00002872  6100 0CD6               2540              BSR     GET_EA_EA_SRC       *GETS <ea>
00002876                          2541  
00002876                          2542              
00002876  6000 0192               2543              BRA     OP1100_AND_RETURN
0000287A                          2544  OP1100_PRINT_W2
0000287A  163C 0057               2545              MOVE.B  #'W',D3
0000287E  6100 1568               2546              BSR     PUSH_STACK
00002882                          2547  
00002882                          2548              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002882  13FC 0000 0000470E      2549              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000288A  13FC 0083 0000470F      2550              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002892                          2551             
00002892                          2552              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002892  13FC 00B9 00004711      2553              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000289A  13FC 0020 00004712      2554              MOVE.B   #$20,GET_SRC_START_END
000028A2                          2555  
000028A2                          2556              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028A2  0285 0000FE3F           2557              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028A8  0685 00000000           2558              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000028AE                          2559  
000028AE                          2560        
000028AE  6100 10CA               2561              BSR     GET_EA_EA_DEST      *GETS Dn
000028B2  163C 002C               2562              MOVE.B  #',',D3
000028B6  6100 1530               2563              BSR     PUSH_STACK               
000028BA  6100 0C8E               2564              BSR     GET_EA_EA_SRC       *GETS <ea>       
000028BE                          2565  
000028BE                          2566  
000028BE                          2567  
000028BE  6000 049A               2568              BRA     OP1101_ADD_RETURN
000028C2                          2569  OP1100_PRINT_L2 
000028C2  163C 004C               2570              MOVE.B  #'L',D3
000028C6  6100 1520               2571              BSR     PUSH_STACK
000028CA                          2572              
000028CA                          2573              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028CA  13FC 0000 0000470E      2574              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000028D2  13FC 0083 0000470F      2575              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000028DA                          2576             
000028DA                          2577              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000028DA  13FC 00B9 00004711      2578              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000028E2  13FC 0020 00004712      2579              MOVE.B   #$20,GET_SRC_START_END
000028EA                          2580  
000028EA                          2581             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000028EA  0285 0000FE3F           2582              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000028F0  0685 00000000           2583              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000028F6                          2584  
000028F6                          2585               
000028F6  6100 1082               2586              BSR     GET_EA_EA_DEST       *GETS Dn
000028FA  163C 002C               2587              MOVE.B  #',',D3
000028FE  6100 14E8               2588              BSR     PUSH_STACK          
00002902  6100 0C46               2589              BSR     GET_EA_EA_SRC        *GETS <ea>
00002906                          2590  
00002906  6000 0102               2591              BRA     OP1100_AND_RETURN
0000290A                          2592              
0000290A                          2593  OP1100_EA_DN           
0000290A                          2594              *BITS (7 TO 6) 
0000290A                          2595              *00 = .B
0000290A                          2596              *01 = .W
0000290A                          2597              *10 = .L 
0000290A  2205                    2598              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000290C  EC99                    2599              ROR.L   #6,D1
0000290E  0281 00000003           2600              ANDI.L  #$03,D1
00002914  0C81 00000000           2601              CMPI.L  #$00,D1 *EQUALS .B
0000291A  6700 0016               2602              BEQ     OP1100_PRINT_B
0000291E  0C81 00000001           2603              CMPI.L  #$01,D1 *EQUALS .W
00002924  6700 0054               2604              BEQ     OP1100_PRINT_W
00002928  0C81 00000002           2605              CMPI.L  #$02,D1 *EQUALS .L
0000292E  6700 0092               2606              BEQ     OP1100_PRINT_L
00002932                          2607  OP1100_PRINT_B
00002932  163C 0042               2608              MOVE.B  #'B',D3
00002936  6100 14B0               2609              BSR     PUSH_STACK
0000293A                          2610                
0000293A                          2611              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000293A  13FC 0000 0000470E      2612              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002942  13FC 0002 0000470F      2613              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000294A                          2614             
0000294A                          2615              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000294A  13FC 00B9 00004711      2616              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002952  13FC 0020 00004712      2617              MOVE.B   #$20,GET_SRC_START_END
0000295A                          2618  
0000295A                          2619             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000295A  0285 0000FE3F           2620              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002960  0685 00000000           2621              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002966                          2622  
00002966                          2623              
00002966  6100 0BE2               2624              BSR     GET_EA_EA_SRC      *GETS <ea>
0000296A  163C 002C               2625              MOVE.B  #',',D3
0000296E  6100 1478               2626              BSR     PUSH_STACK          
00002972  6100 1006               2627              BSR     GET_EA_EA_DEST       *GETS Dn
00002976                          2628              
00002976  6000 03E2               2629              BRA     OP1101_ADD_RETURN
0000297A                          2630  OP1100_PRINT_W
0000297A  163C 0057               2631              MOVE.B  #'W',D3
0000297E  6100 1468               2632              BSR     PUSH_STACK
00002982                          2633  
00002982                          2634              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002982  13FC 0000 0000470E      2635              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000298A  13FC 0002 0000470F      2636              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002992                          2637             
00002992                          2638              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002992  13FC 00B9 00004711      2639              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000299A  13FC 0020 00004712      2640              MOVE.B   #$20,GET_SRC_START_END
000029A2                          2641  
000029A2                          2642             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029A2  0285 0000FE3F           2643              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029A8  0685 00000000           2644              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029AE                          2645  
000029AE                          2646              
000029AE  6100 0B9A               2647              BSR     GET_EA_EA_SRC      *GETS <ea>
000029B2  163C 002C               2648              MOVE.B  #',',D3
000029B6  6100 1430               2649              BSR     PUSH_STACK
000029BA  6100 0FBE               2650              BSR     GET_EA_EA_DEST       *GETS Dn    
000029BE                          2651              
000029BE  6000 F988               2652              BRA     OP1001_ADD_RETURN
000029C2                          2653  OP1100_PRINT_L 
000029C2  163C 004C               2654              MOVE.B  #'L',D3
000029C6  6100 1420               2655              BSR     PUSH_STACK
000029CA                          2656              
000029CA                          2657              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000029CA  13FC 0000 0000470E      2658              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000029D2  13FC 0002 0000470F      2659              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000029DA                          2660             
000029DA                          2661              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000029DA  13FC 00B9 00004711      2662              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029E2  13FC 0020 00004712      2663              MOVE.B   #$20,GET_SRC_START_END
000029EA                          2664  
000029EA                          2665              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029EA  0285 0000FE3F           2666              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029F0  0685 00000000           2667              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029F6                          2668  
000029F6                          2669                     
000029F6  6100 0B52               2670              BSR     GET_EA_EA_SRC      *GETS <ea>
000029FA  163C 002C               2671              MOVE.B  #',',D3
000029FE  6100 13E8               2672              BSR     PUSH_STACK                  
00002A02  6100 0F76               2673              BSR     GET_EA_EA_DEST       *GETS Dn    
00002A06                          2674  
00002A06                          2675              
00002A06  6000 0002               2676              BRA     OP1100_AND_RETURN
00002A0A                          2677              
00002A0A                          2678  OP1100_AND_RETURN
00002A0A  4E75                    2679              RTS
00002A0C                          2680  
00002A0C                          2681  
00002A0C                          2682  *---------------------------------------------------------------------------*
00002A0C                          2683  * OP1101: Decode ADD/ADDA
00002A0C                          2684  *---------------------------------------------------------------------------* 
00002A0C  4280                    2685  OP1101      CLR.L   D0                  
00002A0E  4281                    2686              CLR.L   D1       
00002A10  4284                    2687              CLR.L   D4                   
00002A12  227C 00000000           2688              MOVEA.L #0, A1              
00002A18  2205                    2689              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002A1A                          2690              
00002A1A                          2691              *CLEAR D3
00002A1A  4283                    2692              CLR.L   D3
00002A1C                          2693              
00002A1C                          2694              
00002A1C                          2695              
00002A1C                          2696              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002A1C  2205                    2697              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002A1E                          2698              *BITS (INDEX 8) 
00002A1E                          2699              *0 = ADD.B/W/L <EA>,Dn
00002A1E                          2700              *1 = ADD.B/W/L Dn,<EA> 
00002A1E  EC99                    2701              ROR.L   #6,D1
00002A20  0281 00000007           2702              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002A26  0C81 00000007           2703              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002A2C  6700 0010               2704              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002A30  0C81 00000003           2705              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002A36  6700 0078               2706              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002A3A  6000 00E6               2707              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002A3E                          2708              
00002A3E                          2709  OP1101_ADDA_L
00002A3E                          2710              *LOAD STACK WITH THIS OPMODE
00002A3E  6100 13A8               2711              BSR     PUSH_STACK
00002A42  163C 0041               2712              MOVE.B  #'A',D3
00002A46  6100 13A0               2713              BSR     PUSH_STACK
00002A4A  163C 0044               2714              MOVE.B  #'D',D3
00002A4E  6100 1398               2715              BSR     PUSH_STACK
00002A52  163C 0044               2716              MOVE.B  #'D',D3
00002A56  6100 1390               2717              BSR     PUSH_STACK
00002A5A  163C 0041               2718              MOVE.B  #'A',D3
00002A5E  6100 1388               2719              BSR     PUSH_STACK
00002A62  163C 002E               2720              MOVE.B  #'.',D3
00002A66  6100 1380               2721              BSR     PUSH_STACK
00002A6A  163C 004C               2722              MOVE.B  #'L',D3
00002A6E  6100 1378               2723              BSR     PUSH_STACK
00002A72                          2724              
00002A72                          2725             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A72  13FC 0000 0000470E      2726             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A7A  13FC 0000 0000470F      2727             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A82                          2728             
00002A82                          2729             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A82  13FC 00B9 00004711      2730             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A8A  13FC 0020 00004712      2731             MOVE.B   #$20,GET_SRC_START_END
00002A92                          2732  
00002A92                          2733              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A92  0285 0000FE3F           2734              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A98  0685 00000040           2735              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A9E                          2736       
00002A9E                          2737              *PRINT <EA>,AN
00002A9E  6100 0AAA               2738              BSR     GET_EA_EA_SRC       *GETS <ea>
00002AA2  163C 002C               2739              MOVE.B  #',',D3
00002AA6  6100 1340               2740              BSR     PUSH_STACK                     
00002AAA  6100 0ECE               2741              BSR     GET_EA_EA_DEST      *GETS Dn
00002AAE                          2742  
00002AAE                          2743              
00002AAE                          2744              
00002AAE  4E75                    2745              RTS
00002AB0                          2746  OP1101_ADDA_W
00002AB0                          2747              *LOAD STACK WITH THIS OPMODE
00002AB0  6100 1336               2748              BSR     PUSH_STACK
00002AB4  163C 0041               2749              MOVE.B  #'A',D3
00002AB8  6100 132E               2750              BSR     PUSH_STACK
00002ABC  163C 0044               2751              MOVE.B  #'D',D3
00002AC0  6100 1326               2752              BSR     PUSH_STACK
00002AC4  163C 0044               2753              MOVE.B  #'D',D3
00002AC8  6100 131E               2754              BSR     PUSH_STACK
00002ACC  163C 0041               2755              MOVE.B  #'A',D3
00002AD0  6100 1316               2756              BSR     PUSH_STACK
00002AD4  163C 002E               2757              MOVE.B  #'.',D3
00002AD8  6100 130E               2758              BSR     PUSH_STACK
00002ADC  163C 0057               2759              MOVE.B  #'W',D3
00002AE0  6100 1306               2760              BSR     PUSH_STACK
00002AE4                          2761              
00002AE4                          2762             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AE4  13FC 0000 0000470E      2763             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AEC  13FC 0000 0000470F      2764             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AF4                          2765             
00002AF4                          2766             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AF4  13FC 00B9 00004711      2767             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AFC  13FC 0020 00004712      2768             MOVE.B   #$20,GET_SRC_START_END
00002B04                          2769  
00002B04                          2770              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B04  0285 0000FE3F           2771              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B0A  0685 00000040           2772              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B10                          2773       
00002B10                          2774              *PRINT <EA>,AN
00002B10  6100 0A38               2775              BSR     GET_EA_EA_SRC       *GETS <ea>
00002B14  163C 002C               2776              MOVE.B  #',',D3
00002B18  6100 12CE               2777              BSR     PUSH_STACK                     
00002B1C  6100 0E5C               2778              BSR     GET_EA_EA_DEST      *GETS Dn
00002B20                          2779  
00002B20  4E75                    2780              RTS
00002B22                          2781  
00002B22                          2782  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002B22                          2783              *LOAD STACK WITH THIS OPMODE
00002B22  6100 12C4               2784              BSR     PUSH_STACK
00002B26  163C 0041               2785              MOVE.B  #'A',D3
00002B2A  6100 12BC               2786              BSR     PUSH_STACK
00002B2E  163C 0044               2787              MOVE.B  #'D',D3
00002B32  6100 12B4               2788              BSR     PUSH_STACK
00002B36  163C 0044               2789              MOVE.B  #'D',D3
00002B3A  6100 12AC               2790              BSR     PUSH_STACK
00002B3E  163C 002E               2791              MOVE.B  #'.',D3
00002B42  6100 12A4               2792              BSR     PUSH_STACK
00002B46                          2793              
00002B46  2205                    2794              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002B48                          2795              
00002B48                          2796              *BITS (INDEX 8) 
00002B48                          2797              *0 = ADD.B/W/L <EA>,Dn
00002B48                          2798              *1 = ADD.B/W/L Dn,<EA> 
00002B48  E099                    2799              ROR.L   #8,D1
00002B4A  0281 00000001           2800              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002B50  0C81 00000000           2801              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002B56  6700 0102               2802              BEQ     OP1101_EA_DN
00002B5A                          2803              *else procede to Dn_EA
00002B5A                          2804              
00002B5A                          2805  OP1101_DN_EA
00002B5A                          2806              *BITS (7 TO 6) 
00002B5A                          2807              *00 = .B
00002B5A                          2808              *01 = .W
00002B5A                          2809              *10 = .L 
00002B5A  2205                    2810              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002B5C  EC99                    2811              ROR.L   #6,D1
00002B5E  0281 00000003           2812              ANDI.L  #$03,D1
00002B64  0C81 00000000           2813              CMPI.L  #$00,D1 *EQUALS .B
00002B6A  6700 0016               2814              BEQ     OP1101_PRINT_B2
00002B6E  0C81 00000001           2815              CMPI.L  #$01,D1 *EQUALS .W
00002B74  6700 0054               2816              BEQ     OP1101_PRINT_W2
00002B78  0C81 00000002           2817              CMPI.L  #$02,D1 *EQUALS .L
00002B7E  6700 0092               2818              BEQ     OP1101_PRINT_L2
00002B82                          2819  OP1101_PRINT_B2
00002B82                          2820              *PUSH 'B'
00002B82  163C 0042               2821              MOVE.B  #'B',D3
00002B86  6100 1260               2822              BSR     PUSH_STACK
00002B8A                          2823             
00002B8A                          2824              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B8A  13FC 0002 0000470E      2825             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B92  13FC 0083 0000470F      2826             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B9A                          2827             
00002B9A                          2828             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B9A  13FC 00B9 00004711      2829             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BA2  13FC 0020 00004712      2830             MOVE.B   #$20,GET_SRC_START_END
00002BAA                          2831  
00002BAA                          2832              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BAA  0285 0000FE3F           2833              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BB0  0685 00000000           2834              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002BB6                          2835       
00002BB6  6100 0DC2               2836              BSR     GET_EA_EA_DEST      *GETS Dn
00002BBA  163C 002C               2837              MOVE.B  #',',D3
00002BBE  6100 1228               2838              BSR     PUSH_STACK                     
00002BC2  6100 0986               2839              BSR     GET_EA_EA_SRC       *GETS <ea>
00002BC6                          2840  
00002BC6                          2841              
00002BC6  6000 0192               2842              BRA     OP1101_ADD_RETURN
00002BCA                          2843  OP1101_PRINT_W2
00002BCA  163C 0057               2844              MOVE.B  #'W',D3
00002BCE  6100 1218               2845              BSR     PUSH_STACK
00002BD2                          2846  
00002BD2                          2847              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BD2  13FC 0000 0000470E      2848              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BDA  13FC 0083 0000470F      2849              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BE2                          2850             
00002BE2                          2851              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BE2  13FC 00B9 00004711      2852              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BEA  13FC 0020 00004712      2853              MOVE.B   #$20,GET_SRC_START_END
00002BF2                          2854  
00002BF2                          2855              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BF2  0285 0000FE3F           2856              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BF8  0685 00000000           2857              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002BFE                          2858  
00002BFE                          2859        
00002BFE  6100 0D7A               2860              BSR     GET_EA_EA_DEST      *GETS Dn
00002C02  163C 002C               2861              MOVE.B  #',',D3
00002C06  6100 11E0               2862              BSR     PUSH_STACK               
00002C0A  6100 093E               2863              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002C0E                          2864  
00002C0E                          2865  
00002C0E                          2866  
00002C0E  6000 014A               2867              BRA     OP1101_ADD_RETURN
00002C12                          2868  OP1101_PRINT_L2 
00002C12  163C 004C               2869              MOVE.B  #'L',D3
00002C16  6100 11D0               2870              BSR     PUSH_STACK
00002C1A                          2871              
00002C1A                          2872              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C1A  13FC 0000 0000470E      2873              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C22  13FC 0083 0000470F      2874              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C2A                          2875             
00002C2A                          2876              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C2A  13FC 00B9 00004711      2877              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C32  13FC 0020 00004712      2878              MOVE.B   #$20,GET_SRC_START_END
00002C3A                          2879  
00002C3A                          2880             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C3A  0285 0000FE3F           2881              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C40  0685 00000000           2882              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002C46                          2883  
00002C46                          2884               
00002C46  6100 0D32               2885              BSR     GET_EA_EA_DEST       *GETS Dn
00002C4A  163C 002C               2886              MOVE.B  #',',D3
00002C4E  6100 1198               2887              BSR     PUSH_STACK          
00002C52  6100 08F6               2888              BSR     GET_EA_EA_SRC        *GETS <ea>
00002C56                          2889  
00002C56  6000 0102               2890              BRA     OP1101_ADD_RETURN
00002C5A                          2891              
00002C5A                          2892  OP1101_EA_DN           
00002C5A                          2893              *BITS (7 TO 6) 
00002C5A                          2894              *00 = .B
00002C5A                          2895              *01 = .W
00002C5A                          2896              *10 = .L 
00002C5A  2205                    2897              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002C5C  EC99                    2898              ROR.L   #6,D1
00002C5E  0281 00000003           2899              ANDI.L  #$03,D1
00002C64  0C81 00000000           2900              CMPI.L  #$00,D1 *EQUALS .B
00002C6A  6700 0016               2901              BEQ     OP1101_PRINT_B
00002C6E  0C81 00000001           2902              CMPI.L  #$01,D1 *EQUALS .W
00002C74  6700 0054               2903              BEQ     OP1101_PRINT_W
00002C78  0C81 00000002           2904              CMPI.L  #$02,D1 *EQUALS .L
00002C7E  6700 0092               2905              BEQ     OP1101_PRINT_L
00002C82                          2906  OP1101_PRINT_B
00002C82  163C 0042               2907              MOVE.B  #'B',D3
00002C86  6100 1160               2908              BSR     PUSH_STACK
00002C8A                          2909                
00002C8A                          2910              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C8A  13FC 0002 0000470E      2911              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C92  13FC 0002 0000470F      2912              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C9A                          2913             
00002C9A                          2914              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C9A  13FC 00B9 00004711      2915              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CA2  13FC 0020 00004712      2916              MOVE.B   #$20,GET_SRC_START_END
00002CAA                          2917  
00002CAA                          2918             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CAA  0285 0000FE3F           2919              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CB0  0685 00000000           2920              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002CB6                          2921  
00002CB6                          2922              
00002CB6  6100 0892               2923              BSR     GET_EA_EA_SRC      *GETS <ea>
00002CBA  163C 002C               2924              MOVE.B  #',',D3
00002CBE  6100 1128               2925              BSR     PUSH_STACK          
00002CC2  6100 0CB6               2926              BSR     GET_EA_EA_DEST       *GETS Dn
00002CC6                          2927              
00002CC6  6000 0092               2928              BRA     OP1101_ADD_RETURN
00002CCA                          2929  OP1101_PRINT_W
00002CCA  163C 0057               2930              MOVE.B  #'W',D3
00002CCE  6100 1118               2931              BSR     PUSH_STACK
00002CD2                          2932  
00002CD2                          2933              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CD2  13FC 0000 0000470E      2934              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CDA  13FC 0000 0000470F      2935              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CE2                          2936             
00002CE2                          2937              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CE2  13FC 00B9 00004711      2938              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CEA  13FC 0020 00004712      2939              MOVE.B   #$20,GET_SRC_START_END
00002CF2                          2940  
00002CF2                          2941             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CF2  0285 0000FE3F           2942              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CF8  0685 00000000           2943              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002CFE                          2944  
00002CFE                          2945              
00002CFE  6100 084A               2946              BSR     GET_EA_EA_SRC      *GETS <ea>
00002D02  163C 002C               2947              MOVE.B  #',',D3
00002D06  6100 10E0               2948              BSR     PUSH_STACK
00002D0A  6100 0C6E               2949              BSR     GET_EA_EA_DEST       *GETS Dn    
00002D0E                          2950              
00002D0E  6000 004A               2951              BRA     OP1101_ADD_RETURN
00002D12                          2952  OP1101_PRINT_L 
00002D12  163C 004C               2953              MOVE.B  #'L',D3
00002D16  6100 10D0               2954              BSR     PUSH_STACK
00002D1A                          2955              
00002D1A                          2956              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D1A  13FC 0000 0000470E      2957              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D22  13FC 0000 0000470F      2958              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D2A                          2959             
00002D2A                          2960              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D2A  13FC 00B9 00004711      2961              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D32  13FC 0020 00004712      2962              MOVE.B   #$20,GET_SRC_START_END
00002D3A                          2963  
00002D3A                          2964              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D3A  0285 0000FE3F           2965              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D40  0685 00000000           2966              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D46                          2967  
00002D46                          2968                     
00002D46  6100 0802               2969              BSR     GET_EA_EA_SRC      *GETS <ea>
00002D4A  163C 002C               2970              MOVE.B  #',',D3
00002D4E  6100 1098               2971              BSR     PUSH_STACK                  
00002D52  6100 0C26               2972              BSR     GET_EA_EA_DEST       *GETS Dn    
00002D56                          2973  
00002D56                          2974              
00002D56  6000 0002               2975              BRA     OP1101_ADD_RETURN
00002D5A                          2976              
00002D5A                          2977  OP1101_ADD_RETURN
00002D5A  4E75                    2978              RTS
00002D5C                          2979              
00002D5C                          2980              *ADDW
00002D5C  0C01 0006               2981              CMPI.B  #$6,D1
00002D60  6700 0056               2982              BEQ     OP_ADDA_W
00002D64  0C01 000E               2983              CMPI.B  #$E,D1
00002D68  6700 0066               2984              BEQ     OP_ADDA_L 
00002D6C                          2985  
00002D6C  4EF8 15E2               2986              JMP     OP_DATA  
00002D70                          2987            
00002D70                          2988  *---------------------------------------------------------------------------*
00002D70                          2989  * OP_ADD: display ADD and proceed to EA
00002D70                          2990  *---------------------------------------------------------------------------*  
00002D70  43F9 000045C5           2991  OP_ADD_B    LEA     DISP_ADD_B,A1
00002D76  103C 000E               2992              MOVE.B  #14,D0
00002D7A  4E4F                    2993              TRAP    #15
00002D7C  183C 0000               2994              MOVE.B  #0,D4
00002D80  4EF9 000030FA           2995              JMP     EA_GEN
00002D86                          2996  
00002D86  4E75                    2997              RTS
00002D88                          2998  
00002D88  43F9 000045CE           2999  OP_ADD_W    LEA     DISP_ADD_W,A1
00002D8E  103C 000E               3000              MOVE.B  #14,D0
00002D92  4E4F                    3001              TRAP    #15
00002D94  183C 0001               3002              MOVE.B  #1,D4
00002D98  4EF9 000030FA           3003              JMP     EA_GEN
00002D9E                          3004  
00002D9E  4E75                    3005              RTS
00002DA0                          3006  
00002DA0  43F9 000045D7           3007  OP_ADD_L    LEA     DISP_ADD_L,A1
00002DA6  103C 000E               3008              MOVE.B  #14,D0
00002DAA  4E4F                    3009              TRAP    #15
00002DAC  183C 0002               3010              MOVE.B  #2,D4
00002DB0  4EF9 000030FA           3011              JMP     EA_GEN
00002DB6                          3012  
00002DB6  4E75                    3013              RTS
00002DB8                          3014  
00002DB8                          3015  *---------------------------------------------------------------------------*
00002DB8                          3016  * OP_ADDA: display ADDA and proceed to EA
00002DB8                          3017  *---------------------------------------------------------------------------*  
00002DB8  43F9 000045E0           3018  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002DBE  103C 000E               3019              MOVE.B  #14,D0
00002DC2  4E4F                    3020              TRAP    #15
00002DC4  183C 0001               3021              MOVE.B  #1,D4
00002DC8  4EF9 000030FA           3022              JMP     EA_GEN
00002DCE                          3023  
00002DCE  4E75                    3024              RTS
00002DD0                          3025  
00002DD0  43F9 000045EA           3026  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002DD6  103C 000E               3027              MOVE.B  #14,D0
00002DDA  4E4F                    3028              TRAP    #15
00002DDC  183C 0002               3029              MOVE.B  #2,D4
00002DE0  4EF9 000030FA           3030              JMP     EA_GEN
00002DE6                          3031  
00002DE6  4E75                    3032              RTS
00002DE8                          3033              
00002DE8                          3034  *---------------------------------------------------------------------------*
00002DE8                          3035  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002DE8                          3036  *---------------------------------------------------------------------------* 
00002DE8  4280                    3037  OP1110      CLR.L   D0                  
00002DEA  4281                    3038              CLR.L   D1   
00002DEC  4284                    3039              CLR.L   D4                   
00002DEE  227C 00000000           3040              MOVEA.L #0, A1                 
00002DF4  2205                    3041              MOVE.L  D5,D1
00002DF6                          3042              
00002DF6                          3043              * check for LSX
00002DF6  E699                    3044              ROR.L   #3,D1
00002DF8  0281 00000001           3045              ANDI.L  #$1,D1
00002DFE  0C01 0001               3046              CMPI.B  #1,D1
00002E02  6700 002E               3047              BEQ     OP_LSX
00002E06                          3048              
00002E06                          3049              * reset D1 and check for ASX
00002E06  4281                    3050              CLR.L   D1
00002E08  2205                    3051              MOVE.L  D5,D1
00002E0A  E699                    3052              ROR.L   #3,D1
00002E0C  0281 00000001           3053              ANDI.L  #$1,D1
00002E12  0C01 0000               3054              CMPI.B  #0,D1
00002E16  6700 0032               3055              BEQ     OP_ASX
00002E1A                          3056  
00002E1A                          3057              * reset D1 and check for ROX
00002E1A  4281                    3058              CLR.L   D1
00002E1C  2205                    3059              MOVE.L  D5,D1
00002E1E  E699                    3060              ROR.L   #3,D1
00002E20  0281 00000001           3061              ANDI.L  #$1,D1
00002E26  0C01 0003               3062              CMPI.B  #3,D1
00002E2A  6700 0036               3063              BEQ     OP_ROX
00002E2E                          3064              
00002E2E  4EF8 15E2               3065              JMP     OP_DATA
00002E32                          3066  
00002E32                          3067  *---------------------------------------------------------------------------*
00002E32                          3068  * OP_LSX: process LSR/LSL
00002E32                          3069  *---------------------------------------------------------------------------*            
00002E32  EA99                    3070  OP_LSX      ROR.L   #5,D1
00002E34  0281 00000001           3071              ANDI.L  #$1,D1
00002E3A  0C01 0000               3072              CMPI.B  #0,D1
00002E3E  6700 003A               3073              BEQ     OP_LSR
00002E42  0C01 0001               3074              CMPI.B  #1,D1
00002E46  6700 008C               3075              BEQ     OP_LSL
00002E4A                          3076              
00002E4A                          3077  *---------------------------------------------------------------------------*
00002E4A                          3078  * OP_ASX: process ASR/ASL
00002E4A                          3079  *---------------------------------------------------------------------------*  
00002E4A  EA99                    3080  OP_ASX      ROR.L   #5,D1
00002E4C  0281 00000001           3081              ANDI.L  #$1,D1
00002E52  0C01 0000               3082              CMPI.B  #0,D1
00002E56  6700 00D6               3083              BEQ     OP_ASR
00002E5A  0C01 0001               3084              CMPI.B  #1,D1
00002E5E  6700 0128               3085              BEQ     OP_ASL
00002E62                          3086              
00002E62                          3087  *---------------------------------------------------------------------------*
00002E62                          3088  * OP_ROX: process ROR/ROL
00002E62                          3089  *---------------------------------------------------------------------------*  
00002E62  EA99                    3090  OP_ROX      ROR.L   #5,D1
00002E64  0281 00000001           3091              ANDI.L  #$1,D1
00002E6A  0C01 0000               3092              CMPI.B  #0,D1
00002E6E  6700 0172               3093              BEQ     OP_ROR
00002E72  0C01 0001               3094              CMPI.B  #1,D1
00002E76  6700 01C4               3095              BEQ     OP_ROL
00002E7A                          3096  
00002E7A                          3097  *---------------------------------------------------------------------------*
00002E7A                          3098  * OP_LSR: decode and display LSR
00002E7A                          3099  *---------------------------------------------------------------------------*        
00002E7A  E599                    3100  OP_LSR      ROL.L   #2,D1
00002E7C  0281 00000003           3101              ANDI.L  #$3,D1
00002E82  0C01 0000               3102              CMPI.B  #0,D1
00002E86  6700 0016               3103              BEQ     OP_LSR_B
00002E8A  0C01 0001               3104              CMPI.B  #$1,D1
00002E8E  6700 0032               3105              BEQ     OP_LSR_W
00002E92  0C01 0002               3106              CMPI.B  #$2,D1
00002E96  6700 0018               3107              BEQ     OP_LSR_L
00002E9A                          3108              
00002E9A  4EF8 15E2               3109              JMP     OP_DATA
00002E9E                          3110  
00002E9E  43F9 000045F4           3111  OP_LSR_B    LEA     DISP_LSR_B,A1
00002EA4  103C 000E               3112              MOVE.B  #14,D0
00002EA8  4E4F                    3113              TRAP    #15
00002EAA  183C 0000               3114              MOVE.B  #0,D4
00002EAE  4E75                    3115              RTS
00002EB0                          3116  
00002EB0  43F9 00004618           3117  OP_LSR_L    LEA     DISP_LSR_L,A1
00002EB6  103C 000E               3118              MOVE.B  #14,D0
00002EBA  4E4F                    3119              TRAP    #15
00002EBC  183C 0002               3120              MOVE.B  #2,D4
00002EC0  4E75                    3121              RTS
00002EC2                          3122  
00002EC2  43F9 00004606           3123  OP_LSR_W    LEA     DISP_LSR_W,A1
00002EC8  103C 000E               3124              MOVE.B  #14,D0
00002ECC  4E4F                    3125              TRAP    #15
00002ECE  183C 0001               3126              MOVE.B  #1,D4
00002ED2  4E75                    3127              RTS
00002ED4                          3128   
00002ED4                          3129  *---------------------------------------------------------------------------*
00002ED4                          3130  * OP_LSL: decode and display LSL
00002ED4                          3131  *---------------------------------------------------------------------------*             
00002ED4  E599                    3132  OP_LSL      ROL.L   #2,D1
00002ED6  0281 00000003           3133              ANDI.L  #$3,D1
00002EDC  0C01 0000               3134              CMPI.B  #0,D1
00002EE0  6700 0016               3135              BEQ     OP_LSL_B
00002EE4  0C01 0001               3136              CMPI.B  #$1,D1
00002EE8  6700 0032               3137              BEQ     OP_LSL_W
00002EEC  0C01 0002               3138              CMPI.B  #$2,D1
00002EF0  6700 0018               3139              BEQ     OP_LSL_L
00002EF4                          3140              
00002EF4  4EF8 15E2               3141              JMP OP_DATA
00002EF8                          3142  
00002EF8  43F9 000045FD           3143  OP_LSL_B    LEA     DISP_LSL_B,A1
00002EFE  103C 000E               3144              MOVE.B  #14,D0
00002F02  4E4F                    3145              TRAP    #15
00002F04  183C 0000               3146              MOVE.B  #0,D4
00002F08  4E75                    3147              RTS
00002F0A                          3148  
00002F0A  43F9 00004621           3149  OP_LSL_L    LEA     DISP_LSL_L,A1
00002F10  103C 000E               3150              MOVE.B  #14,D0
00002F14  4E4F                    3151              TRAP    #15
00002F16  183C 0002               3152              MOVE.B  #2,D4
00002F1A  4E75                    3153              RTS
00002F1C                          3154  
00002F1C  43F9 0000460F           3155  OP_LSL_W    LEA     DISP_LSL_W,A1
00002F22  103C 000E               3156              MOVE.B  #14,D0
00002F26  4E4F                    3157              TRAP    #15
00002F28  183C 0001               3158              MOVE.B  #1,D4
00002F2C  4E75                    3159              RTS
00002F2E                          3160   
00002F2E                          3161  *---------------------------------------------------------------------------*
00002F2E                          3162  * OP_ASR: decode and display ASR
00002F2E                          3163  *---------------------------------------------------------------------------*             
00002F2E  E599                    3164  OP_ASR      ROL.L   #2,D1
00002F30  0281 00000003           3165              ANDI.L  #$3,D1
00002F36  0C01 0000               3166              CMPI.B  #0,D1
00002F3A  6700 0016               3167              BEQ     OP_ASR_B
00002F3E  0C01 0001               3168              CMPI.B  #$1,D1
00002F42  6700 0032               3169              BEQ     OP_ASR_W
00002F46  0C01 0002               3170              CMPI.B  #$2,D1
00002F4A  6700 0018               3171              BEQ     OP_ASR_L
00002F4E                          3172              
00002F4E  4EF8 15E2               3173              JMP OP_DATA
00002F52                          3174  
00002F52  43F9 0000462A           3175  OP_ASR_B    LEA     DISP_ASR_B,A1
00002F58  103C 000E               3176              MOVE.B  #14,D0
00002F5C  4E4F                    3177              TRAP    #15
00002F5E  183C 0000               3178              MOVE.B  #0,D4
00002F62  4E75                    3179              RTS
00002F64                          3180  
00002F64  43F9 0000464E           3181  OP_ASR_L    LEA     DISP_ASR_L,A1
00002F6A  103C 000E               3182              MOVE.B  #14,D0
00002F6E  4E4F                    3183              TRAP    #15
00002F70  183C 0002               3184              MOVE.B  #2,D4
00002F74  4E75                    3185              RTS
00002F76                          3186  
00002F76  43F9 0000463C           3187  OP_ASR_W    LEA     DISP_ASR_W,A1
00002F7C  103C 000E               3188              MOVE.B  #14,D0
00002F80  4E4F                    3189              TRAP    #15
00002F82  183C 0001               3190              MOVE.B  #1,D4
00002F86  4E75                    3191              RTS
00002F88                          3192       
00002F88                          3193  *---------------------------------------------------------------------------*
00002F88                          3194  * OP_ASL: decode and display ASL
00002F88                          3195  *---------------------------------------------------------------------------*         
00002F88  E599                    3196  OP_ASL      ROL.L   #2,D1
00002F8A  0281 00000003           3197              ANDI.L  #$3,D1
00002F90  0C01 0000               3198              CMPI.B  #0,D1
00002F94  6700 0016               3199              BEQ     OP_ASL_B
00002F98  0C01 0001               3200              CMPI.B  #$1,D1
00002F9C  6700 0032               3201              BEQ     OP_ASL_W
00002FA0  0C01 0002               3202              CMPI.B  #$2,D1
00002FA4  6700 0018               3203              BEQ     OP_ASL_L
00002FA8                          3204              
00002FA8  4EF8 15E2               3205              JMP OP_DATA
00002FAC                          3206  
00002FAC  43F9 00004633           3207  OP_ASL_B    LEA     DISP_ASL_B,A1
00002FB2  103C 000E               3208              MOVE.B  #14,D0
00002FB6  4E4F                    3209              TRAP    #15
00002FB8  183C 0000               3210              MOVE.B  #0,D4
00002FBC  4E75                    3211              RTS
00002FBE                          3212  
00002FBE  43F9 00004657           3213  OP_ASL_L    LEA     DISP_ASL_L,A1
00002FC4  103C 000E               3214              MOVE.B  #14,D0
00002FC8  4E4F                    3215              TRAP    #15
00002FCA  183C 0002               3216              MOVE.B  #2,D4
00002FCE  4E75                    3217              RTS
00002FD0                          3218  
00002FD0  43F9 00004645           3219  OP_ASL_W    LEA     DISP_ASL_W,A1
00002FD6  103C 000E               3220              MOVE.B  #14,D0
00002FDA  4E4F                    3221              TRAP    #15
00002FDC  183C 0001               3222              MOVE.B  #1,D4
00002FE0  4E75                    3223              RTS
00002FE2                          3224   
00002FE2                          3225  *---------------------------------------------------------------------------*
00002FE2                          3226  * OP_ROR: decode and display ROR
00002FE2                          3227  *---------------------------------------------------------------------------*             
00002FE2  E599                    3228  OP_ROR      ROL.L   #2,D1
00002FE4  0281 00000003           3229              ANDI.L  #$3,D1
00002FEA  0C01 0000               3230              CMPI.B  #0,D1
00002FEE  6700 0016               3231              BEQ     OP_ROR_B
00002FF2  0C01 0001               3232              CMPI.B  #$1,D1
00002FF6  6700 0032               3233              BEQ     OP_ROR_W
00002FFA  0C01 0002               3234              CMPI.B  #$2,D1
00002FFE  6700 0018               3235              BEQ     OP_ROR_L
00003002                          3236              
00003002  4EF8 15E2               3237              JMP OP_DATA
00003006                          3238  
00003006  43F9 00004660           3239  OP_ROR_B    LEA     DISP_ROR_B,A1
0000300C  103C 000E               3240              MOVE.B  #14,D0
00003010  4E4F                    3241              TRAP    #15
00003012  183C 0000               3242              MOVE.B  #0,D4
00003016  4E75                    3243              RTS
00003018                          3244  
00003018  43F9 00004684           3245  OP_ROR_L    LEA     DISP_ROR_L,A1
0000301E  103C 000E               3246              MOVE.B  #14,D0
00003022  4E4F                    3247              TRAP    #15
00003024  183C 0002               3248              MOVE.B  #2,D4
00003028  4E75                    3249              RTS
0000302A                          3250  
0000302A  43F9 00004672           3251  OP_ROR_W    LEA     DISP_ROR_W,A1
00003030  103C 000E               3252              MOVE.B  #14,D0
00003034  4E4F                    3253              TRAP    #15
00003036  183C 0001               3254              MOVE.B  #1,D4
0000303A  4E75                    3255              RTS
0000303C                          3256  
0000303C                          3257  *---------------------------------------------------------------------------*
0000303C                          3258  * OP_ROL: decode and display ROL
0000303C                          3259  *---------------------------------------------------------------------------*             
0000303C  E599                    3260  OP_ROL      ROL.L   #2,D1
0000303E  0281 00000003           3261              ANDI.L  #$3,D1
00003044  0C01 0000               3262              CMPI.B  #0,D1
00003048  6700 0016               3263              BEQ     OP_ROL_B
0000304C  0C01 0001               3264              CMPI.B  #$1,D1
00003050  6700 0032               3265              BEQ     OP_ROL_W
00003054  0C01 0002               3266              CMPI.B  #$2,D1
00003058  6700 0018               3267              BEQ     OP_ROL_L
0000305C                          3268              
0000305C  4EF8 15E2               3269              JMP OP_DATA
00003060                          3270  
00003060                          3271  
00003060  43F9 00004669           3272  OP_ROL_B    LEA     DISP_ROL_B,A1
00003066  103C 000E               3273              MOVE.B  #14,D0
0000306A  4E4F                    3274              TRAP    #15
0000306C  183C 0000               3275              MOVE.B  #0,D4
00003070  4E75                    3276              RTS
00003072                          3277  
00003072  43F9 0000468D           3278  OP_ROL_L    LEA     DISP_ROL_L,A1
00003078  103C 000E               3279              MOVE.B  #14,D0
0000307C  4E4F                    3280              TRAP    #15
0000307E  183C 0002               3281              MOVE.B  #2,D4
00003082  4E75                    3282              RTS
00003084                          3283  
00003084  43F9 0000467B           3284  OP_ROL_W    LEA     DISP_ROL_W,A1
0000308A  103C 000E               3285              MOVE.B  #14,D0
0000308E  4E4F                    3286              TRAP    #15
00003090  183C 0001               3287              MOVE.B  #1,D4
00003094  4E75                    3288              RTS
00003096                          3289              
00003096                          3290  *---------------------------------------------------------------------------*
00003096                          3291  * OP1111 : Special reserved
00003096                          3292  *---------------------------------------------------------------------------*           
00003096  4EF8 15E2               3293  OP1111      JMP     OP_DATA
0000309A                          3294  
0000309A                          3295  *---------------------------------------------------------------------------*
0000309A                          3296  * EA_NOSRC: decode and display effective addresses for NEG/JSR
0000309A                          3297  *---------------------------------------------------------------------------*
0000309A                          3298  EA_NOSRC    
0000309A  4EB9 00003158           3299              JSR     SRC_MODE
000030A0  43F9 0000435A           3300              LEA     ENDLINE_M,A1
000030A6  103C 000E               3301              MOVE.B  #14,D0
000030AA  4E4F                    3302              TRAP    #15
000030AC  4E75                    3303              RTS
000030AE                          3304              
000030AE                          3305  *---------------------------------------------------------------------------*
000030AE                          3306  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000030AE                          3307  *---------------------------------------------------------------------------*
000030AE                          3308  EA_ARITH
000030AE  4EB9 00003158           3309              JSR     SRC_MODE
000030B4  43F9 000046D4           3310              LEA     DISP_D,A1
000030BA  103C 000E               3311              MOVE.B  #14,D0
000030BE  4E4F                    3312              TRAP    #15
000030C0  4EB9 000033E4           3313              JSR     DEST_REGISTER
000030C6  43F9 0000435A           3314              LEA     ENDLINE_M,A1
000030CC  103C 000E               3315              MOVE.B  #14,D0
000030D0  4E4F                    3316              TRAP    #15
000030D2  4E75                    3317              RTS
000030D4                          3318              
000030D4                          3319  *---------------------------------------------------------------------------*
000030D4                          3320  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000030D4                          3321  *---------------------------------------------------------------------------*
000030D4                          3322  EA_MOVEA
000030D4  4EB9 00003158           3323              JSR     SRC_MODE
000030DA  43F9 000046E5           3324              LEA     DISP_AOP,A1
000030E0  103C 000E               3325              MOVE.B  #14,D0
000030E4  4E4F                    3326              TRAP    #15
000030E6  4EB9 000033E4           3327              JSR     DEST_REGISTER
000030EC  43F9 000046E3           3328              LEA     DISP_CP,A1
000030F2  103C 000D               3329              MOVE.B  #13,D0
000030F6  4E4F                    3330              TRAP    #15
000030F8  4E75                    3331              RTS
000030FA                          3332              
000030FA                          3333  *---------------------------------------------------------------------------*
000030FA                          3334  * EA_GEN: decode and display effective addresses for MOVE
000030FA                          3335  *---------------------------------------------------------------------------*
000030FA                          3336  EA_GEN          
000030FA                          3337              * retrieve/display source mode/register
000030FA  4EB9 00003158           3338              JSR     SRC_MODE
00003100                          3339              
00003100                          3340              * retrieve/display destination mode/register
00003100  4EB9 00003114           3341              JSR     DEST_MODE
00003106                          3342              
00003106  43F9 0000435A           3343              LEA     ENDLINE_M,A1
0000310C  103C 000E               3344              MOVE.B  #14,D0
00003110  4E4F                    3345              TRAP    #15
00003112                          3346              
00003112  4E75                    3347              RTS
00003114                          3348  
00003114                          3349  *---------------------------------------------------------------------------*
00003114                          3350  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00003114                          3351  *---------------------------------------------------------------------------*           
00003114                          3352  DEST_MODE   
00003114                          3353              * clear registers to store temp data
00003114  4280                    3354              CLR.L   D0                      
00003116  4281                    3355              CLR.L   D1                      
00003118  207C 00000000           3356              MOVEA.L #0, A0                  
0000311E  227C 00000000           3357              MOVEA.L #0, A1                  
00003124  2205                    3358              MOVE.L  D5,D1
00003126  EC89                    3359              LSR.L   #6,D1
00003128  0281 00000007           3360              ANDI.L  #$7,D1
0000312E  0C01 0000               3361              CMPI.B  #0,D1   * Dn
00003132  6700 0082               3362              BEQ     D_MODE000
00003136  0C01 0002               3363              CMPI.B  #2,D1   * (An)
0000313A  6700 00C2               3364              BEQ     D_MODE010
0000313E  0C01 0003               3365              CMPI.B  #3,D1   * (An)+
00003142  6700 011A               3366              BEQ     D_MODE011
00003146  0C01 0004               3367              CMPI.B  #4,D1   * -(An)
0000314A  6700 0132               3368              BEQ     D_MODE100
0000314E  0C01 0007               3369              CMPI.B  #7,D1  * abs
00003152  6700 017C               3370              BEQ     D_MODE111 
00003156  4E75                    3371              RTS
00003158                          3372  
00003158                          3373  *---------------------------------------------------------------------------*
00003158                          3374  * SRC_MODE: decode and display source mode (bit 5 - 3)
00003158                          3375  *---------------------------------------------------------------------------*  
00003158                          3376  SRC_MODE    
00003158                          3377              * clear registers to store temp data
00003158  4280                    3378              CLR.L   D0                      
0000315A  4281                    3379              CLR.L   D1                      
0000315C  207C 00000000           3380              MOVEA.L #0, A0                  
00003162  227C 00000000           3381              MOVEA.L #0, A1                  
00003168  2205                    3382              MOVE.L  D5,D1
0000316A  E489                    3383              LSR.L   #2,D1
0000316C  0281 0000000E           3384              ANDI.L  #$E,D1
00003172                          3385              
00003172  0C01 0000               3386              CMPI.B  #0,D1   * Dn
00003176  6700 002A               3387              BEQ     MODE000
0000317A  0C01 0002               3388              CMPI.B  #2,D1   * An 
0000317E  6700 004A               3389              BEQ     MODE001
00003182  0C01 0004               3390              CMPI.B  #4,D1   * (An)
00003186  6700 0056               3391              BEQ     MODE010
0000318A  0C01 0006               3392              CMPI.B  #6,D1   * (An)+
0000318E  6700 008E               3393              BEQ     MODE011
00003192  0C01 0008               3394              CMPI.B  #8,D1   * -(An)
00003196  6700 00A6               3395              BEQ     MODE100
0000319A  0C01 000F               3396              CMPI.B  #15,D1  * abs/immediate
0000319E  6700 00FE               3397              BEQ     MODE111 
000031A2                          3398        
000031A2                          3399  *---------------------------------------------------------------------------*
000031A2                          3400  * MODE000: decode and display source mode Dn
000031A2                          3401  *---------------------------------------------------------------------------*           
000031A2                          3402  MODE000     *Dn
000031A2  43F9 000046D4           3403              LEA     DISP_D,A1
000031A8  103C 000E               3404              MOVE.B  #14,D0
000031AC  4E4F                    3405              TRAP    #15
000031AE  4EB9 00003440           3406              JSR     SRC_REGISTER
000031B4  4E75                    3407              RTS
000031B6                          3408  
000031B6                          3409  *---------------------------------------------------------------------------*
000031B6                          3410  * D_MODE000: decode and display dest mode Dn
000031B6                          3411  *---------------------------------------------------------------------------*
000031B6                          3412  D_MODE000     *Dn
000031B6  43F9 000046D4           3413              LEA     DISP_D,A1
000031BC  103C 000E               3414              MOVE.B  #14,D0
000031C0  4E4F                    3415              TRAP    #15
000031C2  4EB9 000033E4           3416              JSR     DEST_REGISTER
000031C8  4E75                    3417              RTS
000031CA                          3418  
000031CA                          3419  *---------------------------------------------------------------------------*
000031CA                          3420  * MODE001: decode and display source mode An
000031CA                          3421  *---------------------------------------------------------------------------* 
000031CA                          3422  MODE001 *An
000031CA  43F9 000046D9           3423              LEA     DISP_A,A1
000031D0  103C 000E               3424              MOVE.B  #14,D0
000031D4  4E4F                    3425              TRAP    #15
000031D6  4EB9 00003440           3426              JSR     SRC_REGISTER
000031DC                          3427          
000031DC  4E75                    3428              RTS
000031DE                          3429  
000031DE                          3430  *---------------------------------------------------------------------------*
000031DE                          3431  * MODE010: decode and display source mode (An)
000031DE                          3432  *---------------------------------------------------------------------------*    
000031DE                          3433  MODE010 *(An)
000031DE  43F9 000046E5           3434              LEA     DISP_AOP,A1  *display (A
000031E4  103C 000E               3435              MOVE.B  #14,D0
000031E8  4E4F                    3436              TRAP    #15
000031EA                          3437  
000031EA  4EB9 00003440           3438              JSR     SRC_REGISTER * display register
000031F0                          3439  
000031F0  43F9 000046E3           3440              LEA     DISP_CP,A1   *display )
000031F6  103C 000E               3441              MOVE.B  #14,D0
000031FA  4E4F                    3442              TRAP    #15
000031FC                          3443              
000031FC  4E75                    3444              RTS
000031FE                          3445  
000031FE                          3446  *---------------------------------------------------------------------------*
000031FE                          3447  * D_MODE010: decode and display dest mode (An)
000031FE                          3448  *---------------------------------------------------------------------------*
000031FE                          3449  D_MODE010 *(An)
000031FE  43F9 000046E5           3450              LEA     DISP_AOP,A1  *display (A
00003204  103C 000E               3451              MOVE.B  #14,D0
00003208  4E4F                    3452              TRAP    #15
0000320A                          3453     
0000320A  4EB9 000033E4           3454              JSR     DEST_REGISTER * display register
00003210                          3455  
00003210  43F9 000046E3           3456              LEA     DISP_CP,A1   *display )
00003216  103C 000E               3457              MOVE.B  #14,D0
0000321A  4E4F                    3458              TRAP    #15
0000321C                          3459              
0000321C  4E75                    3460              RTS
0000321E                          3461  
0000321E                          3462  *---------------------------------------------------------------------------*
0000321E                          3463  * MODE011: decode and display source mode (An)+
0000321E                          3464  *---------------------------------------------------------------------------*
0000321E                          3465  MODE011 *(An)+
0000321E  43F9 000046E5           3466              LEA     DISP_AOP,A1      *display (A
00003224  103C 000E               3467              MOVE.B  #14,D0
00003228  4E4F                    3468              TRAP    #15
0000322A                          3469              
0000322A  4EB9 00003440           3470              JSR     SRC_REGISTER    * display register
00003230                          3471  
00003230  43F9 000046F2           3472              LEA     DISP_POST,A1    *display )+
00003236  103C 000E               3473              MOVE.B  #14,D0
0000323A  4E4F                    3474              TRAP    #15
0000323C                          3475              
0000323C  4E75                    3476              RTS
0000323E                          3477              
0000323E                          3478  *---------------------------------------------------------------------------*
0000323E                          3479  * MODE100: decode and display source mode -(An)
0000323E                          3480  *---------------------------------------------------------------------------*
0000323E                          3481  MODE100 *-(An)
0000323E  43F9 000046EB           3482              LEA     DISP_PRE,A1    *display -(A
00003244  103C 000E               3483              MOVE.B  #14,D0
00003248  4E4F                    3484              TRAP    #15
0000324A                          3485  
0000324A  4EB9 00003440           3486              JSR     SRC_REGISTER    *display register
00003250                          3487  
00003250  43F9 000046E3           3488              LEA     DISP_CP,A1   *display )
00003256  103C 000E               3489              MOVE.B  #14,D0
0000325A  4E4F                    3490              TRAP    #15
0000325C                          3491              
0000325C  4E75                    3492              RTS
0000325E                          3493  
0000325E                          3494  *---------------------------------------------------------------------------*
0000325E                          3495  * D_MODE011: decode and display dest mode (An)+
0000325E                          3496  *---------------------------------------------------------------------------*
0000325E                          3497  D_MODE011 *(An)+
0000325E  43F9 000046E5           3498              LEA     DISP_AOP,A1      *display (A
00003264  103C 000E               3499              MOVE.B  #14,D0
00003268  4E4F                    3500              TRAP    #15
0000326A                          3501  
0000326A  4EB9 000033E4           3502              JSR     DEST_REGISTER    * display register
00003270                          3503  
00003270  43F9 000046F2           3504              LEA     DISP_POST,A1    *display )+
00003276  103C 000E               3505              MOVE.B  #14,D0
0000327A  4E4F                    3506              TRAP    #15
0000327C                          3507              
0000327C  4E75                    3508              RTS
0000327E                          3509              
0000327E                          3510  *---------------------------------------------------------------------------*
0000327E                          3511  * D_MODE100: decode and display dest mode -(An)
0000327E                          3512  *---------------------------------------------------------------------------*            
0000327E                          3513  D_MODE100 *-(An)
0000327E  43F9 000046EB           3514              LEA     DISP_PRE,A1    *display -(A
00003284  103C 000E               3515              MOVE.B  #14,D0
00003288  4E4F                    3516              TRAP    #15
0000328A                          3517              
0000328A  4EB9 000033E4           3518              JSR     DEST_REGISTER    *display register
00003290                          3519  
00003290  43F9 000046E3           3520              LEA     DISP_CP,A1   *display )
00003296  103C 000E               3521              MOVE.B  #14,D0
0000329A  4E4F                    3522              TRAP    #15
0000329C                          3523              
0000329C  4E75                    3524              RTS
0000329E                          3525  
0000329E                          3526  *---------------------------------------------------------------------------*
0000329E                          3527  * MODE111: decode and display source mode absolute/immediate
0000329E                          3528  *---------------------------------------------------------------------------*
0000329E                          3529  MODE111     * abs/immediate
0000329E                          3530              * clear registers to store temp data
0000329E  4280                    3531              CLR.L   D0                      
000032A0  4281                    3532              CLR.L   D1                      
000032A2  207C 00000000           3533              MOVEA.L #0, A0                  
000032A8  227C 00000000           3534              MOVEA.L #0, A1                  
000032AE  2205                    3535              MOVE.L  D5,D1
000032B0                          3536              
000032B0                          3537              * retrieve source register for MODE 111
000032B0  E389                    3538              LSL.L   #1,D1   * shift the bits to left by 1
000032B2  0281 0000000E           3539              ANDI.L  #$E,D1  * mask the first 4 bits 
000032B8  0C01 0000               3540              CMPI.B  #0, D1  * if it's 0000, absolute word address
000032BC  6700 003E               3541              BEQ     WORDMODE
000032C0  0C01 0002               3542              CMPI.B  #2, D1  * if it's 0010, absolute long address
000032C4  6700 0062               3543              BEQ     LONGMODE
000032C8  0C01 0008               3544              CMPI.B  #8, D1  * if it's 1000, immediate data
000032CC  6700 0086               3545              BEQ     IMMEDIATE
000032D0                          3546       
000032D0                          3547  *---------------------------------------------------------------------------*
000032D0                          3548  * D_MODE111: decode and display dest mode absolute/immediate
000032D0                          3549  *---------------------------------------------------------------------------*           
000032D0                          3550  D_MODE111   * abs
000032D0                          3551              * clear registers to store temp data
000032D0  4280                    3552              CLR.L   D0                      
000032D2  4281                    3553              CLR.L   D1                      
000032D4  207C 00000000           3554              MOVEA.L #0, A0                  
000032DA  227C 00000000           3555              MOVEA.L #0, A1                  
000032E0  2205                    3556              MOVE.L  D5,D1
000032E2                          3557              
000032E2                          3558              * retrieve dest register for MODE 111
000032E2  EC89                    3559              LSR.L   #6,D1   * shift the bits to right by 6
000032E4  E689                    3560              LSR.L   #3,D1   * shift the bits to right by extra 3
000032E6  0201 0001               3561              ANDI.B  #1,D1   * mask the first 2 bits 
000032EA  0C01 0000               3562              CMPI.B  #0, D1  * if it's 000, absolute word address
000032EE  6700 000C               3563              BEQ     WORDMODE
000032F2  0C01 0001               3564              CMPI.B  #1, D1  * if it's 001, absolute long address
000032F6  6700 0030               3565              BEQ     LONGMODE
000032FA                          3566              *JSR     OP_DATA *not sure..
000032FA  4E75                    3567              RTS
000032FC                          3568  
000032FC                          3569  
000032FC                          3570  *---------------------------------------------------------------------------*
000032FC                          3571  * WORDMODE: absolute word address
000032FC                          3572  *---------------------------------------------------------------------------*
000032FC  43F9 000046CF           3573  WORDMODE    LEA     DISP_HEX,A1
00003302  103C 000E               3574              MOVE.B  #14,D0
00003306  4E4F                    3575              TRAP    #15
00003308                          3576              
00003308  4285                    3577              CLR.L   D5
0000330A  3A1D                    3578              MOVE.W  (A5)+,D5
0000330C                          3579              
0000330C  43F9 000043AD           3580              LEA     TMPOUTPUT,A1
00003312  2205                    3581              MOVE.L  D5,D1
00003314  7404                    3582              MOVE.L  #4,D2       *move word size 4
00003316  4EB8 11C8               3583              JSR     HEX2ASCII
0000331A  43F9 000043AD           3584              LEA     TMPOUTPUT,A1
00003320  103C 000E               3585              MOVE.B  #14,D0
00003324  4E4F                    3586              TRAP    #15
00003326                          3587              
00003326  4E75                    3588              RTS
00003328                          3589  
00003328                          3590  *---------------------------------------------------------------------------*
00003328                          3591  * LONGMODE: absolute long address
00003328                          3592  *---------------------------------------------------------------------------*
00003328  43F9 000046CF           3593  LONGMODE    LEA     DISP_HEX,A1
0000332E  103C 000E               3594              MOVE.B  #14,D0
00003332  4E4F                    3595              TRAP    #15
00003334                          3596              
00003334  4285                    3597              CLR.L   D5
00003336  2A1D                    3598              MOVE.L  (A5)+,D5
00003338                          3599              
00003338  43F9 000043AD           3600              LEA     TMPOUTPUT,A1
0000333E  2205                    3601              MOVE.L  D5,D1
00003340  7408                    3602              MOVE.L  #8,D2           *move longword size 8
00003342  4EB8 11C8               3603              JSR     HEX2ASCII
00003346  43F9 000043AD           3604              LEA     TMPOUTPUT,A1
0000334C  103C 000E               3605              MOVE.B  #14,D0
00003350  4E4F                    3606              TRAP    #15
00003352                          3607              
00003352  4E75                    3608              RTS
00003354                          3609  
00003354                          3610  
00003354                          3611  *---------------------------------------------------------------------------*
00003354                          3612  * IMMEDIATE: immediate address
00003354                          3613  *---------------------------------------------------------------------------*
00003354  43F9 000046F5           3614  IMMEDIATE   LEA     DISP_LB,A1
0000335A  103C 000E               3615              MOVE.B  #14,D0
0000335E  4E4F                    3616              TRAP    #15
00003360  43F9 000046CF           3617              LEA     DISP_HEX,A1
00003366  103C 000E               3618              MOVE.B  #14,D0
0000336A  4E4F                    3619              TRAP    #15
0000336C                          3620              
0000336C                          3621              * check for size
0000336C  0C04 0000               3622              CMPI.B  #0,D4
00003370  6700 0012               3623              BEQ     IMMD_B
00003374  0C04 0001               3624              CMPI.B  #1,D4
00003378  6700 002A               3625              BEQ     IMMD_W
0000337C  0C04 0002               3626              CMPI.B  #2,D4
00003380  6700 0042               3627              BEQ     IMMD_L
00003384                          3628  
00003384                          3629  IMMD_B
00003384  4285                    3630              CLR.L   D5
00003386  3A1D                    3631              MOVE.W  (A5)+,D5
00003388                          3632              
00003388  43F9 000043AD           3633              LEA     TMPOUTPUT,A1
0000338E  2205                    3634              MOVE.L  D5,D1
00003390  7402                    3635              MOVE.L  #2,D2
00003392  4EB8 11C8               3636              JSR     HEX2ASCII
00003396  43F9 000043AD           3637              LEA     TMPOUTPUT,A1
0000339C  103C 000E               3638              MOVE.B  #14,D0
000033A0  4E4F                    3639              TRAP    #15
000033A2  4E75                    3640              RTS
000033A4                          3641              
000033A4                          3642  IMMD_W
000033A4  4285                    3643              CLR.L   D5
000033A6  3A1D                    3644              MOVE.W  (A5)+,D5
000033A8                          3645              
000033A8  43F9 000043AD           3646              LEA     TMPOUTPUT,A1
000033AE  2205                    3647              MOVE.L  D5,D1
000033B0  7404                    3648              MOVE.L  #4,D2
000033B2  4EB8 11C8               3649              JSR     HEX2ASCII
000033B6  43F9 000043AD           3650              LEA     TMPOUTPUT,A1
000033BC  103C 000E               3651              MOVE.B  #14,D0
000033C0  4E4F                    3652              TRAP    #15
000033C2  4E75                    3653              RTS
000033C4                          3654              
000033C4                          3655  
000033C4                          3656  IMMD_L
000033C4  4285                    3657              CLR.L   D5
000033C6  3A1D                    3658              MOVE.W  (A5)+,D5
000033C8                          3659              
000033C8  43F9 000043AD           3660              LEA     TMPOUTPUT,A1
000033CE  2205                    3661              MOVE.L  D5,D1
000033D0  7408                    3662              MOVE.L  #8,D2
000033D2  4EB8 11C8               3663              JSR     HEX2ASCII
000033D6  43F9 000043AD           3664              LEA     TMPOUTPUT,A1
000033DC  103C 000E               3665              MOVE.B  #14,D0
000033E0  4E4F                    3666              TRAP    #15
000033E2  4E75                    3667              RTS
000033E4                          3668  
000033E4                          3669  
000033E4                          3670  *---------------------------------------------------------------------------*
000033E4                          3671  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000033E4                          3672  *---------------------------------------------------------------------------*
000033E4                          3673  DEST_REGISTER
000033E4                          3674              * clear registers to store temp data
000033E4  4280                    3675              CLR.L   D0                      
000033E6  4281                    3676              CLR.L   D1                      
000033E8  207C 00000000           3677              MOVEA.L #0, A0                  
000033EE  227C 00000000           3678              MOVEA.L #0, A1 
000033F4                          3679              
000033F4  2205                    3680              MOVE.L  D5,D1
000033F6  EC89                    3681              LSR.L   #6,D1
000033F8  E689                    3682              LSR.L   #3,D1
000033FA  0281 00000007           3683              ANDI.L  #7,D1
00003400                          3684              
00003400  0C01 0000               3685              CMPI.B  #0,D1
00003404  6700 0092               3686              BEQ     REG_0
00003408  0C01 0001               3687              CMPI.B  #1,D1
0000340C  6700 0098               3688              BEQ     REG_1
00003410  0C01 0002               3689              CMPI.B  #2,D1
00003414  6700 009E               3690              BEQ     REG_2
00003418  0C01 0003               3691              CMPI.B  #3,D1
0000341C  6700 00A4               3692              BEQ     REG_3
00003420  0C01 0004               3693              CMPI.B  #4,D1
00003424  6700 00AA               3694              BEQ     REG_4
00003428  0C01 0005               3695              CMPI.B  #5,D1
0000342C  6700 00B0               3696              BEQ     REG_5
00003430  0C01 0006               3697              CMPI.B  #6,D1
00003434  6700 00B6               3698              BEQ     REG_6
00003438  0C01 0007               3699              CMPI.B  #7,D1
0000343C  6700 00BC               3700              BEQ     REG_7
00003440                          3701  
00003440                          3702  *---------------------------------------------------------------------------*
00003440                          3703  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003440                          3704  *---------------------------------------------------------------------------*           
00003440                          3705  SRC_REGISTER 
00003440                          3706              * clear registers to store temp data
00003440  4280                    3707              CLR.L   D0                      
00003442  4281                    3708              CLR.L   D1                      
00003444  207C 00000000           3709              MOVEA.L #0, A0                  
0000344A  227C 00000000           3710              MOVEA.L #0, A1                  
00003450                          3711              
00003450  2205                    3712              MOVE.L  D5,D1   * temp store the processing data
00003452  0281 00000007           3713              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00003458                          3714              
00003458  0C01 0000               3715              CMPI.B  #0,D1
0000345C  6700 003A               3716              BEQ     REG_0
00003460  0C01 0001               3717              CMPI.B  #1,D1
00003464  6700 0040               3718              BEQ     REG_1
00003468  0C01 0002               3719              CMPI.B  #2,D1
0000346C  6700 0046               3720              BEQ     REG_2
00003470  0C01 0003               3721              CMPI.B  #3,D1
00003474  6700 004C               3722              BEQ     REG_3
00003478  0C01 0004               3723              CMPI.B  #4,D1
0000347C  6700 0052               3724              BEQ     REG_4
00003480  0C01 0005               3725              CMPI.B  #5,D1
00003484  6700 0058               3726              BEQ     REG_5
00003488  0C01 0006               3727              CMPI.B  #6,D1
0000348C  6700 005E               3728              BEQ     REG_6
00003490  0C01 0007               3729              CMPI.B  #7,D1
00003494  6700 0064               3730              BEQ     REG_7
00003498                          3731  
00003498                          3732  *---------------------------------------------------------------------------*
00003498                          3733  * REG_0 ~ REG_7: display register 0 to 7
00003498                          3734  *---------------------------------------------------------------------------*
00003498  43F9 000046FA           3735  REG_0       LEA     DISP_0,A1
0000349E  103C 000E               3736              MOVE.B  #14,D0
000034A2  4E4F                    3737              TRAP    #15
000034A4  4E75                    3738              RTS
000034A6                          3739              
000034A6  43F9 000046FC           3740  REG_1       LEA     DISP_1,A1
000034AC  103C 000E               3741              MOVE.B  #14,D0
000034B0  4E4F                    3742              TRAP    #15
000034B2  4E75                    3743              RTS
000034B4                          3744              
000034B4                          3745  
000034B4  43F9 000046FE           3746  REG_2       LEA     DISP_2,A1
000034BA  103C 000E               3747              MOVE.B  #14,D0
000034BE  4E4F                    3748              TRAP    #15
000034C0  4E75                    3749              RTS
000034C2                          3750            
000034C2  43F9 00004700           3751  REG_3       LEA     DISP_3,A1
000034C8  103C 000E               3752              MOVE.B  #14,D0
000034CC  4E4F                    3753              TRAP    #15
000034CE  4E75                    3754              RTS
000034D0                          3755              
000034D0  43F9 00004702           3756  REG_4       LEA     DISP_4,A1
000034D6  103C 000E               3757              MOVE.B  #14,D0
000034DA  4E4F                    3758              TRAP    #15
000034DC  4E75                    3759              RTS
000034DE                          3760              
000034DE  43F9 00004704           3761  REG_5       LEA     DISP_5,A1
000034E4  103C 000E               3762              MOVE.B  #14,D0
000034E8  4E4F                    3763              TRAP    #15
000034EA  4E75                    3764              RTS
000034EC                          3765              
000034EC  43F9 00004706           3766  REG_6       LEA     DISP_6,A1
000034F2  103C 000E               3767              MOVE.B  #14,D0
000034F6  4E4F                    3768              TRAP    #15
000034F8  4E75                    3769              RTS
000034FA                          3770              
000034FA  43F9 00004708           3771  REG_7       LEA     DISP_7,A1
00003500  103C 000E               3772              MOVE.B  #14,D0
00003504  4E4F                    3773              TRAP    #15
00003506  4E75                    3774              RTS
00003508                          3775              
00003508                          3776  *---------------------------------------------------------------------------*
00003508                          3777  * REPEAT : Ask user whether they wish to run the program again
00003508                          3778  *---------------------------------------------------------------------------*           
00003508  4246                    3779  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
0000350A  43F9 000041D3           3780              LEA     REPEATMSG,A1
00003510  103C 000E               3781              MOVE.B  #14,D0
00003514  4E4F                    3782              TRAP    #15
00003516                          3783              
00003516  43F9 0000435D           3784              LEA     TMPINPUT,A1             * allocate space to temp store user input
0000351C  103C 0002               3785              MOVE.B  #2,D0
00003520  4E4F                    3786              TRAP    #15
00003522                          3787  
00003522  0C01 0001               3788              CMPI.B  #1,D1                   * check for length of user input
00003526  66E0                    3789              BNE     REPEAT                  * return to the beginning of the function if unequal
00003528                          3790              
00003528  0C11 0059               3791              CMPI.B  #$59,(A1)               * compare the input with Y    
0000352C  6700 DADC               3792              BEQ     PROGLP                  * repeat the program
00003530                          3793              
00003530  0C11 0079               3794              CMPI.B  #$79,(A1)               * compare the input with y    
00003534  6700 DAD4               3795              BEQ     PROGLP                  * repeat the program
00003538                          3796              
00003538  0C11 004E               3797              CMPI.B  #$4E,(A1)               * compare the input with N    
0000353C  6700 0928               3798              BEQ     TERMINATE               * finish program
00003540                          3799              
00003540  0C11 006E               3800              CMPI.B  #$6E,(A1)               * compare the input with n    
00003544  6700 0920               3801              BEQ     TERMINATE               * finish program
00003548                          3802              
00003548  60BE                    3803              BRA     REPEAT                  * invalid input/repeat the function
0000354A                          3804  
0000354A                          3805  *---------------------------------------------------------------------------*
0000354A                          3806  * EA DECODING INTERFACE
0000354A                          3807  * [A0] - RESERVED FOR USE
0000354A                          3808  * [D2] - RESERVED FOR USE
0000354A                          3809  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
0000354A                          3810  *---------------------------------------------------------------------------*
0000354A                          3811  GET_EA_EA_SRC
0000354A                          3812      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
0000354A                          3813      
0000354A                          3814      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
0000354A  2405                    3815      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000354C  E68A                    3816      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
0000354E  23C2 00004720           3817      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003554  7407                    3818      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003556  C5B9 00004720           3819      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000355C                          3820                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000355C                          3821      
0000355C                          3822      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000355C                          3823      *DESTINATION REGISTER FORMAT STANDARD         *
0000355C                          3824      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000355C                          3825      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000355C                          3826      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000355C                          3827      *0 - Dn                                       *
0000355C                          3828      *1 - An                                       *
0000355C                          3829      *2 - (An)                                     *
0000355C                          3830      *3 - (An)+                                    *
0000355C                          3831      *4 - -(An)                                    *
0000355C                          3832      *5 - (XXX).W                                  *
0000355C                          3833      *6 - (XXX).L                                  *
0000355C                          3834      *7 - #<data>                                  *
0000355C                          3835      ***********************************************
0000355C                          3836      
0000355C                          3837      *** Check if source ...  <ea> = Dn
0000355C                          3838  CHECK0    
0000355C  41F9 00004710           3839            LEA     TEMP_REGISTER_FORMAT,A0
00003562  1439 0000470F           3840            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003568  1082                    3841            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000356A  0239 0001 00004710      3842            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003572  0C39 0001 00004710      3843            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
0000357A  6700 006A               3844            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000357E  0CB9 00000000 00004720  3845            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003588  6600 005C               3846            BNE     CHECK1
0000358C                          3847            
0000358C                          3848            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000358C  163C 0020               3849            MOVE.B    #' ',D3
00003590  6100 0856               3850            BSR       PUSH_STACK
00003594  163C 0044               3851            MOVE.B    #'D',D3
00003598  6100 084E               3852            BSR       PUSH_STACK
0000359C                          3853  
0000359C                          3854            *FIND REGISTER NUMBER END LOCATION*  
0000359C  13F9 00004712 00004718  3855            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000035A6  0239 000F 00004718      3856            AND.B   #$0F,VAR_BYTE_END
000035AE                          3857            
000035AE                          3858            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000035AE  23C5 0000471C           3859            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000035B4  1439 00004718           3860            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000035BA                          3861            
000035BA                          3862            *INTITIALIZE FOR BIT SHIFTING
000035BA  41F9 0000471C           3863            LEA     VAR_TEMP_CLEANCOPY,A0
000035C0  2639 0000471C           3864            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000035C6                          3865  LOOP_SHIFTING
000035C6  0C02 0000               3866            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000035CA  6700 0008               3867            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000035CE  E24B                    3868            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000035D0  5302                    3869            SUB.B   #1,D2                     *DECREMENT COUNTER
000035D2  60F2                    3870            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000035D4                          3871  MASKING_NEXT
000035D4  C6BC 00000007           3872            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000035DA  0603 0030               3873            ADD.B   #$30,D3                   *CONVERT TO CHAR
000035DE  6100 0808               3874            BSR     PUSH_STACK                *PUSH TO STACK
000035E2                          3875            
000035E2  6000 0394               3876            BRA     GET_SRC_SUCCESS           *RETURN          
000035E6                          3877            
000035E6                          3878            
000035E6                          3879            *** Check if source ...  <ea> = An
000035E6  41F9 00004710           3880  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000035EC  1439 0000470F           3881            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000035F2  1082                    3882            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000035F4  0239 0002 00004710      3883            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000035FC  0C39 0002 00004710      3884            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003604  6700 006A               3885            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003608  0CB9 00000001 00004720  3886            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003612  6600 005C               3887            BNE     CHECK2
00003616                          3888            
00003616                          3889            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003616  163C 0020               3890            MOVE.B    #' ',D3
0000361A  6100 07CC               3891            BSR       PUSH_STACK
0000361E  163C 0041               3892            MOVE.B    #'A',D3
00003622  6100 07C4               3893            BSR       PUSH_STACK
00003626                          3894  
00003626                          3895            
00003626                          3896            *FIND REGISTER NUMBER END LOCATION*  
00003626  13F9 00004712 00004718  3897            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003630  0239 000F 00004718      3898            AND.B   #$0F,VAR_BYTE_END
00003638                          3899            
00003638                          3900            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003638  23C5 0000471C           3901            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000363E  1439 00004718           3902            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003644                          3903            
00003644                          3904            *INTITIALIZE FOR BIT SHIFTING
00003644  41F9 0000471C           3905            LEA     VAR_TEMP_CLEANCOPY,A0
0000364A  2639 0000471C           3906            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003650                          3907  LOOP_SHIFTING1
00003650  0C02 0000               3908            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003654  6700 0008               3909            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003658  E24B                    3910            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000365A  5302                    3911            SUB.B   #1,D2                     *DECREMENT COUNTER
0000365C  60F2                    3912            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
0000365E                          3913  MASKING_NEXT1
0000365E  C6BC 00000007           3914            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003664  0603 0030               3915            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003668  6100 077E               3916            BSR     PUSH_STACK                *PUSH TO STACK
0000366C                          3917            
0000366C  6000 030A               3918            BRA     GET_SRC_SUCCESS                   *RETURN 
00003670                          3919            
00003670                          3920            
00003670                          3921            
00003670                          3922            
00003670                          3923            *** Check if source ...  <ea> = (An)       
00003670  41F9 00004710           3924  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003676  1439 0000470F           3925            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000367C  1082                    3926            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000367E  0239 0004 00004710      3927            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003686  0C39 0004 00004710      3928            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
0000368E  6700 007A               3929            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003692  0CB9 00000002 00004720  3930            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000369C  6600 006C               3931            BNE     CHECK3
000036A0                          3932            
000036A0                          3933            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000036A0  163C 0020               3934            MOVE.B    #' ',D3
000036A4  6100 0742               3935            BSR       PUSH_STACK
000036A8  163C 0028               3936            MOVE.B    #'(',D3
000036AC  6100 073A               3937            BSR       PUSH_STACK
000036B0  163C 0041               3938            MOVE.B    #'A',D3
000036B4  6100 0732               3939            BSR       PUSH_STACK
000036B8                          3940  
000036B8                          3941            
000036B8                          3942            *FIND REGISTER NUMBER END LOCATION*  
000036B8  13F9 00004712 00004718  3943            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000036C2  0239 000F 00004718      3944            AND.B   #$0F,VAR_BYTE_END
000036CA                          3945            
000036CA                          3946            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036CA  23C5 0000471C           3947            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000036D0  1439 00004718           3948            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000036D6                          3949            
000036D6                          3950            *INTITIALIZE FOR BIT SHIFTING
000036D6  41F9 0000471C           3951            LEA     VAR_TEMP_CLEANCOPY,A0
000036DC  2639 0000471C           3952            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000036E2                          3953  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000036E2  0C02 0000               3954            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000036E6  6700 0008               3955            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000036EA  E24B                    3956            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000036EC  5302                    3957            SUB.B   #1,D2                     *DECREMENT COUNTER
000036EE  60F2                    3958            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000036F0                          3959  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000036F0  0283 00000007           3960            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000036F6  0603 0030               3961            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000036FA  6100 06EC               3962            BSR     PUSH_STACK                *PUSH TO STACK
000036FE                          3963            
000036FE  163C 0029               3964            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003702  6100 06E4               3965            BSR       PUSH_STACK
00003706                          3966            
00003706  6000 0270               3967            BRA     GET_SRC_SUCCESS                   *RETURN 
0000370A                          3968  
0000370A                          3969            
0000370A                          3970            
0000370A                          3971                      
0000370A                          3972  *** Check if source ...  <ea> = (An)+       
0000370A  41F9 00004710           3973  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003710  1439 0000470F           3974            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003716  1082                    3975            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003718  0239 0008 00004710      3976            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003720  0C39 0008 00004710      3977            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003728  6700 0082               3978            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
0000372C  0CB9 00000003 00004720  3979            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003736  6600 0074               3980            BNE     CHECK4
0000373A                          3981            
0000373A                          3982            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000373A  163C 0020               3983            MOVE.B    #' ',D3
0000373E  6100 06A8               3984            BSR       PUSH_STACK
00003742  163C 0028               3985            MOVE.B    #'(',D3
00003746  6100 06A0               3986            BSR       PUSH_STACK
0000374A  163C 0041               3987            MOVE.B    #'A',D3
0000374E  6100 0698               3988            BSR       PUSH_STACK
00003752                          3989  
00003752                          3990            
00003752                          3991            *FIND REGISTER NUMBER END LOCATION*  
00003752  13F9 00004712 00004718  3992            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000375C  0239 000F 00004718      3993            ANDI.B   #$0F,VAR_BYTE_END
00003764                          3994            
00003764                          3995            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003764  23C5 0000471C           3996            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000376A  1439 00004718           3997            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003770                          3998            
00003770                          3999            *INTITIALIZE FOR BIT SHIFTING
00003770  41F9 0000471C           4000            LEA     VAR_TEMP_CLEANCOPY,A0
00003776  2639 0000471C           4001            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000377C                          4002            
0000377C                          4003  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000377C  0C02 0000               4004            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003780  6700 0008               4005            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003784  E24B                    4006            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003786  5302                    4007            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003788  60F2                    4008            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
0000378A                          4009                                               *change: NAME OF LABEL*
0000378A                          4010  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
0000378A  0283 00000007           4011            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003790  0603 0030               4012            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003794  6100 0652               4013            BSR     PUSH_STACK                *PUSH TO STACK
00003798                          4014            
00003798  163C 0029               4015            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000379C  6100 064A               4016            BSR       PUSH_STACK
000037A0  163C 002B               4017            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000037A4  6100 0642               4018            BSR       PUSH_STACK
000037A8                          4019            
000037A8  6000 01CE               4020            BRA       GET_SRC_SUCCESS                   *RETURN 
000037AC                          4021  
000037AC                          4022            
000037AC                          4023            
000037AC                          4024                      
000037AC                          4025            *** Check if source ...  <ea> = -(An)       
000037AC  41F9 00004710           4026  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
000037B2  1439 0000470F           4027            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037B8  1082                    4028            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037BA  0239 0010 00004710      4029            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000037C2  0C39 0010 00004710      4030            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000037CA  6700 0082               4031            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000037CE  0CB9 00000004 00004720  4032            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000037D8  6600 0074               4033            BNE     CHECK7
000037DC                          4034            
000037DC                          4035            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000037DC  163C 0020               4036            MOVE.B    #' ',D3
000037E0  6100 0606               4037            BSR       PUSH_STACK
000037E4  163C 002D               4038            MOVE.B    #'-',D3
000037E8  6100 05FE               4039            BSR       PUSH_STACK
000037EC  163C 0028               4040            MOVE.B    #'(',D3
000037F0  6100 05F6               4041            BSR       PUSH_STACK
000037F4  163C 0041               4042            MOVE.B    #'A',D3
000037F8  6100 05EE               4043            BSR       PUSH_STACK
000037FC                          4044  
000037FC                          4045            
000037FC                          4046            *FIND REGISTER NUMBER END LOCATION*  
000037FC  13F9 00004712 00004718  4047            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003806  0239 000F 00004718      4048            AND.B   #$0F,VAR_BYTE_END
0000380E                          4049            
0000380E                          4050            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000380E  23C5 0000471C           4051            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003814  1439 00004718           4052            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000381A                          4053            
0000381A                          4054            *INTITIALIZE FOR BIT SHIFTING
0000381A  41F9 0000471C           4055            LEA     VAR_TEMP_CLEANCOPY,A0
00003820  2639 0000471C           4056            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003826                          4057            
00003826                          4058  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003826  0C02 0000               4059            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000382A  6700 0008               4060            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
0000382E  E24B                    4061            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003830  5302                    4062            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003832  60F2                    4063            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003834                          4064                                               *change: NAME OF LABEL*
00003834                          4065  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003834  0283 00000007           4066            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000383A  0603 0030               4067            ADDI.B   #$30,D3                   *CONVERT TO CHAR
0000383E  6100 05A8               4068            BSR     PUSH_STACK                *PUSH TO STACK
00003842                          4069            
00003842  163C 0029               4070            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003846  6100 05A0               4071            BSR       PUSH_STACK
0000384A                          4072            
0000384A  6000 012C               4073            BRA     GET_SRC_SUCCESS                   *RETURN
0000384E                          4074            
0000384E                          4075                      
0000384E                          4076            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
0000384E  0CB9 00000007 00004720  4077  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003858  6600 011A               4078            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
0000385C                          4079                   
0000385C                          4080            *NEXT: (MODE == 111) 
0000385C                          4081            *NOW: CHECK FOR SRC REGISTER 
0000385C                          4082                  *(000 = (xxx).W)
0000385C                          4083                  *(001 = (xxx).L)
0000385C                          4084                  *(010 = #<data>)
0000385C                          4085                  
0000385C                          4086            *FIND REGISTER NUMBER END LOCATION*  
0000385C  13F9 00004712 00004718  4087            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003866  0239 000F 00004718      4088            AND.B   #$0F,VAR_BYTE_END
0000386E                          4089            
0000386E                          4090            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000386E  23C5 0000471C           4091            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003874  1439 00004718           4092            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000387A                          4093            
0000387A                          4094            *INTITIALIZE FOR BIT SHIFTING
0000387A  41F9 0000471C           4095            LEA     VAR_TEMP_CLEANCOPY,A0
00003880  2C39 0000471C           4096            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003886                          4097  SRC_LOOP_SHIFTING
00003886  0C02 0000               4098            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000388A  6700 0008               4099            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000388E  E24E                    4100            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003890  5302                    4101            SUB.B   #1,D2                     *DECREMENT COUNTER
00003892  60F2                    4102            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003894                          4103  SRC_MASKING_NEXT
00003894  CCBC 00000007           4104            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
0000389A                          4105           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
0000389A                          4106           
0000389A                          4107  CHECK_WORD  
0000389A  41F9 00004710           4108            LEA     TEMP_REGISTER_FORMAT,A0
000038A0  1439 0000470F           4109            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000038A6  1082                    4110            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000038A8  0239 0020 00004710      4111            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000038B0  0C39 0020 00004710      4112            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000038B8  6700 0026               4113            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000038BC  0C06 0000               4114            CMPI.B  #0,D6                          
000038C0  6600 001E               4115            BNE     CHECK_LONG 
000038C4                          4116            
000038C4                          4117            *IT IS A WORD AT THIS POINT*
000038C4                          4118            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000038C4  163C 0020               4119            MOVE.B    #' ',D3
000038C8  6100 051E               4120            BSR       PUSH_STACK
000038CC  163C 0024               4121            MOVE.B    #'$',D3
000038D0  6100 0516               4122            BSR       PUSH_STACK
000038D4  321D                    4123            MOVE.W    (A5)+,D1
000038D6  7404                    4124            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000038D8  6100 D930               4125            BSR       HEX2ASCII2STACK
000038DC  6000 009A               4126            BRA     GET_SRC_SUCCESS
000038E0                          4127  
000038E0                          4128  CHECK_LONG
000038E0  41F9 00004710           4129            LEA     TEMP_REGISTER_FORMAT,A0
000038E6  1439 0000470F           4130            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000038EC  1082                    4131            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000038EE  0239 0040 00004710      4132            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000038F6  0C39 0040 00004710      4133            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000038FE  6700 002E               4134            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003902  0C06 0001               4135            CMPI.B  #1,D6                          
00003906  6600 0026               4136            BNE     CHECK_IMMEDIATE  
0000390A                          4137  
0000390A                          4138            *IT IS A WORD AT THIS POINT*
0000390A                          4139            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000390A  163C 0020               4140            MOVE.B    #' ',D3
0000390E  6100 04D8               4141            BSR       PUSH_STACK
00003912  163C 0024               4142            MOVE.B    #'$',D3
00003916  6100 04D0               4143            BSR       PUSH_STACK
0000391A  321D                    4144            MOVE.W    (A5)+,D1
0000391C  7404                    4145            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000391E  6100 D8EA               4146            BSR       HEX2ASCII2STACK
00003922  321D                    4147            MOVE.W    (A5)+,D1
00003924  7404                    4148            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003926  6100 D8E2               4149            BSR       HEX2ASCII2STACK
0000392A  6000 004C               4150            BRA     GET_SRC_SUCCESS
0000392E                          4151            
0000392E                          4152  CHECK_IMMEDIATE
0000392E  41F9 00004710           4153            LEA     TEMP_REGISTER_FORMAT,A0
00003934  1439 0000470F           4154            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000393A  1082                    4155            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000393C  0239 0080 00004710      4156            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003944  0C39 0080 00004710      4157            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000394C  6700 0026               4158            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003950  0C06 0004               4159            CMPI.B  #4,D6                          
00003954  6600 001E               4160            BNE     GET_SRC_FAILED 
00003958                          4161  
00003958                          4162            *IT IS A WORD AT THIS POINT*
00003958                          4163            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003958  163C 0020               4164            MOVE.B    #' ',D3
0000395C  6100 048A               4165            BSR       PUSH_STACK
00003960  163C 0023               4166            MOVE.B    #'#',D3
00003964  6100 0482               4167            BSR       PUSH_STACK
00003968  321D                    4168            MOVE.W    (A5)+,D1
0000396A  7404                    4169            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000396C  6100 D89C               4170            BSR       HEX2ASCII2STACK
00003970  6000 0006               4171            BRA     GET_SRC_SUCCESS
00003974                          4172            
00003974                          4173  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003974  7801                    4174            MOVE.L #1,D4
00003976  4E75                    4175            RTS
00003978                          4176  GET_SRC_SUCCESS 
00003978  4E75                    4177            RTS
0000397A                          4178                                 
0000397A                          4179      
0000397A                          4180  
0000397A                          4181  
0000397A                          4182  
0000397A                          4183  
0000397A                          4184  
0000397A                          4185  
0000397A                          4186  GET_EA_EA_DEST
0000397A                          4187  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
0000397A                          4188      
0000397A                          4189      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
0000397A  2405                    4190      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000397C  EC8A                    4191      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
0000397E  23C2 00004720           4192      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003984  7407                    4193      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003986  C5B9 00004720           4194      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000398C                          4195                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000398C                          4196      
0000398C                          4197      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000398C                          4198      *DESTINATION REGISTER FORMAT STANDARD         *
0000398C                          4199      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000398C                          4200      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000398C                          4201      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000398C                          4202      *0 - Dn                                       *
0000398C                          4203      *1 - An                                       *
0000398C                          4204      *2 - (An)                                     *
0000398C                          4205      *3 - (An)+                                    *
0000398C                          4206      *4 - -(An)                                    *
0000398C                          4207      *5 - (XXX).W                                  *
0000398C                          4208      *6 - (XXX).L                                  *
0000398C                          4209      *7 - #<data>                                  *
0000398C                          4210      ***********************************************
0000398C                          4211      
0000398C                          4212      *** Check if source ...  <ea> = Dn
0000398C                          4213  DEST_CHECK0    
0000398C  41F9 00004710           4214            LEA     TEMP_REGISTER_FORMAT,A0
00003992  1439 0000470E           4215            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003998  1082                    4216            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000399A  0239 0001 00004710      4217            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
000039A2  0C39 0001 00004710      4218            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
000039AA  6700 006A               4219            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000039AE  0CB9 00000000 00004720  4220            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
000039B8  6600 005C               4221            BNE     DEST_CHECK1
000039BC                          4222            
000039BC                          4223            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000039BC  163C 0020               4224            MOVE.B    #' ',D3
000039C0  6100 0426               4225            BSR       PUSH_STACK
000039C4  163C 0044               4226            MOVE.B    #'D',D3
000039C8  6100 041E               4227            BSR       PUSH_STACK
000039CC                          4228  
000039CC                          4229            *FIND REGISTER NUMBER END LOCATION*  
000039CC  13F9 00004711 00004718  4230            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
000039D6  0239 000F 00004718      4231            AND.B   #$0F,VAR_BYTE_END
000039DE                          4232            
000039DE                          4233            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000039DE  23C5 0000471C           4234            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000039E4  1439 00004718           4235            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000039EA                          4236            
000039EA                          4237            *INTITIALIZE FOR BIT SHIFTING
000039EA  41F9 0000471C           4238            LEA     VAR_TEMP_CLEANCOPY,A0
000039F0  2639 0000471C           4239            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000039F6                          4240  DEST_LOOP_SHIFTING
000039F6  0C02 0000               4241            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000039FA  6700 0008               4242            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000039FE  E24B                    4243            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A00  5302                    4244            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A02  60F2                    4245            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003A04                          4246  DEST_MASKING_NEXT
00003A04  C6BC 00000007           4247            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A0A  0603 0030               4248            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003A0E  6100 03D8               4249            BSR     PUSH_STACK                *PUSH TO STACK
00003A12                          4250            
00003A12  6000 0394               4251            BRA     GET_DST_SUCCESS           *RETURN          
00003A16                          4252            
00003A16                          4253            
00003A16                          4254            *** Check if source ...  <ea> = An
00003A16                          4255  DEST_CHECK1    
00003A16  41F9 00004710           4256            LEA     TEMP_REGISTER_FORMAT,A0
00003A1C  1439 0000470E           4257            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A22  1082                    4258            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A24  0239 0002 00004710      4259            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003A2C  0C39 0002 00004710      4260            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003A34  6700 006A               4261            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003A38  0CB9 00000001 00004720  4262            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003A42  6600 005C               4263            BNE     DEST_CHECK2
00003A46                          4264            
00003A46                          4265            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A46  163C 0020               4266            MOVE.B    #' ',D3
00003A4A  6100 039C               4267            BSR       PUSH_STACK
00003A4E  163C 0041               4268            MOVE.B    #'A',D3
00003A52  6100 0394               4269            BSR       PUSH_STACK
00003A56                          4270  
00003A56                          4271            
00003A56                          4272            *FIND REGISTER NUMBER END LOCATION*  
00003A56  13F9 00004711 00004718  4273            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A60  0239 000F 00004718      4274            AND.B   #$0F,VAR_BYTE_END
00003A68                          4275            
00003A68                          4276            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A68  23C5 0000471C           4277            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A6E  1439 00004718           4278            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003A74                          4279            
00003A74                          4280            *INTITIALIZE FOR BIT SHIFTING
00003A74  41F9 0000471C           4281            LEA     VAR_TEMP_CLEANCOPY,A0
00003A7A  2639 0000471C           4282            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003A80                          4283  DEST_LOOP_SHIFTING1
00003A80  0C02 0000               4284            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A84  6700 0008               4285            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003A88  E24B                    4286            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A8A  5302                    4287            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A8C  60F2                    4288            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003A8E                          4289  DEST_MASKING_NEXT1
00003A8E  C6BC 00000007           4290            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A94  0603 0030               4291            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003A98  6100 034E               4292            BSR     PUSH_STACK                *PUSH TO STACK
00003A9C                          4293            
00003A9C  6000 030A               4294            BRA     GET_DST_SUCCESS                   *RETURN 
00003AA0                          4295            
00003AA0                          4296            
00003AA0                          4297            
00003AA0                          4298            
00003AA0                          4299            *** Check if source ...  <ea> = (An)       
00003AA0                          4300  DEST_CHECK2    
00003AA0  41F9 00004710           4301            LEA     TEMP_REGISTER_FORMAT,A0
00003AA6  1439 0000470E           4302            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AAC  1082                    4303            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AAE  0239 0004 00004710      4304            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003AB6  0C39 0004 00004710      4305            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003ABE  6700 007A               4306            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003AC2  0CB9 00000002 00004720  4307            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003ACC  6600 006C               4308            BNE     DEST_CHECK3
00003AD0                          4309            
00003AD0                          4310            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003AD0  163C 0020               4311            MOVE.B    #' ',D3
00003AD4  6100 0312               4312            BSR       PUSH_STACK
00003AD8  163C 0028               4313            MOVE.B    #'(',D3
00003ADC  6100 030A               4314            BSR       PUSH_STACK
00003AE0  163C 0041               4315            MOVE.B    #'A',D3
00003AE4  6100 0302               4316            BSR       PUSH_STACK
00003AE8                          4317  
00003AE8                          4318            
00003AE8                          4319            *FIND REGISTER NUMBER END LOCATION*  
00003AE8  13F9 00004711 00004718  4320            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003AF2  0239 000F 00004718      4321            AND.B   #$0F,VAR_BYTE_END
00003AFA                          4322            
00003AFA                          4323            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003AFA  23C5 0000471C           4324            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B00  1439 00004718           4325            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003B06                          4326            
00003B06                          4327            *INTITIALIZE FOR BIT SHIFTING
00003B06  41F9 0000471C           4328            LEA     VAR_TEMP_CLEANCOPY,A0
00003B0C  2639 0000471C           4329            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B12                          4330  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003B12  0C02 0000               4331            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B16  6700 0008               4332            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003B1A  E24B                    4333            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B1C  5302                    4334            SUB.B   #1,D2                     *DECREMENT COUNTER
00003B1E  60F2                    4335            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003B20                          4336  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003B20  0283 00000007           4337            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B26  0603 0030               4338            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003B2A  6100 02BC               4339            BSR     PUSH_STACK                *PUSH TO STACK
00003B2E                          4340            
00003B2E  163C 0029               4341            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003B32  6100 02B4               4342            BSR       PUSH_STACK
00003B36                          4343            
00003B36  6000 0270               4344            BRA     GET_DST_SUCCESS                   *RETURN 
00003B3A                          4345  
00003B3A                          4346            
00003B3A                          4347            
00003B3A                          4348                      
00003B3A                          4349  *** Check if source ...  <ea> = (An)+       
00003B3A  41F9 00004710           4350  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003B40  1439 0000470E           4351            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B46  1082                    4352            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B48  0239 0008 00004710      4353            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003B50  0C39 0008 00004710      4354            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B58  6700 0082               4355            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003B5C  0CB9 00000003 00004720  4356            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003B66  6600 0074               4357            BNE     DEST_CHECK4
00003B6A                          4358            
00003B6A                          4359            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003B6A  163C 0020               4360            MOVE.B    #' ',D3
00003B6E  6100 0278               4361            BSR       PUSH_STACK
00003B72  163C 0028               4362            MOVE.B    #'(',D3
00003B76  6100 0270               4363            BSR       PUSH_STACK
00003B7A  163C 0041               4364            MOVE.B    #'A',D3
00003B7E  6100 0268               4365            BSR       PUSH_STACK
00003B82                          4366  
00003B82                          4367            
00003B82                          4368            *FIND REGISTER NUMBER END LOCATION*  
00003B82  13F9 00004711 00004718  4369            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B8C  0239 000F 00004718      4370            ANDI.B   #$0F,VAR_BYTE_END
00003B94                          4371            
00003B94                          4372            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B94  23C5 0000471C           4373            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B9A  1439 00004718           4374            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003BA0                          4375            
00003BA0                          4376            *INTITIALIZE FOR BIT SHIFTING
00003BA0  41F9 0000471C           4377            LEA     VAR_TEMP_CLEANCOPY,A0
00003BA6  2639 0000471C           4378            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003BAC                          4379            
00003BAC                          4380  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003BAC  0C02 0000               4381            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003BB0  6700 0008               4382            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003BB4  E24B                    4383            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003BB6  5302                    4384            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003BB8  60F2                    4385            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003BBA                          4386                                               *change: NAME OF LABEL*
00003BBA                          4387  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003BBA  0283 00000007           4388            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003BC0  0603 0030               4389            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003BC4  6100 0222               4390            BSR     PUSH_STACK                *PUSH TO STACK
00003BC8                          4391            
00003BC8  163C 0029               4392            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003BCC  6100 021A               4393            BSR       PUSH_STACK
00003BD0  163C 002B               4394            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003BD4  6100 0212               4395            BSR       PUSH_STACK
00003BD8                          4396            
00003BD8  6000 01CE               4397            BRA       GET_DST_SUCCESS                   *RETURN 
00003BDC                          4398  
00003BDC                          4399            
00003BDC                          4400            
00003BDC                          4401                      
00003BDC                          4402            *** Check if source ...  <ea> = -(An)       
00003BDC                          4403  DEST_CHECK4    
00003BDC  41F9 00004710           4404            LEA     TEMP_REGISTER_FORMAT,A0
00003BE2  1439 0000470E           4405            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003BE8  1082                    4406            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003BEA  0239 0010 00004710      4407            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003BF2  0C39 0010 00004710      4408            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003BFA  6700 0082               4409            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003BFE  0CB9 00000004 00004720  4410            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003C08  6600 0074               4411            BNE     DEST_CHECK7
00003C0C                          4412            
00003C0C                          4413            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003C0C  163C 0020               4414            MOVE.B    #' ',D3
00003C10  6100 01D6               4415            BSR       PUSH_STACK
00003C14  163C 002D               4416            MOVE.B    #'-',D3
00003C18  6100 01CE               4417            BSR       PUSH_STACK
00003C1C  163C 0028               4418            MOVE.B    #'(',D3
00003C20  6100 01C6               4419            BSR       PUSH_STACK
00003C24  163C 0041               4420            MOVE.B    #'A',D3
00003C28  6100 01BE               4421            BSR       PUSH_STACK
00003C2C                          4422  
00003C2C                          4423            
00003C2C                          4424            *FIND REGISTER NUMBER END LOCATION*  
00003C2C  13F9 00004711 00004718  4425            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C36  0239 000F 00004718      4426            AND.B   #$0F,VAR_BYTE_END
00003C3E                          4427            
00003C3E                          4428            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C3E  23C5 0000471C           4429            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C44  1439 00004718           4430            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C4A                          4431            
00003C4A                          4432            *INTITIALIZE FOR BIT SHIFTING
00003C4A  41F9 0000471C           4433            LEA     VAR_TEMP_CLEANCOPY,A0
00003C50  2639 0000471C           4434            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C56                          4435            
00003C56                          4436  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003C56  0C02 0000               4437            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C5A  6700 0008               4438            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003C5E  E24B                    4439            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C60  5302                    4440            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003C62  60F2                    4441            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003C64                          4442                                               *change: NAME OF LABEL*
00003C64                          4443  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003C64  0283 00000007           4444            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C6A  0603 0030               4445            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003C6E  6100 0178               4446            BSR     PUSH_STACK                *PUSH TO STACK
00003C72                          4447            
00003C72  163C 0029               4448            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C76  6100 0170               4449            BSR       PUSH_STACK
00003C7A                          4450            
00003C7A  6000 012C               4451            BRA     GET_DST_SUCCESS                   *RETURN
00003C7E                          4452            
00003C7E                          4453                      
00003C7E                          4454            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003C7E                          4455  DEST_CHECK7    
00003C7E  0CB9 00000007 00004720  4456            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003C88  6600 011A               4457            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003C8C                          4458                   
00003C8C                          4459            *NEXT: (MODE == 111) 
00003C8C                          4460            *NOW: CHECK FOR SRC REGISTER 
00003C8C                          4461                  *(000 = (xxx).W)
00003C8C                          4462                  *(001 = (xxx).L)
00003C8C                          4463                  *(010 = #<data>)
00003C8C                          4464                  
00003C8C                          4465            *FIND REGISTER NUMBER END LOCATION*  
00003C8C  13F9 00004711 00004718  4466            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C96  0239 000F 00004718      4467            AND.B   #$0F,VAR_BYTE_END
00003C9E                          4468            
00003C9E                          4469            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C9E  23C5 0000471C           4470            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003CA4  1439 00004718           4471            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003CAA                          4472            
00003CAA                          4473            *INTITIALIZE FOR BIT SHIFTING
00003CAA  41F9 0000471C           4474            LEA     VAR_TEMP_CLEANCOPY,A0
00003CB0  2C39 0000471C           4475            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003CB6                          4476  DEST_LOOP_SHIFTING7
00003CB6  0C02 0000               4477            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003CBA  6700 0008               4478            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003CBE  E24E                    4479            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003CC0  5302                    4480            SUB.B   #1,D2                     *DECREMENT COUNTER
00003CC2  60F2                    4481            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003CC4                          4482  DEST_MASKING_NEXT7
00003CC4  CCBC 00000007           4483            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003CCA                          4484           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003CCA                          4485            
00003CCA                          4486  DEST_CHECK_WORD  
00003CCA  41F9 00004710           4487            LEA     TEMP_REGISTER_FORMAT,A0
00003CD0  1439 0000470E           4488            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CD6  1082                    4489            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CD8  0239 0020 00004710      4490            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003CE0  0C39 0020 00004710      4491            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CE8  6700 0026               4492            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003CEC  0C06 0000               4493            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003CF0  6600 001E               4494            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003CF4                          4495            *IT IS A WORD AT THIS POINT*
00003CF4                          4496            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003CF4  163C 0020               4497            MOVE.B    #' ',D3
00003CF8  6100 00EE               4498            BSR       PUSH_STACK
00003CFC  163C 0024               4499            MOVE.B    #'$',D3
00003D00  6100 00E6               4500            BSR       PUSH_STACK
00003D04  321D                    4501            MOVE.W    (A5)+,D1
00003D06  7404                    4502            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003D08  6100 D500               4503            BSR       HEX2ASCII2STACK
00003D0C  6000 009A               4504            BRA       GET_DST_SUCCESS
00003D10                          4505  
00003D10                          4506  DEST_CHECK_LONG
00003D10  41F9 00004710           4507            LEA     TEMP_REGISTER_FORMAT,A0
00003D16  1439 0000470E           4508            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D1C  1082                    4509            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D1E  0239 0040 00004710      4510            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003D26  0C39 0040 00004710      4511            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D2E  6700 002E               4512            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003D32  0C06 0001               4513            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003D36  6600 0026               4514            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003D3A                          4515            *IT IS A WORD AT THIS POINT*
00003D3A                          4516            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003D3A  163C 0020               4517            MOVE.B    #' ',D3
00003D3E  6100 00A8               4518            BSR       PUSH_STACK
00003D42  163C 0024               4519            MOVE.B    #'$',D3
00003D46  6100 00A0               4520            BSR       PUSH_STACK
00003D4A  321D                    4521            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003D4C  7404                    4522            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003D4E  6100 D4BA               4523            BSR       HEX2ASCII2STACK
00003D52  321D                    4524            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003D54  7404                    4525            MOVE.L    #4,D2          
00003D56  6100 D4B2               4526            BSR       HEX2ASCII2STACK
00003D5A  6000 004C               4527            BRA     GET_DST_SUCCESS
00003D5E                          4528            
00003D5E                          4529  DEST_CHECK_IMMEDIATE
00003D5E  41F9 00004710           4530            LEA     TEMP_REGISTER_FORMAT,A0
00003D64  1439 0000470E           4531            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D6A  1082                    4532            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D6C  0239 0080 00004710      4533            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003D74  0C39 0080 00004710      4534            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D7C  6700 0026               4535            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003D80  0C06 0004               4536            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003D84  6600 001E               4537            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003D88                          4538            
00003D88                          4539            *IT IS A WORD AT THIS POINT*
00003D88                          4540            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003D88  163C 0020               4541            MOVE.B    #' ',D3
00003D8C  6100 005A               4542            BSR       PUSH_STACK
00003D90  163C 0023               4543            MOVE.B    #'#',D3
00003D94  6100 0052               4544            BSR       PUSH_STACK
00003D98  321D                    4545            MOVE.W    (A5)+,D1
00003D9A  7404                    4546            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003D9C  6100 D46C               4547            BSR       HEX2ASCII2STACK
00003DA0  6000 0006               4548            BRA       GET_DST_SUCCESS
00003DA4                          4549            
00003DA4                          4550  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003DA4  7801                    4551            MOVE.L #1,D4
00003DA6  4E75                    4552            RTS
00003DA8                          4553  GET_DST_SUCCESS 
00003DA8  4E75                    4554            RTS
00003DAA                          4555  
00003DAA                          4556  
00003DAA                          4557  *---------------------------------------------------------------------------*
00003DAA                          4558  * STACK/QUEUE INTERFACE
00003DAA                          4559  *---------------------------------------------------------------------------*
00003DAA                          4560  PRINT_STACK
00003DAA  0C39 0000 0000470A      4561            CMP.B     #0,COUNTER
00003DB2  6700 000E               4562            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003DB6                          4563            
00003DB6                          4564  PRINT_STACK_HELPER
00003DB6  6100 0038               4565            BSR      POP_STACK          *PRINTS ADDRESS
00003DBA  103C 0006               4566            MOVE.B   #6,D0              *Display single character in D1.B. 
00003DBE  4E4F                    4567            TRAP     #15             *ACTIVATES PRINT
00003DC0                          4568  
00003DC0  60E8                    4569            BRA       PRINT_STACK
00003DC2                          4570  PRINT_STACK_RETURN
00003DC2  4E75                    4571            RTS
00003DC4                          4572            
00003DC4                          4573            
00003DC4                          4574  PRINT_QUEUE
00003DC4  0C39 0000 0000470A      4575            CMP.B     #0,COUNTER
00003DCC  6700 0018               4576            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003DD0                          4577            
00003DD0                          4578  PRINT_QUEUE_HELPER
00003DD0  33F9 0000470A 0000470C  4579            MOVE.W   COUNTER,QUEUE_COUNTER
00003DDA  6100 0022               4580            BSR      POP_FRONT          *PRINTS ADDRESS
00003DDE  103C 0006               4581            MOVE.B   #6,D0              *Display single character in D1.B. 
00003DE2  4E4F                    4582            TRAP     #15             *ACTIVATES PRINT
00003DE4                          4583  
00003DE4  60DE                    4584            BRA       PRINT_QUEUE
00003DE6                          4585  PRINT_QUEUE_RETURN
00003DE6  4E75                    4586            RTS
00003DE8                          4587            
00003DE8                          4588  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003DE8                          4589  PUSH_STACK
00003DE8  1503                    4590              MOVE.B  D3,-(A2)
00003DEA  6100 0058               4591              BSR     INCREMENT
00003DEE  4E75                    4592              RTS
00003DF0                          4593  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003DF0                          4594  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003DF0                          4595  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003DF0                          4596  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003DF0                          4597  *         TRAP        #15             *ACTIVATES PRINT
00003DF0                          4598  POP_STACK
00003DF0  BECA                    4599              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003DF2  6700 0008               4600              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003DF6  121A                    4601              MOVE.B  (A2)+,D1 
00003DF8  6100 0052               4602              BSR     DECREMENT
00003DFC                          4603  POP_RETURN
00003DFC  4E75                    4604              RTS 
00003DFE                          4605        
00003DFE                          4606  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003DFE  0C39 0000 0000470C      4607  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003E06  6700 0030               4608              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003E0A                          4609              
00003E0A                          4610              
00003E0A                          4611              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003E0A  347C 7000               4612              MOVEA.W #STACK,A2   *START A2 AT STACK
00003E0E  0622 0000               4613              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003E12  384A                    4614              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003E14  0624 0000               4615              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003E18  1212                    4616              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003E1A                          4617  POP_SHIFT_LOOP
00003E1A  0C39 0000 0000470C      4618              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003E22  6700 0014               4619              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003E26  1494                    4620              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003E28  0624 0000               4621              ADD.B   #0,-(A4)
00003E2C  0622 0000               4622              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003E30  5339 0000470C           4623              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003E36                          4624              
00003E36  60E2                    4625              BRA     POP_SHIFT_LOOP
00003E38                          4626                          
00003E38                          4627  POP_FRONT_RETURN 
00003E38                          4628              *RESET A2 BACK TO SP
00003E38  347C 7000               4629              MOVEA.W #STACK,A2    
00003E3C  5339 0000470A           4630              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003E42  4E75                    4631              RTS   
00003E44                          4632  
00003E44                          4633  INCREMENT
00003E44  5239 0000470A           4634              ADD.B   #1, COUNTER
00003E4A  4E75                    4635              RTS           
00003E4C                          4636  DECREMENT
00003E4C  5339 0000470A           4637              SUB.B   #1, COUNTER
00003E52  4E75                    4638              RTS           
00003E54                          4639  CLEAR_STACK
00003E54  0C39 0000 0000470A      4640              CMP.B     #0,COUNTER
00003E5C  6700 0006               4641              BEQ       CLEAR_RETURN
00003E60  618E                    4642              BSR       POP_STACK
00003E62  60F0                    4643              BRA       CLEAR_STACK
00003E64                          4644   
00003E64                          4645  CLEAR_RETURN
00003E64  4E75                    4646              RTS    
00003E66                          4647  *---------------------------------------------------------------------------*
00003E66                          4648  * TERMINATE
00003E66                          4649  *---------------------------------------------------------------------------*
00003E66                          4650  TERMINATE   
00003E66  43F9 00004216           4651              LEA     FINMSG,A1
00003E6C  103C 000E               4652              MOVE.B  #14,D0
00003E70  4E4F                    4653              TRAP    #15
00003E72                          4654  
00003E72  103C 0009               4655              MOVE.B  #9,D0
00003E76  4E4F                    4656              TRAP    #15
00003E78                          4657  
00003E78                          4658  *---------------------------------------------------------------------------*
00003E78                          4659  * Data storage                                                 
00003E78                          4660  *---------------------------------------------------------------------------*  
00003E78                          4661  WELCOME
00003E78= 20 20 20 20 20 20 ...   4662              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00003EC8= 3D 3D 3D 3D 3D 20 ...   4663              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003F18= 3D 3D 3D 3D 3D 20 ...   4664              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
00003F68                          4665      
00003F68= 20 20 20 20 20 20 ...   4666              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00003FB8= 20 20 20 20 20 20 ...   4667              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004008= 20 20 20 20 20 20 ...   4668              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
00004058                          4669      
00004058= 20 20 20 20 20 20 ...   4670              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
000040A8= 3D 3D 3D 3D 3D 20 ...   4671              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
000040F8= 3D 3D 3D 3D 3D 20 ...   4672              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
0000414D                          4673  
0000414D                          4674  PROMPT_START
0000414D= 50 6C 65 61 73 65 ...   4675              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
0000417C                          4676      
0000417C                          4677  PROMPT_END
0000417C= 50 6C 65 61 73 65 ...   4678              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
000041A9= 0D 0A 48 69 74 20 ...   4679  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
000041D3= 57 6F 75 6C 64 20 ...   4680  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004216= 54 68 61 6E 6B 20 ...   4681  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00004241= 45 72 72 6F 72 3A ...   4682  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00004260= 45 72 72 6F 72 3A ...   4683  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00004285= 45 72 72 6F 72 3A ...   4684  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
000042B2                          4685  
000042B2                          4686  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
00004302                          4687  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00004352                          4688  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00004356                          4689  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
0000435A= 0D 0A 00                4690  ENDLINE_M   DC.B    CR,LF,0
0000435D                          4691  TMPINPUT    DS.B    80                      * temp store user input
000043AD                          4692  TMPOUTPUT   DS.B    80                      * temp store prog output
000043FD= 20 20 20 4F 52 49 ...   4693  DISP_ORI_B  DC.B    '   ORI.B',0
00004406= 20 20 20 4F 52 49 ...   4694  DISP_ORI_W  DC.B    '   ORI.W',0
0000440F= 20 20 20 4F 52 49 ...   4695  DISP_ORI_L  DC.B    '   ORI.L',0
00004418= 20 20 20 45 4F 52 ...   4696  DISP_EORI_B  DC.B    '   EORI.B',0
00004422= 20 20 20 45 4F 52 ...   4697  DISP_EORI_W  DC.B    '   EORI.W',0
0000442C= 20 20 20 45 4F 52 ...   4698  DISP_EORI_L  DC.B    '   EORI.L',0
00004436= 20 20 20 42 54 53 ...   4699  DISP_BTST   DC.B    '   BTST',0
0000443E= 20 20 20 43 4D 50 ...   4700  DISP_CMPI_B  DC.B    '   CMPI.B',0
00004448= 20 20 20 43 4D 50 ...   4701  DISP_CMPI_W  DC.B    '   CMPI.W',0
00004452= 20 20 20 43 4D 50 ...   4702  DISP_CMPI_L  DC.B    '   CMPI.L',0
0000445C= 20 20 20 44 41 54 ...   4703  DISP_DATA   DC.B    '   DATA',0
00004464= 20 20 20 4D 4F 56 ...   4704  DISP_MOVE_B DC.B    '   MOVE.B',0
0000446E= 20 20 20 4D 4F 56 ...   4705  DISP_MOVE_W DC.B    '   MOVE.W',0
00004478= 20 20 20 4D 4F 56 ...   4706  DISP_MOVE_L DC.B    '   MOVE.L',0
00004482= 20 20 20 52 54 53 00    4707  DISP_RTS    DC.B    '   RTS',0
00004489= 20 20 20 4A 53 52 00    4708  DISP_JSR    DC.B    '   JSR',0
00004490= 20 20 20 4E 45 47 ...   4709  DISP_NEG_B    DC.B    '   NEG.B',0
00004499= 20 20 20 4E 45 47 ...   4710  DISP_NEG_W    DC.B    '   NEG.W',0
000044A2= 20 20 20 4E 45 47 ...   4711  DISP_NEG_L    DC.B    '   NEG.L',0
000044AB= 20 20 20 4E 4F 54 ...   4712  DISP_NOT_B  DC.B    '   NOT.B',0
000044B4= 20 20 20 4E 4F 54 ...   4713  DISP_NOT_W  DC.B    '   NOT.W',0
000044BD= 20 20 20 4E 4F 54 ...   4714  DISP_NOT_L  DC.B    '   NOT.L',0
000044C6= 20 20 20 4C 45 41 00    4715  DISP_LEA    DC.B    '   LEA',0
000044CD= 20 20 20 4D 4F 56 ...   4716  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
000044D8= 20 20 20 4D 4F 56 ...   4717  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
000044E3= 20 20 20 41 44 44 ...   4718  DISP_ADDQ_B DC.B    '   ADDQ.B',0
000044ED= 20 20 20 41 44 44 ...   4719  DISP_ADDQ_W DC.B    '   ADDQ.W',0
000044F7= 20 20 20 41 44 44 ...   4720  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00004501= 20 20 20 44 49 56 ...   4721  DISP_DIVS   DC.B    '   DIVS',0
00004509= 20 20 20 53 55 42 ...   4722  DISP_SUB_B  DC.B    '   SUB.B',0
00004512= 20 20 20 53 55 42 ...   4723  DISP_SUB_W  DC.B    '   SUB.W',0
0000451B= 20 20 20 53 55 42 ...   4724  DISP_SUB_L  DC.B    '   SUB.L',0
00004524= 20 20 20 53 55 42 ...   4725  DISP_SUBI_B  DC.B    '   SUBI.B',0
0000452E= 20 20 20 53 55 42 ...   4726  DISP_SUBI_W  DC.B    '   SUBI.W',0
00004538= 20 20 20 53 55 42 ...   4727  DISP_SUBI_L  DC.B    '   SUBI.L',0
00004542= 20 20 20 53 55 42 ...   4728  DISP_SUBA_W  DC.B    '   SUBA.W',0
0000454C= 20 20 20 53 55 42 ...   4729  DISP_SUBA_L  DC.B    '   SUBA.L',0
00004556= 20 20 20 45 4F 52 ...   4730  DISP_EOR_B  DC.B    '   EOR.B',0
0000455F= 20 20 20 45 4F 52 ...   4731  DISP_EOR_W  DC.B    '   EOR.W',0
00004568= 20 20 20 45 4F 52 ...   4732  DISP_EOR_L  DC.B    '   EOR.L',0
00004571= 20 20 20 43 4D 50 ...   4733  DISP_CMP_B  DC.B    '   CMP.B',0
0000457A= 20 20 20 43 4D 50 ...   4734  DISP_CMP_W  DC.B    '   CMP.W',0
00004583= 20 20 20 43 4D 50 ...   4735  DISP_CMP_L  DC.B    '   CMP.L',0
0000458C= 20 20 20 43 4D 50 ...   4736  DISP_CMPA_W  DC.B    '   CMPA.W',0
00004596= 20 20 20 43 4D 50 ...   4737  DISP_CMPA_L  DC.B    '   CMPA.L',0
000045A0= 20 20 20 4D 55 4C ...   4738  DISP_MULS_W DC.B    '   MULS.W',0
000045AA= 20 20 20 41 4E 44 ...   4739  DISP_AND_B  DC.B    '   AND.B',0
000045B3= 20 20 20 41 4E 44 ...   4740  DISP_AND_W  DC.B    '   AND.W',0
000045BC= 20 20 20 41 4E 44 ...   4741  DISP_AND_L  DC.B    '   AND.L',0
000045C5= 20 20 20 41 44 44 ...   4742  DISP_ADD_B  DC.B    '   ADD.B',0
000045CE= 20 20 20 41 44 44 ...   4743  DISP_ADD_W  DC.B    '   ADD.W',0
000045D7= 20 20 20 41 44 44 ...   4744  DISP_ADD_L  DC.B    '   ADD.L',0
000045E0= 20 20 20 41 44 44 ...   4745  DISP_ADDA_W DC.B    '   ADDA.W',0
000045EA= 20 20 20 41 44 44 ...   4746  DISP_ADDA_L DC.B    '   ADDA.L',0
000045F4= 20 20 20 4C 53 52 ...   4747  DISP_LSR_B  DC.B    '   LSR.B',0
000045FD= 20 20 20 4C 53 4C ...   4748  DISP_LSL_B  DC.B    '   LSL.B',0
00004606= 20 20 20 4C 53 52 ...   4749  DISP_LSR_W  DC.B    '   LSR.W',0
0000460F= 20 20 20 4C 53 4C ...   4750  DISP_LSL_W  DC.B    '   LSL.W',0
00004618= 20 20 20 4C 53 52 ...   4751  DISP_LSR_L  DC.B    '   LSR.L',0
00004621= 20 20 20 4C 53 4C ...   4752  DISP_LSL_L  DC.B    '   LSL.L',0
0000462A= 20 20 20 41 53 52 ...   4753  DISP_ASR_B  DC.B    '   ASR.B',0
00004633= 20 20 20 41 53 4C ...   4754  DISP_ASL_B  DC.B    '   ASL.B',0
0000463C= 20 20 20 41 53 52 ...   4755  DISP_ASR_W  DC.B    '   ASR.W',0
00004645= 20 20 20 41 53 4C ...   4756  DISP_ASL_W  DC.B    '   ASL.W',0
0000464E= 20 20 20 41 53 52 ...   4757  DISP_ASR_L  DC.B    '   ASR.L',0
00004657= 20 20 20 41 53 4C ...   4758  DISP_ASL_L  DC.B    '   ASL.L',0
00004660= 20 20 20 52 4F 52 ...   4759  DISP_ROR_B  DC.B    '   ROR.B',0
00004669= 20 20 20 52 4F 4C ...   4760  DISP_ROL_B  DC.B    '   ROL.B',0
00004672= 20 20 20 52 4F 52 ...   4761  DISP_ROR_W  DC.B    '   ROR.W',0
0000467B= 20 20 20 52 4F 4C ...   4762  DISP_ROL_W  DC.B    '   ROL.W',0
00004684= 20 20 20 52 4F 52 ...   4763  DISP_ROR_L  DC.B    '   ROR.L',0
0000468D= 20 20 20 52 4F 4C ...   4764  DISP_ROL_L  DC.B    '   ROL.L',0
00004696= 20 20 20 42 52 41 00    4765  DISP_BRA    DC.B    '   BRA',0
0000469D= 20 20 20 42 4C 54 00    4766  DISP_BLT    DC.B    '   BLT',0
000046A4= 20 20 20 42 45 51 00    4767  DISP_BEQ    DC.B    '   BEQ',0
000046AB= 20 20 20 42 4E 45 00    4768  DISP_BNE    DC.B    '   BNE',0
000046B2= 20 20 20 42 48 49 00    4769  DISP_BHI    DC.B    '   BHI',0
000046B9= 20 20 20 4D 4F 56 ...   4770  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
000046C4= 20 20 20 4D 4F 56 ...   4771  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
000046CF                          4772  
000046CF= 20 20 20 24 00          4773  DISP_HEX     DC.B    '   $',0
000046D4= 20 20 20 44 00          4774  DISP_D  DC.B    '   D',0
000046D9= 20 20 20 41 00          4775  DISP_A  DC.B    '   A',0
000046DE= 20 20 20 28 00          4776  DISP_OP  DC.B    '   (',0
000046E3= 29 00                   4777  DISP_CP  DC.B   ')',0
000046E5= 20 20 20 28 41 00       4778  DISP_AOP  DC.B    '   (A',0
000046EB                          4779  
000046EB= 20 20 20 2D 28 41 00    4780  DISP_PRE    DC.B    '   -(A',0
000046F2= 29 2B 00                4781  DISP_POST   DC.B    ')+',0
000046F5= 20 20 20 23 00          4782  DISP_LB DC.B    '   #',0
000046FA= 30 00                   4783  DISP_0  DC.B    '0',0
000046FC= 31 00                   4784  DISP_1  DC.B    '1',0
000046FE= 32 00                   4785  DISP_2  DC.B    '2',0
00004700= 33 00                   4786  DISP_3  DC.B    '3',0
00004702= 34 00                   4787  DISP_4  DC.B    '4',0
00004704= 35 00                   4788  DISP_5  DC.B    '5',0
00004706= 36 00                   4789  DISP_6  DC.B    '6',0
00004708= 37 00                   4790  DISP_7  DC.B    '7',0
0000470A                          4791  
0000470A                          4792  *STACK INTERFACE VARIABLES*
0000470A                          4793  COUNTER         DS.W    1
0000470C                          4794  QUEUE_COUNTER   DS.W    1
0000470E                          4795  
0000470E                          4796  *EA DECODING INTERFACE VARIABLES* 
0000470E                          4797  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
0000470F                          4798  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004710                          4799  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004711                          4800  
00004711                          4801  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004711                          4802  * WORD + WORD = LONG
00004711                          4803  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004711                          4804  * A              + F            = AF         <= EXAMPLE
00004711                          4805  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004711                          4806  GET_DST_START_END    DS.B    1
00004712                          4807  GET_SRC_START_END    DS.B    1
00004713                          4808  
00004713                          4809  *STORES THE START + END BITS HERE (FROM ABOVE)
00004714                          4810  VAR_BYTE_START      DS.L    1
00004718                          4811  VAR_BYTE_END        DS.L    1
0000471C                          4812  VAR_TEMP_CLEANCOPY  DS.L    1
00004720                          4813  
00004720                          4814  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004724                          4815  
00004724                          4816  *MORE FOR STACK USAGE*
00004724= 2C 00                   4817  DISP_COMMA  DC.B    ',',0
00004726= 20 20 20 00             4818  DISP_INDENT  DC.B    '   ',0
0000472A                          4819  
0000472A                          4820  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
0000472A                          4821  POINTER_WORD    DS.W       1
0000472C                          4822  
0000472C                          4823  
0000472C                          4824  
0000472C                          4825  *---------------------------------------------------------------------------*
0000472C                          4826  * Ends program
0000472C                          4827  *---------------------------------------------------------------------------*
0000472C                          4828              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1166
ASCII2HEX           1160
ASC_ERR             11C2
ASC_LOW             11A4
ASC_NUM             11B4
ASC_SFT             11BC
ASC_UPP             11AC
CHECK0              355C
CHECK1              35E6
CHECK2              3670
CHECK3              370A
CHECK4              37AC
CHECK7              384E
CHECK_IMMEDIATE     392E
CHECK_LONG          38E0
CHECK_WORD          389A
CLEAR_RETURN        3E64
CLEAR_STACK         3E54
COUNTER             470A
CR                  D
DECREMENT           3E4C
DEST_CHECK0         398C
DEST_CHECK1         3A16
DEST_CHECK2         3AA0
DEST_CHECK3         3B3A
DEST_CHECK4         3BDC
DEST_CHECK7         3C7E
DEST_CHECK_IMMEDIATE  3D5E
DEST_CHECK_LONG     3D10
DEST_CHECK_WORD     3CCA
DEST_LOOP_SHIFTING  39F6
DEST_LOOP_SHIFTING1  3A80
DEST_LOOP_SHIFTING2  3B12
DEST_LOOP_SHIFTING3  3BAC
DEST_LOOP_SHIFTING4  3C56
DEST_LOOP_SHIFTING7  3CB6
DEST_MASKING_NEXT   3A04
DEST_MASKING_NEXT1  3A8E
DEST_MASKING_NEXT2  3B20
DEST_MASKING_NEXT3  3BBA
DEST_MASKING_NEXT4  3C64
DEST_MASKING_NEXT7  3CC4
DEST_MODE           3114
DEST_REGISTER       33E4
DEST_REGISTER_FORMAT  470E
DISPLAY_30_LINES    130E
DISP_0              46FA
DISP_1              46FC
DISP_2              46FE
DISP_3              4700
DISP_4              4702
DISP_5              4704
DISP_6              4706
DISP_7              4708
DISP_A              46D9
DISP_ADDA_L         45EA
DISP_ADDA_W         45E0
DISP_ADDQ_B         44E3
DISP_ADDQ_L         44F7
DISP_ADDQ_W         44ED
DISP_ADD_B          45C5
DISP_ADD_L          45D7
DISP_ADD_W          45CE
DISP_AND_B          45AA
DISP_AND_L          45BC
DISP_AND_W          45B3
DISP_AOP            46E5
DISP_ASL_B          4633
DISP_ASL_L          4657
DISP_ASL_W          4645
DISP_ASR_B          462A
DISP_ASR_L          464E
DISP_ASR_W          463C
DISP_BEQ            46A4
DISP_BHI            46B2
DISP_BLT            469D
DISP_BNE            46AB
DISP_BRA            4696
DISP_BTST           4436
DISP_CMPA_L         4596
DISP_CMPA_W         458C
DISP_CMPI_B         443E
DISP_CMPI_L         4452
DISP_CMPI_W         4448
DISP_CMP_B          4571
DISP_CMP_L          4583
DISP_CMP_W          457A
DISP_COMMA          4724
DISP_CP             46E3
DISP_D              46D4
DISP_DATA           445C
DISP_DIVS           4501
DISP_EORI_B         4418
DISP_EORI_L         442C
DISP_EORI_W         4422
DISP_EOR_B          4556
DISP_EOR_L          4568
DISP_EOR_W          455F
DISP_HEX            46CF
DISP_INDENT         4726
DISP_JSR            4489
DISP_LB             46F5
DISP_LEA            44C6
DISP_LSL_B          45FD
DISP_LSL_L          4621
DISP_LSL_W          460F
DISP_LSR_B          45F4
DISP_LSR_L          4618
DISP_LSR_W          4606
DISP_MOVEA_L        46C4
DISP_MOVEA_W        46B9
DISP_MOVEM_L        44D8
DISP_MOVEM_W        44CD
DISP_MOVE_B         4464
DISP_MOVE_L         4478
DISP_MOVE_W         446E
DISP_MULS_W         45A0
DISP_NEG_B          4490
DISP_NEG_L          44A2
DISP_NEG_W          4499
DISP_NEXT           41A9
DISP_NOT_B          44AB
DISP_NOT_L          44BD
DISP_NOT_W          44B4
DISP_OP             46DE
DISP_ORI_B          43FD
DISP_ORI_L          440F
DISP_ORI_W          4406
DISP_POST           46F2
DISP_PRE            46EB
DISP_ROL_B          4669
DISP_ROL_L          468D
DISP_ROL_W          467B
DISP_ROR_B          4660
DISP_ROR_L          4684
DISP_ROR_W          4672
DISP_RTS            4482
DISP_SUBA_L         454C
DISP_SUBA_W         4542
DISP_SUBI_B         4524
DISP_SUBI_L         4538
DISP_SUBI_W         452E
DISP_SUB_B          4509
DISP_SUB_L          451B
DISP_SUB_W          4512
D_MODE000           31B6
D_MODE010           31FE
D_MODE011           325E
D_MODE100           327E
D_MODE111           32D0
EA_ARITH            30AE
EA_DATA             1606
EA_GEN              30FA
EA_MOVEA            30D4
EA_NOSRC            309A
ENDLINE_M           435A
END_ADDR            10AC
ERRMSG_1            4241
ERRMSG_3            4260
ERRMSG_5            4285
ERROR_1             1110
ERROR_2             1120
ERROR_3             1130
ERROR_4             1140
ERROR_5             1150
E_ADDR_HX           4356
FINMSG              4216
GET_DST_FAILED      3DA4
GET_DST_START_END   4711
GET_DST_SUCCESS     3DA8
GET_EA_EA_DEST      397A
GET_EA_EA_SRC       354A
GET_SRC_FAILED      3974
GET_SRC_START_END   4712
GET_SRC_SUCCESS     3978
HEX2ASCII           11C8
HEX2ASCII2STACK     120A
HEX_CHAR            11F6
HEX_CONT            11FA
HEX_LOOP            11DC
IMMD_B              3384
IMMD_L              33C4
IMMD_W              33A4
IMMEDIATE           3354
INCREMENT           3E44
INTRO               1028
IS_ODD              124E
IS_ODD_ERR          1264
JMPTABLE            133A
LF                  A
LONGMODE            3328
LOOP_SHIFTING       35C6
LOOP_SHIFTING1      3650
LOOP_SHIFTING2      36E2
LOOP_SHIFTING3      377C
LOOP_SHIFTING4      3826
MAIN                126A
MASKING_NEXT        35D4
MASKING_NEXT1       365E
MASKING_NEXT2       36F0
MASKING_NEXT3       378A
MASKING_NEXT4       3834
MODE000             31A2
MODE001             31CA
MODE010             31DE
MODE011             321E
MODE100             323E
MODE111             329E
NEXTLINES           131C
OP0000              139A
OP0000_BTST_B       1504
OP0000_CMPI         162E
OP0000_CMPI_B       16A4
OP0000_CMPI_L       16F4
OP0000_CMPI_W       16CC
OP0000_ORI_B        1788
OP0000_ORI_L        17D8
OP0000_ORI_W        17B0
OP0000_RETURN_BTST  1534
OP0000_RETURN_CMPI  1718
OP0000_RETURN_ORI   17FC
OP0001              17FE
OP0010              186C
OP0011              196A
OP0100              1A66
OP0101              1CBC
OP0101_ADDQ_B       1D38
OP0101_ADDQ_B_0     1DB4
OP0101_ADDQ_B_1     1DC0
OP0101_ADDQ_B_2     1DCC
OP0101_ADDQ_B_3     1DD8
OP0101_ADDQ_B_4     1DE4
OP0101_ADDQ_B_5     1DF0
OP0101_ADDQ_B_6     1DFC
OP0101_ADDQ_B_7     1E08
OP0101_ADDQ_B_8     1E14
OP0101_ADDQ_L       1D50
OP0101_ADDQ_W       1D44
OP0101_RETURN       1D58
OP0101_RETURN2      1E1C
OP0110              1E60
OP0111              1EEE
OP1000              1EF2
OP1000_DIVS_DN_EA_OR_EA_DN  1F00
OP1000_DIVS_RETURN  1FE4
OP1000_EA_DN_DIVS   1F2E
OP1000_PRINT_L_DIVS  1F9C
OP1000_PRINT_W_DIVS  1F54
OP1001              1FFA
OP1001_ADD_RETURN   2348
OP1001_DETERMINE_DN_EA_OR_EA_DN  2110
OP1001_DN_EA        2148
OP1001_EA_DN        2248
OP1001_PRINT_B      2270
OP1001_PRINT_B2     2170
OP1001_PRINT_L      2300
OP1001_PRINT_L2     2200
OP1001_PRINT_W      22B8
OP1001_PRINT_W2     21B8
OP1001_SUBA_L       202C
OP1001_SUBA_W       209E
OP1010              23B6
OP1011              23BA
OP1011_CMP          2414
OP1011_CMPA         24C6
OP1011_CMPA_L       2540
OP1011_CMPA_W       2534
OP1011_CMP_B        2488
OP1011_CMP_L        24A0
OP1011_CMP_W        2494
OP1011_EOR          2566
OP1011_EOR_B        25DA
OP1011_EOR_L        25F2
OP1011_EOR_W        25E6
OP1011_RETURN       25FA
OP1011_RETURN_CMP   24A8
OP1011_RETURN_CMPA  2548
OP1100              26BA
OP1100_AND_RETURN   2A0A
OP1100_DETERMINE_DN_EA_OR_EA_DN  27D0
OP1100_DN_EA        280A
OP1100_EA_DN        290A
OP1100_EA_DN_MULS   2718
OP1100_MULS_DN_EA_OR_EA_DN  26EA
OP1100_MULS_RETURN  27CE
OP1100_PRINT_B      2932
OP1100_PRINT_B2     2832
OP1100_PRINT_L      29C2
OP1100_PRINT_L2     28C2
OP1100_PRINT_L_MULS  2786
OP1100_PRINT_W      297A
OP1100_PRINT_W2     287A
OP1100_PRINT_W_MULS  273E
OP1101              2A0C
OP1101_ADDA_L       2A3E
OP1101_ADDA_W       2AB0
OP1101_ADD_RETURN   2D5A
OP1101_DETERMINE_DN_EA_OR_EA_DN  2B22
OP1101_DN_EA        2B5A
OP1101_EA_DN        2C5A
OP1101_PRINT_B      2C82
OP1101_PRINT_B2     2B82
OP1101_PRINT_L      2D12
OP1101_PRINT_L2     2C12
OP1101_PRINT_W      2CCA
OP1101_PRINT_W2     2BCA
OP1110              2DE8
OP1111              3096
OP_ADDA_L           2DD0
OP_ADDA_W           2DB8
OP_ADDQ_B           1E2A
OP_ADDQ_L           1E4E
OP_ADDQ_W           1E3C
OP_ADD_B            2D70
OP_ADD_L            2DA0
OP_ADD_W            2D88
OP_ASL              2F88
OP_ASL_B            2FAC
OP_ASL_L            2FBE
OP_ASL_W            2FD0
OP_ASR              2F2E
OP_ASR_B            2F52
OP_ASR_L            2F64
OP_ASR_W            2F76
OP_ASX              2E4A
OP_BEQ              1EC4
OP_BHI              1EA8
OP_BLT              1EE0
OP_BNE              1EB6
OP_BRA              1ED2
OP_BTST             1424
OP_BTST_IMMEDIATE   14AE
OP_CMPA_L           262A
OP_CMPA_W           2618
OP_CMP_B            263C
OP_CMP_L            266C
OP_CMP_W            2654
OP_DATA             15E2
OP_DIVS             1FE6
OP_EORI             1536
OP_EORI_B           1556
OP_EORI_L           157A
OP_EORI_W           1568
OP_EOR_B            2684
OP_EOR_L            26A8
OP_EOR_W            2696
OP_JSR              1C8E
OP_LEA              1B14
OP_LEA_DN_EA_OR_EA_DN  1B22
OP_LEA_RETURN       1B80
OP_LSL              2ED4
OP_LSL_B            2EF8
OP_LSL_L            2F0A
OP_LSL_W            2F1C
OP_LSR              2E7A
OP_LSR_B            2E9E
OP_LSR_L            2EB0
OP_LSR_W            2EC2
OP_LSX              2E32
OP_MOVEA_L          18FA
OP_MOVEA_W          19F6
OP_MOVEM_L          1B02
OP_MOVEM_W          1AF0
OP_MOVE_B           1804
OP_MOVE_L           1892
OP_MOVE_W           198E
OP_MULS             26DC
OP_NEG              1B82
OP_NEG_B            1BCE
OP_NEG_L            1BE6
OP_NEG_PRINT_EA     1BF2
OP_NEG_W            1BDA
OP_NOT              1C08
OP_NOT_B            1C54
OP_NOT_L            1C6C
OP_NOT_PRINT_EA     1C78
OP_NOT_W            1C60
OP_ORI              171A
OP_PRINT_L_LEA      1B40
OP_ROL              303C
OP_ROL_B            3060
OP_ROL_L            3072
OP_ROL_W            3084
OP_ROR              2FE2
OP_ROR_B            3006
OP_ROR_L            3018
OP_ROR_W            302A
OP_ROX              2E62
OP_RTS              1CA2
OP_SUBA_L           23A4
OP_SUBA_W           2392
OP_SUBI             158C
OP_SUBI_B           15AC
OP_SUBI_L           15D0
OP_SUBI_W           15BE
OP_SUB_B            234A
OP_SUB_L            237A
OP_SUB_W            2362
OUTPUT_PROCESSED_DATA  12EE
POINTER_WORD        472A
POP_FRONT           3DFE
POP_FRONT_RETURN    3E38
POP_RETURN          3DFC
POP_SHIFT_LOOP      3E1A
POP_STACK           3DF0
PRINT_QUEUE         3DC4
PRINT_QUEUE_HELPER  3DD0
PRINT_QUEUE_RETURN  3DE6
PRINT_STACK         3DAA
PRINT_STACK_HELPER  3DB6
PRINT_STACK_RETURN  3DC2
PROGLP              100A
PROMPT_END          417C
PROMPT_START        414D
PUSH_STACK          3DE8
QUEUE_COUNTER       470C
REG_0               3498
REG_1               34A6
REG_2               34B4
REG_3               34C2
REG_4               34D0
REG_5               34DE
REG_6               34EC
REG_7               34FA
REPEAT              3508
REPEATMSG           41D3
RETURN              11C6
SRC_LOOP_SHIFTING   3886
SRC_MASKING_NEXT    3894
SRC_MODE            3158
SRC_REGISTER        3440
SRC_REGISTER_FORMAT  470F
STACK               7000
STACK_HEX_CHAR      1238
STACK_HEX_CONT      123C
STACK_HEX_LOOP      121E
START               1004
START_ADDR          105A
S_ADDR_HX           4352
TEMP_REGISTER_FORMAT  4710
TERMINATE           3E66
TESTING             1036
TMPINPUT            435D
TMPOUTPUT           43AD
VAR_BYTE_END        4718
VAR_BYTE_START      4714
VAR_LONG_ADDRESS_MODE_CHECK  4720
VAR_TEMP_CLEANCOPY  471C
VR_E_ADDR           4302
VR_S_ADDR           42B2
WELCOME             3E78
WORDMODE            32FC
