00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 12/10/2014 9:06:55 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001060             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010B2             38              JSR     END_ADDR
00001016  43F9 000045C2             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012D8             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 000040E0             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036                            53  
00001036  EA48                      54              LSR.W   #5,D0
00001038  E2D1                      55              LSR.W   (A1)
0000103A  E2DA                      56              LSR.W   (A2)+
0000103C  E2E3                      57              LSR.W   -(A3)
0000103E  E2F8 1234                 58              LSR.W   $1234
00001042  E2F9 12345678             59              LSR.W   $12345678 
00001048                            60  
00001048                            61              
00001048  EA08                      62              LSR.B   #5,D0
0000104A  EA48                      63              LSR.W   #5,D0
0000104C  E2D1                      64              LSR.W   (A1)
0000104E                            65  
0000104E  E220                      66              ASR.B   D1,D0
00001050  EA00                      67              ASR.B   #5,D0
00001052  EA40                      68              ASR.W   #5,D0
00001054  E0D1                      69              ASR.W   (A1)
00001056                            70  
00001056  E238                      71              ROR.B   D1,D0
00001058  EA18                      72              ROR.B   #5,D0
0000105A  EA58                      73              ROR.W   #5,D0
0000105C  E6D1                      74              ROR.W   (A1)
0000105E                            75  
0000105E                            76  
0000105E  4E75                      77              RTS
00001060                            78  *---------------------------------------------------------------------------*
00001060                            79  * START_ADDR: Compute the starting address
00001060                            80  *---------------------------------------------------------------------------*
00001060                            81  START_ADDR
00001060                            82              * Output
00001060  43F9 000043B5             83              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001066  103C 000E                 84              MOVE.B  #14,D0                  * Display PROMPT_START
0000106A  4E4F                      85              TRAP    #15
0000106C                            86      
0000106C                            87              * Input
0000106C  43F9 0000451A             88              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
00001072  103C 0002                 89              MOVE.B  #2,D0                   * Ask user for input
00001076  4E4F                      90              TRAP    #15
00001078                            91              
00001078                            92              * Error Checking (length)
00001078  0C01 0000                 93              CMPI.B  #0, D1                  * Check if input length <= 0
0000107C  6F00 0098                 94              BLE     ERROR_1
00001080  0C01 0008                 95              CMPI.B  #8, D1                  * Check if input length > 8
00001084  6E00 0090                 96              BGT     ERROR_1
00001088                            97              
00001088                            98              * Conversion & Storage
00001088  4EB9 00001166             99              JSR     ASCII2HEX               * Jump to ASCII2HEX
0000108E  0C07 0001                100              CMPI.B  #1, D7                  * Check for error
00001092  6700 0082                101              BEQ     ERROR_1                 
00001096  23C1 000045BA            102              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
0000109C                           103              
0000109C                           104              * Error Checking (Odd)
0000109C  43F9 000045BA            105              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
000010A2  4EB9 000012BC            106              JSR     IS_ODD                  * Check if the input address is odd
000010A8  0C07 0001                107              CMPI.B  #1, D7                  * Check for error
000010AC  6700 0088                108              BEQ     ERROR_3
000010B0                           109              
000010B0                           110              * Return
000010B0  4E75                     111              RTS     
000010B2                           112  *---------------------------------------------------------------------------*
000010B2                           113  * END_ADDR: Compute the ending address
000010B2                           114  *---------------------------------------------------------------------------*
000010B2                           115  END_ADDR
000010B2                           116              * Output
000010B2  43F9 000043E4            117              LEA     PROMPT_END,A1           * Load PROMPT_END
000010B8  103C 000E                118              MOVE.B  #14,D0                  * Display PROMPT_END
000010BC  4E4F                     119              TRAP    #15
000010BE                           120  
000010BE                           121              * Input
000010BE  43F9 0000456A            122              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010C4  103C 0002                123              MOVE.B  #2,D0                   * Ask user for input
000010C8  4E4F                     124              TRAP    #15
000010CA                           125              
000010CA                           126              * Error Checking (length)
000010CA  0C01 0000                127              CMPI.B  #0, D1                  * Check if input length <= 0
000010CE  6F00 0056                128              BLE     ERROR_2
000010D2  0C01 0008                129              CMPI.B  #8, D1                  * Check if input length > 8
000010D6  6E00 004E                130              BGT     ERROR_2
000010DA                           131              
000010DA                           132              * Conversion & Storage
000010DA  4EB9 00001166            133              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010E0  0C07 0001                134              CMPI.B  #1, D7                  * Check for error
000010E4  6700 0040                135              BEQ     ERROR_2
000010E8  23C1 000045BE            136              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010EE                           137              
000010EE                           138              * Error Checking (start > end case)
000010EE  2439 000045BA            139              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010F4  B282                     140              CMP.L   D2, D1                  * Compare starting and ending address
000010F6  6300 005E                141              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010FA                           142              
000010FA                           143              * Error Checking (Odd case)
000010FA  43F9 000045BE            144              LEA     E_ADDR_HX, A1           * Move the ending address
00001100  4EB9 000012BC            145              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
00001106  0C07 0001                146              CMPI.B  #1, D7                  * Check for an error flag
0000110A  6700 003A                147              BEQ     ERROR_4
0000110E                           148              
0000110E                           149              * Inputs are valid
0000110E  2A79 000045BA            150              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
00001114                           151              
00001114  4E75                     152              RTS
00001116                           153              
00001116                           154  *---------------------------------------------------------------------------*
00001116                           155  * ERROR_1: Address error (Invalid starting address)
00001116                           156  *---------------------------------------------------------------------------*
00001116                           157  ERROR_1
00001116  43F9 000044A9            158              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000111C  103C 000E                159              MOVE.B  #14, D0                 * Display ERRMSG_1
00001120  4E4F                     160              TRAP    #15
00001122  4EF8 1060                161              JMP     START_ADDR              * Jump to START_ADDR
00001126                           162      
00001126                           163  *---------------------------------------------------------------------------*
00001126                           164  * ERROR_2: Address error (Invalid ending address)
00001126                           165  *---------------------------------------------------------------------------*
00001126                           166  ERROR_2
00001126  43F9 000044A9            167              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000112C  103C 000E                168              MOVE.B  #14, D0                 * Display ERRMSG_1
00001130  4E4F                     169              TRAP    #15
00001132  4EF8 10B2                170              JMP     END_ADDR                * Jump to END_ADDR
00001136                           171  
00001136                           172  *---------------------------------------------------------------------------*
00001136                           173  * ERROR_3: Address error (Odd starting address)
00001136                           174  *---------------------------------------------------------------------------*
00001136                           175  ERROR_3
00001136  43F9 000044C8            176              LEA     ERRMSG_3, A1
0000113C  103C 000E                177              MOVE.B  #14, D0
00001140  4E4F                     178              TRAP    #15
00001142  4EF8 1060                179              JMP     START_ADDR
00001146                           180     
00001146                           181  *---------------------------------------------------------------------------*
00001146                           182  * ERROR_4: Address error (Odd ending address)
00001146                           183  *---------------------------------------------------------------------------*         
00001146                           184  ERROR_4
00001146  43F9 000044C8            185              LEA     ERRMSG_3, A1
0000114C  103C 000E                186              MOVE.B  #14, D0
00001150  4E4F                     187              TRAP    #15
00001152  4EF8 10B2                188              JMP     END_ADDR
00001156                           189            
00001156                           190  *---------------------------------------------------------------------------*
00001156                           191  * ERROR_3: Address error (Ending address is less than starting address)
00001156                           192  *---------------------------------------------------------------------------*
00001156                           193  ERROR_5
00001156  43F9 000044ED            194              LEA     ERRMSG_5, A1
0000115C  103C 000E                195              MOVE.B  #14, D0
00001160  4E4F                     196              TRAP    #15
00001162  4EF8 10B2                197              JMP     END_ADDR
00001166                           198    
00001166                           199  *---------------------------------------------------------------------------*
00001166                           200  * ASCII2HEX: Convert ASCii to Hexadecimal
00001166                           201  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001166                           202  *---------------------------------------------------------------------------*
00001166  4281                     203  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001168  4287                     204              CLR.L   D7                      * Set the error flag to 0
0000116A  4282                     205              CLR.L   D2                      * Clear D2 for temp storage
0000116C                           206              
0000116C  1419                     207  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
0000116E  0C02 0000                208              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
00001172  6700 0058                209              BEQ     RETURN                  * If it's NULL, go to return
00001176  0C02 0066                210              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
0000117A  6E00 004C                211              BGT     ASC_ERR                 * ASCII > f (invalid input) 
0000117E  0C02 0061                212              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
00001182  6C00 0026                213              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001186  0C02 0046                214              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
0000118A  6E00 003C                215              BGT     ASC_ERR                 * ASCII > F (invalid input)
0000118E  0C02 0041                216              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
00001192  6C00 001E                217              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001196  0C02 0039                218              CMPI.B  #57, D2                 * Decimal value of 9 is 57
0000119A  6E00 002C                219              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
0000119E  0C02 0030                220              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011A2  6C00 0016                221              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
000011A6  6000 0020                222              BRA     ASC_ERR                 * Invalid input
000011AA                           223  
000011AA  0442 0057                224  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011AE  6000 0012                225              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011B2                           226              
000011B2  0442 0037                227  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011B6  6000 000A                228              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011BA                           229              
000011BA  0442 0030                230  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011BE  6000 0002                231              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011C2                           232              
000011C2  E981                     233  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011C4  D202                     234              ADD.B   D2, D1                  * Add the converted input to D1
000011C6  60A4                     235              BRA     ASC2HXLP                * Loop
000011C8                           236  
000011C8  1E3C 0001                237  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011CC  4E75                     238  RETURN      RTS     
000011CE                           239  
000011CE                           240  *---------------------------------------------------------------------------*
000011CE                           241  * ASCII2HEX: Convert ASCii to Hexadecimal
000011CE                           242  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011CE                           243  *---------------------------------------------------------------------------*
000011CE                           244  ASCII2HEX2STACK
000011CE  4283                     245              CLR.L   D3                      * Clear the destination 
000011D0  4287                     246              CLR.L   D7                      * Set the error flag to 0
000011D2  4282                     247              CLR.L   D2                      * Clear D2 for temp storage
000011D4                           248              
000011D4                           249  ASC2HXLP2STACK
000011D4  1419                     250              MOVE.B  (A1)+, D2               * Read a byte to D2
000011D6  0C02 0000                251              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011DA  6700 0058                252              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011DE  0C02 0066                253              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011E2  6E00 004C                254              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011E6  0C02 0061                255              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011EA  6C00 0026                256              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011EE  0C02 0046                257              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011F2  6E00 003C                258              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011F6  0C02 0041                259              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011FA  6C00 001E                260              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011FE  0C02 0039                261              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001202  6E00 002C                262              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
00001206  0C02 0030                263              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000120A  6C00 0016                264              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
0000120E  6000 0020                265              BRA     ASC_ERR2STACK                 * Invalid input
00001212                           266  
00001212                           267  ASC_LOW2STACK
00001212  0442 0057                268              SUBI    #87, D2                 * Convert the ASCII input to Hex
00001216  6000 0012                269              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
0000121A                           270              
0000121A                           271  ASC_UPP2STACK
0000121A  0442 0037                272              SUBI    #55, D2                 * Convert the ASCII input to Hex
0000121E  6000 000A                273              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
00001222                           274              
00001222                           275  ASC_NUM2STACK
00001222  0442 0030                276              SUBI    #48, D2                 * Convert the ASCII input to Hex
00001226  6000 0002                277              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
0000122A                           278              
0000122A                           279  ASC_SFT2STACK
0000122A  E983                     280              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
0000122C  D602                     281              ADD.B   D2, D3                  * Add the converted input to D1
0000122E  60A4                     282              BRA     ASC2HXLP2STACK                * Loop
00001230                           283  
00001230                           284  ASC_ERR2STACK
00001230  1E3C 0001                285              MOVE.B  #1, D7                  * Set the error flag to 1            
00001234                           286  RETURN2STACK
00001234  4E75                     287              RTS  
00001236                           288  *---------------------------------------------------------------------------*
00001236                           289  * HEX2ASCII: Convert Hexadecimal to ASCii 
00001236                           290  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001236                           291  *---------------------------------------------------------------------------*
00001236  0C02 0008                292  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
0000123A  6700 000E                293              BEQ     HEX_LOOP
0000123E  4841                     294              SWAP    D1
00001240  0C02 0002                295              CMPI.B  #2,D2
00001244  6600 0004                296              BNE     HEX_LOOP
00001248  E189                     297              LSL.L   #8,D1
0000124A                           298             
0000124A  E999                     299  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
0000124C  2601                     300              MOVE.L  D1, D3                  * Move D1 to D3
0000124E  0283 0000000F            301              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001254  0C03 0009                302              CMPI.B  #9, D3                  * Compare te digit
00001258  6E00 000A                303              BGT     HEX_CHAR              
0000125C  0603 0030                304              ADDI.B  #48,D3                  * Add 48 for numerical output
00001260  6000 0006                305              BRA     HEX_CONT
00001264                           306              
00001264  0603 0037                307  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001268                           308  
00001268  12C3                     309  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
0000126A  5342                     310              SUBI    #1, D2                  * Decrement the size
0000126C  0C02 0000                311              CMPI.B  #0, D2                  * Check if D2 is 0
00001270  66D8                     312              BNE     HEX_LOOP                * Loop
00001272  12BC 0000                313              MOVE.B  #$0,(A1)                * Null terminator
00001276  4E75                     314              RTS
00001278                           315  *---------------------------------------------------------------------------*
00001278                           316  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001278                           317  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
00001278                           318  *---------------------------------------------------------------------------*
00001278                           319  HEX2ASCII2STACK
00001278  0C02 0008                320              CMPI.B  #8, D2                  * Check to see if the size is long
0000127C  6700 000E                321              BEQ     STACK_HEX_LOOP
00001280  4841                     322              SWAP    D1
00001282  0C02 0002                323              CMPI.B  #2,D2
00001286  6600 0004                324              BNE     STACK_HEX_LOOP
0000128A  E189                     325              LSL.L   #8,D1
0000128C                           326             
0000128C                           327  STACK_HEX_LOOP    
0000128C  E999                     328              ROL.L   #4, D1                  * Roll D1 to left
0000128E  2601                     329              MOVE.L  D1, D3                  * Move D1 to D3
00001290  0283 0000000F            330              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001296  0C03 0009                331              CMPI.B  #9, D3                  * Compare te digit
0000129A  6E00 000A                332              BGT     STACK_HEX_CHAR              
0000129E  0603 0030                333              ADDI.B  #48,D3                  * Add 48 for numerical output
000012A2  6000 0006                334              BRA     STACK_HEX_CONT
000012A6                           335              
000012A6                           336  STACK_HEX_CHAR    
000012A6  0603 0037                337              ADDI.B  #55,D3                  * Add 55 for character output
000012AA                           338  
000012AA                           339  STACK_HEX_CONT    
000012AA  6100 2D40                340              BSR     PUSH_STACK              *PLACE INTO STACK
000012AE  5342                     341              SUBI    #1, D2                  * Decrement the size
000012B0  0C02 0000                342              CMPI.B  #0, D2                  * Check if D2 is 0
000012B4  66D6                     343              BNE     STACK_HEX_LOOP                * Loop
000012B6  12BC 0000                344              MOVE.B  #$0,(A1)                * Null terminator
000012BA  4E75                     345              RTS
000012BC                           346  
000012BC                           347  
000012BC                           348  *---------------------------------------------------------------------------*
000012BC                           349  * IS_ODD: Check whether the source address is odd
000012BC                           350  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
000012BC                           351  *---------------------------------------------------------------------------*
000012BC  4281                     352  IS_ODD      CLR.L   D1                      * Clear the result
000012BE  4287                     353              CLR.L   D7                      * Set the error flag to 0
000012C0  2211                     354              MOVE.L  (A1),D1                * Temp store the checking address to D1
000012C2  82FC 0002                355              DIVU    #2, D1                  * Divide the result by 2
000012C6  4841                     356              SWAP    D1                      * Swap remainder with quotient
000012C8  0C01 0001                357              CMPI.B  #1, D1                  * Check for error
000012CC  6700 0004                358              BEQ     IS_ODD_ERR
000012D0  4E75                     359              RTS
000012D2                           360              
000012D2  1E3C 0001                361  IS_ODD_ERR  MOVE.B  #1, D7
000012D6  4E75                     362              RTS
000012D8                           363  
000012D8                           364  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012D8                           365  * MAINDEBUG                    
000012D8                           366  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012D8                           367  * A5: Processing address
000012D8                           368  *
000012D8                           369  * D3: USED FOR PUSHING INTO STACK
000012D8                           370  *     To push into stack => MOVE.W #DATA,D3 
000012D8                           371  *                           BSR    PUSH_STACK
000012D8                           372  *     To print stack     => BSR    PRINT_STACK 
000012D8                           373  *     To clear stack     => BSR    CLEAR_STACK
000012D8                           374  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012D8                           375  MAIN        
000012D8                           376              *initialize stack pointer
000012D8  33FC 0000 00004972       377              MOVE.W  #0,COUNTER
000012E0  347C 7000                378              MOVEA.W #STACK,A2
000012E4  163C 0020                379              MOVE.B  #' ',D3
000012E8  6100 2D02                380              BSR     PUSH_STACK
000012EC  6100 2CFE                381              BSR     PUSH_STACK
000012F0  6100 2CFA                382              BSR     PUSH_STACK
000012F4                           383              
000012F4                           384              * clear registers for temp storage
000012F4  4280                     385              CLR.L   D0                   
000012F6  4281                     386              CLR.L   D1                   
000012F8  227C 00000000            387              MOVEA.L #0, A1                
000012FE                           388              
000012FE  220D                     389              MOVE.L  A5,D1                   * check to see if the address is fully read
00001300  23CD 000045BA            390              MOVE.L  A5,S_ADDR_HX
00001306  B2B9 000045BE            391              CMP.L   E_ADDR_HX,D1
0000130C  6C00 23FE                392              BGE     REPEAT                  * go to repeat for user action
00001310                           393  
00001310  43F9 00004615            394              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001316  143C 0008                395              MOVE.B  #8,D2                   * set the output size
0000131A  4EB8 1236                396              JSR     HEX2ASCII               
0000131E  43F9 00004615            397              LEA     TMPOUTPUT,A1
00001324  103C 000E                398              MOVE.B  #14,D0
00001328  4E4F                     399              TRAP    #15
0000132A                           400              
0000132A  4285                     401              CLR.L    D5                      * clear the processing data
0000132C  3A1D                     402              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
0000132E                           403                                               * advance the current instruction pointer to the next
0000132E                           404                                               * instruction in memory
0000132E                           405  *----------------------------------------*
0000132E                           406  * Registers          
0000132E                           407  * [D1] - COPY OF D5
0000132E                           408  * [D5] - DATA TO BE PROCESSED
0000132E                           409  * [D6] - COUNTER FOR LINES PROCESSED
0000132E                           410  *
0000132E                           411  * [D4]      - ERROR FLAG BEFORE PRINTING
0000132E                           412  * [STACK]   - PRINTS PROCESS DATA
0000132E                           413  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
0000132E                           414  *
0000132E                           415  * [A1] - USED FOR JUMPING/PRINTING
0000132E                           416  *
0000132E                           417  *----------------------------------------*
0000132E                           418  
0000132E                           419              
0000132E                           420              *Processing the first 4 most significant bits 
0000132E  2205                     421              MOVE.L  D5,D1                    * copy the current processing data to D1
00001330  143C 000C                422              MOVE.B  #12,D2                   * shift to right by 12 bits
00001334  E469                     423              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
00001336  C2FC 0006                424              MULU    #6,D1                    * form offset
0000133A  43F9 000013A8            425              LEA     JMPTABLE,A1              * index into table
00001340  4EB1 1000                426              JSR     0(A1,D1)                 * jump indirect with index
00001344                           427              
00001344                           428              *SECURED EA*
00001344  B83C 0001                429              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001348  6600 0012                430              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
0000134C  6100 041A                431              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001350  6100 2D06                432              BSR     CLEAR_STACK              * CLEARS THE STACK 
00001354  183C 0000                433              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001358  6000 0022                434              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
0000135C                           435             
0000135C                           436  OUTPUT_PROCESSED_DATA       
0000135C  163C 000D                437              MOVE.B  #$D,D3                  *carriage return
00001360  6100 2C8A                438              BSR     PUSH_STACK
00001364  163C 000A                439              MOVE.B  #$A,D3                  *new line feed
00001368  6100 2C82                440              BSR     PUSH_STACK
0000136C  163C 0000                441              MOVE.B  #$0,D3                  *null
00001370  6100 2C7A                442              BSR     PUSH_STACK
00001374                           443       
00001374  6100 2C52                444              BSR     PRINT_QUEUE
00001378  183C 0000                445              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
0000137C                           446  DISPLAY_30_LINES
0000137C                           447              * display 30 lines per page
0000137C  5206                     448              ADDI.B  #1,D6
0000137E  0C06 001E                449              CMPI.B  #30,D6
00001382  6C00 0006                450              BGE     NEXTLINES
00001386  6000 FF50                451              BRA     MAIN
0000138A                           452            
0000138A                           453  *---------------------------------------------------------------------------*
0000138A                           454  * NEXTLINES: receive input from user to print the next 30 lines
0000138A                           455  *---------------------------------------------------------------------------*  
0000138A  4206                     456  NEXTLINES   CLR.B   D6
0000138C  43F9 00004411            457              LEA     DISP_NEXT,A1
00001392  103C 000E                458              MOVE.B  #14,D0
00001396  4E4F                     459              TRAP    #15
00001398  43F9 000045C5            460              LEA     TMPINPUT,A1
0000139E  103C 0002                461              MOVE.B  #2,D0
000013A2  4E4F                     462              TRAP    #15
000013A4  4EF8 12D8                463              JMP     MAIN
000013A8                           464    
000013A8                           465  *---------------------------------------------------------------------------*
000013A8                           466  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
000013A8                           467  *---------------------------------------------------------------------------*  
000013A8  4EF9 00001408            468  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - 
000013AE  4EF9 00001984            469              JMP     OP0001  * MOVE.B                                        *FINISHED - 
000013B4  4EF9 000019F2            470              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - 
000013BA  4EF9 00001AF0            471              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - 
000013C0  4EF9 00001BEC            472              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - 
000013C6  4EF9 00001E42            473              JMP     OP0101  * ADDQ                                          *FINISHED - 
000013CC  4EF9 00001FE6            474              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *FINISHED - 
000013D2  4EF9 000020EC            475              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013D8  4EF9 000020F0            476              JMP     OP1000  * DIVS                                          *FINISHED - 
000013DE  4EF9 000021F8            477              JMP     OP1001  * SUB/SUBA                                      *FINISHED - 
000013E4  4EF9 000025B4            478              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013EA  4EF9 000025B8            479              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - 
000013F0  4EF9 000028B8            480              JMP     OP1100  * MULS/AND                                      *FINISHED - 
000013F6  4EF9 00002C0A            481              JMP     OP1101  * ADD/ADDA                                      *FINISHED - 
000013FC  4EF9 00002FE6            482              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
00001402  4EF9 0000329A            483              JMP     OP1111  * Special/Reserved
00001408                           484              
00001408                           485  *---------------------------------------------------------------------------*
00001408                           486  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
00001408                           487  *---------------------------------------------------------------------------*           
00001408                           488  OP0000                                                                                  
00001408  4281                     489              CLR.L   D1          * to temporarily store the address to process
0000140A  4280                     490              CLR.L   D0  
0000140C  4284                     491              CLR.L   D4                 
0000140E  227C 00000000            492              MOVEA.L #0, A1                
00001414                           493              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
00001414                           494              * Check if bit 11,10,9,8 are 0000)
00001414  2205                     495              MOVE.L  D5,D1
00001416  0281 00000F00            496              ANDI.L  #$0F00,D1
0000141C  0C81 00000000            497              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
00001422  6700 047C                498              BEQ     OP_ORI
00001426                           499  
00001426                           500              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
00001426                           501              * check if bit 11,10,9,8 are 1100
00001426  4281                     502              CLR.L   D1
00001428  2205                     503              MOVE.L  D5,D1
0000142A  0281 00000F00            504              ANDI.L  #$0F00,D1
00001430  0C81 00000C00            505              CMPI.L  #$0C00,D1
00001436  6700 037C                506              BEQ     OP0000_CMPI
0000143A                           507              
0000143A                           508              * check for SUBI
0000143A  4281                     509              CLR.L   D1
0000143C  2205                     510              MOVE.L  D5,D1
0000143E  0281 00000F00            511              ANDI.L  #$0F00,D1
00001444  0C81 00000400            512              CMPI.L  #$0400,D1
0000144A  6700 023A                513              BEQ     OP_SUBI
0000144E                           514              
0000144E                           515              * check for EORI
0000144E  4281                     516              CLR.L   D1
00001450  2205                     517              MOVE.L  D5,D1
00001452  0281 00000F00            518              ANDI.L  #$0F00,D1
00001458  0C81 00000A00            519              CMPI.L  #$0A00,D1
0000145E  6700 0144                520              BEQ     OP_EORI
00001462                           521              
00001462                           522              * check for BTST
00001462  4281                     523              CLR.L   D1
00001464  2205                     524              MOVE.L  D5,D1
00001466  E099                     525              ROR.L   #8,D1
00001468  0281 00000001            526              ANDI.L  #$1,D1
0000146E  0C01 0001                527              CMPI.B  #$1,D1
00001472  6700 001E                528              BEQ     OP_BTST
00001476  4281                     529              CLR.L   D1
00001478  2205                     530              MOVE.L  D5,D1
0000147A  EC99                     531              ROR.L   #6,D1
0000147C  0281 000003FF            532              ANDI.L  #$03FF,D1
00001482  0C81 00000020            533              CMPI.L  #%000100000,D1
00001488  6700 0008                534              BEQ     OP_BTST
0000148C                           535  
0000148C                           536  
0000148C                           537              * OP0000 series other than ORI/CMPI/BTST/EORI
0000148C  4EF9 00001768            538              JMP     OP_DATA
00001492                           539              
00001492                           540  *---------------------------------------------------------------------------*
00001492                           541  * OP_BTST: display BTST
00001492                           542  *---------------------------------------------------------------------------* 
00001492                           543  OP_BTST       
00001492                           544              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
00001492                           545              *bits #8 indicates which
00001492                           546              *0 - #immediate format
00001492                           547              *1 - Dn format
00001492  4281                     548              CLR.L   D1
00001494  2205                     549              MOVE.L  D5,D1
00001496  E099                     550              ROR.L   #8,D1
00001498  0281 00000001            551              ANDI.L  #1,D1
0000149E  0C01 0001                552              CMPI.B  #1,D1
000014A2  6600 0078                553              BNE     OP_BTST_IMMEDIATE
000014A6                           554  
000014A6                           555             
000014A6                           556             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000014A6  13FC 0000 00004976       557             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014AE  13FC 0002 00004977       558             MOVE.B   #$02,SRC_REGISTER_FORMAT
000014B6                           559             
000014B6                           560             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014B6  13FC 00B9 00004979       561             MOVE.B   #$B9,GET_DST_START_END
000014BE  13FC 0020 0000497A       562             MOVE.B   #$20,GET_SRC_START_END
000014C6                           563             
000014C6  0285 0000FE3F            564             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014CC  0685 00000000            565             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014D2                           566              
000014D2                           567              *CLEAR D3
000014D2  4283                     568              CLR.L   D3
000014D4                           569              *LOAD STACK WITH THIS OPMODE
000014D4  6100 2B16                570              BSR     PUSH_STACK
000014D8  163C 0042                571              MOVE.B  #'B',D3
000014DC  6100 2B0E                572              BSR     PUSH_STACK
000014E0  163C 0054                573              MOVE.B  #'T',D3
000014E4  6100 2B06                574              BSR     PUSH_STACK
000014E8  163C 0053                575              MOVE.B  #'S',D3
000014EC  6100 2AFE                576              BSR     PUSH_STACK
000014F0  163C 0054                577              MOVE.B  #'T',D3
000014F4  6100 2AF6                578              BSR     PUSH_STACK
000014F8  163C 002E                579              MOVE.B  #'.',D3
000014FC  6100 2AEE                580              BSR     PUSH_STACK
00001500  163C 0042                581              MOVE.B  #'B',D3
00001504  6100 2AE6                582              BSR     PUSH_STACK
00001508                           583              
00001508  6100 2674                584              BSR     GET_EA_EA_DEST
0000150C  163C 002C                585              MOVE.B  #',',D3
00001510  6100 2ADA                586              BSR     PUSH_STACK
00001514  6100 2238                587              BSR     GET_EA_EA_SRC
00001518                           588              
00001518  6000 0088                589              BRA     OP0000_RETURN_BTST
0000151C                           590              
0000151C                           591              
0000151C                           592              *MOVE **** OR **** CMPI
0000151C                           593              
0000151C                           594  OP_BTST_IMMEDIATE              
0000151C                           595   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000151C  13FC 0000 00004976       596             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001524  13FC 0082 00004977       597             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000152C                           598             
0000152C                           599             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000152C  13FC 00B9 00004979       600             MOVE.B   #$B9,GET_DST_START_END
00001534  13FC 0020 0000497A       601             MOVE.B   #$20,GET_SRC_START_END
0000153C                           602             
0000153C                           603              *CLEAR D3
0000153C  4283                     604              CLR.L   D3
0000153E                           605              *LOAD STACK WITH THIS OPMODE
0000153E  6100 2AAC                606              BSR     PUSH_STACK
00001542  163C 0042                607              MOVE.B  #'B',D3
00001546  6100 2AA4                608              BSR     PUSH_STACK
0000154A  163C 0054                609              MOVE.B  #'T',D3
0000154E  6100 2A9C                610              BSR     PUSH_STACK
00001552  163C 0053                611              MOVE.B  #'S',D3
00001556  6100 2A94                612              BSR     PUSH_STACK
0000155A  163C 0054                613              MOVE.B  #'T',D3
0000155E  6100 2A8C                614              BSR     PUSH_STACK
00001562  163C 002E                615              MOVE.B  #'.',D3
00001566  6100 2A84                616              BSR     PUSH_STACK
0000156A  163C 0042                617              MOVE.B  #'B',D3
0000156E  6100 2A7C                618              BSR     PUSH_STACK
00001572                           619  
00001572                           620  OP0000_BTST_B
00001572                           621              *GET DATA FROM ADDQ AND PRINT #0-8
00001572                           622              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001572  0285 0000F03F            623              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001578  0685 000001C0            624              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000157E                           625  
0000157E                           626              *GRAB #IMMEDIATE DATA AS WORD SIZE
0000157E                           627             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
0000157E                           628             * MOVE.W    (A5)+,D1
0000157E                           629             * MOVE.B  #' ',D3
0000157E                           630             * BSR     PUSH_STACK
0000157E                           631             * MOVE.B  #'#',D3
0000157E                           632             * BSR     PUSH_STACK
0000157E                           633             * BSR     HEX2ASCII2STACK
0000157E                           634             * BSR     PUSH_STACK
0000157E                           635              
0000157E  163C 0020                636              MOVE.B  #' ',D3
00001582  6100 2A68                637              BSR     PUSH_STACK
00001586  163C 0023                638              MOVE.B  #'#',D3
0000158A  6100 2A60                639              BSR     PUSH_STACK
0000158E  6100 25EE                640              BSR     GET_EA_EA_DEST
00001592  163C 002C                641              MOVE.B  #',',D3
00001596  6100 2A54                642              BSR     PUSH_STACK
0000159A  6100 21B2                643              BSR     GET_EA_EA_SRC
0000159E  6000 0002                644              BRA     OP0000_RETURN_BTST
000015A2                           645  OP0000_RETURN_BTST
000015A2                           646              
000015A2  4E75                     647              RTS
000015A4                           648  
000015A4                           649  
000015A4                           650  *---------------------------------------------------------------------------*
000015A4                           651  * OP_EORI: decode and display EORI
000015A4                           652  *---------------------------------------------------------------------------* 
000015A4                           653  OP_EORI
000015A4                           654                         
000015A4                           655  
000015A4                           656   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000015A4  13FC 0000 00004976       657             MOVE.B   #$00,DEST_REGISTER_FORMAT
000015AC  13FC 0080 00004977       658             MOVE.B   #$80,SRC_REGISTER_FORMAT
000015B4                           659             
000015B4                           660             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000015B4  13FC 00B9 00004979       661             MOVE.B   #$B9,GET_DST_START_END
000015BC  13FC 0020 0000497A       662             MOVE.B   #$20,GET_SRC_START_END
000015C4                           663             
000015C4                           664              *CLEAR D3
000015C4  4283                     665              CLR.L   D3
000015C6                           666              *LOAD STACK WITH THIS OPMODE
000015C6  6100 2A24                667              BSR     PUSH_STACK
000015CA  163C 0045                668              MOVE.B  #'E',D3
000015CE  6100 2A1C                669              BSR     PUSH_STACK
000015D2  163C 004F                670              MOVE.B  #'O',D3
000015D6  6100 2A14                671              BSR     PUSH_STACK
000015DA  163C 0052                672              MOVE.B  #'R',D3
000015DE  6100 2A0C                673              BSR     PUSH_STACK
000015E2  163C 0049                674              MOVE.B  #'I',D3
000015E6  6100 2A04                675              BSR     PUSH_STACK
000015EA  163C 002E                676              MOVE.B  #'.',D3
000015EE  6100 29FC                677              BSR     PUSH_STACK
000015F2                           678              
000015F2                           679              *FIGURE OUT SIZE*
000015F2                           680              *00 = BYTE
000015F2                           681              *01 = WORD
000015F2                           682              *10 = LONG
000015F2                           683              * BITS 7&6
000015F2                           684              
000015F2                           685              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015F2  2205                     686              MOVE.L  D5,D1
000015F4  EC99                     687              ROR.L   #6,D1
000015F6  0281 00000003            688              ANDI.L  #$03,D1
000015FC  0C01 0000                689              CMPI.B  #%00,D1
00001600  6700 001E                690              BEQ     OP0000_EOR_B
00001604  0281 00000003            691              ANDI.L  #$03,D1
0000160A  0C01 0001                692              CMPI.B  #%01,D1
0000160E  6700 0028                693              BEQ     OP0000_EOR_W
00001612  0281 00000003            694              ANDI.L  #$03,D1
00001618  0C01 0002                695              CMPI.B  #%10,D1
0000161C  6700 0032                696              BEQ     OP0000_EOR_L
00001620                           697            
00001620                           698  OP0000_EOR_B
00001620                           699              
00001620  163C 0042                700              MOVE.B  #'B',D3
00001624  6100 29C6                701              BSR     PUSH_STACK
00001628                           702              
00001628                           703              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001628  0285 0000F03F            704              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000162E  0685 000001C0            705              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001634                           706  
00001634                           707              
00001634  6000 002E                708              BRA     OP0000_RETURN_EOR
00001638                           709  OP0000_EOR_W
00001638                           710              
00001638  163C 0057                711              MOVE.B  #'W',D3
0000163C  6100 29AE                712              BSR     PUSH_STACK
00001640                           713              
00001640                           714              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001640  0285 0000F03F            715              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001646  0685 000001C0            716              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000164C                           717  
0000164C                           718              
0000164C  6000 0016                719              BRA     OP0000_RETURN_EOR
00001650                           720  OP0000_EOR_L
00001650                           721              
00001650  163C 004C                722              MOVE.B  #'L',D3
00001654  6100 2996                723              BSR     PUSH_STACK
00001658                           724              
00001658                           725              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001658  0285 0000FE3F            726              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000165E  0685 000009C0            727              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001664                           728  
00001664                           729  
00001664                           730  OP0000_RETURN_EOR       
00001664  163C 0020                731              MOVE.B  #' ',D3
00001668  6100 2982                732              BSR     PUSH_STACK
0000166C  163C 0023                733              MOVE.B  #'#',D3
00001670  6100 297A                734              BSR     PUSH_STACK
00001674  6100 2508                735              BSR     GET_EA_EA_DEST
00001678  163C 002C                736              MOVE.B  #',',D3
0000167C  6100 296E                737              BSR     PUSH_STACK
00001680  6100 20CC                738              BSR     GET_EA_EA_SRC
00001684                           739              
00001684  4E75                     740              RTS
00001686                           741  
00001686                           742  *---------------------------------------------------------------------------*
00001686                           743  * OP_SUBI: decode SUBI.B/.W/.L
00001686                           744  *---------------------------------------------------------------------------* 
00001686                           745  OP_SUBI
00001686                           746             
00001686                           747   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001686  13FC 0000 00004976       748             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000168E  13FC 0080 00004977       749             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001696                           750             
00001696                           751             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001696  13FC 00B9 00004979       752             MOVE.B   #$B9,GET_DST_START_END
0000169E  13FC 0020 0000497A       753             MOVE.B   #$20,GET_SRC_START_END
000016A6                           754             
000016A6                           755              *CLEAR D3
000016A6  4283                     756              CLR.L   D3
000016A8                           757              *LOAD STACK WITH THIS OPMODE
000016A8  6100 2942                758              BSR     PUSH_STACK
000016AC  163C 0053                759              MOVE.B  #'S',D3
000016B0  6100 293A                760              BSR     PUSH_STACK
000016B4  163C 0055                761              MOVE.B  #'U',D3
000016B8  6100 2932                762              BSR     PUSH_STACK
000016BC  163C 0042                763              MOVE.B  #'B',D3
000016C0  6100 292A                764              BSR     PUSH_STACK
000016C4  163C 0049                765              MOVE.B  #'I',D3
000016C8  6100 2922                766              BSR     PUSH_STACK
000016CC  163C 002E                767              MOVE.B  #'.',D3
000016D0  6100 291A                768              BSR     PUSH_STACK
000016D4                           769              
000016D4                           770              *FIGURE OUT SIZE*
000016D4                           771              *00 = BYTE
000016D4                           772              *01 = WORD
000016D4                           773              *10 = LONG
000016D4                           774              * BITS 7&6
000016D4                           775              
000016D4                           776              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016D4  2205                     777              MOVE.L  D5,D1
000016D6  EC99                     778              ROR.L   #6,D1
000016D8  0281 00000003            779              ANDI.L  #$03,D1
000016DE  0C01 0000                780              CMPI.B  #%00,D1
000016E2  6700 001E                781              BEQ     OP0000_SUB_B
000016E6  0281 00000003            782              ANDI.L  #$03,D1
000016EC  0C01 0001                783              CMPI.B  #%01,D1
000016F0  6700 0028                784              BEQ     OP0000_SUB_W
000016F4  0281 00000003            785              ANDI.L  #$03,D1
000016FA  0C01 0002                786              CMPI.B  #%10,D1
000016FE  6700 0032                787              BEQ     OP0000_SUB_L
00001702                           788            
00001702                           789  OP0000_SUB_B
00001702                           790              
00001702  163C 0042                791              MOVE.B  #'B',D3
00001706  6100 28E4                792              BSR     PUSH_STACK
0000170A                           793              
0000170A                           794              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000170A  0285 0000F03F            795              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001710  0685 000001C0            796              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001716                           797  
00001716                           798              
00001716  6000 002E                799              BRA     OP0000_RETURN_SUBI
0000171A                           800  OP0000_SUB_W
0000171A                           801              
0000171A  163C 0057                802              MOVE.B  #'W',D3
0000171E  6100 28CC                803              BSR     PUSH_STACK
00001722                           804              
00001722                           805              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001722  0285 0000F03F            806              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001728  0685 000001C0            807              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000172E                           808  
0000172E                           809              
0000172E  6000 0016                810              BRA     OP0000_RETURN_SUBI
00001732                           811  OP0000_SUB_L
00001732                           812              
00001732  163C 004C                813              MOVE.B  #'L',D3
00001736  6100 28B4                814              BSR     PUSH_STACK
0000173A                           815              
0000173A                           816              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000173A  0285 0000F03F            817              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001740  0685 000003C0            818              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001746                           819                      
00001746                           820  OP0000_RETURN_SUBI            
00001746  163C 0020                821              MOVE.B  #' ',D3
0000174A  6100 28A0                822              BSR     PUSH_STACK
0000174E  163C 0023                823              MOVE.B  #'#',D3
00001752  6100 2898                824              BSR     PUSH_STACK
00001756  6100 2426                825              BSR     GET_EA_EA_DEST
0000175A  163C 002C                826              MOVE.B  #',',D3
0000175E  6100 288C                827              BSR     PUSH_STACK
00001762  6100 1FEA                828              BSR     GET_EA_EA_SRC
00001766                           829              
00001766  4E75                     830              RTS
00001768                           831  
00001768                           832              
00001768                           833  *---------------------------------------------------------------------------*
00001768                           834  * OP_DATA : unidentified opcode
00001768                           835  *---------------------------------------------------------------------------* 
00001768                           836  OP_DATA
00001768  4280                     837              CLR.L   D0                   
0000176A  4281                     838              CLR.L   D1     
0000176C  4284                     839              CLR.L   D4                    
0000176E  227C 00000000            840              MOVEA.L #0, A1             
00001774  4287                     841              CLR.L   D7
00001776  1E3C 0001                842              MOVE.B  #1,D7                   * error flag is true
0000177A                           843              
0000177A  43F9 000046C4            844              LEA     DISP_DATA,A1
00001780  103C 000E                845              MOVE.B  #14,D0
00001784  4E4F                     846              TRAP    #15
00001786                           847              
00001786  4EF9 0000178C            848              JMP     EA_DATA
0000178C                           849             
0000178C                           850             
0000178C                           851  *---------------------------------------------------------------------------*
0000178C                           852  * EA_DATA
0000178C                           853  *---------------------------------------------------------------------------*       
0000178C  43F9 00004615            854  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
00001792  2205                     855              MOVE.L  D5,D1           * transfer the processing data to D1
00001794  7404                     856              MOVE.L  #4,D2           * set to word size
00001796  4EB8 1236                857              JSR     HEX2ASCII       * prepare output in ascii
0000179A  43F9 00004937            858              LEA     DISP_HEX,A1     * display $ symbol
000017A0  103C 000E                859              MOVE.B  #14,D0      
000017A4  4E4F                     860              TRAP    #15
000017A6  43F9 00004615            861              LEA     TMPOUTPUT,A1    * display with a new line
000017AC  103C 000D                862              MOVE.B  #13,D0
000017B0  4E4F                     863              TRAP    #15
000017B2                           864  
000017B2  4E75                     865              RTS
000017B4                           866              
000017B4                           867  *---------------------------------------------------------------------------*
000017B4                           868  * OP_CMPI : decode CMPI and its size
000017B4                           869  *---------------------------------------------------------------------------*          
000017B4                           870  OP0000_CMPI
000017B4                           871  
000017B4                           872              
000017B4                           873   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017B4  13FC 0000 00004976       874             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017BC  13FC 0082 00004977       875             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017C4                           876             
000017C4                           877             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017C4  13FC 00B9 00004979       878             MOVE.B   #$B9,GET_DST_START_END
000017CC  13FC 0020 0000497A       879             MOVE.B   #$20,GET_SRC_START_END
000017D4                           880             
000017D4                           881              *CLEAR D3
000017D4  4283                     882              CLR.L   D3
000017D6                           883              *LOAD STACK WITH THIS OPMODE
000017D6  6100 2814                884              BSR     PUSH_STACK
000017DA  163C 0043                885              MOVE.B  #'C',D3
000017DE  6100 280C                886              BSR     PUSH_STACK
000017E2  163C 004D                887              MOVE.B  #'M',D3
000017E6  6100 2804                888              BSR     PUSH_STACK
000017EA  163C 0050                889              MOVE.B  #'P',D3
000017EE  6100 27FC                890              BSR     PUSH_STACK
000017F2  163C 0049                891              MOVE.B  #'I',D3
000017F6  6100 27F4                892              BSR     PUSH_STACK
000017FA  163C 002E                893              MOVE.B  #'.',D3
000017FE  6100 27EC                894              BSR     PUSH_STACK
00001802                           895              
00001802                           896              *FIGURE OUT SIZE*
00001802                           897              *00 = BYTE
00001802                           898              *01 = WORD
00001802                           899              *10 = LONG
00001802                           900              * BITS 7&6
00001802                           901              
00001802                           902              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001802  2205                     903              MOVE.L  D5,D1
00001804  EC99                     904              ROR.L   #6,D1
00001806  0281 00000003            905              ANDI.L  #$03,D1
0000180C  0C01 0000                906              CMPI.B  #%00,D1
00001810  6700 0018                907              BEQ     OP0000_CMPI_B
00001814  0C01 0001                908              CMPI.B  #%01,D1
00001818  6700 0038                909              BEQ     OP0000_CMPI_W
0000181C  0281 00000003            910              ANDI.L  #$03,D1
00001822  0C01 0002                911              CMPI.B  #%10,D1
00001826  6700 0052                912              BEQ     OP0000_CMPI_L
0000182A                           913  
0000182A                           914  OP0000_CMPI_B
0000182A  163C 0042                915              MOVE.B  #'B',D3
0000182E  6100 27BC                916              BSR     PUSH_STACK
00001832                           917  *GET DATA FROM ADDQ AND PRINT #0-8
00001832                           918              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001832  0285 0000F03F            919              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001838  0685 000001C0            920              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000183E  6100 233E                921              BSR     GET_EA_EA_DEST
00001842  163C 002C                922              MOVE.B  #',',D3
00001846  6100 27A4                923              BSR     PUSH_STACK
0000184A  6100 1F02                924              BSR     GET_EA_EA_SRC
0000184E  6000 004E                925              BRA     OP0000_RETURN_CMPI
00001852                           926  
00001852                           927  OP0000_CMPI_W
00001852  163C 0057                928              MOVE.B  #'W',D3
00001856  6100 2794                929              BSR     PUSH_STACK
0000185A                           930  *GET DATA FROM ADDQ AND PRINT #0-8
0000185A                           931              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000185A  0285 0000F03F            932              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001860  0685 000001C0            933              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001866  6100 2316                934              BSR     GET_EA_EA_DEST
0000186A  163C 002C                935              MOVE.B  #',',D3
0000186E  6100 277C                936              BSR     PUSH_STACK
00001872  6100 1EDA                937              BSR     GET_EA_EA_SRC
00001876  6000 0026                938              BRA     OP0000_RETURN_CMPI
0000187A                           939  
0000187A                           940  OP0000_CMPI_L
0000187A  163C 004C                941              MOVE.B  #'L',D3
0000187E  6100 276C                942              BSR     PUSH_STACK
00001882                           943              *GET DATA FROM ADDQ AND PRINT #0-8
00001882                           944              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001882  0285 0000F03F            945              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001888  0685 000003C0            946              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000188E  6100 22EE                947              BSR     GET_EA_EA_DEST
00001892  163C 002C                948              MOVE.B  #',',D3
00001896  6100 2754                949              BSR     PUSH_STACK
0000189A  6100 1EB2                950              BSR     GET_EA_EA_SRC
0000189E                           951              
0000189E                           952  OP0000_RETURN_CMPI
0000189E                           953  
0000189E                           954  
0000189E                           955              
0000189E  4E75                     956              RTS
000018A0                           957   
000018A0                           958  *---------------------------------------------------------------------------*
000018A0                           959  * OP_ORI : decode ORI and its size
000018A0                           960  *---------------------------------------------------------------------------* 
000018A0                           961  OP_ORI      
000018A0                           962           
000018A0                           963   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018A0  13FC 0000 00004976       964             MOVE.B   #$00,DEST_REGISTER_FORMAT
000018A8  13FC 0082 00004977       965             MOVE.B   #$82,SRC_REGISTER_FORMAT
000018B0                           966             
000018B0                           967             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000018B0  13FC 00B9 00004979       968             MOVE.B   #$B9,GET_DST_START_END
000018B8  13FC 0020 0000497A       969             MOVE.B   #$20,GET_SRC_START_END
000018C0                           970             
000018C0                           971              *CLEAR D3
000018C0  4283                     972              CLR.L   D3
000018C2                           973              *LOAD STACK WITH THIS OPMODE
000018C2  6100 2728                974              BSR     PUSH_STACK
000018C6  163C 004F                975              MOVE.B  #'O',D3
000018CA  6100 2720                976              BSR     PUSH_STACK
000018CE  163C 0052                977              MOVE.B  #'R',D3
000018D2  6100 2718                978              BSR     PUSH_STACK
000018D6  163C 0049                979              MOVE.B  #'I',D3
000018DA  6100 2710                980              BSR     PUSH_STACK
000018DE  163C 002E                981              MOVE.B  #'.',D3
000018E2  6100 2708                982              BSR     PUSH_STACK
000018E6                           983              
000018E6                           984              *FIGURE OUT SIZE*
000018E6                           985              *00 = BYTE
000018E6                           986              *01 = WORD
000018E6                           987              *10 = LONG
000018E6                           988              * BITS 7&6
000018E6                           989              
000018E6                           990              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018E6  2205                     991              MOVE.L  D5,D1
000018E8  EC99                     992              ROR.L   #6,D1
000018EA  0281 00000003            993              ANDI.L  #$03,D1
000018F0  0C01 0000                994              CMPI.B  #%00,D1
000018F4  6700 0018                995              BEQ     OP0000_ORI_B
000018F8  0C01 0001                996              CMPI.B  #%01,D1
000018FC  6700 0038                997              BEQ     OP0000_ORI_W
00001900  0281 00000003            998              ANDI.L  #$03,D1
00001906  0C01 0002                999              CMPI.B  #%10,D1
0000190A  6700 0052               1000              BEQ     OP0000_ORI_L
0000190E                          1001  
0000190E                          1002  OP0000_ORI_B
0000190E  163C 0042               1003              MOVE.B  #'B',D3
00001912  6100 26D8               1004              BSR     PUSH_STACK
00001916                          1005  *GET DATA FROM ADDQ AND PRINT #0-8
00001916                          1006              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001916  0285 0000F03F           1007              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000191C  0685 000001C0           1008              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001922  6100 225A               1009              BSR     GET_EA_EA_DEST
00001926  163C 002C               1010              MOVE.B  #',',D3
0000192A  6100 26C0               1011              BSR     PUSH_STACK
0000192E  6100 1E1E               1012              BSR     GET_EA_EA_SRC
00001932  6000 004E               1013              BRA     OP0000_RETURN_ORI
00001936                          1014  
00001936                          1015  OP0000_ORI_W
00001936  163C 0057               1016              MOVE.B  #'W',D3
0000193A  6100 26B0               1017              BSR     PUSH_STACK
0000193E                          1018  *GET DATA FROM ADDQ AND PRINT #0-8
0000193E                          1019              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000193E  0285 0000F03F           1020              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001944  0685 000001C0           1021              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000194A  6100 2232               1022              BSR     GET_EA_EA_DEST
0000194E  163C 002C               1023              MOVE.B  #',',D3
00001952  6100 2698               1024              BSR     PUSH_STACK
00001956  6100 1DF6               1025              BSR     GET_EA_EA_SRC
0000195A  6000 0026               1026              BRA     OP0000_RETURN_ORI
0000195E                          1027  
0000195E                          1028  OP0000_ORI_L
0000195E  163C 004C               1029              MOVE.B  #'L',D3
00001962  6100 2688               1030              BSR     PUSH_STACK
00001966                          1031              *GET DATA FROM ADDQ AND PRINT #0-8
00001966                          1032              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001966  0285 0000F03F           1033              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000196C  0685 000003C0           1034              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001972  6100 220A               1035              BSR     GET_EA_EA_DEST
00001976  163C 002C               1036              MOVE.B  #',',D3
0000197A  6100 2670               1037              BSR     PUSH_STACK
0000197E  6100 1DCE               1038              BSR     GET_EA_EA_SRC
00001982                          1039              
00001982                          1040  OP0000_RETURN_ORI
00001982                          1041  
00001982                          1042  
00001982                          1043              
00001982  4E75                    1044              RTS
00001984                          1045  
00001984                          1046          
00001984                          1047  *---------------------------------------------------------------------------*
00001984                          1048  * OP0001: MOVE.B
00001984                          1049  *---------------------------------------------------------------------------*
00001984                          1050  OP0001      
00001984  4EF9 0000198A           1051              JMP     OP_MOVE_B   * display MOVE.B
0000198A                          1052              
0000198A                          1053  *---------------------------------------------------------------------------*
0000198A                          1054  * OP_MOVE_B: display MOVE_B and proceed to EA
0000198A                          1055  *---------------------------------------------------------------------------*
0000198A                          1056  OP_MOVE_B                                                                       
0000198A                          1057             
0000198A                          1058             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000198A  13FC 0082 00004976      1059             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001992  13FC 0000 00004977      1060             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000199A                          1061             
0000199A                          1062             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000199A  13FC 00B9 00004979      1063             MOVE.B   #$B9,GET_DST_START_END
000019A2  13FC 0020 0000497A      1064             MOVE.B   #$20,GET_SRC_START_END
000019AA                          1065             
000019AA                          1066              *CLEAR D3
000019AA  4283                    1067              CLR.L   D3
000019AC                          1068              *LOAD STACK WITH THIS OPMODE
000019AC  6100 263E               1069              BSR     PUSH_STACK
000019B0  163C 004D               1070              MOVE.B  #'M',D3
000019B4  6100 2636               1071              BSR     PUSH_STACK
000019B8  163C 004F               1072              MOVE.B  #'O',D3
000019BC  6100 262E               1073              BSR     PUSH_STACK
000019C0  163C 0056               1074              MOVE.B  #'V',D3
000019C4  6100 2626               1075              BSR     PUSH_STACK
000019C8  163C 0045               1076              MOVE.B  #'E',D3
000019CC  6100 261E               1077              BSR     PUSH_STACK
000019D0  163C 002E               1078              MOVE.B  #'.',D3
000019D4  6100 2616               1079              BSR     PUSH_STACK
000019D8  163C 0042               1080              MOVE.B  #'B',D3
000019DC  6100 260E               1081              BSR     PUSH_STACK
000019E0                          1082              
000019E0  6100 1D6C               1083              BSR     GET_EA_EA_SRC
000019E4  163C 002C               1084              MOVE.B  #',',D3
000019E8  6100 2602               1085              BSR     PUSH_STACK
000019EC  6100 2190               1086              BSR     GET_EA_EA_DEST
000019F0                          1087              
000019F0  4E75                    1088              RTS
000019F2                          1089              
000019F2                          1090             
000019F2                          1091  *---------------------------------------------------------------------------*
000019F2                          1092  * OP0010: decode MOVE.L/MOVEA.L
000019F2                          1093  *---------------------------------------------------------------------------*
000019F2                          1094  OP0010      
000019F2  183C 0002               1095              MOVE.B  #2,D4
000019F6  4280                    1096              CLR.L   D0                     
000019F8  4281                    1097              CLR.L   D1                      
000019FA  227C 00000000           1098              MOVEA.L #0, A1                 
00001A00                          1099              
00001A00  2205                    1100              MOVE.L  D5,D1
00001A02  EA99                    1101              ROR.L   #5,D1
00001A04  0281 0000000E           1102              ANDI.L  #$E,D1
00001A0A  0C01 0002               1103              CMPI.B  #2,D1
00001A0E  6700 0070               1104              BEQ     OP_MOVEA_L
00001A12                          1105  
00001A12  4EF9 00001A18           1106              JMP     OP_MOVE_L
00001A18                          1107             
00001A18                          1108  
00001A18                          1109  *---------------------------------------------------------------------------*
00001A18                          1110  * OP_MOVE_L: display MOVE_L and proceed to EA
00001A18                          1111  *---------------------------------------------------------------------------*
00001A18                          1112  OP_MOVE_L   
00001A18                          1113             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A18  13FC 0082 00004976      1114             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A20  13FC 0000 00004977      1115             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A28                          1116             
00001A28                          1117             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A28  13FC 00B9 00004979      1118             MOVE.B   #$B9,GET_DST_START_END
00001A30  13FC 0020 0000497A      1119             MOVE.B   #$20,GET_SRC_START_END
00001A38                          1120             
00001A38                          1121              *CLEAR D3
00001A38  4283                    1122              CLR.L   D3
00001A3A                          1123              *LOAD STACK WITH THIS OPMODE
00001A3A  6100 25B0               1124              BSR     PUSH_STACK
00001A3E  163C 004D               1125              MOVE.B  #'M',D3
00001A42  6100 25A8               1126              BSR     PUSH_STACK
00001A46  163C 004F               1127              MOVE.B  #'O',D3
00001A4A  6100 25A0               1128              BSR     PUSH_STACK
00001A4E  163C 0056               1129              MOVE.B  #'V',D3
00001A52  6100 2598               1130              BSR     PUSH_STACK
00001A56  163C 0045               1131              MOVE.B  #'E',D3
00001A5A  6100 2590               1132              BSR     PUSH_STACK
00001A5E  163C 002E               1133              MOVE.B  #'.',D3
00001A62  6100 2588               1134              BSR     PUSH_STACK
00001A66  163C 004C               1135              MOVE.B  #'L',D3
00001A6A  6100 2580               1136              BSR     PUSH_STACK
00001A6E                          1137              
00001A6E  6100 1CDE               1138              BSR     GET_EA_EA_SRC
00001A72  163C 002C               1139              MOVE.B  #',',D3
00001A76  6100 2574               1140              BSR     PUSH_STACK
00001A7A  6100 2102               1141              BSR     GET_EA_EA_DEST
00001A7E                          1142              
00001A7E  4E75                    1143              RTS
00001A80                          1144  
00001A80                          1145  
00001A80                          1146  *---------------------------------------------------------------------------*
00001A80                          1147  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A80                          1148  *---------------------------------------------------------------------------*
00001A80                          1149  OP_MOVEA_L 
00001A80                          1150             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A80  13FC 00FD 00004976      1151             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A88  13FC 0000 00004977      1152             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A90                          1153             
00001A90                          1154             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A90  13FC 00B9 00004979      1155             MOVE.B   #$B9,GET_DST_START_END
00001A98  13FC 0020 0000497A      1156             MOVE.B   #$20,GET_SRC_START_END
00001AA0                          1157             
00001AA0                          1158              *CLEAR D3
00001AA0  4283                    1159              CLR.L   D3
00001AA2                          1160              *LOAD STACK WITH THIS OPMODE
00001AA2  6100 2548               1161              BSR     PUSH_STACK
00001AA6  163C 004D               1162              MOVE.B  #'M',D3
00001AAA  6100 2540               1163              BSR     PUSH_STACK
00001AAE  163C 004F               1164              MOVE.B  #'O',D3
00001AB2  6100 2538               1165              BSR     PUSH_STACK
00001AB6  163C 0056               1166              MOVE.B  #'V',D3
00001ABA  6100 2530               1167              BSR     PUSH_STACK
00001ABE  163C 0045               1168              MOVE.B  #'E',D3
00001AC2  6100 2528               1169              BSR     PUSH_STACK           
00001AC6  163C 0041               1170              MOVE.B  #'A',D3
00001ACA  6100 2520               1171              BSR     PUSH_STACK
00001ACE  163C 002E               1172              MOVE.B  #'.',D3
00001AD2  6100 2518               1173              BSR     PUSH_STACK
00001AD6  163C 004C               1174              MOVE.B  #'L',D3
00001ADA  6100 2510               1175              BSR     PUSH_STACK
00001ADE                          1176              
00001ADE  6100 1C6E               1177              BSR     GET_EA_EA_SRC
00001AE2  163C 002C               1178              MOVE.B  #',',D3
00001AE6  6100 2504               1179              BSR     PUSH_STACK
00001AEA  6100 2092               1180              BSR     GET_EA_EA_DEST
00001AEE                          1181              
00001AEE  4E75                    1182              RTS
00001AF0                          1183  
00001AF0                          1184              
00001AF0                          1185  *---------------------------------------------------------------------------*
00001AF0                          1186  * OP0011: decode MOVE.W/MOVEA.W
00001AF0                          1187  *---------------------------------------------------------------------------*
00001AF0                          1188  OP0011      
00001AF0  4280                    1189              CLR.L   D0                      
00001AF2  4281                    1190              CLR.L   D1  
00001AF4  4284                    1191              CLR.L   D4                   
00001AF6  227C 00000000           1192              MOVEA.L #0, A1 
00001AFC                          1193                
00001AFC  2205                    1194              MOVE.L  D5,D1
00001AFE  EC99                    1195              ROR.L   #6,D1
00001B00  0281 00000007           1196              ANDI.L  #$07,D1
00001B06  0C01 0001               1197              CMPI.B  #1,D1
00001B0A  6700 0070               1198              BEQ     OP_MOVEA_W
00001B0E                          1199              
00001B0E  4EF9 00001B14           1200              JMP     OP_MOVE_W
00001B14                          1201            
00001B14                          1202  *---------------------------------------------------------------------------*
00001B14                          1203  * OP_MOVE_W: display MOVE_W and proceed to EA
00001B14                          1204  *---------------------------------------------------------------------------*
00001B14                          1205  OP_MOVE_W   
00001B14                          1206             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B14  13FC 0082 00004976      1207             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001B1C  13FC 0000 00004977      1208             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B24                          1209             
00001B24                          1210             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B24  13FC 00B9 00004979      1211             MOVE.B   #$B9,GET_DST_START_END
00001B2C  13FC 0020 0000497A      1212             MOVE.B   #$20,GET_SRC_START_END
00001B34                          1213             
00001B34                          1214              *CLEAR D3
00001B34  4283                    1215              CLR.L   D3
00001B36                          1216              *LOAD STACK WITH THIS OPMODE
00001B36  6100 24B4               1217              BSR     PUSH_STACK
00001B3A  163C 004D               1218              MOVE.B  #'M',D3
00001B3E  6100 24AC               1219              BSR     PUSH_STACK
00001B42  163C 004F               1220              MOVE.B  #'O',D3
00001B46  6100 24A4               1221              BSR     PUSH_STACK
00001B4A  163C 0056               1222              MOVE.B  #'V',D3
00001B4E  6100 249C               1223              BSR     PUSH_STACK
00001B52  163C 0045               1224              MOVE.B  #'E',D3
00001B56  6100 2494               1225              BSR     PUSH_STACK
00001B5A  163C 002E               1226              MOVE.B  #'.',D3
00001B5E  6100 248C               1227              BSR     PUSH_STACK
00001B62  163C 0057               1228              MOVE.B  #'W',D3
00001B66  6100 2484               1229              BSR     PUSH_STACK
00001B6A                          1230              
00001B6A  6100 1BE2               1231              BSR     GET_EA_EA_SRC
00001B6E  163C 002C               1232              MOVE.B  #',',D3
00001B72  6100 2478               1233              BSR     PUSH_STACK
00001B76  6100 2006               1234              BSR     GET_EA_EA_DEST
00001B7A                          1235              
00001B7A  4E75                    1236              RTS
00001B7C                          1237  
00001B7C                          1238  *---------------------------------------------------------------------------*
00001B7C                          1239  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B7C                          1240  *---------------------------------------------------------------------------*
00001B7C                          1241  OP_MOVEA_W 
00001B7C                          1242             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B7C  13FC 00FD 00004976      1243             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B84  13FC 0000 00004977      1244             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B8C                          1245             
00001B8C                          1246             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B8C  13FC 00B9 00004979      1247             MOVE.B   #$B9,GET_DST_START_END
00001B94  13FC 0020 0000497A      1248             MOVE.B   #$20,GET_SRC_START_END
00001B9C                          1249             
00001B9C                          1250              *CLEAR D3
00001B9C  4283                    1251              CLR.L   D3
00001B9E                          1252              *LOAD STACK WITH THIS OPMODE
00001B9E  6100 244C               1253              BSR     PUSH_STACK
00001BA2  163C 004D               1254              MOVE.B  #'M',D3
00001BA6  6100 2444               1255              BSR     PUSH_STACK
00001BAA  163C 004F               1256              MOVE.B  #'O',D3
00001BAE  6100 243C               1257              BSR     PUSH_STACK
00001BB2  163C 0056               1258              MOVE.B  #'V',D3
00001BB6  6100 2434               1259              BSR     PUSH_STACK
00001BBA  163C 0045               1260              MOVE.B  #'E',D3
00001BBE  6100 242C               1261              BSR     PUSH_STACK           
00001BC2  163C 0041               1262              MOVE.B  #'A',D3
00001BC6  6100 2424               1263              BSR     PUSH_STACK
00001BCA  163C 002E               1264              MOVE.B  #'.',D3
00001BCE  6100 241C               1265              BSR     PUSH_STACK
00001BD2  163C 0057               1266              MOVE.B  #'W',D3
00001BD6  6100 2414               1267              BSR     PUSH_STACK
00001BDA                          1268              
00001BDA  6100 1B72               1269              BSR     GET_EA_EA_SRC
00001BDE  163C 002C               1270              MOVE.B  #',',D3
00001BE2  6100 2408               1271              BSR     PUSH_STACK
00001BE6  6100 1F96               1272              BSR     GET_EA_EA_DEST
00001BEA                          1273            
00001BEA  4E75                    1274              RTS
00001BEC                          1275  *---------------------------------------------------------------------------*
00001BEC                          1276  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BEC                          1277  *---------------------------------------------------------------------------*
00001BEC                          1278  OP0100
00001BEC  4280                    1279              CLR.L   D0                      
00001BEE  4281                    1280              CLR.L   D1  
00001BF0  4284                    1281              CLR.L   D4                      
00001BF2  227C 00000000           1282              MOVEA.L #0, A1                  
00001BF8  2205                    1283              MOVE.L  D5,D1  
00001BFA                          1284              
00001BFA                          1285              * check for RTS
00001BFA  0C41 4E75               1286              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BFE  6700 0228               1287              BEQ     OP_RTS
00001C02                          1288              
00001C02                          1289              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001C02  4281                    1290              CLR.L   D1 
00001C04  2205                    1291              MOVE.L  D5,D1  
00001C06  0241 0F00               1292              ANDI.W  #$0F00,D1
00001C0A  0C41 0E00               1293              CMPI.W  #$0E00,D1
00001C0E  6700 0204               1294              BEQ     OP_JSR
00001C12                          1295  
00001C12                          1296              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001C12  4281                    1297              CLR.L   D1 
00001C14  2205                    1298              MOVE.L  D5,D1  
00001C16  0241 0F00               1299              ANDI.W  #$0F00,D1
00001C1A  0C41 0400               1300              CMPI.W  #$0400,D1
00001C1E  6700 00E8               1301              BEQ     OP_NEG
00001C22                          1302              
00001C22                          1303              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001C22  4281                    1304              CLR.L   D1 
00001C24  2205                    1305              MOVE.L  D5,D1  
00001C26  0241 0F00               1306              ANDI.W  #$0F00,D1
00001C2A  0C41 0600               1307              CMPI.W  #$0600,D1
00001C2E  6700 015E               1308              BEQ     OP_NOT
00001C32                          1309              
00001C32                          1310              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C32  4281                    1311              CLR.L   D1 
00001C34  2205                    1312              MOVE.L  D5,D1  
00001C36  EC99                    1313              ROR.L   #6,D1
00001C38  0281 00000007           1314              ANDI.L  #7,D1
00001C3E  0C81 00000007           1315              CMPI.L  #7,D1
00001C44  6700 0054               1316              BEQ     OP_LEA
00001C48                          1317              
00001C48                          1318              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C48  4281                    1319              CLR.L   D1 
00001C4A  2205                    1320              MOVE.L  D5,D1  
00001C4C  EB59                    1321              ROL.W   #5,D1
00001C4E  0C01 0001               1322              CMPI.B  #1,D1
00001C52  6600 FB14               1323              BNE     OP_DATA
00001C56  E959                    1324              ROL.W   #4,D1
00001C58  0C01 0001               1325              CMPI.B  #1,D1
00001C5C  6600 FB0A               1326              BNE     OP_DATA
00001C60  E359                    1327              ROL.W   #1,D1
00001C62  0C01 0000               1328              CMPI.B  #0,D1
00001C66  6700 000E               1329              BEQ     OP_MOVEM_W
00001C6A  0C01 0001               1330              CMPI.B  #1,D1
00001C6E  6700 0018               1331              BEQ     OP_MOVEM_L
00001C72  4EF8 1768               1332              JMP     OP_DATA
00001C76                          1333  
00001C76                          1334  *---------------------------------------------------------------------------*
00001C76                          1335  * OP_MOVEM_W: display MOVEM_W
00001C76                          1336  *---------------------------------------------------------------------------*    
00001C76                          1337  OP_MOVEM_W  
00001C76  183C 0001               1338              MOVE.B  #1,D4
00001C7A  43F9 00004735           1339              LEA     DISP_MOVEM_W,A1
00001C80  103C 000E               1340              MOVE.B  #14,D0
00001C84  4E4F                    1341              TRAP    #15
00001C86  4E75                    1342              RTS
00001C88                          1343  
00001C88                          1344  *---------------------------------------------------------------------------*
00001C88                          1345  * OP_MOVEM_L: display MOVEM_L
00001C88                          1346  *---------------------------------------------------------------------------*
00001C88                          1347  OP_MOVEM_L  
00001C88  183C 0002               1348              MOVE.B  #2,D4
00001C8C  43F9 00004740           1349              LEA     DISP_MOVEM_L,A1
00001C92  103C 000E               1350              MOVE.B  #14,D0
00001C96  4E4F                    1351              TRAP    #15
00001C98  4E75                    1352              RTS
00001C9A                          1353     
00001C9A                          1354  *---------------------------------------------------------------------------*
00001C9A                          1355  * OP_LEA: decode and display LEA
00001C9A                          1356  *---------------------------------------------------------------------------*
00001C9A                          1357  OP_LEA      
00001C9A  4281                    1358               CLR.L   D1       
00001C9C  4284                    1359              CLR.L   D4                   
00001C9E  227C 00000000           1360              MOVEA.L #0, A1              
00001CA4  2205                    1361              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001CA6                          1362              *CLEAR D3
00001CA6  4283                    1363              CLR.L   D3
00001CA8                          1364  
00001CA8                          1365  OP_LEA_DN_EA_OR_EA_DN 
00001CA8                          1366              *LOAD STACK WITH THIS OPMODE
00001CA8  6100 2342               1367              BSR     PUSH_STACK
00001CAC  163C 004C               1368              MOVE.B  #'L',D3
00001CB0  6100 233A               1369              BSR     PUSH_STACK
00001CB4  163C 0045               1370              MOVE.B  #'E',D3
00001CB8  6100 2332               1371              BSR     PUSH_STACK
00001CBC  163C 0041               1372              MOVE.B  #'A',D3
00001CC0  6100 232A               1373              BSR     PUSH_STACK
00001CC4  2205                    1374              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CC6                          1375          
00001CC6                          1376  
00001CC6                          1377  OP_PRINT_L_LEA
00001CC6                          1378                          
00001CC6                          1379              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CC6  13FC 0000 00004976      1380              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CCE  13FC 009B 00004977      1381              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CD6                          1382             
00001CD6                          1383              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CD6  13FC 00B9 00004979      1384              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CDE  13FC 0020 0000497A      1385              MOVE.B   #$20,GET_SRC_START_END
00001CE6                          1386  
00001CE6                          1387              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CE6  0285 0000FE3F           1388              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CEC  0685 00000040           1389              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CF2                          1390  
00001CF2  6100 1A5A               1391              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CF6  163C 002C               1392              MOVE.B  #',',D3
00001CFA  6100 22F0               1393              BSR     PUSH_STACK           
00001CFE  6100 1E7E               1394              BSR     GET_EA_EA_DEST       *GETS Dn    
00001D02                          1395  
00001D02                          1396              
00001D02  6000 0002               1397              BRA     OP_LEA_RETURN
00001D06                          1398              
00001D06                          1399  OP_LEA_RETURN
00001D06  4E75                    1400              RTS
00001D08                          1401              
00001D08                          1402  
00001D08                          1403  
00001D08                          1404  *---------------------------------------------------------------------------*
00001D08                          1405  * OP_NEG: decode and display NEG 
00001D08                          1406  *---------------------------------------------------------------------------*
00001D08                          1407  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001D08  4281                    1408              CLR.L   D1
00001D0A  4284                    1409              CLR.L   D4
00001D0C  2205                    1410              MOVE.L  D5,D1
00001D0E                          1411              
00001D0E                          1412              *CLEAR D3
00001D0E  4283                    1413              CLR.L   D3
00001D10                          1414              *LOAD STACK WITH THIS OPMODE
00001D10  6100 22DA               1415              BSR     PUSH_STACK
00001D14  163C 004E               1416              MOVE.B  #'N',D3
00001D18  6100 22D2               1417              BSR     PUSH_STACK
00001D1C  163C 0045               1418              MOVE.B  #'E',D3
00001D20  6100 22CA               1419              BSR     PUSH_STACK
00001D24  163C 0047               1420              MOVE.B  #'G',D3
00001D28  6100 22C2               1421              BSR     PUSH_STACK
00001D2C  163C 002E               1422              MOVE.B  #'.',D3
00001D30  6100 22BA               1423              BSR     PUSH_STACK
00001D34                          1424              
00001D34                          1425              
00001D34  EC99                    1426              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D36  0281 00000007           1427              ANDI.L  #$07,D1
00001D3C                          1428              
00001D3C  0C01 0000               1429              CMPI.B  #0,D1
00001D40  6700 0012               1430              BEQ     OP_NEG_B    * size is byte
00001D44  0C01 0001               1431              CMPI.B  #1,D1
00001D48  6700 0016               1432              BEQ     OP_NEG_W    * size is word
00001D4C  0C01 0002               1433              CMPI.B  #2,D1
00001D50  6700 001A               1434              BEQ     OP_NEG_L    * size is long
00001D54                          1435                         
00001D54                          1436  
00001D54                          1437  OP_NEG_B    * size is byte   
00001D54  163C 0042               1438              MOVE.B  #'B',D3
00001D58  6100 2292               1439              BSR     PUSH_STACK
00001D5C  6000 001A               1440              BRA     OP_NEG_PRINT_EA
00001D60                          1441  
00001D60                          1442              
00001D60                          1443  OP_NEG_W    * size is word
00001D60  163C 0057               1444              MOVE.B  #'W',D3
00001D64  6100 2286               1445              BSR     PUSH_STACK
00001D68  6000 000E               1446              BRA     OP_NEG_PRINT_EA
00001D6C                          1447  
00001D6C                          1448              
00001D6C                          1449  OP_NEG_L    * size is long
00001D6C  163C 004C               1450              MOVE.B  #'L',D3
00001D70  6100 227A               1451              BSR     PUSH_STACK
00001D74  6000 0002               1452              BRA     OP_NEG_PRINT_EA
00001D78                          1453  
00001D78                          1454  
00001D78                          1455  OP_NEG_PRINT_EA
00001D78                          1456   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D78  13FC 0082 00004977      1457             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D80                          1458             
00001D80                          1459             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D80  13FC 0020 0000497A      1460             MOVE.B   #$20,GET_SRC_START_END
00001D88                          1461                         
00001D88                          1462  
00001D88  6100 19C4               1463              BSR     GET_EA_EA_SRC
00001D8C                          1464              
00001D8C  4E75                    1465              RTS
00001D8E                          1466  
00001D8E                          1467  *---------------------------------------------------------------------------*
00001D8E                          1468  * OP_NOT: decode and display NOT 
00001D8E                          1469  *---------------------------------------------------------------------------*
00001D8E                          1470  OP_NOT
00001D8E  4281                    1471              CLR.L   D1
00001D90  4284                    1472              CLR.L   D4
00001D92  2205                    1473              MOVE.L  D5,D1
00001D94                          1474              
00001D94                          1475              *CLEAR D3
00001D94  4283                    1476              CLR.L   D3
00001D96                          1477              *LOAD STACK WITH THIS OPMODE
00001D96  6100 2254               1478              BSR     PUSH_STACK
00001D9A  163C 004E               1479              MOVE.B  #'N',D3
00001D9E  6100 224C               1480              BSR     PUSH_STACK
00001DA2  163C 004F               1481              MOVE.B  #'O',D3
00001DA6  6100 2244               1482              BSR     PUSH_STACK
00001DAA  163C 0054               1483              MOVE.B  #'T',D3
00001DAE  6100 223C               1484              BSR     PUSH_STACK
00001DB2  163C 002E               1485              MOVE.B  #'.',D3
00001DB6  6100 2234               1486              BSR     PUSH_STACK
00001DBA                          1487              
00001DBA                          1488              
00001DBA  EC99                    1489              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DBC  0281 00000007           1490              ANDI.L  #$07,D1
00001DC2                          1491              
00001DC2  0C01 0000               1492              CMPI.B  #0,D1
00001DC6  6700 0012               1493              BEQ     OP_NOT_B    * size is byte
00001DCA  0C01 0001               1494              CMPI.B  #1,D1
00001DCE  6700 0016               1495              BEQ     OP_NOT_W    * size is word
00001DD2  0C01 0002               1496              CMPI.B  #2,D1
00001DD6  6700 001A               1497              BEQ     OP_NOT_L    * size is long
00001DDA                          1498                         
00001DDA                          1499  
00001DDA                          1500  OP_NOT_B    * size is byte   
00001DDA  163C 0042               1501              MOVE.B  #'B',D3
00001DDE  6100 220C               1502              BSR     PUSH_STACK
00001DE2  6000 001A               1503              BRA     OP_NOT_PRINT_EA
00001DE6                          1504  
00001DE6                          1505              
00001DE6                          1506  OP_NOT_W    * size is word
00001DE6  163C 0057               1507              MOVE.B  #'W',D3
00001DEA  6100 2200               1508              BSR     PUSH_STACK
00001DEE  6000 000E               1509              BRA     OP_NOT_PRINT_EA
00001DF2                          1510  
00001DF2                          1511              
00001DF2                          1512  OP_NOT_L    * size is long
00001DF2  163C 004C               1513              MOVE.B  #'L',D3
00001DF6  6100 21F4               1514              BSR     PUSH_STACK
00001DFA  6000 0002               1515              BRA     OP_NOT_PRINT_EA
00001DFE                          1516  
00001DFE                          1517  
00001DFE                          1518  OP_NOT_PRINT_EA
00001DFE                          1519   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DFE  13FC 0082 00004977      1520             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001E06                          1521             
00001E06                          1522             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E06  13FC 0020 0000497A      1523             MOVE.B   #$20,GET_SRC_START_END
00001E0E  6100 193E               1524              BSR     GET_EA_EA_SRC
00001E12                          1525              
00001E12  4E75                    1526              RTS
00001E14                          1527  
00001E14                          1528  
00001E14                          1529  *---------------------------------------------------------------------------*
00001E14                          1530  * OP_JSR: display JSR     
00001E14                          1531  *---------------------------------------------------------------------------*
00001E14  43F9 000046F1           1532  OP_JSR      LEA     DISP_JSR,A1
00001E1A  103C 000E               1533              MOVE.B  #14,D0
00001E1E  4E4F                    1534              TRAP    #15
00001E20  4EB9 0000329E           1535              JSR     EA_NOSRC
00001E26                          1536  
00001E26  4E75                    1537              RTS
00001E28                          1538  
00001E28                          1539  *---------------------------------------------------------------------------*
00001E28                          1540  * OP_RTS: display RTS     
00001E28                          1541  *---------------------------------------------------------------------------* 
00001E28                          1542  OP_RTS      
00001E28  163C 0052               1543              MOVE.B #'R',D3
00001E2C  6100 21BE               1544              BSR     PUSH_STACK
00001E30  163C 0054               1545              MOVE.B #'T',D3
00001E34  6100 21B6               1546              BSR     PUSH_STACK
00001E38  163C 0053               1547              MOVE.B #'S',D3
00001E3C  6100 21AE               1548              BSR     PUSH_STACK
00001E40  4E75                    1549              RTS
00001E42                          1550  
00001E42                          1551  *---------------------------------------------------------------------------*
00001E42                          1552  * OP0101: decode ADDQ
00001E42                          1553  *---------------------------------------------------------------------------* 
00001E42                          1554  OP0101      
00001E42                          1555             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E42  13FC 0082 00004976      1556             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E4A  13FC 0080 00004977      1557             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E52                          1558             
00001E52                          1559             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E52  13FC 00B9 00004979      1560             MOVE.B   #$B9,GET_DST_START_END
00001E5A  13FC 0020 0000497A      1561             MOVE.B   #$20,GET_SRC_START_END
00001E62                          1562             
00001E62                          1563              *CLEAR D3
00001E62  4283                    1564              CLR.L   D3
00001E64                          1565              *LOAD STACK WITH THIS OPMODE
00001E64  6100 2186               1566              BSR     PUSH_STACK
00001E68  163C 0041               1567              MOVE.B  #'A',D3
00001E6C  6100 217E               1568              BSR     PUSH_STACK
00001E70  163C 0044               1569              MOVE.B  #'D',D3
00001E74  6100 2176               1570              BSR     PUSH_STACK
00001E78  163C 0044               1571              MOVE.B  #'D',D3
00001E7C  6100 216E               1572              BSR     PUSH_STACK
00001E80  163C 0051               1573              MOVE.B  #'Q',D3
00001E84  6100 2166               1574              BSR     PUSH_STACK
00001E88  163C 002E               1575              MOVE.B  #'.',D3
00001E8C  6100 215E               1576              BSR     PUSH_STACK
00001E90                          1577              
00001E90                          1578              *FIGURE OUT SIZE*
00001E90                          1579              *00 = BYTE
00001E90                          1580              *01 = WORD
00001E90                          1581              *10 = LONG
00001E90                          1582              * BITS 7&6
00001E90                          1583              
00001E90                          1584              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E90  2205                    1585              MOVE.L  D5,D1
00001E92  EC99                    1586              ROR.L   #6,D1
00001E94  0281 00000003           1587              ANDI.L  #$03,D1
00001E9A  0C01 0000               1588              CMPI.B  #%00,D1
00001E9E  6700 001E               1589              BEQ     OP0101_ADDQ_B
00001EA2  0281 00000003           1590              ANDI.L  #$03,D1
00001EA8  0C01 0001               1591              CMPI.B  #%01,D1
00001EAC  6700 001C               1592              BEQ     OP0101_ADDQ_W
00001EB0  0281 00000003           1593              ANDI.L  #$03,D1
00001EB6  0C01 0002               1594              CMPI.B  #%10,D1
00001EBA  6700 001A               1595              BEQ     OP0101_ADDQ_L
00001EBE                          1596            
00001EBE                          1597  OP0101_ADDQ_B
00001EBE                          1598              
00001EBE  163C 0042               1599              MOVE.B  #'B',D3
00001EC2  6100 2128               1600              BSR     PUSH_STACK
00001EC6  6000 0016               1601              BRA     OP0101_RETURN
00001ECA                          1602  OP0101_ADDQ_W
00001ECA                          1603              
00001ECA  163C 0057               1604              MOVE.B  #'W',D3
00001ECE  6100 211C               1605              BSR     PUSH_STACK
00001ED2  6000 000A               1606              BRA     OP0101_RETURN
00001ED6                          1607  OP0101_ADDQ_L
00001ED6                          1608              
00001ED6  163C 004C               1609              MOVE.B  #'L',D3
00001EDA  6100 2110               1610              BSR     PUSH_STACK
00001EDE                          1611  OP0101_RETURN            
00001EDE                          1612  
00001EDE                          1613              
00001EDE                          1614  *GET DATA FROM ADDQ AND PRINT #0-8
00001EDE  163C 0020               1615              MOVE.B  #' ',D3
00001EE2  6100 2108               1616              BSR     PUSH_STACK
00001EE6  163C 0023               1617              MOVE.B  #'#',D3
00001EEA  6100 2100               1618              BSR     PUSH_STACK 
00001EEE                          1619  
00001EEE                          1620                       
00001EEE                          1621              *GET DATA #   
00001EEE  2205                    1622              MOVE.L  D5,D1
00001EF0  EC99                    1623              ROR.L   #6,D1            
00001EF2  E699                    1624              ROR.L   #3,D1
00001EF4  0281 00000007           1625              ANDI.L  #$07,D1
00001EFA                          1626              
00001EFA  0C01 0000               1627              CMPI.B  #%000,D1
00001EFE  6700 009A               1628              BEQ     OP0101_ADDQ_B_8
00001F02  0C01 0001               1629              CMPI.B  #%001,D1
00001F06  6700 003E               1630              BEQ     OP0101_ADDQ_B_1
00001F0A  0C01 0002               1631              CMPI.B  #%010,D1
00001F0E  6700 0042               1632              BEQ     OP0101_ADDQ_B_2
00001F12  0C01 0003               1633              CMPI.B  #%011,D1
00001F16  6700 0046               1634              BEQ     OP0101_ADDQ_B_3
00001F1A  0C01 0004               1635              CMPI.B  #%100,D1
00001F1E  6700 004A               1636              BEQ     OP0101_ADDQ_B_4
00001F22  0C01 0005               1637              CMPI.B  #%101,D1
00001F26  6700 004E               1638              BEQ     OP0101_ADDQ_B_5
00001F2A  0C01 0006               1639              CMPI.B  #%110,D1
00001F2E  6700 0052               1640              BEQ     OP0101_ADDQ_B_6
00001F32  0C01 0007               1641              CMPI.B  #%111,D1
00001F36  6700 0056               1642              BEQ     OP0101_ADDQ_B_7
00001F3A                          1643              
00001F3A                          1644  OP0101_ADDQ_B_0
00001F3A  163C 0030               1645              MOVE.B  #'0',D3
00001F3E  6100 20AC               1646              BSR     PUSH_STACK
00001F42  6000 005E               1647              BRA     OP0101_RETURN2            
00001F46                          1648  OP0101_ADDQ_B_1
00001F46  163C 0031               1649              MOVE.B  #'1',D3
00001F4A  6100 20A0               1650              BSR     PUSH_STACK
00001F4E  6000 0052               1651              BRA     OP0101_RETURN2            
00001F52                          1652  OP0101_ADDQ_B_2
00001F52  163C 0032               1653              MOVE.B  #'2',D3
00001F56  6100 2094               1654              BSR     PUSH_STACK
00001F5A  6000 0046               1655              BRA     OP0101_RETURN2            
00001F5E                          1656  OP0101_ADDQ_B_3
00001F5E  163C 0033               1657              MOVE.B  #'3',D3
00001F62  6100 2088               1658              BSR     PUSH_STACK
00001F66  6000 003A               1659              BRA     OP0101_RETURN2            
00001F6A                          1660  OP0101_ADDQ_B_4
00001F6A  163C 0034               1661              MOVE.B  #'4',D3
00001F6E  6100 207C               1662              BSR     PUSH_STACK
00001F72  6000 002E               1663              BRA     OP0101_RETURN2            
00001F76                          1664  OP0101_ADDQ_B_5
00001F76  163C 0035               1665              MOVE.B  #'5',D3
00001F7A  6100 2070               1666              BSR     PUSH_STACK
00001F7E  6000 0022               1667              BRA     OP0101_RETURN2
00001F82                          1668  OP0101_ADDQ_B_6
00001F82  163C 0036               1669              MOVE.B  #'6',D3
00001F86  6100 2064               1670              BSR     PUSH_STACK
00001F8A  6000 0016               1671              BRA     OP0101_RETURN2
00001F8E                          1672  OP0101_ADDQ_B_7
00001F8E  163C 0037               1673              MOVE.B  #'7',D3
00001F92  6100 2058               1674              BSR     PUSH_STACK
00001F96  6000 000A               1675              BRA     OP0101_RETURN2
00001F9A                          1676  
00001F9A                          1677  OP0101_ADDQ_B_8
00001F9A  163C 0038               1678              MOVE.B  #'8',D3
00001F9E  6100 204C               1679              BSR     PUSH_STACK
00001FA2                          1680              
00001FA2                          1681  OP0101_RETURN2            
00001FA2  163C 002C               1682              MOVE.B  #',',D3
00001FA6  6100 2044               1683              BSR     PUSH_STACK
00001FAA  6100 17A2               1684              BSR     GET_EA_EA_SRC
00001FAE                          1685              
00001FAE  4E75                    1686              RTS
00001FB0                          1687  
00001FB0                          1688  
00001FB0                          1689              
00001FB0                          1690  *---------------------------------------------------------------------------*
00001FB0                          1691  * OP_ADDQ: display ADDQ
00001FB0                          1692  *---------------------------------------------------------------------------*              
00001FB0                          1693  OP_ADDQ_B    * size is byte   
00001FB0  183C 0000               1694              MOVE.B  #0,D4 
00001FB4  43F9 0000474B           1695              LEA     DISP_ADDQ_B,A1
00001FBA  103C 000E               1696              MOVE.B  #14,D0
00001FBE  4E4F                    1697              TRAP    #15
00001FC0  4E75                    1698              RTS
00001FC2                          1699              
00001FC2                          1700  OP_ADDQ_W    * size is word
00001FC2  183C 0001               1701              MOVE.B  #1,D4
00001FC6  43F9 00004755           1702              LEA     DISP_ADDQ_W,A1
00001FCC  103C 000E               1703              MOVE.B  #14,D0
00001FD0  4E4F                    1704              TRAP    #15
00001FD2  4E75                    1705              RTS
00001FD4                          1706              
00001FD4                          1707  OP_ADDQ_L    * size is long
00001FD4  183C 0002               1708              MOVE.B  #2,D4
00001FD8  43F9 0000475F           1709              LEA     DISP_ADDQ_L,A1
00001FDE  103C 000E               1710              MOVE.B  #14,D0
00001FE2  4E4F                    1711              TRAP    #15
00001FE4  4E75                    1712              RTS
00001FE6                          1713  
00001FE6                          1714  *---------------------------------------------------------------------------*
00001FE6                          1715  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FE6                          1716  *---------------------------------------------------------------------------*              
00001FE6  4280                    1717  OP0110      CLR.L   D0                  
00001FE8  4281                    1718              CLR.L   D1   
00001FEA  4284                    1719              CLR.L   D4                 
00001FEC  227C 00000000           1720              MOVEA.L #0,A1
00001FF2  2205                    1721              MOVE.L  D5, D1                
00001FF4  0281 000000FF           1722              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FFA  2205                    1723              MOVE.L  D5,D1                  
00001FFC  0281 00000F00           1724              ANDI.L  #$0F00,D1
00002002                          1725                 
00002002  0C41 0000               1726              CMPI.W  #$0000,D1               * Check for BRA
00002006  6700 0098               1727              BEQ     OP_BRA                  
0000200A                          1728                          
0000200A  0C41 0D00               1729              CMPI.W  #$0D00,D1               * Check for BLT
0000200E  6700 00B6               1730              BEQ     OP_BLT      
00002012                          1731  
00002012  0C41 0700               1732              CMPI.W  #$0700,D1               * Check for BEQ
00002016  6700 0062               1733              BEQ     OP_BEQ      
0000201A                          1734  
0000201A  0C41 0600               1735              CMPI.W  #$0600,D1               * Check for BNE
0000201E  6700 0034               1736              BEQ     OP_BNE  
00002022                          1737              
00002022  0C41 0200               1738              CMPI.W  #$0200,D1               * Check for BHI
00002026  6700 0006               1739              BEQ     OP_BHI
0000202A                          1740  
0000202A  4EF8 1768               1741              JMP     OP_DATA
0000202E                          1742              
0000202E  163C 0042               1743  OP_BHI      MOVE.B  #'B',D3
00002032  6100 1FB8               1744              BSR     PUSH_STACK
00002036  163C 0048               1745              MOVE.B  #'H',D3
0000203A  6100 1FB0               1746              BSR     PUSH_STACK
0000203E  163C 0049               1747              MOVE.B  #'I',D3
00002042  6100 1FA8               1748              BSR     PUSH_STACK
00002046  163C 0009               1749              MOVE.B  #$9,D3
0000204A  6100 1FA0               1750              BSR     PUSH_STACK
0000204E  6100 201A               1751              BSR     GET_DISPLACEMENT_ADDRESS
00002052  4E75                    1752              RTS
00002054                          1753  
00002054  163C 0042               1754  OP_BNE      MOVE.B  #'B',D3
00002058  6100 1F92               1755              BSR     PUSH_STACK
0000205C  163C 004E               1756              MOVE.B  #'N',D3
00002060  6100 1F8A               1757              BSR     PUSH_STACK
00002064  163C 0045               1758              MOVE.B  #'E',D3
00002068  6100 1F82               1759              BSR     PUSH_STACK
0000206C  163C 0009               1760              MOVE.B  #$9,D3
00002070  6100 1F7A               1761              BSR     PUSH_STACK
00002074  6100 1FF4               1762              BSR     GET_DISPLACEMENT_ADDRESS
00002078  4E75                    1763              RTS
0000207A                          1764  
0000207A  163C 0042               1765  OP_BEQ      MOVE.B  #'B',D3
0000207E  6100 1F6C               1766              BSR     PUSH_STACK
00002082  163C 0045               1767              MOVE.B  #'E',D3
00002086  6100 1F64               1768              BSR     PUSH_STACK
0000208A  163C 0051               1769              MOVE.B  #'Q',D3
0000208E  6100 1F5C               1770              BSR     PUSH_STACK
00002092  163C 0009               1771              MOVE.B  #$9,D3
00002096  6100 1F54               1772              BSR     PUSH_STACK
0000209A  6100 1FCE               1773              BSR     GET_DISPLACEMENT_ADDRESS
0000209E  4E75                    1774              RTS          
000020A0                          1775                          
000020A0                          1776  OP_BRA      
000020A0  163C 0042               1777              MOVE.B  #'B',D3
000020A4  6100 1F46               1778              BSR     PUSH_STACK
000020A8  163C 0052               1779              MOVE.B  #'R',D3
000020AC  6100 1F3E               1780              BSR     PUSH_STACK
000020B0  163C 0041               1781              MOVE.B  #'A',D3
000020B4  6100 1F36               1782              BSR     PUSH_STACK
000020B8  163C 0009               1783              MOVE.B  #$9,D3
000020BC  6100 1F2E               1784              BSR     PUSH_STACK
000020C0  6100 1FA8               1785              BSR     GET_DISPLACEMENT_ADDRESS
000020C4                          1786              
000020C4  4E75                    1787              RTS
000020C6                          1788              
000020C6  163C 0042               1789  OP_BLT      MOVE.B  #'B',D3
000020CA  6100 1F20               1790              BSR     PUSH_STACK
000020CE  163C 004C               1791              MOVE.B  #'L',D3
000020D2  6100 1F18               1792              BSR     PUSH_STACK
000020D6  163C 0054               1793              MOVE.B  #'T',D3
000020DA  6100 1F10               1794              BSR     PUSH_STACK
000020DE  163C 0009               1795              MOVE.B  #$9,D3
000020E2  6100 1F08               1796              BSR     PUSH_STACK
000020E6  6100 1F82               1797              BSR     GET_DISPLACEMENT_ADDRESS
000020EA  4E75                    1798              RTS
000020EC                          1799     
000020EC                          1800  *---------------------------------------------------------------------------*
000020EC                          1801  * OP0111 : MOVEQ not required
000020EC                          1802  *---------------------------------------------------------------------------*           
000020EC  4EF8 1768               1803  OP0111      JMP     OP_DATA
000020F0                          1804             
000020F0                          1805  *---------------------------------------------------------------------------*
000020F0                          1806  * OP1000 : decode DIVS
000020F0                          1807  *---------------------------------------------------------------------------*           
000020F0                          1808  OP1000                           
000020F0  4281                    1809              CLR.L   D1       
000020F2  4284                    1810              CLR.L   D4                   
000020F4  227C 00000000           1811              MOVEA.L #0, A1              
000020FA  2205                    1812              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020FC                          1813              *CLEAR D3
000020FC  4283                    1814              CLR.L   D3
000020FE                          1815  
000020FE                          1816  OP1000_DIVS_DN_EA_OR_EA_DN 
000020FE                          1817              *LOAD STACK WITH THIS OPMODE
000020FE  6100 1EEC               1818              BSR     PUSH_STACK
00002102  163C 0044               1819              MOVE.B  #'D',D3
00002106  6100 1EE4               1820              BSR     PUSH_STACK
0000210A  163C 0049               1821              MOVE.B  #'I',D3
0000210E  6100 1EDC               1822              BSR     PUSH_STACK
00002112  163C 0056               1823              MOVE.B  #'V',D3
00002116  6100 1ED4               1824              BSR     PUSH_STACK
0000211A  163C 0053               1825              MOVE.B  #'S',D3
0000211E  6100 1ECC               1826              BSR     PUSH_STACK
00002122  163C 002E               1827              MOVE.B  #'.',D3
00002126  6100 1EC4               1828              BSR     PUSH_STACK
0000212A                          1829              
0000212A  2205                    1830              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000212C                          1831              
0000212C                          1832  OP1000_EA_DN_DIVS
0000212C                          1833              *BITS (7 TO 6) 
0000212C                          1834              *00 = .B
0000212C                          1835              *01 = .W
0000212C                          1836              *10 = .L 
0000212C  2205                    1837              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000212E  EC99                    1838              ROR.L   #6,D1
00002130  0281 00000003           1839              ANDI.L  #$03,D1
00002136  0C81 00000003           1840              CMPI.L  #%11,D1 *EQUALS .W
0000213C  6700 0014               1841              BEQ     OP1000_PRINT_W_DIVS
00002140  0C81 00000000           1842              CMPI.L  #%00,D1 *EQUALS .L
00002146  6700 0052               1843              BEQ     OP1000_PRINT_L_DIVS
0000214A                          1844              
0000214A  183C 0001               1845              MOVE.B  #1,D4               *ERROR READ
0000214E  6000 0092               1846              BRA     OP1000_DIVS_RETURN
00002152                          1847  OP1000_PRINT_W_DIVS
00002152  163C 0057               1848              MOVE.B  #'W',D3
00002156  6100 1E94               1849              BSR     PUSH_STACK
0000215A                          1850  
0000215A                          1851              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000215A  13FC 0000 00004976      1852              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002162  13FC 0000 00004977      1853              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000216A                          1854             
0000216A                          1855              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000216A  13FC 00B9 00004979      1856              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002172  13FC 0020 0000497A      1857              MOVE.B   #$20,GET_SRC_START_END
0000217A                          1858  
0000217A                          1859             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000217A  0285 0000FE3F           1860              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002180  0685 00000000           1861              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002186                          1862  
00002186                          1863              
00002186  6100 15C6               1864              BSR     GET_EA_EA_SRC      *GETS <ea>
0000218A  163C 002C               1865              MOVE.B  #',',D3
0000218E  6100 1E5C               1866              BSR     PUSH_STACK
00002192  6100 19EA               1867              BSR     GET_EA_EA_DEST       *GETS Dn    
00002196                          1868              
00002196  6000 004A               1869              BRA     OP1000_DIVS_RETURN
0000219A                          1870  OP1000_PRINT_L_DIVS
0000219A  163C 004C               1871              MOVE.B  #'L',D3
0000219E  6100 1E4C               1872              BSR     PUSH_STACK
000021A2                          1873              
000021A2                          1874              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000021A2  13FC 0000 00004976      1875              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000021AA  13FC 0000 00004977      1876              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021B2                          1877             
000021B2                          1878              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021B2  13FC 00B9 00004979      1879              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021BA  13FC 0020 0000497A      1880              MOVE.B   #$20,GET_SRC_START_END
000021C2                          1881  
000021C2                          1882              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021C2  0285 0000FE3F           1883              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021C8  0685 00000000           1884              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021CE                          1885  
000021CE                          1886                     
000021CE  6100 157E               1887              BSR     GET_EA_EA_SRC      *GETS <ea>
000021D2  163C 002C               1888              MOVE.B  #',',D3
000021D6  6100 1E14               1889              BSR     PUSH_STACK                  
000021DA  6100 19A2               1890              BSR     GET_EA_EA_DEST       *GETS Dn    
000021DE                          1891  
000021DE                          1892              
000021DE  6000 0002               1893              BRA     OP1000_DIVS_RETURN
000021E2                          1894              
000021E2                          1895  OP1000_DIVS_RETURN
000021E2  4E75                    1896              RTS
000021E4                          1897              
000021E4                          1898  
000021E4                          1899  
000021E4                          1900  *---------------------------------------------------------------------------*
000021E4                          1901  * OP_DIVS: display DIVS and proceed to EA
000021E4                          1902  *---------------------------------------------------------------------------*  
000021E4  43F9 00004769           1903  OP_DIVS     LEA     DISP_DIVS,A1
000021EA  103C 000E               1904              MOVE.B  #14,D0
000021EE  4E4F                    1905              TRAP    #15
000021F0  4EF9 000032B2           1906              JMP     EA_ARITH
000021F6                          1907  
000021F6  4E75                    1908              RTS
000021F8                          1909              
000021F8                          1910  *---------------------------------------------------------------------------*
000021F8                          1911  * OP1001: decode SUB/SUBA
000021F8                          1912  *---------------------------------------------------------------------------*      
000021F8                          1913  OP1001      
000021F8  4280                    1914              CLR.L   D0                  
000021FA  4281                    1915              CLR.L   D1       
000021FC  4284                    1916              CLR.L   D4                   
000021FE  227C 00000000           1917              MOVEA.L #0, A1              
00002204  2205                    1918              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002206                          1919              
00002206                          1920              *CLEAR D3
00002206  4283                    1921              CLR.L   D3
00002208                          1922              
00002208                          1923              
00002208                          1924              
00002208                          1925              **INTEGRATING SUB.W/.L INTO THIS CODE**
00002208  2205                    1926              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000220A                          1927              *BITS (INDEX 8) 
0000220A                          1928              *0 = ADD.B/W/L <EA>,Dn
0000220A                          1929              *1 = ADD.B/W/L Dn,<EA> 
0000220A  EC99                    1930              ROR.L   #6,D1
0000220C  0281 00000007           1931              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002212  0C81 00000007           1932              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002218  6700 0010               1933              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
0000221C  0C81 00000003           1934              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002222  6700 0078               1935              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00002226  6000 00E6               1936              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
0000222A                          1937              
0000222A                          1938  OP1001_SUBA_L
0000222A                          1939              *LOAD STACK WITH THIS OPMODE
0000222A  6100 1DC0               1940              BSR     PUSH_STACK
0000222E  163C 0053               1941              MOVE.B  #'S',D3
00002232  6100 1DB8               1942              BSR     PUSH_STACK
00002236  163C 0055               1943              MOVE.B  #'U',D3
0000223A  6100 1DB0               1944              BSR     PUSH_STACK
0000223E  163C 0042               1945              MOVE.B  #'B',D3
00002242  6100 1DA8               1946              BSR     PUSH_STACK
00002246  163C 0041               1947              MOVE.B  #'A',D3
0000224A  6100 1DA0               1948              BSR     PUSH_STACK
0000224E  163C 002E               1949              MOVE.B  #'.',D3
00002252  6100 1D98               1950              BSR     PUSH_STACK
00002256  163C 004C               1951              MOVE.B  #'L',D3
0000225A  6100 1D90               1952              BSR     PUSH_STACK
0000225E                          1953              
0000225E                          1954             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000225E  13FC 0000 00004976      1955             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002266  13FC 0000 00004977      1956             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000226E                          1957             
0000226E                          1958             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000226E  13FC 00B9 00004979      1959             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002276  13FC 0020 0000497A      1960             MOVE.B   #$20,GET_SRC_START_END
0000227E                          1961  
0000227E                          1962              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000227E  0285 0000FE3F           1963              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002284  0685 00000040           1964              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000228A                          1965       
0000228A                          1966              *PRINT <EA>,AN
0000228A  6100 14C2               1967              BSR     GET_EA_EA_SRC       *GETS <ea>
0000228E  163C 002C               1968              MOVE.B  #',',D3
00002292  6100 1D58               1969              BSR     PUSH_STACK                     
00002296  6100 18E6               1970              BSR     GET_EA_EA_DEST      *GETS Dn
0000229A                          1971  
0000229A                          1972              
0000229A                          1973              
0000229A  4E75                    1974              RTS
0000229C                          1975  OP1001_SUBA_W
0000229C                          1976              *LOAD STACK WITH THIS OPMODE
0000229C  6100 1D4E               1977              BSR     PUSH_STACK
000022A0  163C 0053               1978              MOVE.B  #'S',D3
000022A4  6100 1D46               1979              BSR     PUSH_STACK
000022A8  163C 0055               1980              MOVE.B  #'U',D3
000022AC  6100 1D3E               1981              BSR     PUSH_STACK
000022B0  163C 0042               1982              MOVE.B  #'B',D3
000022B4  6100 1D36               1983              BSR     PUSH_STACK
000022B8  163C 0041               1984              MOVE.B  #'A',D3
000022BC  6100 1D2E               1985              BSR     PUSH_STACK
000022C0  163C 002E               1986              MOVE.B  #'.',D3
000022C4  6100 1D26               1987              BSR     PUSH_STACK
000022C8  163C 0057               1988              MOVE.B  #'W',D3
000022CC  6100 1D1E               1989              BSR     PUSH_STACK
000022D0                          1990              
000022D0                          1991             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022D0  13FC 0000 00004976      1992             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022D8  13FC 0000 00004977      1993             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022E0                          1994             
000022E0                          1995             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022E0  13FC 00B9 00004979      1996             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022E8  13FC 0020 0000497A      1997             MOVE.B   #$20,GET_SRC_START_END
000022F0                          1998  
000022F0                          1999              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022F0  0285 0000FE3F           2000              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022F6  0685 00000040           2001              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022FC                          2002       
000022FC                          2003              *PRINT <EA>,AN
000022FC  6100 1450               2004              BSR     GET_EA_EA_SRC       *GETS <ea>
00002300  163C 002C               2005              MOVE.B  #',',D3
00002304  6100 1CE6               2006              BSR     PUSH_STACK                     
00002308  6100 1874               2007              BSR     GET_EA_EA_DEST      *GETS Dn
0000230C                          2008  
0000230C  4E75                    2009              RTS
0000230E                          2010  
0000230E                          2011  OP1001_DETERMINE_DN_EA_OR_EA_DN 
0000230E                          2012              *LOAD STACK WITH THIS OPMODE
0000230E  6100 1CDC               2013              BSR     PUSH_STACK
00002312  163C 0053               2014              MOVE.B  #'S',D3
00002316  6100 1CD4               2015              BSR     PUSH_STACK
0000231A  163C 0055               2016              MOVE.B  #'U',D3
0000231E  6100 1CCC               2017              BSR     PUSH_STACK
00002322  163C 0042               2018              MOVE.B  #'B',D3
00002326  6100 1CC4               2019              BSR     PUSH_STACK
0000232A  163C 002E               2020              MOVE.B  #'.',D3
0000232E  6100 1CBC               2021              BSR     PUSH_STACK
00002332                          2022              
00002332  2205                    2023              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002334                          2024              
00002334                          2025              *BITS (INDEX 8) 
00002334                          2026              *0 = ADD.B/W/L <EA>,Dn
00002334                          2027              *1 = ADD.B/W/L Dn,<EA> 
00002334  E099                    2028              ROR.L   #8,D1
00002336  0281 00000001           2029              ANDI.L  #$01,D1     *MASKS WITH 00000001
0000233C  0C81 00000000           2030              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002342  6700 0102               2031              BEQ     OP1001_EA_DN
00002346                          2032              *else procede to Dn_EA
00002346                          2033              
00002346                          2034  OP1001_DN_EA
00002346                          2035              *BITS (7 TO 6) 
00002346                          2036              *00 = .B
00002346                          2037              *01 = .W
00002346                          2038              *10 = .L 
00002346  2205                    2039              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002348  EC99                    2040              ROR.L   #6,D1
0000234A  0281 00000003           2041              ANDI.L  #$03,D1
00002350  0C81 00000000           2042              CMPI.L  #$00,D1 *EQUALS .B
00002356  6700 0016               2043              BEQ     OP1001_PRINT_B2
0000235A  0C81 00000001           2044              CMPI.L  #$01,D1 *EQUALS .W
00002360  6700 0054               2045              BEQ     OP1001_PRINT_W2
00002364  0C81 00000002           2046              CMPI.L  #$02,D1 *EQUALS .L
0000236A  6700 0092               2047              BEQ     OP1001_PRINT_L2
0000236E                          2048  OP1001_PRINT_B2
0000236E                          2049              *PUSH 'B'
0000236E  163C 0042               2050              MOVE.B  #'B',D3
00002372  6100 1C78               2051              BSR     PUSH_STACK
00002376                          2052             
00002376                          2053              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002376  13FC 0000 00004976      2054             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000237E  13FC 0083 00004977      2055             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002386                          2056             
00002386                          2057             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002386  13FC 00B9 00004979      2058             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000238E  13FC 0020 0000497A      2059             MOVE.B   #$20,GET_SRC_START_END
00002396                          2060  
00002396                          2061              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002396  0285 0000FE3F           2062              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000239C  0685 00000040           2063              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023A2                          2064       
000023A2  6100 17DA               2065              BSR     GET_EA_EA_DEST      *GETS Dn
000023A6  163C 002C               2066              MOVE.B  #',',D3
000023AA  6100 1C40               2067              BSR     PUSH_STACK                     
000023AE  6100 139E               2068              BSR     GET_EA_EA_SRC       *GETS <ea>
000023B2                          2069  
000023B2                          2070              
000023B2  6000 0BA4               2071              BRA     OP1101_ADD_RETURN
000023B6                          2072  OP1001_PRINT_W2
000023B6  163C 0057               2073              MOVE.B  #'W',D3
000023BA  6100 1C30               2074              BSR     PUSH_STACK
000023BE                          2075  
000023BE                          2076              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023BE  13FC 0000 00004976      2077              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023C6  13FC 0083 00004977      2078              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023CE                          2079             
000023CE                          2080              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023CE  13FC 00B9 00004979      2081              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023D6  13FC 0020 0000497A      2082              MOVE.B   #$20,GET_SRC_START_END
000023DE                          2083  
000023DE                          2084              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023DE  0285 0000FE3F           2085              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023E4  0685 00000040           2086              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000023EA                          2087  
000023EA                          2088        
000023EA  6100 1792               2089              BSR     GET_EA_EA_DEST      *GETS Dn
000023EE  163C 002C               2090              MOVE.B  #',',D3
000023F2  6100 1BF8               2091              BSR     PUSH_STACK               
000023F6  6100 1356               2092              BSR     GET_EA_EA_SRC       *GETS <ea>       
000023FA                          2093  
000023FA                          2094  
000023FA                          2095  
000023FA  6000 0B5C               2096              BRA     OP1101_ADD_RETURN
000023FE                          2097  OP1001_PRINT_L2 
000023FE  163C 004C               2098              MOVE.B  #'L',D3
00002402  6100 1BE8               2099              BSR     PUSH_STACK
00002406                          2100              
00002406                          2101              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002406  13FC 0000 00004976      2102              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000240E  13FC 0083 00004977      2103              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002416                          2104             
00002416                          2105              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002416  13FC 00B9 00004979      2106              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000241E  13FC 0020 0000497A      2107              MOVE.B   #$20,GET_SRC_START_END
00002426                          2108  
00002426                          2109             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002426  0285 0000FE3F           2110              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000242C  0685 00000040           2111              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002432                          2112  
00002432                          2113               
00002432  6100 174A               2114              BSR     GET_EA_EA_DEST       *GETS Dn
00002436  163C 002C               2115              MOVE.B  #',',D3
0000243A  6100 1BB0               2116              BSR     PUSH_STACK          
0000243E  6100 130E               2117              BSR     GET_EA_EA_SRC        *GETS <ea>
00002442                          2118  
00002442  6000 0B14               2119              BRA     OP1101_ADD_RETURN
00002446                          2120              
00002446                          2121  OP1001_EA_DN           
00002446                          2122              *BITS (7 TO 6) 
00002446                          2123              *00 = .B
00002446                          2124              *01 = .W
00002446                          2125              *10 = .L 
00002446  2205                    2126              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002448  EC99                    2127              ROR.L   #6,D1
0000244A  0281 00000003           2128              ANDI.L  #$03,D1
00002450  0C81 00000000           2129              CMPI.L  #$00,D1 *EQUALS .B
00002456  6700 0016               2130              BEQ     OP1001_PRINT_B
0000245A  0C81 00000001           2131              CMPI.L  #$01,D1 *EQUALS .W
00002460  6700 0054               2132              BEQ     OP1001_PRINT_W
00002464  0C81 00000002           2133              CMPI.L  #$02,D1 *EQUALS .L
0000246A  6700 0092               2134              BEQ     OP1001_PRINT_L
0000246E                          2135  OP1001_PRINT_B
0000246E  163C 0042               2136              MOVE.B  #'B',D3
00002472  6100 1B78               2137              BSR     PUSH_STACK
00002476                          2138                
00002476                          2139              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002476  13FC 0000 00004976      2140              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000247E  13FC 0002 00004977      2141              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002486                          2142             
00002486                          2143              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002486  13FC 00B9 00004979      2144              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000248E  13FC 0020 0000497A      2145              MOVE.B   #$20,GET_SRC_START_END
00002496                          2146  
00002496                          2147             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002496  0285 0000FE3F           2148              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000249C  0685 00000040           2149              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
000024A2                          2150  
000024A2                          2151              
000024A2  6100 12AA               2152              BSR     GET_EA_EA_SRC      *GETS <ea>
000024A6  163C 002C               2153              MOVE.B  #',',D3
000024AA  6100 1B40               2154              BSR     PUSH_STACK          
000024AE  6100 16CE               2155              BSR     GET_EA_EA_DEST       *GETS Dn
000024B2                          2156              
000024B2  6000 0AA4               2157              BRA     OP1101_ADD_RETURN
000024B6                          2158  OP1001_PRINT_W
000024B6  163C 0057               2159              MOVE.B  #'W',D3
000024BA  6100 1B30               2160              BSR     PUSH_STACK
000024BE                          2161  
000024BE                          2162              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024BE  13FC 0000 00004976      2163              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024C6  13FC 0000 00004977      2164              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024CE                          2165             
000024CE                          2166              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024CE  13FC 00B9 00004979      2167              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024D6  13FC 0020 0000497A      2168              MOVE.B   #$20,GET_SRC_START_END
000024DE                          2169  
000024DE                          2170             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024DE  0285 0000FE3F           2171              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024E4  0685 00000040           2172              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024EA                          2173  
000024EA                          2174              
000024EA  6100 1262               2175              BSR     GET_EA_EA_SRC      *GETS <ea>
000024EE  163C 002C               2176              MOVE.B  #',',D3
000024F2  6100 1AF8               2177              BSR     PUSH_STACK
000024F6  6100 1686               2178              BSR     GET_EA_EA_DEST       *GETS Dn    
000024FA                          2179              
000024FA  6000 004A               2180              BRA     OP1001_ADD_RETURN
000024FE                          2181  OP1001_PRINT_L 
000024FE  163C 004C               2182              MOVE.B  #'L',D3
00002502  6100 1AE8               2183              BSR     PUSH_STACK
00002506                          2184              
00002506                          2185              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002506  13FC 0000 00004976      2186              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000250E  13FC 0000 00004977      2187              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002516                          2188             
00002516                          2189              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002516  13FC 00B9 00004979      2190              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000251E  13FC 0020 0000497A      2191              MOVE.B   #$20,GET_SRC_START_END
00002526                          2192  
00002526                          2193              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002526  0285 0000FE3F           2194              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000252C  0685 00000040           2195              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002532                          2196  
00002532                          2197                     
00002532  6100 121A               2198              BSR     GET_EA_EA_SRC      *GETS <ea>
00002536  163C 002C               2199              MOVE.B  #',',D3
0000253A  6100 1AB0               2200              BSR     PUSH_STACK                  
0000253E  6100 163E               2201              BSR     GET_EA_EA_DEST       *GETS Dn    
00002542                          2202  
00002542                          2203              
00002542  6000 0002               2204              BRA     OP1001_ADD_RETURN
00002546                          2205              
00002546                          2206  OP1001_ADD_RETURN
00002546  4E75                    2207              RTS
00002548                          2208  
00002548                          2209    
00002548                          2210  *---------------------------------------------------------------------------*
00002548                          2211  * OP_SUB: display SUB and proceed to EA
00002548                          2212  *---------------------------------------------------------------------------*            
00002548  43F9 00004771           2213  OP_SUB_B    LEA     DISP_SUB_B,A1
0000254E  103C 000E               2214              MOVE.B  #14,D0
00002552  4E4F                    2215              TRAP    #15
00002554  183C 0000               2216              MOVE.B  #0,D4
00002558  4EF9 000032FE           2217              JMP     EA_GEN
0000255E                          2218  
0000255E  4E75                    2219              RTS
00002560                          2220  
00002560  43F9 0000477A           2221  OP_SUB_W    LEA     DISP_SUB_W,A1
00002566  103C 000E               2222              MOVE.B  #14,D0
0000256A  4E4F                    2223              TRAP    #15
0000256C  183C 0001               2224              MOVE.B  #1,D4
00002570  4EF9 000032FE           2225              JMP     EA_GEN
00002576                          2226  
00002576  4E75                    2227              RTS
00002578                          2228  
00002578  43F9 00004783           2229  OP_SUB_L    LEA     DISP_SUB_L,A1
0000257E  103C 000E               2230              MOVE.B  #14,D0
00002582  4E4F                    2231              TRAP    #15
00002584  183C 0002               2232              MOVE.B  #2,D4
00002588  4EF9 000032FE           2233              JMP     EA_GEN
0000258E                          2234  
0000258E  4E75                    2235              RTS
00002590                          2236  
00002590                          2237  *---------------------------------------------------------------------------*
00002590                          2238  * OP_SUBA: display SUBA
00002590                          2239  *---------------------------------------------------------------------------*  
00002590  43F9 000047AA           2240  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00002596  103C 000E               2241              MOVE.B  #14,D0
0000259A  4E4F                    2242              TRAP    #15
0000259C  183C 0001               2243              MOVE.B  #1,D4
000025A0  4E75                    2244              RTS
000025A2                          2245  
000025A2  43F9 000047B4           2246  OP_SUBA_L   LEA     DISP_SUBA_L,A1
000025A8  103C 000E               2247              MOVE.B  #14,D0
000025AC  4E4F                    2248              TRAP    #15
000025AE  183C 0002               2249              MOVE.B  #2,D4
000025B2  4E75                    2250              RTS         
000025B4                          2251  *---------------------------------------------------------------------------*
000025B4                          2252  * OP1010 : unassigned
000025B4                          2253  *---------------------------------------------------------------------------*           
000025B4  4EF8 1768               2254  OP1010      JMP     OP_DATA
000025B8                          2255              
000025B8                          2256  *---------------------------------------------------------------------------*
000025B8                          2257  * OP1011 : decode CMP/EOR/CMPA
000025B8                          2258  *---------------------------------------------------------------------------*           
000025B8  4280                    2259  OP1011      CLR.L   D0                
000025BA  4281                    2260              CLR.L   D1            
000025BC  4284                    2261              CLR.L   D4                   
000025BE  227C 00000000           2262              MOVEA.L #0, A1               
000025C4  2205                    2263              MOVE.L  D5,D1
000025C6  EA99                    2264              ROR.L   #5,D1
000025C8  0281 0000000E           2265              ANDI.L  #$E,D1
000025CE  0C01 0000               2266              CMPI.B  #$0,D1
000025D2  6700 003E               2267              BEQ     OP1011_CMP
000025D6  0C01 0002               2268              CMPI.B  #$2,D1
000025DA  6700 0036               2269              BEQ     OP1011_CMP
000025DE  0C01 0004               2270              CMPI.B  #$4,D1
000025E2  6700 002E               2271              BEQ     OP1011_CMP
000025E6  0C01 0008               2272              CMPI.B  #$8,D1
000025EA  6700 0178               2273              BEQ     OP1011_EOR
000025EE  0C01 000A               2274              CMPI.B  #$A,D1
000025F2  6700 0170               2275              BEQ     OP1011_EOR
000025F6  0C01 000C               2276              CMPI.B  #$C,D1
000025FA  6700 0168               2277              BEQ     OP1011_EOR  
000025FE  0C01 0006               2278              CMPI.B  #$6,D1
00002602  6700 00C0               2279              BEQ     OP1011_CMPA
00002606  0C01 000E               2280              CMPI.B  #$E,D1
0000260A  6700 00B8               2281              BEQ     OP1011_CMPA 
0000260E                          2282  
0000260E  4EF8 1768               2283              JMP     OP_DATA          
00002612                          2284  
00002612                          2285  
00002612                          2286  
00002612                          2287  
00002612                          2288  OP1011_CMP
00002612                          2289             
00002612                          2290   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002612  13FC 0082 00004976      2291             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000261A  13FC 0000 00004977      2292             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002622                          2293             
00002622                          2294             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002622  13FC 00B9 00004979      2295             MOVE.B   #$B9,GET_DST_START_END
0000262A  13FC 0020 0000497A      2296             MOVE.B   #$20,GET_SRC_START_END
00002632                          2297             
00002632                          2298              *CLEAR D3
00002632  4283                    2299              CLR.L   D3
00002634                          2300              *LOAD STACK WITH THIS OPMODE
00002634  6100 19B6               2301              BSR     PUSH_STACK
00002638  163C 0043               2302              MOVE.B  #'C',D3
0000263C  6100 19AE               2303              BSR     PUSH_STACK
00002640  163C 004D               2304              MOVE.B  #'M',D3
00002644  6100 19A6               2305              BSR     PUSH_STACK
00002648  163C 0050               2306              MOVE.B  #'P',D3
0000264C  6100 199E               2307              BSR     PUSH_STACK
00002650  163C 002E               2308              MOVE.B  #'.',D3
00002654  6100 1996               2309              BSR     PUSH_STACK
00002658                          2310              
00002658                          2311              *FIGURE OUT SIZE*
00002658                          2312              *00 = BYTE
00002658                          2313              *01 = WORD
00002658                          2314              *10 = LONG
00002658                          2315              * BITS 7&6
00002658                          2316              
00002658                          2317              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002658  2205                    2318              MOVE.L  D5,D1
0000265A  EC99                    2319              ROR.L   #6,D1
0000265C  0281 00000003           2320              ANDI.L  #$03,D1
00002662  0C01 0000               2321              CMPI.B  #%00,D1
00002666  6700 001E               2322              BEQ     OP1011_CMP_B
0000266A  0281 00000003           2323              ANDI.L  #$03,D1
00002670  0C01 0001               2324              CMPI.B  #%01,D1
00002674  6700 001C               2325              BEQ     OP1011_CMP_W
00002678  0281 00000003           2326              ANDI.L  #$03,D1
0000267E  0C01 0002               2327              CMPI.B  #%10,D1
00002682  6700 001A               2328              BEQ     OP1011_CMP_L
00002686                          2329            
00002686                          2330  OP1011_CMP_B
00002686                          2331              
00002686  163C 0042               2332              MOVE.B  #'B',D3
0000268A  6100 1960               2333              BSR     PUSH_STACK
0000268E  6000 0016               2334              BRA     OP1011_RETURN_CMP  
00002692                          2335  OP1011_CMP_W
00002692                          2336              
00002692  163C 0057               2337              MOVE.B  #'W',D3
00002696  6100 1954               2338              BSR     PUSH_STACK
0000269A  6000 000A               2339              BRA     OP1011_RETURN_CMP  
0000269E                          2340  OP1011_CMP_L
0000269E                          2341              
0000269E  163C 004C               2342              MOVE.B  #'L',D3
000026A2  6100 1948               2343              BSR     PUSH_STACK
000026A6                          2344  OP1011_RETURN_CMP            
000026A6                          2345  
000026A6                          2346              
000026A6                          2347  *GET DATA FROM ADDQ AND PRINT #0-8
000026A6                          2348       
000026A6                          2349              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026A6  0285 0000FE3F           2350              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026AC  0685 00000000           2351              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026B2                          2352  
000026B2  6100 109A               2353              BSR     GET_EA_EA_SRC
000026B6  163C 002C               2354              MOVE.B  #',',D3
000026BA  6100 1930               2355              BSR     PUSH_STACK
000026BE  6100 14BE               2356              BSR     GET_EA_EA_DEST
000026C2                          2357              
000026C2  4E75                    2358              RTS
000026C4                          2359              
000026C4                          2360  
000026C4                          2361  
000026C4                          2362  OP1011_CMPA
000026C4                          2363              
000026C4                          2364   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026C4  13FC 0080 00004976      2365             MOVE.B   #$80,DEST_REGISTER_FORMAT
000026CC  13FC 0000 00004977      2366             MOVE.B   #$00,SRC_REGISTER_FORMAT
000026D4                          2367             
000026D4                          2368             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026D4  13FC 00B9 00004979      2369             MOVE.B   #$B9,GET_DST_START_END
000026DC  13FC 0020 0000497A      2370             MOVE.B   #$20,GET_SRC_START_END
000026E4                          2371             
000026E4                          2372              *CLEAR D3
000026E4  4283                    2373              CLR.L   D3
000026E6                          2374              *LOAD STACK WITH THIS OPMODE
000026E6  6100 1904               2375              BSR     PUSH_STACK
000026EA  163C 0043               2376              MOVE.B  #'C',D3
000026EE  6100 18FC               2377              BSR     PUSH_STACK
000026F2  163C 004D               2378              MOVE.B  #'M',D3
000026F6  6100 18F4               2379              BSR     PUSH_STACK
000026FA  163C 0050               2380              MOVE.B  #'P',D3
000026FE  6100 18EC               2381              BSR     PUSH_STACK
00002702  163C 0041               2382              MOVE.B  #'A',D3
00002706  6100 18E4               2383              BSR     PUSH_STACK
0000270A  163C 002E               2384              MOVE.B  #'.',D3
0000270E  6100 18DC               2385              BSR     PUSH_STACK
00002712                          2386              
00002712                          2387              *FIGURE OUT SIZE*
00002712                          2388              *00 = BYTE
00002712                          2389              *01 = WORD
00002712                          2390              *10 = LONG
00002712                          2391              * BITS 7&6
00002712                          2392              
00002712                          2393              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002712  2205                    2394              MOVE.L  D5,D1
00002714  EC99                    2395              ROR.L   #6,D1
00002716  0281 00000003           2396              ANDI.L  #$03,D1
0000271C  0C01 0001               2397              CMPI.B  #%01,D1
00002720  6700 0010               2398              BEQ     OP1011_CMPA_W
00002724  0281 00000003           2399              ANDI.L  #$03,D1
0000272A  0C01 0002               2400              CMPI.B  #%10,D1
0000272E  6700 000E               2401              BEQ     OP1011_CMPA_L
00002732                          2402  OP1011_CMPA_W
00002732                          2403              
00002732  163C 0057               2404              MOVE.B  #'W',D3
00002736  6100 18B4               2405              BSR     PUSH_STACK
0000273A  6000 000A               2406              BRA     OP1011_RETURN_CMPA 
0000273E                          2407  OP1011_CMPA_L
0000273E                          2408              
0000273E  163C 004C               2409              MOVE.B  #'L',D3
00002742  6100 18A8               2410              BSR     PUSH_STACK
00002746                          2411  OP1011_RETURN_CMPA            
00002746                          2412  
00002746                          2413              
00002746                          2414  *GET DATA FROM ADDQ AND PRINT #0-8
00002746                          2415       
00002746                          2416              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002746  0285 0000FE3F           2417              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000274C  0685 00000040           2418              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00002752                          2419  
00002752  6100 0FFA               2420              BSR     GET_EA_EA_SRC
00002756  163C 002C               2421              MOVE.B  #',',D3
0000275A  6100 1890               2422              BSR     PUSH_STACK
0000275E  6100 141E               2423              BSR     GET_EA_EA_DEST
00002762                          2424              
00002762  4E75                    2425              RTS
00002764                          2426  
00002764                          2427  OP1011_EOR
00002764                          2428  
00002764                          2429   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002764  13FC 0082 00004976      2430             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000276C  13FC 0080 00004977      2431             MOVE.B   #$80,SRC_REGISTER_FORMAT
00002774                          2432             
00002774                          2433             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002774  13FC 00B9 00004979      2434             MOVE.B   #$B9,GET_DST_START_END
0000277C  13FC 0020 0000497A      2435             MOVE.B   #$20,GET_SRC_START_END
00002784                          2436             
00002784                          2437              *CLEAR D3
00002784  4283                    2438              CLR.L   D3
00002786                          2439              *LOAD STACK WITH THIS OPMODE
00002786  6100 1864               2440              BSR     PUSH_STACK
0000278A  163C 0045               2441              MOVE.B  #'E',D3
0000278E  6100 185C               2442              BSR     PUSH_STACK
00002792  163C 004F               2443              MOVE.B  #'O',D3
00002796  6100 1854               2444              BSR     PUSH_STACK
0000279A  163C 0052               2445              MOVE.B  #'R',D3
0000279E  6100 184C               2446              BSR     PUSH_STACK
000027A2  163C 002E               2447              MOVE.B  #'.',D3
000027A6  6100 1844               2448              BSR     PUSH_STACK
000027AA                          2449              
000027AA                          2450              *FIGURE OUT SIZE*
000027AA                          2451              *00 = BYTE
000027AA                          2452              *01 = WORD
000027AA                          2453              *10 = LONG
000027AA                          2454              * BITS 7&6
000027AA                          2455              
000027AA                          2456              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000027AA  2205                    2457              MOVE.L  D5,D1
000027AC  EC99                    2458              ROR.L   #6,D1
000027AE  0281 00000003           2459              ANDI.L  #$03,D1
000027B4  0C01 0000               2460              CMPI.B  #%00,D1
000027B8  6700 001E               2461              BEQ     OP1011_EOR_B
000027BC  0281 00000003           2462              ANDI.L  #$03,D1
000027C2  0C01 0001               2463              CMPI.B  #%01,D1
000027C6  6700 001C               2464              BEQ     OP1011_EOR_W
000027CA  0281 00000003           2465              ANDI.L  #$03,D1
000027D0  0C01 0002               2466              CMPI.B  #%10,D1
000027D4  6700 001A               2467              BEQ     OP1011_EOR_L
000027D8                          2468            
000027D8                          2469  OP1011_EOR_B
000027D8                          2470              
000027D8  163C 0042               2471              MOVE.B  #'B',D3
000027DC  6100 180E               2472              BSR     PUSH_STACK
000027E0  6000 0016               2473              BRA     OP1011_RETURN
000027E4                          2474  OP1011_EOR_W
000027E4                          2475              
000027E4  163C 0057               2476              MOVE.B  #'W',D3
000027E8  6100 1802               2477              BSR     PUSH_STACK
000027EC  6000 000A               2478              BRA     OP1011_RETURN
000027F0                          2479  OP1011_EOR_L
000027F0                          2480              
000027F0  163C 004C               2481              MOVE.B  #'L',D3
000027F4  6100 17F6               2482              BSR     PUSH_STACK
000027F8                          2483  OP1011_RETURN            
000027F8                          2484  
000027F8                          2485              
000027F8                          2486  *GET DATA FROM ADDQ AND PRINT #0-8
000027F8                          2487       
000027F8                          2488              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027F8  0285 0000FE3F           2489              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027FE  0685 00000000           2490              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002804                          2491  
00002804  6100 1378               2492              BSR     GET_EA_EA_DEST
00002808  163C 002C               2493              MOVE.B  #',',D3
0000280C  6100 17DE               2494              BSR     PUSH_STACK
00002810  6100 0F3C               2495              BSR     GET_EA_EA_SRC
00002814                          2496              
00002814  4E75                    2497              RTS
00002816                          2498              
00002816                          2499              
00002816                          2500              
00002816                          2501              
00002816                          2502  
00002816                          2503  *---------------------------------------------------------------------------*
00002816                          2504  * OP_CMPA: display CMPA 
00002816                          2505  *---------------------------------------------------------------------------
00002816  43F9 000047F4           2506  OP_CMPA_W   LEA     DISP_CMPA_W,A1
0000281C  103C 000E               2507              MOVE.B  #14,D0
00002820  4E4F                    2508              TRAP    #15
00002822  183C 0001               2509              MOVE.B  #1,D4
00002826  4E75                    2510              RTS
00002828                          2511  
00002828  43F9 000047FE           2512  OP_CMPA_L   LEA     DISP_CMPA_L,A1
0000282E  103C 000E               2513              MOVE.B  #14,D0
00002832  4E4F                    2514              TRAP    #15
00002834  183C 0002               2515              MOVE.B  #2,D4
00002838  4E75                    2516              RTS
0000283A                          2517  
0000283A                          2518  *---------------------------------------------------------------------------*
0000283A                          2519  * OP_CMP: display CMP and proceed to EA
0000283A                          2520  *---------------------------------------------------------------------------*  
0000283A  43F9 000047D9           2521  OP_CMP_B    LEA     DISP_CMP_B,A1
00002840  103C 000E               2522              MOVE.B  #14,D0
00002844  4E4F                    2523              TRAP    #15
00002846  183C 0000               2524              MOVE.B  #0,D4
0000284A  4EF9 000032FE           2525              JMP     EA_GEN
00002850                          2526  
00002850  4E75                    2527              RTS
00002852                          2528              
00002852  43F9 000047E2           2529  OP_CMP_W    LEA     DISP_CMP_W,A1
00002858  103C 000E               2530              MOVE.B  #14,D0
0000285C  4E4F                    2531              TRAP    #15
0000285E  183C 0001               2532              MOVE.B  #1,D4
00002862  4EF9 000032FE           2533              JMP     EA_GEN
00002868                          2534  
00002868  4E75                    2535              RTS
0000286A                          2536              
0000286A  43F9 000047EB           2537  OP_CMP_L    LEA     DISP_CMP_L,A1
00002870  103C 000E               2538              MOVE.B  #14,D0
00002874  4E4F                    2539              TRAP    #15
00002876  183C 0002               2540              MOVE.B  #2,D4
0000287A  4EF9 000032FE           2541              JMP     EA_GEN
00002880                          2542  
00002880  4E75                    2543              RTS
00002882                          2544              
00002882                          2545  *---------------------------------------------------------------------------*
00002882                          2546  * OP_EOR: display EOR
00002882                          2547  *---------------------------------------------------------------------------*  
00002882  43F9 000047BE           2548  OP_EOR_B    LEA     DISP_EOR_B,A1
00002888  103C 000E               2549              MOVE.B  #14,D0
0000288C  4E4F                    2550              TRAP    #15
0000288E  183C 0000               2551              MOVE.B  #0,D4
00002892  4E75                    2552              RTS
00002894                          2553              
00002894  43F9 000047C7           2554  OP_EOR_W    LEA     DISP_EOR_W,A1
0000289A  103C 000E               2555              MOVE.B  #14,D0
0000289E  4E4F                    2556              TRAP    #15
000028A0  183C 0001               2557              MOVE.B  #1,D4
000028A4  4E75                    2558              RTS
000028A6                          2559              
000028A6  43F9 000047D0           2560  OP_EOR_L    LEA     DISP_EOR_L,A1
000028AC  103C 000E               2561              MOVE.B  #14,D0
000028B0  4E4F                    2562              TRAP    #15
000028B2  183C 0002               2563              MOVE.B  #2,D4
000028B6  4E75                    2564              RTS    
000028B8                          2565  
000028B8                          2566  *---------------------------------------------------------------------------*
000028B8                          2567  * OP1100: Decode and display MULS/AND and proceed to EA
000028B8                          2568  *---------------------------------------------------------------------------* 
000028B8  4280                    2569  OP1100      CLR.L   D0                 
000028BA  4281                    2570              CLR.L   D1    
000028BC  4284                    2571              CLR.L   D4                
000028BE  227C 00000000           2572              MOVEA.L #0, A1        
000028C4  2205                    2573              MOVE.L  D5,D1
000028C6  EA89                    2574              LSR.L   #5,D1
000028C8  0281 0000000E           2575              ANDI.L  #$E,D1
000028CE  0C41 000E               2576              CMPI.W  #$E,D1
000028D2  6700 0006               2577              BEQ     OP_MULS
000028D6  6000 00F6               2578              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000028DA                          2579  
000028DA                          2580  OP_MULS                      
000028DA  4281                    2581              CLR.L   D1       
000028DC  4284                    2582              CLR.L   D4                   
000028DE  227C 00000000           2583              MOVEA.L #0, A1              
000028E4  2205                    2584              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000028E6                          2585              *CLEAR D3
000028E6  4283                    2586              CLR.L   D3
000028E8                          2587  
000028E8                          2588  OP1100_MULS_DN_EA_OR_EA_DN 
000028E8                          2589              *LOAD STACK WITH THIS OPMODE
000028E8  6100 1702               2590              BSR     PUSH_STACK
000028EC  163C 004D               2591              MOVE.B  #'M',D3
000028F0  6100 16FA               2592              BSR     PUSH_STACK
000028F4  163C 0055               2593              MOVE.B  #'U',D3
000028F8  6100 16F2               2594              BSR     PUSH_STACK
000028FC  163C 004C               2595              MOVE.B  #'L',D3
00002900  6100 16EA               2596              BSR     PUSH_STACK
00002904  163C 0053               2597              MOVE.B  #'S',D3
00002908  6100 16E2               2598              BSR     PUSH_STACK
0000290C  163C 002E               2599              MOVE.B  #'.',D3
00002910  6100 16DA               2600              BSR     PUSH_STACK
00002914                          2601              
00002914  2205                    2602              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002916                          2603              
00002916                          2604  OP1100_EA_DN_MULS           
00002916                          2605              *BITS (7 TO 6) 
00002916                          2606              *00 = .B
00002916                          2607              *01 = .W
00002916                          2608              *10 = .L 
00002916  2205                    2609              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002918  EC99                    2610              ROR.L   #6,D1
0000291A  0281 00000003           2611              ANDI.L  #$03,D1
00002920  0C81 00000003           2612              CMPI.L  #%11,D1 *EQUALS .W
00002926  6700 0014               2613              BEQ     OP1100_PRINT_W_MULS
0000292A  0C81 00000000           2614              CMPI.L  #%00,D1 *EQUALS .L
00002930  6700 0052               2615              BEQ     OP1100_PRINT_L_MULS
00002934                          2616              
00002934  183C 0001               2617              MOVE.B  #1,D4               *ERROR READ
00002938  6000 0092               2618              BRA     OP1100_MULS_RETURN
0000293C                          2619  OP1100_PRINT_W_MULS
0000293C  163C 0057               2620              MOVE.B  #'W',D3
00002940  6100 16AA               2621              BSR     PUSH_STACK
00002944                          2622  
00002944                          2623              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002944  13FC 0000 00004976      2624              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000294C  13FC 0000 00004977      2625              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002954                          2626             
00002954                          2627              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002954  13FC 00B9 00004979      2628              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000295C  13FC 0020 0000497A      2629              MOVE.B   #$20,GET_SRC_START_END
00002964                          2630  
00002964                          2631             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002964  0285 0000FE3F           2632              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000296A  0685 00000000           2633              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002970                          2634  
00002970                          2635              
00002970  6100 0DDC               2636              BSR     GET_EA_EA_SRC      *GETS <ea>
00002974  163C 002C               2637              MOVE.B  #',',D3
00002978  6100 1672               2638              BSR     PUSH_STACK
0000297C  6100 1200               2639              BSR     GET_EA_EA_DEST       *GETS Dn    
00002980                          2640              
00002980  6000 004A               2641              BRA     OP1100_MULS_RETURN
00002984                          2642  OP1100_PRINT_L_MULS 
00002984  163C 004C               2643              MOVE.B  #'L',D3
00002988  6100 1662               2644              BSR     PUSH_STACK
0000298C                          2645              
0000298C                          2646              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000298C  13FC 0000 00004976      2647              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002994  13FC 0000 00004977      2648              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000299C                          2649             
0000299C                          2650              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000299C  13FC 00B9 00004979      2651              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029A4  13FC 0020 0000497A      2652              MOVE.B   #$20,GET_SRC_START_END
000029AC                          2653  
000029AC                          2654              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029AC  0285 0000FE3F           2655              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029B2  0685 00000000           2656              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000029B8                          2657  
000029B8                          2658                     
000029B8  6100 0D94               2659              BSR     GET_EA_EA_SRC      *GETS <ea>
000029BC  163C 002C               2660              MOVE.B  #',',D3
000029C0  6100 162A               2661              BSR     PUSH_STACK                  
000029C4  6100 11B8               2662              BSR     GET_EA_EA_DEST       *GETS Dn    
000029C8                          2663  
000029C8                          2664              
000029C8  6000 0002               2665              BRA     OP1100_MULS_RETURN
000029CC                          2666              
000029CC                          2667  OP1100_MULS_RETURN
000029CC  4E75                    2668              RTS
000029CE                          2669              
000029CE                          2670  
000029CE                          2671  
000029CE                          2672  
000029CE                          2673  
000029CE                          2674  
000029CE                          2675  
000029CE                          2676  
000029CE                          2677  
000029CE                          2678  
000029CE                          2679  
000029CE                          2680  
000029CE                          2681  
000029CE                          2682  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000029CE                          2683              *LOAD STACK WITH THIS OPMODE
000029CE  4283                    2684              CLR.L   D3
000029D0  6100 161A               2685              BSR     PUSH_STACK
000029D4  163C 0041               2686              MOVE.B  #'A',D3
000029D8  6100 1612               2687              BSR     PUSH_STACK
000029DC  163C 004E               2688              MOVE.B  #'N',D3
000029E0  6100 160A               2689              BSR     PUSH_STACK
000029E4  163C 0044               2690              MOVE.B  #'D',D3
000029E8  6100 1602               2691              BSR     PUSH_STACK
000029EC  163C 002E               2692              MOVE.B  #'.',D3
000029F0  6100 15FA               2693              BSR     PUSH_STACK
000029F4                          2694              
000029F4  2205                    2695              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000029F6                          2696              
000029F6                          2697              *BITS (INDEX 8) 
000029F6                          2698              *0 = ADD.B/W/L <EA>,Dn
000029F6                          2699              *1 = ADD.B/W/L Dn,<EA> 
000029F6  E099                    2700              ROR.L   #8,D1
000029F8  0281 00000001           2701              ANDI.L  #$01,D1     *MASKS WITH 00000001
000029FE  0C81 00000000           2702              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002A04  6700 0102               2703              BEQ     OP1100_EA_DN
00002A08                          2704              *else procede to Dn_EA
00002A08                          2705              
00002A08                          2706  OP1100_DN_EA
00002A08                          2707              *BITS (7 TO 6) 
00002A08                          2708              *00 = .B
00002A08                          2709              *01 = .W
00002A08                          2710              *10 = .L 
00002A08  2205                    2711              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002A0A  EC99                    2712              ROR.L   #6,D1
00002A0C  0281 00000003           2713              ANDI.L  #$03,D1
00002A12  0C81 00000000           2714              CMPI.L  #$00,D1 *EQUALS .B
00002A18  6700 0016               2715              BEQ     OP1100_PRINT_B2
00002A1C  0C81 00000001           2716              CMPI.L  #$01,D1 *EQUALS .W
00002A22  6700 0054               2717              BEQ     OP1100_PRINT_W2
00002A26  0C81 00000002           2718              CMPI.L  #$02,D1 *EQUALS .L
00002A2C  6700 0092               2719              BEQ     OP1100_PRINT_L2
00002A30                          2720  OP1100_PRINT_B2
00002A30                          2721              *PUSH 'B'
00002A30  163C 0042               2722              MOVE.B  #'B',D3
00002A34  6100 15B6               2723              BSR     PUSH_STACK
00002A38                          2724             
00002A38                          2725              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A38  13FC 0000 00004976      2726             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A40  13FC 0083 00004977      2727             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A48                          2728             
00002A48                          2729             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A48  13FC 00B9 00004979      2730             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A50  13FC 0020 0000497A      2731             MOVE.B   #$20,GET_SRC_START_END
00002A58                          2732  
00002A58                          2733              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A58  0285 0000FE3F           2734              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A5E  0685 00000000           2735              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A64                          2736       
00002A64  6100 1118               2737              BSR     GET_EA_EA_DEST      *GETS Dn
00002A68  163C 002C               2738              MOVE.B  #',',D3
00002A6C  6100 157E               2739              BSR     PUSH_STACK                     
00002A70  6100 0CDC               2740              BSR     GET_EA_EA_SRC       *GETS <ea>
00002A74                          2741  
00002A74                          2742              
00002A74  6000 0192               2743              BRA     OP1100_AND_RETURN
00002A78                          2744  OP1100_PRINT_W2
00002A78  163C 0057               2745              MOVE.B  #'W',D3
00002A7C  6100 156E               2746              BSR     PUSH_STACK
00002A80                          2747  
00002A80                          2748              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A80  13FC 0000 00004976      2749              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A88  13FC 0083 00004977      2750              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A90                          2751             
00002A90                          2752              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A90  13FC 00B9 00004979      2753              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A98  13FC 0020 0000497A      2754              MOVE.B   #$20,GET_SRC_START_END
00002AA0                          2755  
00002AA0                          2756              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AA0  0285 0000FE3F           2757              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AA6  0685 00000000           2758              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002AAC                          2759  
00002AAC                          2760        
00002AAC  6100 10D0               2761              BSR     GET_EA_EA_DEST      *GETS Dn
00002AB0  163C 002C               2762              MOVE.B  #',',D3
00002AB4  6100 1536               2763              BSR     PUSH_STACK               
00002AB8  6100 0C94               2764              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002ABC                          2765  
00002ABC                          2766  
00002ABC                          2767  
00002ABC  6000 049A               2768              BRA     OP1101_ADD_RETURN
00002AC0                          2769  OP1100_PRINT_L2 
00002AC0  163C 004C               2770              MOVE.B  #'L',D3
00002AC4  6100 1526               2771              BSR     PUSH_STACK
00002AC8                          2772              
00002AC8                          2773              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AC8  13FC 0000 00004976      2774              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002AD0  13FC 0083 00004977      2775              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AD8                          2776             
00002AD8                          2777              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AD8  13FC 00B9 00004979      2778              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AE0  13FC 0020 0000497A      2779              MOVE.B   #$20,GET_SRC_START_END
00002AE8                          2780  
00002AE8                          2781             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AE8  0285 0000FE3F           2782              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AEE  0685 00000000           2783              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002AF4                          2784  
00002AF4                          2785               
00002AF4  6100 1088               2786              BSR     GET_EA_EA_DEST       *GETS Dn
00002AF8  163C 002C               2787              MOVE.B  #',',D3
00002AFC  6100 14EE               2788              BSR     PUSH_STACK          
00002B00  6100 0C4C               2789              BSR     GET_EA_EA_SRC        *GETS <ea>
00002B04                          2790  
00002B04  6000 0102               2791              BRA     OP1100_AND_RETURN
00002B08                          2792              
00002B08                          2793  OP1100_EA_DN           
00002B08                          2794              *BITS (7 TO 6) 
00002B08                          2795              *00 = .B
00002B08                          2796              *01 = .W
00002B08                          2797              *10 = .L 
00002B08  2205                    2798              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002B0A  EC99                    2799              ROR.L   #6,D1
00002B0C  0281 00000003           2800              ANDI.L  #$03,D1
00002B12  0C81 00000000           2801              CMPI.L  #$00,D1 *EQUALS .B
00002B18  6700 0016               2802              BEQ     OP1100_PRINT_B
00002B1C  0C81 00000001           2803              CMPI.L  #$01,D1 *EQUALS .W
00002B22  6700 0054               2804              BEQ     OP1100_PRINT_W
00002B26  0C81 00000002           2805              CMPI.L  #$02,D1 *EQUALS .L
00002B2C  6700 0092               2806              BEQ     OP1100_PRINT_L
00002B30                          2807  OP1100_PRINT_B
00002B30  163C 0042               2808              MOVE.B  #'B',D3
00002B34  6100 14B6               2809              BSR     PUSH_STACK
00002B38                          2810                
00002B38                          2811              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B38  13FC 0000 00004976      2812              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B40  13FC 0002 00004977      2813              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B48                          2814             
00002B48                          2815              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B48  13FC 00B9 00004979      2816              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B50  13FC 0020 0000497A      2817              MOVE.B   #$20,GET_SRC_START_END
00002B58                          2818  
00002B58                          2819             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B58  0285 0000FE3F           2820              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B5E  0685 00000000           2821              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002B64                          2822  
00002B64                          2823              
00002B64  6100 0BE8               2824              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B68  163C 002C               2825              MOVE.B  #',',D3
00002B6C  6100 147E               2826              BSR     PUSH_STACK          
00002B70  6100 100C               2827              BSR     GET_EA_EA_DEST       *GETS Dn
00002B74                          2828              
00002B74  6000 03E2               2829              BRA     OP1101_ADD_RETURN
00002B78                          2830  OP1100_PRINT_W
00002B78  163C 0057               2831              MOVE.B  #'W',D3
00002B7C  6100 146E               2832              BSR     PUSH_STACK
00002B80                          2833  
00002B80                          2834              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B80  13FC 0000 00004976      2835              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B88  13FC 0002 00004977      2836              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B90                          2837             
00002B90                          2838              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B90  13FC 00B9 00004979      2839              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B98  13FC 0020 0000497A      2840              MOVE.B   #$20,GET_SRC_START_END
00002BA0                          2841  
00002BA0                          2842             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BA0  0285 0000FE3F           2843              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BA6  0685 00000000           2844              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BAC                          2845  
00002BAC                          2846              
00002BAC  6100 0BA0               2847              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BB0  163C 002C               2848              MOVE.B  #',',D3
00002BB4  6100 1436               2849              BSR     PUSH_STACK
00002BB8  6100 0FC4               2850              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BBC                          2851              
00002BBC  6000 F988               2852              BRA     OP1001_ADD_RETURN
00002BC0                          2853  OP1100_PRINT_L 
00002BC0  163C 004C               2854              MOVE.B  #'L',D3
00002BC4  6100 1426               2855              BSR     PUSH_STACK
00002BC8                          2856              
00002BC8                          2857              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BC8  13FC 0000 00004976      2858              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BD0  13FC 0002 00004977      2859              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BD8                          2860             
00002BD8                          2861              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BD8  13FC 00B9 00004979      2862              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BE0  13FC 0020 0000497A      2863              MOVE.B   #$20,GET_SRC_START_END
00002BE8                          2864  
00002BE8                          2865              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BE8  0285 0000FE3F           2866              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BEE  0685 00000000           2867              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BF4                          2868  
00002BF4                          2869                     
00002BF4  6100 0B58               2870              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BF8  163C 002C               2871              MOVE.B  #',',D3
00002BFC  6100 13EE               2872              BSR     PUSH_STACK                  
00002C00  6100 0F7C               2873              BSR     GET_EA_EA_DEST       *GETS Dn    
00002C04                          2874  
00002C04                          2875              
00002C04  6000 0002               2876              BRA     OP1100_AND_RETURN
00002C08                          2877              
00002C08                          2878  OP1100_AND_RETURN
00002C08  4E75                    2879              RTS
00002C0A                          2880  
00002C0A                          2881  
00002C0A                          2882  *---------------------------------------------------------------------------*
00002C0A                          2883  * OP1101: Decode ADD/ADDA
00002C0A                          2884  *---------------------------------------------------------------------------* 
00002C0A  4280                    2885  OP1101      CLR.L   D0                  
00002C0C  4281                    2886              CLR.L   D1       
00002C0E  4284                    2887              CLR.L   D4                   
00002C10  227C 00000000           2888              MOVEA.L #0, A1              
00002C16  2205                    2889              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002C18                          2890              
00002C18                          2891              *CLEAR D3
00002C18  4283                    2892              CLR.L   D3
00002C1A                          2893              
00002C1A                          2894              
00002C1A                          2895              
00002C1A                          2896              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002C1A  2205                    2897              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C1C                          2898              *BITS (INDEX 8) 
00002C1C                          2899              *0 = ADD.B/W/L <EA>,Dn
00002C1C                          2900              *1 = ADD.B/W/L Dn,<EA> 
00002C1C  EC99                    2901              ROR.L   #6,D1
00002C1E  0281 00000007           2902              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002C24  0C81 00000007           2903              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002C2A  6700 0010               2904              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002C2E  0C81 00000003           2905              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002C34  6700 0078               2906              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002C38  6000 00E6               2907              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002C3C                          2908              
00002C3C                          2909  OP1101_ADDA_L
00002C3C                          2910              *LOAD STACK WITH THIS OPMODE
00002C3C  6100 13AE               2911              BSR     PUSH_STACK
00002C40  163C 0041               2912              MOVE.B  #'A',D3
00002C44  6100 13A6               2913              BSR     PUSH_STACK
00002C48  163C 0044               2914              MOVE.B  #'D',D3
00002C4C  6100 139E               2915              BSR     PUSH_STACK
00002C50  163C 0044               2916              MOVE.B  #'D',D3
00002C54  6100 1396               2917              BSR     PUSH_STACK
00002C58  163C 0041               2918              MOVE.B  #'A',D3
00002C5C  6100 138E               2919              BSR     PUSH_STACK
00002C60  163C 002E               2920              MOVE.B  #'.',D3
00002C64  6100 1386               2921              BSR     PUSH_STACK
00002C68  163C 004C               2922              MOVE.B  #'L',D3
00002C6C  6100 137E               2923              BSR     PUSH_STACK
00002C70                          2924              
00002C70                          2925             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C70  13FC 0000 00004976      2926             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C78  13FC 0000 00004977      2927             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C80                          2928             
00002C80                          2929             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C80  13FC 00B9 00004979      2930             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C88  13FC 0020 0000497A      2931             MOVE.B   #$20,GET_SRC_START_END
00002C90                          2932  
00002C90                          2933              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C90  0285 0000FE3F           2934              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C96  0685 00000040           2935              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C9C                          2936       
00002C9C                          2937              *PRINT <EA>,AN
00002C9C  6100 0AB0               2938              BSR     GET_EA_EA_SRC       *GETS <ea>
00002CA0  163C 002C               2939              MOVE.B  #',',D3
00002CA4  6100 1346               2940              BSR     PUSH_STACK                     
00002CA8  6100 0ED4               2941              BSR     GET_EA_EA_DEST      *GETS Dn
00002CAC                          2942  
00002CAC                          2943              
00002CAC                          2944              
00002CAC  4E75                    2945              RTS
00002CAE                          2946  OP1101_ADDA_W
00002CAE                          2947              *LOAD STACK WITH THIS OPMODE
00002CAE  6100 133C               2948              BSR     PUSH_STACK
00002CB2  163C 0041               2949              MOVE.B  #'A',D3
00002CB6  6100 1334               2950              BSR     PUSH_STACK
00002CBA  163C 0044               2951              MOVE.B  #'D',D3
00002CBE  6100 132C               2952              BSR     PUSH_STACK
00002CC2  163C 0044               2953              MOVE.B  #'D',D3
00002CC6  6100 1324               2954              BSR     PUSH_STACK
00002CCA  163C 0041               2955              MOVE.B  #'A',D3
00002CCE  6100 131C               2956              BSR     PUSH_STACK
00002CD2  163C 002E               2957              MOVE.B  #'.',D3
00002CD6  6100 1314               2958              BSR     PUSH_STACK
00002CDA  163C 0057               2959              MOVE.B  #'W',D3
00002CDE  6100 130C               2960              BSR     PUSH_STACK
00002CE2                          2961              
00002CE2                          2962             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CE2  13FC 0000 00004976      2963             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CEA  13FC 0000 00004977      2964             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CF2                          2965             
00002CF2                          2966             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CF2  13FC 00B9 00004979      2967             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CFA  13FC 0020 0000497A      2968             MOVE.B   #$20,GET_SRC_START_END
00002D02                          2969  
00002D02                          2970              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D02  0285 0000FE3F           2971              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D08  0685 00000040           2972              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002D0E                          2973       
00002D0E                          2974              *PRINT <EA>,AN
00002D0E  6100 0A3E               2975              BSR     GET_EA_EA_SRC       *GETS <ea>
00002D12  163C 002C               2976              MOVE.B  #',',D3
00002D16  6100 12D4               2977              BSR     PUSH_STACK                     
00002D1A  6100 0E62               2978              BSR     GET_EA_EA_DEST      *GETS Dn
00002D1E                          2979  
00002D1E  4E75                    2980              RTS
00002D20                          2981  
00002D20                          2982  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002D20                          2983              *LOAD STACK WITH THIS OPMODE
00002D20  6100 12CA               2984              BSR     PUSH_STACK
00002D24  163C 0041               2985              MOVE.B  #'A',D3
00002D28  6100 12C2               2986              BSR     PUSH_STACK
00002D2C  163C 0044               2987              MOVE.B  #'D',D3
00002D30  6100 12BA               2988              BSR     PUSH_STACK
00002D34  163C 0044               2989              MOVE.B  #'D',D3
00002D38  6100 12B2               2990              BSR     PUSH_STACK
00002D3C  163C 002E               2991              MOVE.B  #'.',D3
00002D40  6100 12AA               2992              BSR     PUSH_STACK
00002D44                          2993              
00002D44  2205                    2994              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002D46                          2995              
00002D46                          2996              *BITS (INDEX 8) 
00002D46                          2997              *0 = ADD.B/W/L <EA>,Dn
00002D46                          2998              *1 = ADD.B/W/L Dn,<EA> 
00002D46  E099                    2999              ROR.L   #8,D1
00002D48  0281 00000001           3000              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002D4E  0C81 00000000           3001              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002D54  6700 0102               3002              BEQ     OP1101_EA_DN
00002D58                          3003              *else procede to Dn_EA
00002D58                          3004              
00002D58                          3005  OP1101_DN_EA
00002D58                          3006              *BITS (7 TO 6) 
00002D58                          3007              *00 = .B
00002D58                          3008              *01 = .W
00002D58                          3009              *10 = .L 
00002D58  2205                    3010              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002D5A  EC99                    3011              ROR.L   #6,D1
00002D5C  0281 00000003           3012              ANDI.L  #$03,D1
00002D62  0C81 00000000           3013              CMPI.L  #$00,D1 *EQUALS .B
00002D68  6700 0016               3014              BEQ     OP1101_PRINT_B2
00002D6C  0C81 00000001           3015              CMPI.L  #$01,D1 *EQUALS .W
00002D72  6700 0054               3016              BEQ     OP1101_PRINT_W2
00002D76  0C81 00000002           3017              CMPI.L  #$02,D1 *EQUALS .L
00002D7C  6700 0092               3018              BEQ     OP1101_PRINT_L2
00002D80                          3019  OP1101_PRINT_B2
00002D80                          3020              *PUSH 'B'
00002D80  163C 0042               3021              MOVE.B  #'B',D3
00002D84  6100 1266               3022              BSR     PUSH_STACK
00002D88                          3023             
00002D88                          3024              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D88  13FC 0002 00004976      3025             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D90  13FC 0083 00004977      3026             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D98                          3027             
00002D98                          3028             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D98  13FC 00B9 00004979      3029             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DA0  13FC 0020 0000497A      3030             MOVE.B   #$20,GET_SRC_START_END
00002DA8                          3031  
00002DA8                          3032              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DA8  0285 0000FE3F           3033              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DAE  0685 00000000           3034              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DB4                          3035       
00002DB4  6100 0DC8               3036              BSR     GET_EA_EA_DEST      *GETS Dn
00002DB8  163C 002C               3037              MOVE.B  #',',D3
00002DBC  6100 122E               3038              BSR     PUSH_STACK                     
00002DC0  6100 098C               3039              BSR     GET_EA_EA_SRC       *GETS <ea>
00002DC4                          3040  
00002DC4                          3041              
00002DC4  6000 0192               3042              BRA     OP1101_ADD_RETURN
00002DC8                          3043  OP1101_PRINT_W2
00002DC8  163C 0057               3044              MOVE.B  #'W',D3
00002DCC  6100 121E               3045              BSR     PUSH_STACK
00002DD0                          3046  
00002DD0                          3047              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DD0  13FC 0000 00004976      3048              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DD8  13FC 0083 00004977      3049              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DE0                          3050             
00002DE0                          3051              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DE0  13FC 00B9 00004979      3052              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DE8  13FC 0020 0000497A      3053              MOVE.B   #$20,GET_SRC_START_END
00002DF0                          3054  
00002DF0                          3055              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DF0  0285 0000FE3F           3056              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DF6  0685 00000000           3057              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DFC                          3058  
00002DFC                          3059        
00002DFC  6100 0D80               3060              BSR     GET_EA_EA_DEST      *GETS Dn
00002E00  163C 002C               3061              MOVE.B  #',',D3
00002E04  6100 11E6               3062              BSR     PUSH_STACK               
00002E08  6100 0944               3063              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002E0C                          3064  
00002E0C                          3065  
00002E0C                          3066  
00002E0C  6000 014A               3067              BRA     OP1101_ADD_RETURN
00002E10                          3068  OP1101_PRINT_L2 
00002E10  163C 004C               3069              MOVE.B  #'L',D3
00002E14  6100 11D6               3070              BSR     PUSH_STACK
00002E18                          3071              
00002E18                          3072              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E18  13FC 0000 00004976      3073              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E20  13FC 0083 00004977      3074              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E28                          3075             
00002E28                          3076              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E28  13FC 00B9 00004979      3077              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E30  13FC 0020 0000497A      3078              MOVE.B   #$20,GET_SRC_START_END
00002E38                          3079  
00002E38                          3080             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E38  0285 0000FE3F           3081              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E3E  0685 00000000           3082              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E44                          3083  
00002E44                          3084               
00002E44  6100 0D38               3085              BSR     GET_EA_EA_DEST       *GETS Dn
00002E48  163C 002C               3086              MOVE.B  #',',D3
00002E4C  6100 119E               3087              BSR     PUSH_STACK          
00002E50  6100 08FC               3088              BSR     GET_EA_EA_SRC        *GETS <ea>
00002E54                          3089  
00002E54  6000 0102               3090              BRA     OP1101_ADD_RETURN
00002E58                          3091              
00002E58                          3092  OP1101_EA_DN           
00002E58                          3093              *BITS (7 TO 6) 
00002E58                          3094              *00 = .B
00002E58                          3095              *01 = .W
00002E58                          3096              *10 = .L 
00002E58  2205                    3097              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002E5A  EC99                    3098              ROR.L   #6,D1
00002E5C  0281 00000003           3099              ANDI.L  #$03,D1
00002E62  0C81 00000000           3100              CMPI.L  #$00,D1 *EQUALS .B
00002E68  6700 0016               3101              BEQ     OP1101_PRINT_B
00002E6C  0C81 00000001           3102              CMPI.L  #$01,D1 *EQUALS .W
00002E72  6700 0054               3103              BEQ     OP1101_PRINT_W
00002E76  0C81 00000002           3104              CMPI.L  #$02,D1 *EQUALS .L
00002E7C  6700 0092               3105              BEQ     OP1101_PRINT_L
00002E80                          3106  OP1101_PRINT_B
00002E80  163C 0042               3107              MOVE.B  #'B',D3
00002E84  6100 1166               3108              BSR     PUSH_STACK
00002E88                          3109                
00002E88                          3110              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E88  13FC 0002 00004976      3111              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E90  13FC 0002 00004977      3112              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E98                          3113             
00002E98                          3114              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E98  13FC 00B9 00004979      3115              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002EA0  13FC 0020 0000497A      3116              MOVE.B   #$20,GET_SRC_START_END
00002EA8                          3117  
00002EA8                          3118             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002EA8  0285 0000FE3F           3119              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EAE  0685 00000000           3120              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EB4                          3121  
00002EB4                          3122              
00002EB4  6100 0898               3123              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EB8  163C 002C               3124              MOVE.B  #',',D3
00002EBC  6100 112E               3125              BSR     PUSH_STACK          
00002EC0  6100 0CBC               3126              BSR     GET_EA_EA_DEST       *GETS Dn
00002EC4                          3127              
00002EC4  6000 0092               3128              BRA     OP1101_ADD_RETURN
00002EC8                          3129  OP1101_PRINT_W
00002EC8  163C 0057               3130              MOVE.B  #'W',D3
00002ECC  6100 111E               3131              BSR     PUSH_STACK
00002ED0                          3132  
00002ED0                          3133              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002ED0  13FC 0000 00004976      3134              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002ED8  13FC 0000 00004977      3135              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002EE0                          3136             
00002EE0                          3137              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002EE0  13FC 00B9 00004979      3138              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002EE8  13FC 0020 0000497A      3139              MOVE.B   #$20,GET_SRC_START_END
00002EF0                          3140  
00002EF0                          3141             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002EF0  0285 0000FE3F           3142              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EF6  0685 00000000           3143              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EFC                          3144  
00002EFC                          3145              
00002EFC  6100 0850               3146              BSR     GET_EA_EA_SRC      *GETS <ea>
00002F00  163C 002C               3147              MOVE.B  #',',D3
00002F04  6100 10E6               3148              BSR     PUSH_STACK
00002F08  6100 0C74               3149              BSR     GET_EA_EA_DEST       *GETS Dn    
00002F0C                          3150              
00002F0C  6000 004A               3151              BRA     OP1101_ADD_RETURN
00002F10                          3152  OP1101_PRINT_L 
00002F10  163C 004C               3153              MOVE.B  #'L',D3
00002F14  6100 10D6               3154              BSR     PUSH_STACK
00002F18                          3155              
00002F18                          3156              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002F18  13FC 0000 00004976      3157              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002F20  13FC 0000 00004977      3158              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002F28                          3159             
00002F28                          3160              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002F28  13FC 00B9 00004979      3161              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002F30  13FC 0020 0000497A      3162              MOVE.B   #$20,GET_SRC_START_END
00002F38                          3163  
00002F38                          3164              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002F38  0285 0000FE3F           3165              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002F3E  0685 00000000           3166              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002F44                          3167  
00002F44                          3168                     
00002F44  6100 0808               3169              BSR     GET_EA_EA_SRC      *GETS <ea>
00002F48  163C 002C               3170              MOVE.B  #',',D3
00002F4C  6100 109E               3171              BSR     PUSH_STACK                  
00002F50  6100 0C2C               3172              BSR     GET_EA_EA_DEST       *GETS Dn    
00002F54                          3173  
00002F54                          3174              
00002F54  6000 0002               3175              BRA     OP1101_ADD_RETURN
00002F58                          3176              
00002F58                          3177  OP1101_ADD_RETURN
00002F58  4E75                    3178              RTS
00002F5A                          3179              
00002F5A                          3180              *ADDW
00002F5A  0C01 0006               3181              CMPI.B  #$6,D1
00002F5E  6700 0056               3182              BEQ     OP_ADDA_W
00002F62  0C01 000E               3183              CMPI.B  #$E,D1
00002F66  6700 0066               3184              BEQ     OP_ADDA_L 
00002F6A                          3185  
00002F6A  4EF8 1768               3186              JMP     OP_DATA  
00002F6E                          3187            
00002F6E                          3188  *---------------------------------------------------------------------------*
00002F6E                          3189  * OP_ADD: display ADD and proceed to EA
00002F6E                          3190  *---------------------------------------------------------------------------*  
00002F6E  43F9 0000482D           3191  OP_ADD_B    LEA     DISP_ADD_B,A1
00002F74  103C 000E               3192              MOVE.B  #14,D0
00002F78  4E4F                    3193              TRAP    #15
00002F7A  183C 0000               3194              MOVE.B  #0,D4
00002F7E  4EF9 000032FE           3195              JMP     EA_GEN
00002F84                          3196  
00002F84  4E75                    3197              RTS
00002F86                          3198  
00002F86  43F9 00004836           3199  OP_ADD_W    LEA     DISP_ADD_W,A1
00002F8C  103C 000E               3200              MOVE.B  #14,D0
00002F90  4E4F                    3201              TRAP    #15
00002F92  183C 0001               3202              MOVE.B  #1,D4
00002F96  4EF9 000032FE           3203              JMP     EA_GEN
00002F9C                          3204  
00002F9C  4E75                    3205              RTS
00002F9E                          3206  
00002F9E  43F9 0000483F           3207  OP_ADD_L    LEA     DISP_ADD_L,A1
00002FA4  103C 000E               3208              MOVE.B  #14,D0
00002FA8  4E4F                    3209              TRAP    #15
00002FAA  183C 0002               3210              MOVE.B  #2,D4
00002FAE  4EF9 000032FE           3211              JMP     EA_GEN
00002FB4                          3212  
00002FB4  4E75                    3213              RTS
00002FB6                          3214  
00002FB6                          3215  *---------------------------------------------------------------------------*
00002FB6                          3216  * OP_ADDA: display ADDA and proceed to EA
00002FB6                          3217  *---------------------------------------------------------------------------*  
00002FB6  43F9 00004848           3218  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002FBC  103C 000E               3219              MOVE.B  #14,D0
00002FC0  4E4F                    3220              TRAP    #15
00002FC2  183C 0001               3221              MOVE.B  #1,D4
00002FC6  4EF9 000032FE           3222              JMP     EA_GEN
00002FCC                          3223  
00002FCC  4E75                    3224              RTS
00002FCE                          3225  
00002FCE  43F9 00004852           3226  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002FD4  103C 000E               3227              MOVE.B  #14,D0
00002FD8  4E4F                    3228              TRAP    #15
00002FDA  183C 0002               3229              MOVE.B  #2,D4
00002FDE  4EF9 000032FE           3230              JMP     EA_GEN
00002FE4                          3231  
00002FE4  4E75                    3232              RTS
00002FE6                          3233              
00002FE6                          3234  *---------------------------------------------------------------------------*
00002FE6                          3235  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002FE6                          3236  *---------------------------------------------------------------------------* 
00002FE6  4280                    3237  OP1110      CLR.L   D0                  
00002FE8  4281                    3238              CLR.L   D1   
00002FEA  4284                    3239              CLR.L   D4                   
00002FEC  227C 00000000           3240              MOVEA.L #0, A1                 
00002FF2  2205                    3241              MOVE.L  D5,D1
00002FF4                          3242              
00002FF4                          3243              *1)CHECK FOR MEMORY ROTATE/SHIFT FIRST
00002FF4  2205                    3244              MOVE.L  D5,D1                   *RESET
00002FF6  0281 0000FEC0           3245              ANDI.L  #%1111111011000000,D1
00002FFC  0C81 0000E0C0           3246              CMPI.L  #%1110000011000000,D1
00003002  6700 0276               3247              BEQ     OP_ASX                  *ASX
00003006                          3248  
00003006                          3249              
00003006  0281 0000FEC0           3250              ANDI.L  #%1111111011000000,D1
0000300C  0C81 0000E6C0           3251              CMPI.L  #%1110011011000000,D1
00003012  6700 0276               3252              BEQ     OP_ROX                  *ROX
00003016                          3253  
00003016  2205                    3254              MOVE.L  D5,D1                   *RESET
00003018  0281 0000FEC0           3255              ANDI.L  #%1111111011000000,D1
0000301E  0C81 0000E2C0           3256              CMPI.L  #%1110001011000000,D1
00003024  6700 003A               3257              BEQ     OP_LSX                  *LSX
00003028                          3258  
00003028                          3259    
00003028                          3260              *2) CHECK FOR REGISTER SHIFTS
00003028  2205                    3261              MOVE.L  D5,D1                   *RESET
0000302A  0281 0000F018           3262              ANDI.L  #%1111000000011000,D1
00003030  0C81 0000E008           3263              CMPI.L  #%1110000000001000,D1
00003036  6700 0028               3264              BEQ     OP_LSX                  *LSX
0000303A                          3265  
0000303A                          3266              
0000303A  2205                    3267              MOVE.L  D5,D1                   *RESET
0000303C  0281 0000F018           3268              ANDI.L  #%1111000000011000,D1
00003042  0C81 0000E000           3269              CMPI.L  #%1110000000000000,D1
00003048  6700 0230               3270              BEQ     OP_ASX                  *ASX
0000304C                          3271  
0000304C                          3272              
0000304C  2205                    3273              MOVE.L  D5,D1                   *RESET
0000304E  0281 0000F018           3274              ANDI.L  #%1111000000011000,D1
00003054  0C81 0000E018           3275              CMPI.L  #%1110000000011000,D1
0000305A  6700 022E               3276              BEQ     OP_ROX                  *ROX
0000305E                          3277  
0000305E                          3278  
0000305E                          3279                          
0000305E                          3280  OP1110_RETURN       
0000305E  4E75                    3281              RTS
00003060                          3282  
00003060                          3283  
00003060                          3284  *---------------------------------------------------------------------------*
00003060                          3285  * OP_LSR: decode and display LSR
00003060                          3286  *---------------------------------------------------------------------------*        
00003060                          3287  OP_LSX     
00003060  163C 004C               3288              MOVE.B  #'L',D3
00003064  6100 0F86               3289              BSR     PUSH_STACK
00003068  163C 0053               3290              MOVE.B  #'S',D3
0000306C  6100 0F7E               3291              BSR     PUSH_STACK
00003070                          3292              
00003070                          3293              *FIND IF ITS RIGHT OR LEFT DIR
00003070  2205                    3294              MOVE.L  D5,D1                   *RESET
00003072  0281 00000100           3295              ANDI.L  #%0000000100000000,D1
00003078  0C81 00000000           3296              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
0000307E  6700 000E               3297              BEQ     OP_LSX_R      
00003082  163C 004C               3298              MOVE.B  #'L',D3
00003086  6100 0F64               3299              BSR     PUSH_STACK
0000308A  6000 000A               3300              BRA     OP_LSX_DIR
0000308E                          3301  OP_LSX_R           
0000308E  163C 0052               3302              MOVE.B  #'R',D3
00003092  6100 0F58               3303              BSR     PUSH_STACK
00003096                          3304              
00003096                          3305  OP_LSX_DIR
00003096  163C 002E               3306              MOVE.B  #'.',D3
0000309A  6100 0F50               3307              BSR     PUSH_STACK
0000309E                          3308  
0000309E                          3309              *FIND SIZE OF OPCODE
0000309E  2205                    3310              MOVE.L  D5,D1                   *RESET
000030A0  0281 000000C0           3311              ANDI.L  #%0000000011000000,D1
000030A6  0C81 00000080           3312              CMPI.L  #%0000000010000000,D1            *L
000030AC  6700 0016               3313              BEQ     OP_LSX_L
000030B0  0C81 00000040           3314              CMPI.L  #%0000000001000000,D1            *W
000030B6  6700 0018               3315              BEQ     OP_LSX_W  
000030BA  0C81 00000000           3316              CMPI.L  #%0000000000000000,D1            *W
000030C0  6700 001A               3317              BEQ     OP_LSX_B       
000030C4                          3318                                      *OTHERWISE B    
000030C4                          3319              
000030C4                          3320  OP_LSX_L
000030C4  163C 004C               3321              MOVE.B  #'L',D3
000030C8  6100 0F22               3322              BSR     PUSH_STACK
000030CC  6000 001A               3323              BRA     OP_LSX_CHECK_FORMAT 
000030D0                          3324  OP_LSX_W
000030D0  163C 0057               3325              MOVE.B  #'W',D3
000030D4  6100 0F16               3326              BSR     PUSH_STACK
000030D8  6000 000E               3327              BRA     OP_LSX_CHECK_FORMAT 
000030DC                          3328  OP_LSX_B
000030DC  163C 0042               3329              MOVE.B  #'B',D3
000030E0  6100 0F0A               3330              BSR     PUSH_STACK
000030E4  6000 0002               3331              BRA     OP_LSX_CHECK_FORMAT 
000030E8                          3332                        
000030E8                          3333  OP_LSX_CHECK_FORMAT              
000030E8                          3334              * CHECKS IF ITS A MEMORY SHIFT FORMAT
000030E8  2205                    3335              MOVE.L  D5,D1                   *RESET
000030EA  0281 0000FEC0           3336              ANDI.L  #%1111111011000000,D1
000030F0  0C81 0000E2C0           3337              CMPI.L  #%1110001011000000,D1
000030F6  6700 0156               3338              BEQ     OP_LSX_MEMORY           
000030FA                          3339              
000030FA                          3340              *ELSE ITS REGISTER
000030FA                          3341  OP_LSX_REGISTER
000030FA                          3342             *TODO
000030FA                          3343             *CHECK IF ITS INTERMEDIATE OR REGISTER
000030FA  2205                    3344             MOVE.L  D5,D1                   *RESET
000030FC  EA99                    3345             ROR.L   #5,D1 
000030FE  0281 00000001           3346             ANDI.L  #1,D1
00003104  0C81 00000000           3347             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
0000310A  6700 003E               3348             BEQ     OP_LSX_INTERMEDIATE
0000310E                          3349             *ELSE ITS DATA REGISTER
0000310E                          3350  
0000310E                          3351             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000310E  13FC 0082 00004976      3352             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003116  13FC 0000 00004977      3353             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000311E                          3354             
0000311E                          3355             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000311E  13FC 00B9 00004979      3356             MOVE.B   #$B9,GET_DST_START_END
00003126  13FC 0020 0000497A      3357             MOVE.B   #$20,GET_SRC_START_END
0000312E                          3358             
0000312E                          3359             *SETS BOTH SRC/DEST MODES TO "Dn"
0000312E  0285 0000FE07           3360             ANDI.L   #%1111111000000111,D5
00003134  0685 00000000           3361             ADDI.L   #%0000000000000000,D5
0000313A                          3362             
0000313A                          3363              *CLEAR D3
0000313A  4283                    3364              CLR.L   D3
0000313C                          3365           
0000313C  163C 002C               3366              MOVE.B  #',',D3
00003140  6100 0EAA               3367              BSR     PUSH_STACK
00003144  6100 0608               3368              BSR     GET_EA_EA_SRC
00003148                          3369              
00003148  4E75                    3370              RTS
0000314A                          3371  
0000314A                          3372  OP_LSX_INTERMEDIATE
0000314A                          3373             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000314A  13FC 0082 00004976      3374             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003152  13FC 0000 00004977      3375             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000315A                          3376             
0000315A                          3377             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000315A  13FC 00B9 00004979      3378             MOVE.B   #$B9,GET_DST_START_END
00003162  13FC 0020 0000497A      3379             MOVE.B   #$20,GET_SRC_START_END
0000316A                          3380             
0000316A                          3381             *SETS BOTH SRC/DEST MODES TO "Dn"
0000316A  0285 0000FE07           3382             ANDI.L   #%1111111000000111,D5
00003170  0685 00000000           3383             ADDI.L   #%0000000000000000,D5
00003176                          3384             
00003176                          3385              *CLEAR D3
00003176  4283                    3386              CLR.L   D3
00003178                          3387             
00003178                          3388  *-------------------------grabbing #immediate data-----------------------*
00003178                          3389  
00003178                          3390  *GET DATA FROM ADDQ AND PRINT #0-8
00003178  163C 0020               3391              MOVE.B  #' ',D3
0000317C  6100 0E6E               3392              BSR     PUSH_STACK
00003180  163C 0023               3393              MOVE.B  #'#',D3
00003184  6100 0E66               3394              BSR     PUSH_STACK 
00003188                          3395  
00003188                          3396                       
00003188                          3397              *GET DATA #   
00003188  2205                    3398              MOVE.L  D5,D1
0000318A  EC99                    3399              ROR.L   #6,D1            
0000318C  E699                    3400              ROR.L   #3,D1
0000318E  0281 00000007           3401              ANDI.L  #$07,D1
00003194                          3402              
00003194  0C01 0000               3403              CMPI.B  #%000,D1
00003198  6700 003A               3404              BEQ     OP_LSX_0
0000319C  0C01 0001               3405              CMPI.B  #%001,D1
000031A0  6700 003E               3406              BEQ     OP_LSX_1
000031A4  0C01 0002               3407              CMPI.B  #%010,D1
000031A8  6700 0042               3408              BEQ     OP_LSX_2
000031AC  0C01 0003               3409              CMPI.B  #%011,D1
000031B0  6700 0046               3410              BEQ     OP_LSX_3
000031B4  0C01 0004               3411              CMPI.B  #%100,D1
000031B8  6700 004A               3412              BEQ     OP_LSX_4
000031BC  0C01 0005               3413              CMPI.B  #%101,D1
000031C0  6700 004E               3414              BEQ     OP_LSX_5
000031C4  0C01 0006               3415              CMPI.B  #%110,D1
000031C8  6700 0052               3416              BEQ     OP_LSX_6
000031CC  0C01 0007               3417              CMPI.B  #%111,D1
000031D0  6700 0056               3418              BEQ     OP_LSX_7
000031D4                          3419              
000031D4                          3420  OP_LSX_0
000031D4  163C 0030               3421              MOVE.B  #'0',D3
000031D8  6100 0E12               3422              BSR     PUSH_STACK
000031DC  6000 005E               3423              BRA     OP_LSX_AFTER_IMMEDIATE            
000031E0                          3424  OP_LSX_1
000031E0  163C 0031               3425              MOVE.B  #'1',D3
000031E4  6100 0E06               3426              BSR     PUSH_STACK
000031E8  6000 0052               3427              BRA     OP_LSX_AFTER_IMMEDIATE            
000031EC                          3428  OP_LSX_2
000031EC  163C 0032               3429              MOVE.B  #'2',D3
000031F0  6100 0DFA               3430              BSR     PUSH_STACK
000031F4  6000 0046               3431              BRA     OP_LSX_AFTER_IMMEDIATE            
000031F8                          3432  OP_LSX_3
000031F8  163C 0033               3433              MOVE.B  #'3',D3
000031FC  6100 0DEE               3434              BSR     PUSH_STACK
00003200  6000 003A               3435              BRA     OP_LSX_AFTER_IMMEDIATE            
00003204                          3436  OP_LSX_4
00003204  163C 0034               3437              MOVE.B  #'4',D3
00003208  6100 0DE2               3438              BSR     PUSH_STACK
0000320C  6000 002E               3439              BRA     OP_LSX_AFTER_IMMEDIATE           
00003210                          3440  OP_LSX_5
00003210  163C 0035               3441              MOVE.B  #'5',D3
00003214  6100 0DD6               3442              BSR     PUSH_STACK
00003218  6000 0022               3443              BRA     OP_LSX_AFTER_IMMEDIATE
0000321C                          3444  OP_LSX_6
0000321C  163C 0036               3445              MOVE.B  #'6',D3
00003220  6100 0DCA               3446              BSR     PUSH_STACK
00003224  6000 0016               3447              BRA     OP_LSX_AFTER_IMMEDIATE
00003228                          3448  OP_LSX_7
00003228  163C 0037               3449              MOVE.B  #'7',D3
0000322C  6100 0DBE               3450              BSR     PUSH_STACK
00003230  6000 000A               3451              BRA     OP_LSX_AFTER_IMMEDIATE
00003234                          3452  
00003234                          3453  OP_LSX_8
00003234  163C 0038               3454              MOVE.B  #'8',D3
00003238  6100 0DB2               3455              BSR     PUSH_STACK
0000323C                          3456              
0000323C                          3457  OP_LSX_AFTER_IMMEDIATE            
0000323C                          3458  
0000323C                          3459  *-------------------------grabbing #immediate data-----------------------*
0000323C                          3460  
0000323C  163C 002C               3461              MOVE.B  #',',D3
00003240  6100 0DAA               3462              BSR     PUSH_STACK
00003244  6100 0508               3463              BSR     GET_EA_EA_SRC
00003248                          3464              
00003248  4E75                    3465              RTS
0000324A                          3466  
0000324A  6000 002A               3467              BRA     OP_LSX_RETURN
0000324E                          3468              
0000324E                          3469              
0000324E                          3470  OP_LSX_MEMORY
0000324E                          3471             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000324E  13FC 0083 00004977      3472             MOVE.B   #$83,SRC_REGISTER_FORMAT
00003256                          3473             
00003256                          3474             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003256  13FC 00B9 00004979      3475             MOVE.B   #$B9,GET_DST_START_END
0000325E  13FC 0020 0000497A      3476             MOVE.B   #$20,GET_SRC_START_END
00003266                          3477             
00003266                          3478             *pop previous thing out
00003266  6100 0D8C               3479             BSR      POP_STACK
0000326A                          3480             
0000326A                          3481             *print w
0000326A  163C 0057               3482             MOVE.B  #'W',D3
0000326E  6100 0D7C               3483             BSR     PUSH_STACK
00003272  6100 04DA               3484             BSR     GET_EA_EA_SRC
00003276                          3485  
00003276                          3486  OP_LSX_RETURN
00003276  6000 FDE6               3487              BRA     OP1110_RETURN  
0000327A                          3488              
0000327A                          3489  *---------------------------------------------------------------------------*
0000327A                          3490  * OP_LSR: decode and display LSR IMMEDIATE/REGISTER
0000327A                          3491  *---------------------------------------------------------------------------*        
0000327A                          3492  OP_ASX
0000327A  43F9 00004892           3493              LEA     DISP_ASR_B,A1
00003280  103C 000E               3494              MOVE.B  #14,D0
00003284  4E4F                    3495              TRAP    #15
00003286                          3496  
00003286  6000 FDD6               3497              BRA     OP1110_RETURN  
0000328A                          3498      
0000328A                          3499  *---------------------------------------------------------------------------*
0000328A                          3500  * OP_ROX: decode and display LSR IMMEDIATE/REGISTER
0000328A                          3501  *---------------------------------------------------------------------------*        
0000328A                          3502  OP_ROX
0000328A                          3503  
0000328A  43F9 000048C8           3504              LEA     DISP_ROR_B,A1
00003290  103C 000E               3505              MOVE.B  #14,D0
00003294  4E4F                    3506              TRAP    #15
00003296                          3507  
00003296  6000 FDC6               3508              BRA     OP1110_RETURN  
0000329A                          3509  
0000329A                          3510  
0000329A                          3511  
0000329A                          3512  
0000329A                          3513  
0000329A                          3514  
0000329A                          3515  
0000329A                          3516  
0000329A                          3517  
0000329A                          3518  
0000329A                          3519  
0000329A                          3520  
0000329A                          3521  
0000329A                          3522  
0000329A                          3523  
0000329A                          3524  
0000329A                          3525  
0000329A                          3526  
0000329A                          3527  
0000329A                          3528  
0000329A                          3529  
0000329A                          3530  
0000329A                          3531              
0000329A                          3532  *---------------------------------------------------------------------------*
0000329A                          3533  * OP1111 : Special reserved
0000329A                          3534  *---------------------------------------------------------------------------*           
0000329A  4EF8 1768               3535  OP1111      JMP     OP_DATA
0000329E                          3536  
0000329E                          3537  *---------------------------------------------------------------------------*
0000329E                          3538  * EA_NOSRC: decode and display effective addresses for NEG/JSR
0000329E                          3539  *---------------------------------------------------------------------------*
0000329E                          3540  EA_NOSRC    
0000329E  4EB9 0000335C           3541              JSR     SRC_MODE
000032A4  43F9 000045C2           3542              LEA     ENDLINE_M,A1
000032AA  103C 000E               3543              MOVE.B  #14,D0
000032AE  4E4F                    3544              TRAP    #15
000032B0  4E75                    3545              RTS
000032B2                          3546              
000032B2                          3547  *---------------------------------------------------------------------------*
000032B2                          3548  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000032B2                          3549  *---------------------------------------------------------------------------*
000032B2                          3550  EA_ARITH
000032B2  4EB9 0000335C           3551              JSR     SRC_MODE
000032B8  43F9 0000493C           3552              LEA     DISP_D,A1
000032BE  103C 000E               3553              MOVE.B  #14,D0
000032C2  4E4F                    3554              TRAP    #15
000032C4  4EB9 000035E8           3555              JSR     DEST_REGISTER
000032CA  43F9 000045C2           3556              LEA     ENDLINE_M,A1
000032D0  103C 000E               3557              MOVE.B  #14,D0
000032D4  4E4F                    3558              TRAP    #15
000032D6  4E75                    3559              RTS
000032D8                          3560              
000032D8                          3561  *---------------------------------------------------------------------------*
000032D8                          3562  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000032D8                          3563  *---------------------------------------------------------------------------*
000032D8                          3564  EA_MOVEA
000032D8  4EB9 0000335C           3565              JSR     SRC_MODE
000032DE  43F9 0000494D           3566              LEA     DISP_AOP,A1
000032E4  103C 000E               3567              MOVE.B  #14,D0
000032E8  4E4F                    3568              TRAP    #15
000032EA  4EB9 000035E8           3569              JSR     DEST_REGISTER
000032F0  43F9 0000494B           3570              LEA     DISP_CP,A1
000032F6  103C 000D               3571              MOVE.B  #13,D0
000032FA  4E4F                    3572              TRAP    #15
000032FC  4E75                    3573              RTS
000032FE                          3574              
000032FE                          3575  *---------------------------------------------------------------------------*
000032FE                          3576  * EA_GEN: decode and display effective addresses for MOVE
000032FE                          3577  *---------------------------------------------------------------------------*
000032FE                          3578  EA_GEN          
000032FE                          3579              * retrieve/display source mode/register
000032FE  4EB9 0000335C           3580              JSR     SRC_MODE
00003304                          3581              
00003304                          3582              * retrieve/display destination mode/register
00003304  4EB9 00003318           3583              JSR     DEST_MODE
0000330A                          3584              
0000330A  43F9 000045C2           3585              LEA     ENDLINE_M,A1
00003310  103C 000E               3586              MOVE.B  #14,D0
00003314  4E4F                    3587              TRAP    #15
00003316                          3588              
00003316  4E75                    3589              RTS
00003318                          3590  
00003318                          3591  *---------------------------------------------------------------------------*
00003318                          3592  * DEST_MODE: decode and display destination mode (bit 8 - 6)
00003318                          3593  *---------------------------------------------------------------------------*           
00003318                          3594  DEST_MODE   
00003318                          3595              * clear registers to store temp data
00003318  4280                    3596              CLR.L   D0                      
0000331A  4281                    3597              CLR.L   D1                      
0000331C  207C 00000000           3598              MOVEA.L #0, A0                  
00003322  227C 00000000           3599              MOVEA.L #0, A1                  
00003328  2205                    3600              MOVE.L  D5,D1
0000332A  EC89                    3601              LSR.L   #6,D1
0000332C  0281 00000007           3602              ANDI.L  #$7,D1
00003332  0C01 0000               3603              CMPI.B  #0,D1   * Dn
00003336  6700 0082               3604              BEQ     D_MODE000
0000333A  0C01 0002               3605              CMPI.B  #2,D1   * (An)
0000333E  6700 00C2               3606              BEQ     D_MODE010
00003342  0C01 0003               3607              CMPI.B  #3,D1   * (An)+
00003346  6700 011A               3608              BEQ     D_MODE011
0000334A  0C01 0004               3609              CMPI.B  #4,D1   * -(An)
0000334E  6700 0132               3610              BEQ     D_MODE100
00003352  0C01 0007               3611              CMPI.B  #7,D1  * abs
00003356  6700 017C               3612              BEQ     D_MODE111 
0000335A  4E75                    3613              RTS
0000335C                          3614  
0000335C                          3615  *---------------------------------------------------------------------------*
0000335C                          3616  * SRC_MODE: decode and display source mode (bit 5 - 3)
0000335C                          3617  *---------------------------------------------------------------------------*  
0000335C                          3618  SRC_MODE    
0000335C                          3619              * clear registers to store temp data
0000335C  4280                    3620              CLR.L   D0                      
0000335E  4281                    3621              CLR.L   D1                      
00003360  207C 00000000           3622              MOVEA.L #0, A0                  
00003366  227C 00000000           3623              MOVEA.L #0, A1                  
0000336C  2205                    3624              MOVE.L  D5,D1
0000336E  E489                    3625              LSR.L   #2,D1
00003370  0281 0000000E           3626              ANDI.L  #$E,D1
00003376                          3627              
00003376  0C01 0000               3628              CMPI.B  #0,D1   * Dn
0000337A  6700 002A               3629              BEQ     MODE000
0000337E  0C01 0002               3630              CMPI.B  #2,D1   * An 
00003382  6700 004A               3631              BEQ     MODE001
00003386  0C01 0004               3632              CMPI.B  #4,D1   * (An)
0000338A  6700 0056               3633              BEQ     MODE010
0000338E  0C01 0006               3634              CMPI.B  #6,D1   * (An)+
00003392  6700 008E               3635              BEQ     MODE011
00003396  0C01 0008               3636              CMPI.B  #8,D1   * -(An)
0000339A  6700 00A6               3637              BEQ     MODE100
0000339E  0C01 000F               3638              CMPI.B  #15,D1  * abs/immediate
000033A2  6700 00FE               3639              BEQ     MODE111 
000033A6                          3640        
000033A6                          3641  *---------------------------------------------------------------------------*
000033A6                          3642  * MODE000: decode and display source mode Dn
000033A6                          3643  *---------------------------------------------------------------------------*           
000033A6                          3644  MODE000     *Dn
000033A6  43F9 0000493C           3645              LEA     DISP_D,A1
000033AC  103C 000E               3646              MOVE.B  #14,D0
000033B0  4E4F                    3647              TRAP    #15
000033B2  4EB9 00003644           3648              JSR     SRC_REGISTER
000033B8  4E75                    3649              RTS
000033BA                          3650  
000033BA                          3651  *---------------------------------------------------------------------------*
000033BA                          3652  * D_MODE000: decode and display dest mode Dn
000033BA                          3653  *---------------------------------------------------------------------------*
000033BA                          3654  D_MODE000     *Dn
000033BA  43F9 0000493C           3655              LEA     DISP_D,A1
000033C0  103C 000E               3656              MOVE.B  #14,D0
000033C4  4E4F                    3657              TRAP    #15
000033C6  4EB9 000035E8           3658              JSR     DEST_REGISTER
000033CC  4E75                    3659              RTS
000033CE                          3660  
000033CE                          3661  *---------------------------------------------------------------------------*
000033CE                          3662  * MODE001: decode and display source mode An
000033CE                          3663  *---------------------------------------------------------------------------* 
000033CE                          3664  MODE001 *An
000033CE  43F9 00004941           3665              LEA     DISP_A,A1
000033D4  103C 000E               3666              MOVE.B  #14,D0
000033D8  4E4F                    3667              TRAP    #15
000033DA  4EB9 00003644           3668              JSR     SRC_REGISTER
000033E0                          3669          
000033E0  4E75                    3670              RTS
000033E2                          3671  
000033E2                          3672  *---------------------------------------------------------------------------*
000033E2                          3673  * MODE010: decode and display source mode (An)
000033E2                          3674  *---------------------------------------------------------------------------*    
000033E2                          3675  MODE010 *(An)
000033E2  43F9 0000494D           3676              LEA     DISP_AOP,A1  *display (A
000033E8  103C 000E               3677              MOVE.B  #14,D0
000033EC  4E4F                    3678              TRAP    #15
000033EE                          3679  
000033EE  4EB9 00003644           3680              JSR     SRC_REGISTER * display register
000033F4                          3681  
000033F4  43F9 0000494B           3682              LEA     DISP_CP,A1   *display )
000033FA  103C 000E               3683              MOVE.B  #14,D0
000033FE  4E4F                    3684              TRAP    #15
00003400                          3685              
00003400  4E75                    3686              RTS
00003402                          3687  
00003402                          3688  *---------------------------------------------------------------------------*
00003402                          3689  * D_MODE010: decode and display dest mode (An)
00003402                          3690  *---------------------------------------------------------------------------*
00003402                          3691  D_MODE010 *(An)
00003402  43F9 0000494D           3692              LEA     DISP_AOP,A1  *display (A
00003408  103C 000E               3693              MOVE.B  #14,D0
0000340C  4E4F                    3694              TRAP    #15
0000340E                          3695     
0000340E  4EB9 000035E8           3696              JSR     DEST_REGISTER * display register
00003414                          3697  
00003414  43F9 0000494B           3698              LEA     DISP_CP,A1   *display )
0000341A  103C 000E               3699              MOVE.B  #14,D0
0000341E  4E4F                    3700              TRAP    #15
00003420                          3701              
00003420  4E75                    3702              RTS
00003422                          3703  
00003422                          3704  *---------------------------------------------------------------------------*
00003422                          3705  * MODE011: decode and display source mode (An)+
00003422                          3706  *---------------------------------------------------------------------------*
00003422                          3707  MODE011 *(An)+
00003422  43F9 0000494D           3708              LEA     DISP_AOP,A1      *display (A
00003428  103C 000E               3709              MOVE.B  #14,D0
0000342C  4E4F                    3710              TRAP    #15
0000342E                          3711              
0000342E  4EB9 00003644           3712              JSR     SRC_REGISTER    * display register
00003434                          3713  
00003434  43F9 0000495A           3714              LEA     DISP_POST,A1    *display )+
0000343A  103C 000E               3715              MOVE.B  #14,D0
0000343E  4E4F                    3716              TRAP    #15
00003440                          3717              
00003440  4E75                    3718              RTS
00003442                          3719              
00003442                          3720  *---------------------------------------------------------------------------*
00003442                          3721  * MODE100: decode and display source mode -(An)
00003442                          3722  *---------------------------------------------------------------------------*
00003442                          3723  MODE100 *-(An)
00003442  43F9 00004953           3724              LEA     DISP_PRE,A1    *display -(A
00003448  103C 000E               3725              MOVE.B  #14,D0
0000344C  4E4F                    3726              TRAP    #15
0000344E                          3727  
0000344E  4EB9 00003644           3728              JSR     SRC_REGISTER    *display register
00003454                          3729  
00003454  43F9 0000494B           3730              LEA     DISP_CP,A1   *display )
0000345A  103C 000E               3731              MOVE.B  #14,D0
0000345E  4E4F                    3732              TRAP    #15
00003460                          3733              
00003460  4E75                    3734              RTS
00003462                          3735  
00003462                          3736  *---------------------------------------------------------------------------*
00003462                          3737  * D_MODE011: decode and display dest mode (An)+
00003462                          3738  *---------------------------------------------------------------------------*
00003462                          3739  D_MODE011 *(An)+
00003462  43F9 0000494D           3740              LEA     DISP_AOP,A1      *display (A
00003468  103C 000E               3741              MOVE.B  #14,D0
0000346C  4E4F                    3742              TRAP    #15
0000346E                          3743  
0000346E  4EB9 000035E8           3744              JSR     DEST_REGISTER    * display register
00003474                          3745  
00003474  43F9 0000495A           3746              LEA     DISP_POST,A1    *display )+
0000347A  103C 000E               3747              MOVE.B  #14,D0
0000347E  4E4F                    3748              TRAP    #15
00003480                          3749              
00003480  4E75                    3750              RTS
00003482                          3751              
00003482                          3752  *---------------------------------------------------------------------------*
00003482                          3753  * D_MODE100: decode and display dest mode -(An)
00003482                          3754  *---------------------------------------------------------------------------*            
00003482                          3755  D_MODE100 *-(An)
00003482  43F9 00004953           3756              LEA     DISP_PRE,A1    *display -(A
00003488  103C 000E               3757              MOVE.B  #14,D0
0000348C  4E4F                    3758              TRAP    #15
0000348E                          3759              
0000348E  4EB9 000035E8           3760              JSR     DEST_REGISTER    *display register
00003494                          3761  
00003494  43F9 0000494B           3762              LEA     DISP_CP,A1   *display )
0000349A  103C 000E               3763              MOVE.B  #14,D0
0000349E  4E4F                    3764              TRAP    #15
000034A0                          3765              
000034A0  4E75                    3766              RTS
000034A2                          3767  
000034A2                          3768  *---------------------------------------------------------------------------*
000034A2                          3769  * MODE111: decode and display source mode absolute/immediate
000034A2                          3770  *---------------------------------------------------------------------------*
000034A2                          3771  MODE111     * abs/immediate
000034A2                          3772              * clear registers to store temp data
000034A2  4280                    3773              CLR.L   D0                      
000034A4  4281                    3774              CLR.L   D1                      
000034A6  207C 00000000           3775              MOVEA.L #0, A0                  
000034AC  227C 00000000           3776              MOVEA.L #0, A1                  
000034B2  2205                    3777              MOVE.L  D5,D1
000034B4                          3778              
000034B4                          3779              * retrieve source register for MODE 111
000034B4  E389                    3780              LSL.L   #1,D1   * shift the bits to left by 1
000034B6  0281 0000000E           3781              ANDI.L  #$E,D1  * mask the first 4 bits 
000034BC  0C01 0000               3782              CMPI.B  #0, D1  * if it's 0000, absolute word address
000034C0  6700 003E               3783              BEQ     WORDMODE
000034C4  0C01 0002               3784              CMPI.B  #2, D1  * if it's 0010, absolute long address
000034C8  6700 0062               3785              BEQ     LONGMODE
000034CC  0C01 0008               3786              CMPI.B  #8, D1  * if it's 1000, immediate data
000034D0  6700 0086               3787              BEQ     IMMEDIATE
000034D4                          3788       
000034D4                          3789  *---------------------------------------------------------------------------*
000034D4                          3790  * D_MODE111: decode and display dest mode absolute/immediate
000034D4                          3791  *---------------------------------------------------------------------------*           
000034D4                          3792  D_MODE111   * abs
000034D4                          3793              * clear registers to store temp data
000034D4  4280                    3794              CLR.L   D0                      
000034D6  4281                    3795              CLR.L   D1                      
000034D8  207C 00000000           3796              MOVEA.L #0, A0                  
000034DE  227C 00000000           3797              MOVEA.L #0, A1                  
000034E4  2205                    3798              MOVE.L  D5,D1
000034E6                          3799              
000034E6                          3800              * retrieve dest register for MODE 111
000034E6  EC89                    3801              LSR.L   #6,D1   * shift the bits to right by 6
000034E8  E689                    3802              LSR.L   #3,D1   * shift the bits to right by extra 3
000034EA  0201 0001               3803              ANDI.B  #1,D1   * mask the first 2 bits 
000034EE  0C01 0000               3804              CMPI.B  #0, D1  * if it's 000, absolute word address
000034F2  6700 000C               3805              BEQ     WORDMODE
000034F6  0C01 0001               3806              CMPI.B  #1, D1  * if it's 001, absolute long address
000034FA  6700 0030               3807              BEQ     LONGMODE
000034FE                          3808              *JSR     OP_DATA *not sure..
000034FE  4E75                    3809              RTS
00003500                          3810  
00003500                          3811  
00003500                          3812  *---------------------------------------------------------------------------*
00003500                          3813  * WORDMODE: absolute word address
00003500                          3814  *---------------------------------------------------------------------------*
00003500  43F9 00004937           3815  WORDMODE    LEA     DISP_HEX,A1
00003506  103C 000E               3816              MOVE.B  #14,D0
0000350A  4E4F                    3817              TRAP    #15
0000350C                          3818              
0000350C  4285                    3819              CLR.L   D5
0000350E  3A1D                    3820              MOVE.W  (A5)+,D5
00003510                          3821              
00003510  43F9 00004615           3822              LEA     TMPOUTPUT,A1
00003516  2205                    3823              MOVE.L  D5,D1
00003518  7404                    3824              MOVE.L  #4,D2       *move word size 4
0000351A  4EB8 1236               3825              JSR     HEX2ASCII
0000351E  43F9 00004615           3826              LEA     TMPOUTPUT,A1
00003524  103C 000E               3827              MOVE.B  #14,D0
00003528  4E4F                    3828              TRAP    #15
0000352A                          3829              
0000352A  4E75                    3830              RTS
0000352C                          3831  
0000352C                          3832  *---------------------------------------------------------------------------*
0000352C                          3833  * LONGMODE: absolute long address
0000352C                          3834  *---------------------------------------------------------------------------*
0000352C  43F9 00004937           3835  LONGMODE    LEA     DISP_HEX,A1
00003532  103C 000E               3836              MOVE.B  #14,D0
00003536  4E4F                    3837              TRAP    #15
00003538                          3838              
00003538  4285                    3839              CLR.L   D5
0000353A  2A1D                    3840              MOVE.L  (A5)+,D5
0000353C                          3841              
0000353C  43F9 00004615           3842              LEA     TMPOUTPUT,A1
00003542  2205                    3843              MOVE.L  D5,D1
00003544  7408                    3844              MOVE.L  #8,D2           *move longword size 8
00003546  4EB8 1236               3845              JSR     HEX2ASCII
0000354A  43F9 00004615           3846              LEA     TMPOUTPUT,A1
00003550  103C 000E               3847              MOVE.B  #14,D0
00003554  4E4F                    3848              TRAP    #15
00003556                          3849              
00003556  4E75                    3850              RTS
00003558                          3851  
00003558                          3852  
00003558                          3853  *---------------------------------------------------------------------------*
00003558                          3854  * IMMEDIATE: immediate address
00003558                          3855  *---------------------------------------------------------------------------*
00003558  43F9 0000495D           3856  IMMEDIATE   LEA     DISP_LB,A1
0000355E  103C 000E               3857              MOVE.B  #14,D0
00003562  4E4F                    3858              TRAP    #15
00003564  43F9 00004937           3859              LEA     DISP_HEX,A1
0000356A  103C 000E               3860              MOVE.B  #14,D0
0000356E  4E4F                    3861              TRAP    #15
00003570                          3862              
00003570                          3863              * check for size
00003570  0C04 0000               3864              CMPI.B  #0,D4
00003574  6700 0012               3865              BEQ     IMMD_B
00003578  0C04 0001               3866              CMPI.B  #1,D4
0000357C  6700 002A               3867              BEQ     IMMD_W
00003580  0C04 0002               3868              CMPI.B  #2,D4
00003584  6700 0042               3869              BEQ     IMMD_L
00003588                          3870  
00003588                          3871  IMMD_B
00003588  4285                    3872              CLR.L   D5
0000358A  3A1D                    3873              MOVE.W  (A5)+,D5
0000358C                          3874              
0000358C  43F9 00004615           3875              LEA     TMPOUTPUT,A1
00003592  2205                    3876              MOVE.L  D5,D1
00003594  7402                    3877              MOVE.L  #2,D2
00003596  4EB8 1236               3878              JSR     HEX2ASCII
0000359A  43F9 00004615           3879              LEA     TMPOUTPUT,A1
000035A0  103C 000E               3880              MOVE.B  #14,D0
000035A4  4E4F                    3881              TRAP    #15
000035A6  4E75                    3882              RTS
000035A8                          3883              
000035A8                          3884  IMMD_W
000035A8  4285                    3885              CLR.L   D5
000035AA  3A1D                    3886              MOVE.W  (A5)+,D5
000035AC                          3887              
000035AC  43F9 00004615           3888              LEA     TMPOUTPUT,A1
000035B2  2205                    3889              MOVE.L  D5,D1
000035B4  7404                    3890              MOVE.L  #4,D2
000035B6  4EB8 1236               3891              JSR     HEX2ASCII
000035BA  43F9 00004615           3892              LEA     TMPOUTPUT,A1
000035C0  103C 000E               3893              MOVE.B  #14,D0
000035C4  4E4F                    3894              TRAP    #15
000035C6  4E75                    3895              RTS
000035C8                          3896              
000035C8                          3897  
000035C8                          3898  IMMD_L
000035C8  4285                    3899              CLR.L   D5
000035CA  3A1D                    3900              MOVE.W  (A5)+,D5
000035CC                          3901              
000035CC  43F9 00004615           3902              LEA     TMPOUTPUT,A1
000035D2  2205                    3903              MOVE.L  D5,D1
000035D4  7408                    3904              MOVE.L  #8,D2
000035D6  4EB8 1236               3905              JSR     HEX2ASCII
000035DA  43F9 00004615           3906              LEA     TMPOUTPUT,A1
000035E0  103C 000E               3907              MOVE.B  #14,D0
000035E4  4E4F                    3908              TRAP    #15
000035E6  4E75                    3909              RTS
000035E8                          3910  
000035E8                          3911  
000035E8                          3912  *---------------------------------------------------------------------------*
000035E8                          3913  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000035E8                          3914  *---------------------------------------------------------------------------*
000035E8                          3915  DEST_REGISTER
000035E8                          3916              * clear registers to store temp data
000035E8  4280                    3917              CLR.L   D0                      
000035EA  4281                    3918              CLR.L   D1                      
000035EC  207C 00000000           3919              MOVEA.L #0, A0                  
000035F2  227C 00000000           3920              MOVEA.L #0, A1 
000035F8                          3921              
000035F8  2205                    3922              MOVE.L  D5,D1
000035FA  EC89                    3923              LSR.L   #6,D1
000035FC  E689                    3924              LSR.L   #3,D1
000035FE  0281 00000007           3925              ANDI.L  #7,D1
00003604                          3926              
00003604  0C01 0000               3927              CMPI.B  #0,D1
00003608  6700 0092               3928              BEQ     REG_0
0000360C  0C01 0001               3929              CMPI.B  #1,D1
00003610  6700 0098               3930              BEQ     REG_1
00003614  0C01 0002               3931              CMPI.B  #2,D1
00003618  6700 009E               3932              BEQ     REG_2
0000361C  0C01 0003               3933              CMPI.B  #3,D1
00003620  6700 00A4               3934              BEQ     REG_3
00003624  0C01 0004               3935              CMPI.B  #4,D1
00003628  6700 00AA               3936              BEQ     REG_4
0000362C  0C01 0005               3937              CMPI.B  #5,D1
00003630  6700 00B0               3938              BEQ     REG_5
00003634  0C01 0006               3939              CMPI.B  #6,D1
00003638  6700 00B6               3940              BEQ     REG_6
0000363C  0C01 0007               3941              CMPI.B  #7,D1
00003640  6700 00BC               3942              BEQ     REG_7
00003644                          3943  
00003644                          3944  *---------------------------------------------------------------------------*
00003644                          3945  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003644                          3946  *---------------------------------------------------------------------------*           
00003644                          3947  SRC_REGISTER 
00003644                          3948              * clear registers to store temp data
00003644  4280                    3949              CLR.L   D0                      
00003646  4281                    3950              CLR.L   D1                      
00003648  207C 00000000           3951              MOVEA.L #0, A0                  
0000364E  227C 00000000           3952              MOVEA.L #0, A1                  
00003654                          3953              
00003654  2205                    3954              MOVE.L  D5,D1   * temp store the processing data
00003656  0281 00000007           3955              ANDI.L  #7,D1   * mask the first 4 bits with 0111
0000365C                          3956              
0000365C  0C01 0000               3957              CMPI.B  #0,D1
00003660  6700 003A               3958              BEQ     REG_0
00003664  0C01 0001               3959              CMPI.B  #1,D1
00003668  6700 0040               3960              BEQ     REG_1
0000366C  0C01 0002               3961              CMPI.B  #2,D1
00003670  6700 0046               3962              BEQ     REG_2
00003674  0C01 0003               3963              CMPI.B  #3,D1
00003678  6700 004C               3964              BEQ     REG_3
0000367C  0C01 0004               3965              CMPI.B  #4,D1
00003680  6700 0052               3966              BEQ     REG_4
00003684  0C01 0005               3967              CMPI.B  #5,D1
00003688  6700 0058               3968              BEQ     REG_5
0000368C  0C01 0006               3969              CMPI.B  #6,D1
00003690  6700 005E               3970              BEQ     REG_6
00003694  0C01 0007               3971              CMPI.B  #7,D1
00003698  6700 0064               3972              BEQ     REG_7
0000369C                          3973  
0000369C                          3974  *---------------------------------------------------------------------------*
0000369C                          3975  * REG_0 ~ REG_7: display register 0 to 7
0000369C                          3976  *---------------------------------------------------------------------------*
0000369C  43F9 00004962           3977  REG_0       LEA     DISP_0,A1
000036A2  103C 000E               3978              MOVE.B  #14,D0
000036A6  4E4F                    3979              TRAP    #15
000036A8  4E75                    3980              RTS
000036AA                          3981              
000036AA  43F9 00004964           3982  REG_1       LEA     DISP_1,A1
000036B0  103C 000E               3983              MOVE.B  #14,D0
000036B4  4E4F                    3984              TRAP    #15
000036B6  4E75                    3985              RTS
000036B8                          3986              
000036B8                          3987  
000036B8  43F9 00004966           3988  REG_2       LEA     DISP_2,A1
000036BE  103C 000E               3989              MOVE.B  #14,D0
000036C2  4E4F                    3990              TRAP    #15
000036C4  4E75                    3991              RTS
000036C6                          3992            
000036C6  43F9 00004968           3993  REG_3       LEA     DISP_3,A1
000036CC  103C 000E               3994              MOVE.B  #14,D0
000036D0  4E4F                    3995              TRAP    #15
000036D2  4E75                    3996              RTS
000036D4                          3997              
000036D4  43F9 0000496A           3998  REG_4       LEA     DISP_4,A1
000036DA  103C 000E               3999              MOVE.B  #14,D0
000036DE  4E4F                    4000              TRAP    #15
000036E0  4E75                    4001              RTS
000036E2                          4002              
000036E2  43F9 0000496C           4003  REG_5       LEA     DISP_5,A1
000036E8  103C 000E               4004              MOVE.B  #14,D0
000036EC  4E4F                    4005              TRAP    #15
000036EE  4E75                    4006              RTS
000036F0                          4007              
000036F0  43F9 0000496E           4008  REG_6       LEA     DISP_6,A1
000036F6  103C 000E               4009              MOVE.B  #14,D0
000036FA  4E4F                    4010              TRAP    #15
000036FC  4E75                    4011              RTS
000036FE                          4012              
000036FE  43F9 00004970           4013  REG_7       LEA     DISP_7,A1
00003704  103C 000E               4014              MOVE.B  #14,D0
00003708  4E4F                    4015              TRAP    #15
0000370A  4E75                    4016              RTS
0000370C                          4017              
0000370C                          4018  *---------------------------------------------------------------------------*
0000370C                          4019  * REPEAT : Ask user whether they wish to run the program again
0000370C                          4020  *---------------------------------------------------------------------------*           
0000370C  4246                    4021  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
0000370E  43F9 0000443B           4022              LEA     REPEATMSG,A1
00003714  103C 000E               4023              MOVE.B  #14,D0
00003718  4E4F                    4024              TRAP    #15
0000371A                          4025              
0000371A  43F9 000045C5           4026              LEA     TMPINPUT,A1             * allocate space to temp store user input
00003720  103C 0002               4027              MOVE.B  #2,D0
00003724  4E4F                    4028              TRAP    #15
00003726                          4029  
00003726  0C01 0001               4030              CMPI.B  #1,D1                   * check for length of user input
0000372A  66E0                    4031              BNE     REPEAT                  * return to the beginning of the function if unequal
0000372C                          4032              
0000372C  0C11 0059               4033              CMPI.B  #$59,(A1)               * compare the input with Y    
00003730  6700 D8D8               4034              BEQ     PROGLP                  * repeat the program
00003734                          4035              
00003734  0C11 0079               4036              CMPI.B  #$79,(A1)               * compare the input with y    
00003738  6700 D8D0               4037              BEQ     PROGLP                  * repeat the program
0000373C                          4038              
0000373C  0C11 004E               4039              CMPI.B  #$4E,(A1)               * compare the input with N    
00003740  6700 098C               4040              BEQ     TERMINATE               * finish program
00003744                          4041              
00003744  0C11 006E               4042              CMPI.B  #$6E,(A1)               * compare the input with n    
00003748  6700 0984               4043              BEQ     TERMINATE               * finish program
0000374C                          4044              
0000374C  60BE                    4045              BRA     REPEAT                  * invalid input/repeat the function
0000374E                          4046  
0000374E                          4047  *---------------------------------------------------------------------------*
0000374E                          4048  * EA DECODING INTERFACE
0000374E                          4049  * [A0] - RESERVED FOR USE
0000374E                          4050  * [D2] - RESERVED FOR USE
0000374E                          4051  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
0000374E                          4052  *---------------------------------------------------------------------------*
0000374E                          4053  GET_EA_EA_SRC
0000374E                          4054      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
0000374E                          4055      
0000374E                          4056      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
0000374E  2405                    4057      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003750  E68A                    4058      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00003752  23C2 00004988           4059      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003758  7407                    4060      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
0000375A  C5B9 00004988           4061      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003760                          4062                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003760                          4063      
00003760                          4064      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003760                          4065      *DESTINATION REGISTER FORMAT STANDARD         *
00003760                          4066      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003760                          4067      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003760                          4068      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003760                          4069      *0 - Dn                                       *
00003760                          4070      *1 - An                                       *
00003760                          4071      *2 - (An)                                     *
00003760                          4072      *3 - (An)+                                    *
00003760                          4073      *4 - -(An)                                    *
00003760                          4074      *5 - (XXX).W                                  *
00003760                          4075      *6 - (XXX).L                                  *
00003760                          4076      *7 - #<data>                                  *
00003760                          4077      ***********************************************
00003760                          4078      
00003760                          4079      *** Check if source ...  <ea> = Dn
00003760                          4080  CHECK0    
00003760  41F9 00004978           4081            LEA     TEMP_REGISTER_FORMAT,A0
00003766  1439 00004977           4082            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000376C  1082                    4083            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000376E  0239 0001 00004978      4084            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003776  0C39 0001 00004978      4085            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
0000377E  6700 006A               4086            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003782  0CB9 00000000 00004988  4087            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
0000378C  6600 005C               4088            BNE     CHECK1
00003790                          4089            
00003790                          4090            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003790  163C 0020               4091            MOVE.B    #' ',D3
00003794  6100 0856               4092            BSR       PUSH_STACK
00003798  163C 0044               4093            MOVE.B    #'D',D3
0000379C  6100 084E               4094            BSR       PUSH_STACK
000037A0                          4095  
000037A0                          4096            *FIND REGISTER NUMBER END LOCATION*  
000037A0  13F9 0000497A 00004980  4097            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000037AA  0239 000F 00004980      4098            AND.B   #$0F,VAR_BYTE_END
000037B2                          4099            
000037B2                          4100            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000037B2  23C5 00004984           4101            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000037B8  1439 00004980           4102            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000037BE                          4103            
000037BE                          4104            *INTITIALIZE FOR BIT SHIFTING
000037BE  41F9 00004984           4105            LEA     VAR_TEMP_CLEANCOPY,A0
000037C4  2639 00004984           4106            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037CA                          4107  LOOP_SHIFTING
000037CA  0C02 0000               4108            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037CE  6700 0008               4109            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000037D2  E24B                    4110            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037D4  5302                    4111            SUB.B   #1,D2                     *DECREMENT COUNTER
000037D6  60F2                    4112            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000037D8                          4113  MASKING_NEXT
000037D8  C6BC 00000007           4114            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037DE  0603 0030               4115            ADD.B   #$30,D3                   *CONVERT TO CHAR
000037E2  6100 0808               4116            BSR     PUSH_STACK                *PUSH TO STACK
000037E6                          4117            
000037E6  6000 0394               4118            BRA     GET_SRC_SUCCESS           *RETURN          
000037EA                          4119            
000037EA                          4120            
000037EA                          4121            *** Check if source ...  <ea> = An
000037EA  41F9 00004978           4122  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000037F0  1439 00004977           4123            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037F6  1082                    4124            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037F8  0239 0002 00004978      4125            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003800  0C39 0002 00004978      4126            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003808  6700 006A               4127            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
0000380C  0CB9 00000001 00004988  4128            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003816  6600 005C               4129            BNE     CHECK2
0000381A                          4130            
0000381A                          4131            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000381A  163C 0020               4132            MOVE.B    #' ',D3
0000381E  6100 07CC               4133            BSR       PUSH_STACK
00003822  163C 0041               4134            MOVE.B    #'A',D3
00003826  6100 07C4               4135            BSR       PUSH_STACK
0000382A                          4136  
0000382A                          4137            
0000382A                          4138            *FIND REGISTER NUMBER END LOCATION*  
0000382A  13F9 0000497A 00004980  4139            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003834  0239 000F 00004980      4140            AND.B   #$0F,VAR_BYTE_END
0000383C                          4141            
0000383C                          4142            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000383C  23C5 00004984           4143            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003842  1439 00004980           4144            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003848                          4145            
00003848                          4146            *INTITIALIZE FOR BIT SHIFTING
00003848  41F9 00004984           4147            LEA     VAR_TEMP_CLEANCOPY,A0
0000384E  2639 00004984           4148            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003854                          4149  LOOP_SHIFTING1
00003854  0C02 0000               4150            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003858  6700 0008               4151            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000385C  E24B                    4152            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000385E  5302                    4153            SUB.B   #1,D2                     *DECREMENT COUNTER
00003860  60F2                    4154            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003862                          4155  MASKING_NEXT1
00003862  C6BC 00000007           4156            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003868  0603 0030               4157            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000386C  6100 077E               4158            BSR     PUSH_STACK                *PUSH TO STACK
00003870                          4159            
00003870  6000 030A               4160            BRA     GET_SRC_SUCCESS                   *RETURN 
00003874                          4161            
00003874                          4162            
00003874                          4163            
00003874                          4164            
00003874                          4165            *** Check if source ...  <ea> = (An)       
00003874  41F9 00004978           4166  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
0000387A  1439 00004977           4167            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003880  1082                    4168            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003882  0239 0004 00004978      4169            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
0000388A  0C39 0004 00004978      4170            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003892  6700 007A               4171            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003896  0CB9 00000002 00004988  4172            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
000038A0  6600 006C               4173            BNE     CHECK3
000038A4                          4174            
000038A4                          4175            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000038A4  163C 0020               4176            MOVE.B    #' ',D3
000038A8  6100 0742               4177            BSR       PUSH_STACK
000038AC  163C 0028               4178            MOVE.B    #'(',D3
000038B0  6100 073A               4179            BSR       PUSH_STACK
000038B4  163C 0041               4180            MOVE.B    #'A',D3
000038B8  6100 0732               4181            BSR       PUSH_STACK
000038BC                          4182  
000038BC                          4183            
000038BC                          4184            *FIND REGISTER NUMBER END LOCATION*  
000038BC  13F9 0000497A 00004980  4185            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038C6  0239 000F 00004980      4186            AND.B   #$0F,VAR_BYTE_END
000038CE                          4187            
000038CE                          4188            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038CE  23C5 00004984           4189            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038D4  1439 00004980           4190            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038DA                          4191            
000038DA                          4192            *INTITIALIZE FOR BIT SHIFTING
000038DA  41F9 00004984           4193            LEA     VAR_TEMP_CLEANCOPY,A0
000038E0  2639 00004984           4194            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038E6                          4195  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000038E6  0C02 0000               4196            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038EA  6700 0008               4197            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000038EE  E24B                    4198            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000038F0  5302                    4199            SUB.B   #1,D2                     *DECREMENT COUNTER
000038F2  60F2                    4200            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000038F4                          4201  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000038F4  0283 00000007           4202            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000038FA  0603 0030               4203            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000038FE  6100 06EC               4204            BSR     PUSH_STACK                *PUSH TO STACK
00003902                          4205            
00003902  163C 0029               4206            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003906  6100 06E4               4207            BSR       PUSH_STACK
0000390A                          4208            
0000390A  6000 0270               4209            BRA     GET_SRC_SUCCESS                   *RETURN 
0000390E                          4210  
0000390E                          4211            
0000390E                          4212            
0000390E                          4213                      
0000390E                          4214  *** Check if source ...  <ea> = (An)+       
0000390E  41F9 00004978           4215  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003914  1439 00004977           4216            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000391A  1082                    4217            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000391C  0239 0008 00004978      4218            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003924  0C39 0008 00004978      4219            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
0000392C  6700 0082               4220            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003930  0CB9 00000003 00004988  4221            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000393A  6600 0074               4222            BNE     CHECK4
0000393E                          4223            
0000393E                          4224            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000393E  163C 0020               4225            MOVE.B    #' ',D3
00003942  6100 06A8               4226            BSR       PUSH_STACK
00003946  163C 0028               4227            MOVE.B    #'(',D3
0000394A  6100 06A0               4228            BSR       PUSH_STACK
0000394E  163C 0041               4229            MOVE.B    #'A',D3
00003952  6100 0698               4230            BSR       PUSH_STACK
00003956                          4231  
00003956                          4232            
00003956                          4233            *FIND REGISTER NUMBER END LOCATION*  
00003956  13F9 0000497A 00004980  4234            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003960  0239 000F 00004980      4235            ANDI.B   #$0F,VAR_BYTE_END
00003968                          4236            
00003968                          4237            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003968  23C5 00004984           4238            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000396E  1439 00004980           4239            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003974                          4240            
00003974                          4241            *INTITIALIZE FOR BIT SHIFTING
00003974  41F9 00004984           4242            LEA     VAR_TEMP_CLEANCOPY,A0
0000397A  2639 00004984           4243            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003980                          4244            
00003980                          4245  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003980  0C02 0000               4246            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003984  6700 0008               4247            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003988  E24B                    4248            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000398A  5302                    4249            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000398C  60F2                    4250            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
0000398E                          4251                                               *change: NAME OF LABEL*
0000398E                          4252  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
0000398E  0283 00000007           4253            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003994  0603 0030               4254            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003998  6100 0652               4255            BSR     PUSH_STACK                *PUSH TO STACK
0000399C                          4256            
0000399C  163C 0029               4257            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000039A0  6100 064A               4258            BSR       PUSH_STACK
000039A4  163C 002B               4259            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
000039A8  6100 0642               4260            BSR       PUSH_STACK
000039AC                          4261            
000039AC  6000 01CE               4262            BRA       GET_SRC_SUCCESS                   *RETURN 
000039B0                          4263  
000039B0                          4264            
000039B0                          4265            
000039B0                          4266                      
000039B0                          4267            *** Check if source ...  <ea> = -(An)       
000039B0  41F9 00004978           4268  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
000039B6  1439 00004977           4269            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039BC  1082                    4270            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039BE  0239 0010 00004978      4271            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
000039C6  0C39 0010 00004978      4272            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039CE  6700 0082               4273            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000039D2  0CB9 00000004 00004988  4274            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000039DC  6600 0074               4275            BNE     CHECK7
000039E0                          4276            
000039E0                          4277            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000039E0  163C 0020               4278            MOVE.B    #' ',D3
000039E4  6100 0606               4279            BSR       PUSH_STACK
000039E8  163C 002D               4280            MOVE.B    #'-',D3
000039EC  6100 05FE               4281            BSR       PUSH_STACK
000039F0  163C 0028               4282            MOVE.B    #'(',D3
000039F4  6100 05F6               4283            BSR       PUSH_STACK
000039F8  163C 0041               4284            MOVE.B    #'A',D3
000039FC  6100 05EE               4285            BSR       PUSH_STACK
00003A00                          4286  
00003A00                          4287            
00003A00                          4288            *FIND REGISTER NUMBER END LOCATION*  
00003A00  13F9 0000497A 00004980  4289            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A0A  0239 000F 00004980      4290            AND.B   #$0F,VAR_BYTE_END
00003A12                          4291            
00003A12                          4292            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A12  23C5 00004984           4293            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A18  1439 00004980           4294            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A1E                          4295            
00003A1E                          4296            *INTITIALIZE FOR BIT SHIFTING
00003A1E  41F9 00004984           4297            LEA     VAR_TEMP_CLEANCOPY,A0
00003A24  2639 00004984           4298            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003A2A                          4299            
00003A2A                          4300  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003A2A  0C02 0000               4301            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A2E  6700 0008               4302            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003A32  E24B                    4303            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A34  5302                    4304            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003A36  60F2                    4305            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003A38                          4306                                               *change: NAME OF LABEL*
00003A38                          4307  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003A38  0283 00000007           4308            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A3E  0603 0030               4309            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003A42  6100 05A8               4310            BSR     PUSH_STACK                *PUSH TO STACK
00003A46                          4311            
00003A46  163C 0029               4312            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003A4A  6100 05A0               4313            BSR       PUSH_STACK
00003A4E                          4314            
00003A4E  6000 012C               4315            BRA     GET_SRC_SUCCESS                   *RETURN
00003A52                          4316            
00003A52                          4317                      
00003A52                          4318            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003A52  0CB9 00000007 00004988  4319  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003A5C  6600 011A               4320            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003A60                          4321                   
00003A60                          4322            *NEXT: (MODE == 111) 
00003A60                          4323            *NOW: CHECK FOR SRC REGISTER 
00003A60                          4324                  *(000 = (xxx).W)
00003A60                          4325                  *(001 = (xxx).L)
00003A60                          4326                  *(010 = #<data>)
00003A60                          4327                  
00003A60                          4328            *FIND REGISTER NUMBER END LOCATION*  
00003A60  13F9 0000497A 00004980  4329            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A6A  0239 000F 00004980      4330            AND.B   #$0F,VAR_BYTE_END
00003A72                          4331            
00003A72                          4332            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A72  23C5 00004984           4333            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A78  1439 00004980           4334            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003A7E                          4335            
00003A7E                          4336            *INTITIALIZE FOR BIT SHIFTING
00003A7E  41F9 00004984           4337            LEA     VAR_TEMP_CLEANCOPY,A0
00003A84  2C39 00004984           4338            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003A8A                          4339  SRC_LOOP_SHIFTING
00003A8A  0C02 0000               4340            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A8E  6700 0008               4341            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003A92  E24E                    4342            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A94  5302                    4343            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A96  60F2                    4344            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003A98                          4345  SRC_MASKING_NEXT
00003A98  CCBC 00000007           4346            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003A9E                          4347           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003A9E                          4348           
00003A9E                          4349  CHECK_WORD  
00003A9E  41F9 00004978           4350            LEA     TEMP_REGISTER_FORMAT,A0
00003AA4  1439 00004977           4351            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AAA  1082                    4352            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AAC  0239 0020 00004978      4353            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003AB4  0C39 0020 00004978      4354            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003ABC  6700 0026               4355            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003AC0  0C06 0000               4356            CMPI.B  #0,D6                          
00003AC4  6600 001E               4357            BNE     CHECK_LONG 
00003AC8                          4358            
00003AC8                          4359            *IT IS A WORD AT THIS POINT*
00003AC8                          4360            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003AC8  163C 0020               4361            MOVE.B    #' ',D3
00003ACC  6100 051E               4362            BSR       PUSH_STACK
00003AD0  163C 0024               4363            MOVE.B    #'$',D3
00003AD4  6100 0516               4364            BSR       PUSH_STACK
00003AD8  321D                    4365            MOVE.W    (A5)+,D1
00003ADA  7404                    4366            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003ADC  6100 D79A               4367            BSR       HEX2ASCII2STACK
00003AE0  6000 009A               4368            BRA     GET_SRC_SUCCESS
00003AE4                          4369  
00003AE4                          4370  CHECK_LONG
00003AE4  41F9 00004978           4371            LEA     TEMP_REGISTER_FORMAT,A0
00003AEA  1439 00004977           4372            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AF0  1082                    4373            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AF2  0239 0040 00004978      4374            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003AFA  0C39 0040 00004978      4375            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B02  6700 002E               4376            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003B06  0C06 0001               4377            CMPI.B  #1,D6                          
00003B0A  6600 0026               4378            BNE     CHECK_IMMEDIATE  
00003B0E                          4379  
00003B0E                          4380            *IT IS A WORD AT THIS POINT*
00003B0E                          4381            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B0E  163C 0020               4382            MOVE.B    #' ',D3
00003B12  6100 04D8               4383            BSR       PUSH_STACK
00003B16  163C 0024               4384            MOVE.B    #'$',D3
00003B1A  6100 04D0               4385            BSR       PUSH_STACK
00003B1E  321D                    4386            MOVE.W    (A5)+,D1
00003B20  7404                    4387            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B22  6100 D754               4388            BSR       HEX2ASCII2STACK
00003B26  321D                    4389            MOVE.W    (A5)+,D1
00003B28  7404                    4390            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B2A  6100 D74C               4391            BSR       HEX2ASCII2STACK
00003B2E  6000 004C               4392            BRA     GET_SRC_SUCCESS
00003B32                          4393            
00003B32                          4394  CHECK_IMMEDIATE
00003B32  41F9 00004978           4395            LEA     TEMP_REGISTER_FORMAT,A0
00003B38  1439 00004977           4396            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B3E  1082                    4397            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B40  0239 0080 00004978      4398            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003B48  0C39 0080 00004978      4399            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B50  6700 0026               4400            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003B54  0C06 0004               4401            CMPI.B  #4,D6                          
00003B58  6600 001E               4402            BNE     GET_SRC_FAILED 
00003B5C                          4403  
00003B5C                          4404            *IT IS A WORD AT THIS POINT*
00003B5C                          4405            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B5C  163C 0020               4406            MOVE.B    #' ',D3
00003B60  6100 048A               4407            BSR       PUSH_STACK
00003B64  163C 0023               4408            MOVE.B    #'#',D3
00003B68  6100 0482               4409            BSR       PUSH_STACK
00003B6C  321D                    4410            MOVE.W    (A5)+,D1
00003B6E  7404                    4411            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003B70  6100 D706               4412            BSR       HEX2ASCII2STACK
00003B74  6000 0006               4413            BRA     GET_SRC_SUCCESS
00003B78                          4414            
00003B78                          4415  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003B78  7801                    4416            MOVE.L #1,D4
00003B7A  4E75                    4417            RTS
00003B7C                          4418  GET_SRC_SUCCESS 
00003B7C  4E75                    4419            RTS
00003B7E                          4420                                 
00003B7E                          4421      
00003B7E                          4422  
00003B7E                          4423  
00003B7E                          4424  
00003B7E                          4425  
00003B7E                          4426  
00003B7E                          4427  
00003B7E                          4428  GET_EA_EA_DEST
00003B7E                          4429  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003B7E                          4430      
00003B7E                          4431      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003B7E  2405                    4432      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003B80  EC8A                    4433      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003B82  23C2 00004988           4434      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003B88  7407                    4435      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003B8A  C5B9 00004988           4436      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003B90                          4437                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003B90                          4438      
00003B90                          4439      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003B90                          4440      *DESTINATION REGISTER FORMAT STANDARD         *
00003B90                          4441      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003B90                          4442      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003B90                          4443      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003B90                          4444      *0 - Dn                                       *
00003B90                          4445      *1 - An                                       *
00003B90                          4446      *2 - (An)                                     *
00003B90                          4447      *3 - (An)+                                    *
00003B90                          4448      *4 - -(An)                                    *
00003B90                          4449      *5 - (XXX).W                                  *
00003B90                          4450      *6 - (XXX).L                                  *
00003B90                          4451      *7 - #<data>                                  *
00003B90                          4452      ***********************************************
00003B90                          4453      
00003B90                          4454      *** Check if source ...  <ea> = Dn
00003B90                          4455  DEST_CHECK0    
00003B90  41F9 00004978           4456            LEA     TEMP_REGISTER_FORMAT,A0
00003B96  1439 00004976           4457            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B9C  1082                    4458            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B9E  0239 0001 00004978      4459            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003BA6  0C39 0001 00004978      4460            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003BAE  6700 006A               4461            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003BB2  0CB9 00000000 00004988  4462            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003BBC  6600 005C               4463            BNE     DEST_CHECK1
00003BC0                          4464            
00003BC0                          4465            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003BC0  163C 0020               4466            MOVE.B    #' ',D3
00003BC4  6100 0426               4467            BSR       PUSH_STACK
00003BC8  163C 0044               4468            MOVE.B    #'D',D3
00003BCC  6100 041E               4469            BSR       PUSH_STACK
00003BD0                          4470  
00003BD0                          4471            *FIND REGISTER NUMBER END LOCATION*  
00003BD0  13F9 00004979 00004980  4472            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BDA  0239 000F 00004980      4473            AND.B   #$0F,VAR_BYTE_END
00003BE2                          4474            
00003BE2                          4475            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BE2  23C5 00004984           4476            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BE8  1439 00004980           4477            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003BEE                          4478            
00003BEE                          4479            *INTITIALIZE FOR BIT SHIFTING
00003BEE  41F9 00004984           4480            LEA     VAR_TEMP_CLEANCOPY,A0
00003BF4  2639 00004984           4481            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003BFA                          4482  DEST_LOOP_SHIFTING
00003BFA  0C02 0000               4483            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003BFE  6700 0008               4484            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C02  E24B                    4485            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C04  5302                    4486            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C06  60F2                    4487            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003C08                          4488  DEST_MASKING_NEXT
00003C08  C6BC 00000007           4489            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C0E  0603 0030               4490            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003C12  6100 03D8               4491            BSR     PUSH_STACK                *PUSH TO STACK
00003C16                          4492            
00003C16  6000 0394               4493            BRA     GET_DST_SUCCESS           *RETURN          
00003C1A                          4494            
00003C1A                          4495            
00003C1A                          4496            *** Check if source ...  <ea> = An
00003C1A                          4497  DEST_CHECK1    
00003C1A  41F9 00004978           4498            LEA     TEMP_REGISTER_FORMAT,A0
00003C20  1439 00004976           4499            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C26  1082                    4500            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C28  0239 0002 00004978      4501            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003C30  0C39 0002 00004978      4502            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003C38  6700 006A               4503            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003C3C  0CB9 00000001 00004988  4504            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003C46  6600 005C               4505            BNE     DEST_CHECK2
00003C4A                          4506            
00003C4A                          4507            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003C4A  163C 0020               4508            MOVE.B    #' ',D3
00003C4E  6100 039C               4509            BSR       PUSH_STACK
00003C52  163C 0041               4510            MOVE.B    #'A',D3
00003C56  6100 0394               4511            BSR       PUSH_STACK
00003C5A                          4512  
00003C5A                          4513            
00003C5A                          4514            *FIND REGISTER NUMBER END LOCATION*  
00003C5A  13F9 00004979 00004980  4515            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C64  0239 000F 00004980      4516            AND.B   #$0F,VAR_BYTE_END
00003C6C                          4517            
00003C6C                          4518            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C6C  23C5 00004984           4519            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C72  1439 00004980           4520            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003C78                          4521            
00003C78                          4522            *INTITIALIZE FOR BIT SHIFTING
00003C78  41F9 00004984           4523            LEA     VAR_TEMP_CLEANCOPY,A0
00003C7E  2639 00004984           4524            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C84                          4525  DEST_LOOP_SHIFTING1
00003C84  0C02 0000               4526            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C88  6700 0008               4527            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C8C  E24B                    4528            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C8E  5302                    4529            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C90  60F2                    4530            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003C92                          4531  DEST_MASKING_NEXT1
00003C92  C6BC 00000007           4532            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C98  0603 0030               4533            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003C9C  6100 034E               4534            BSR     PUSH_STACK                *PUSH TO STACK
00003CA0                          4535            
00003CA0  6000 030A               4536            BRA     GET_DST_SUCCESS                   *RETURN 
00003CA4                          4537            
00003CA4                          4538            
00003CA4                          4539            
00003CA4                          4540            
00003CA4                          4541            *** Check if source ...  <ea> = (An)       
00003CA4                          4542  DEST_CHECK2    
00003CA4  41F9 00004978           4543            LEA     TEMP_REGISTER_FORMAT,A0
00003CAA  1439 00004976           4544            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CB0  1082                    4545            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CB2  0239 0004 00004978      4546            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003CBA  0C39 0004 00004978      4547            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CC2  6700 007A               4548            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CC6  0CB9 00000002 00004988  4549            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003CD0  6600 006C               4550            BNE     DEST_CHECK3
00003CD4                          4551            
00003CD4                          4552            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CD4  163C 0020               4553            MOVE.B    #' ',D3
00003CD8  6100 0312               4554            BSR       PUSH_STACK
00003CDC  163C 0028               4555            MOVE.B    #'(',D3
00003CE0  6100 030A               4556            BSR       PUSH_STACK
00003CE4  163C 0041               4557            MOVE.B    #'A',D3
00003CE8  6100 0302               4558            BSR       PUSH_STACK
00003CEC                          4559  
00003CEC                          4560            
00003CEC                          4561            *FIND REGISTER NUMBER END LOCATION*  
00003CEC  13F9 00004979 00004980  4562            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003CF6  0239 000F 00004980      4563            AND.B   #$0F,VAR_BYTE_END
00003CFE                          4564            
00003CFE                          4565            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003CFE  23C5 00004984           4566            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D04  1439 00004980           4567            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D0A                          4568            
00003D0A                          4569            *INTITIALIZE FOR BIT SHIFTING
00003D0A  41F9 00004984           4570            LEA     VAR_TEMP_CLEANCOPY,A0
00003D10  2639 00004984           4571            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D16                          4572  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003D16  0C02 0000               4573            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D1A  6700 0008               4574            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D1E  E24B                    4575            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D20  5302                    4576            SUB.B   #1,D2                     *DECREMENT COUNTER
00003D22  60F2                    4577            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003D24                          4578  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003D24  0283 00000007           4579            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D2A  0603 0030               4580            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D2E  6100 02BC               4581            BSR     PUSH_STACK                *PUSH TO STACK
00003D32                          4582            
00003D32  163C 0029               4583            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D36  6100 02B4               4584            BSR       PUSH_STACK
00003D3A                          4585            
00003D3A  6000 0270               4586            BRA     GET_DST_SUCCESS                   *RETURN 
00003D3E                          4587  
00003D3E                          4588            
00003D3E                          4589            
00003D3E                          4590                      
00003D3E                          4591  *** Check if source ...  <ea> = (An)+       
00003D3E  41F9 00004978           4592  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003D44  1439 00004976           4593            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D4A  1082                    4594            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D4C  0239 0008 00004978      4595            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003D54  0C39 0008 00004978      4596            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D5C  6700 0082               4597            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003D60  0CB9 00000003 00004988  4598            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003D6A  6600 0074               4599            BNE     DEST_CHECK4
00003D6E                          4600            
00003D6E                          4601            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003D6E  163C 0020               4602            MOVE.B    #' ',D3
00003D72  6100 0278               4603            BSR       PUSH_STACK
00003D76  163C 0028               4604            MOVE.B    #'(',D3
00003D7A  6100 0270               4605            BSR       PUSH_STACK
00003D7E  163C 0041               4606            MOVE.B    #'A',D3
00003D82  6100 0268               4607            BSR       PUSH_STACK
00003D86                          4608  
00003D86                          4609            
00003D86                          4610            *FIND REGISTER NUMBER END LOCATION*  
00003D86  13F9 00004979 00004980  4611            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D90  0239 000F 00004980      4612            ANDI.B   #$0F,VAR_BYTE_END
00003D98                          4613            
00003D98                          4614            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D98  23C5 00004984           4615            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D9E  1439 00004980           4616            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003DA4                          4617            
00003DA4                          4618            *INTITIALIZE FOR BIT SHIFTING
00003DA4  41F9 00004984           4619            LEA     VAR_TEMP_CLEANCOPY,A0
00003DAA  2639 00004984           4620            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003DB0                          4621            
00003DB0                          4622  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003DB0  0C02 0000               4623            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DB4  6700 0008               4624            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003DB8  E24B                    4625            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DBA  5302                    4626            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003DBC  60F2                    4627            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003DBE                          4628                                               *change: NAME OF LABEL*
00003DBE                          4629  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003DBE  0283 00000007           4630            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003DC4  0603 0030               4631            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003DC8  6100 0222               4632            BSR     PUSH_STACK                *PUSH TO STACK
00003DCC                          4633            
00003DCC  163C 0029               4634            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DD0  6100 021A               4635            BSR       PUSH_STACK
00003DD4  163C 002B               4636            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003DD8  6100 0212               4637            BSR       PUSH_STACK
00003DDC                          4638            
00003DDC  6000 01CE               4639            BRA       GET_DST_SUCCESS                   *RETURN 
00003DE0                          4640  
00003DE0                          4641            
00003DE0                          4642            
00003DE0                          4643                      
00003DE0                          4644            *** Check if source ...  <ea> = -(An)       
00003DE0                          4645  DEST_CHECK4    
00003DE0  41F9 00004978           4646            LEA     TEMP_REGISTER_FORMAT,A0
00003DE6  1439 00004976           4647            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003DEC  1082                    4648            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003DEE  0239 0010 00004978      4649            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003DF6  0C39 0010 00004978      4650            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003DFE  6700 0082               4651            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003E02  0CB9 00000004 00004988  4652            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003E0C  6600 0074               4653            BNE     DEST_CHECK7
00003E10                          4654            
00003E10                          4655            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003E10  163C 0020               4656            MOVE.B    #' ',D3
00003E14  6100 01D6               4657            BSR       PUSH_STACK
00003E18  163C 002D               4658            MOVE.B    #'-',D3
00003E1C  6100 01CE               4659            BSR       PUSH_STACK
00003E20  163C 0028               4660            MOVE.B    #'(',D3
00003E24  6100 01C6               4661            BSR       PUSH_STACK
00003E28  163C 0041               4662            MOVE.B    #'A',D3
00003E2C  6100 01BE               4663            BSR       PUSH_STACK
00003E30                          4664  
00003E30                          4665            
00003E30                          4666            *FIND REGISTER NUMBER END LOCATION*  
00003E30  13F9 00004979 00004980  4667            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E3A  0239 000F 00004980      4668            AND.B   #$0F,VAR_BYTE_END
00003E42                          4669            
00003E42                          4670            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E42  23C5 00004984           4671            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E48  1439 00004980           4672            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003E4E                          4673            
00003E4E                          4674            *INTITIALIZE FOR BIT SHIFTING
00003E4E  41F9 00004984           4675            LEA     VAR_TEMP_CLEANCOPY,A0
00003E54  2639 00004984           4676            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003E5A                          4677            
00003E5A                          4678  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003E5A  0C02 0000               4679            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E5E  6700 0008               4680            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003E62  E24B                    4681            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E64  5302                    4682            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003E66  60F2                    4683            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003E68                          4684                                               *change: NAME OF LABEL*
00003E68                          4685  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003E68  0283 00000007           4686            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003E6E  0603 0030               4687            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003E72  6100 0178               4688            BSR     PUSH_STACK                *PUSH TO STACK
00003E76                          4689            
00003E76  163C 0029               4690            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003E7A  6100 0170               4691            BSR       PUSH_STACK
00003E7E                          4692            
00003E7E  6000 012C               4693            BRA     GET_DST_SUCCESS                   *RETURN
00003E82                          4694            
00003E82                          4695                      
00003E82                          4696            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003E82                          4697  DEST_CHECK7    
00003E82  0CB9 00000007 00004988  4698            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003E8C  6600 011A               4699            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003E90                          4700                   
00003E90                          4701            *NEXT: (MODE == 111) 
00003E90                          4702            *NOW: CHECK FOR SRC REGISTER 
00003E90                          4703                  *(000 = (xxx).W)
00003E90                          4704                  *(001 = (xxx).L)
00003E90                          4705                  *(010 = #<data>)
00003E90                          4706                  
00003E90                          4707            *FIND REGISTER NUMBER END LOCATION*  
00003E90  13F9 00004979 00004980  4708            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E9A  0239 000F 00004980      4709            AND.B   #$0F,VAR_BYTE_END
00003EA2                          4710            
00003EA2                          4711            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003EA2  23C5 00004984           4712            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003EA8  1439 00004980           4713            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003EAE                          4714            
00003EAE                          4715            *INTITIALIZE FOR BIT SHIFTING
00003EAE  41F9 00004984           4716            LEA     VAR_TEMP_CLEANCOPY,A0
00003EB4  2C39 00004984           4717            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003EBA                          4718  DEST_LOOP_SHIFTING7
00003EBA  0C02 0000               4719            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003EBE  6700 0008               4720            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003EC2  E24E                    4721            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003EC4  5302                    4722            SUB.B   #1,D2                     *DECREMENT COUNTER
00003EC6  60F2                    4723            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003EC8                          4724  DEST_MASKING_NEXT7
00003EC8  CCBC 00000007           4725            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003ECE                          4726           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003ECE                          4727            
00003ECE                          4728  DEST_CHECK_WORD  
00003ECE  41F9 00004978           4729            LEA     TEMP_REGISTER_FORMAT,A0
00003ED4  1439 00004976           4730            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EDA  1082                    4731            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EDC  0239 0020 00004978      4732            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003EE4  0C39 0020 00004978      4733            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003EEC  6700 0026               4734            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003EF0  0C06 0000               4735            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003EF4  6600 001E               4736            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003EF8                          4737            *IT IS A WORD AT THIS POINT*
00003EF8                          4738            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003EF8  163C 0020               4739            MOVE.B    #' ',D3
00003EFC  6100 00EE               4740            BSR       PUSH_STACK
00003F00  163C 0024               4741            MOVE.B    #'$',D3
00003F04  6100 00E6               4742            BSR       PUSH_STACK
00003F08  321D                    4743            MOVE.W    (A5)+,D1
00003F0A  7404                    4744            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003F0C  6100 D36A               4745            BSR       HEX2ASCII2STACK
00003F10  6000 009A               4746            BRA       GET_DST_SUCCESS
00003F14                          4747  
00003F14                          4748  DEST_CHECK_LONG
00003F14  41F9 00004978           4749            LEA     TEMP_REGISTER_FORMAT,A0
00003F1A  1439 00004976           4750            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F20  1082                    4751            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F22  0239 0040 00004978      4752            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F2A  0C39 0040 00004978      4753            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F32  6700 002E               4754            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F36  0C06 0001               4755            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003F3A  6600 0026               4756            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003F3E                          4757            *IT IS A WORD AT THIS POINT*
00003F3E                          4758            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F3E  163C 0020               4759            MOVE.B    #' ',D3
00003F42  6100 00A8               4760            BSR       PUSH_STACK
00003F46  163C 0024               4761            MOVE.B    #'$',D3
00003F4A  6100 00A0               4762            BSR       PUSH_STACK
00003F4E  321D                    4763            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F50  7404                    4764            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003F52  6100 D324               4765            BSR       HEX2ASCII2STACK
00003F56  321D                    4766            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003F58  7404                    4767            MOVE.L    #4,D2          
00003F5A  6100 D31C               4768            BSR       HEX2ASCII2STACK
00003F5E  6000 004C               4769            BRA     GET_DST_SUCCESS
00003F62                          4770            
00003F62                          4771  DEST_CHECK_IMMEDIATE
00003F62  41F9 00004978           4772            LEA     TEMP_REGISTER_FORMAT,A0
00003F68  1439 00004976           4773            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F6E  1082                    4774            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F70  0239 0080 00004978      4775            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003F78  0C39 0080 00004978      4776            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F80  6700 0026               4777            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003F84  0C06 0004               4778            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003F88  6600 001E               4779            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003F8C                          4780            
00003F8C                          4781            *IT IS A WORD AT THIS POINT*
00003F8C                          4782            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003F8C  163C 0020               4783            MOVE.B    #' ',D3
00003F90  6100 005A               4784            BSR       PUSH_STACK
00003F94  163C 0023               4785            MOVE.B    #'#',D3
00003F98  6100 0052               4786            BSR       PUSH_STACK
00003F9C  321D                    4787            MOVE.W    (A5)+,D1
00003F9E  7404                    4788            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003FA0  6100 D2D6               4789            BSR       HEX2ASCII2STACK
00003FA4  6000 0006               4790            BRA       GET_DST_SUCCESS
00003FA8                          4791            
00003FA8                          4792  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003FA8  7801                    4793            MOVE.L #1,D4
00003FAA  4E75                    4794            RTS
00003FAC                          4795  GET_DST_SUCCESS 
00003FAC  4E75                    4796            RTS
00003FAE                          4797  
00003FAE                          4798  
00003FAE                          4799  *---------------------------------------------------------------------------*
00003FAE                          4800  * STACK/QUEUE INTERFACE
00003FAE                          4801  *---------------------------------------------------------------------------*
00003FAE                          4802  PRINT_STACK
00003FAE  0C39 0000 00004972      4803            CMP.B     #0,COUNTER
00003FB6  6700 000E               4804            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003FBA                          4805            
00003FBA                          4806  PRINT_STACK_HELPER
00003FBA  6100 0038               4807            BSR      POP_STACK          *PRINTS ADDRESS
00003FBE  103C 0006               4808            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FC2  4E4F                    4809            TRAP     #15             *ACTIVATES PRINT
00003FC4                          4810  
00003FC4  60E8                    4811            BRA       PRINT_STACK
00003FC6                          4812  PRINT_STACK_RETURN
00003FC6  4E75                    4813            RTS
00003FC8                          4814            
00003FC8                          4815            
00003FC8                          4816  PRINT_QUEUE
00003FC8  0C39 0000 00004972      4817            CMP.B     #0,COUNTER
00003FD0  6700 0018               4818            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003FD4                          4819            
00003FD4                          4820  PRINT_QUEUE_HELPER
00003FD4  33F9 00004972 00004974  4821            MOVE.W   COUNTER,QUEUE_COUNTER
00003FDE  6100 0022               4822            BSR      POP_FRONT          *PRINTS ADDRESS
00003FE2  103C 0006               4823            MOVE.B   #6,D0              *Display single character in D1.B. 
00003FE6  4E4F                    4824            TRAP     #15             *ACTIVATES PRINT
00003FE8                          4825  
00003FE8  60DE                    4826            BRA       PRINT_QUEUE
00003FEA                          4827  PRINT_QUEUE_RETURN
00003FEA  4E75                    4828            RTS
00003FEC                          4829            
00003FEC                          4830  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003FEC                          4831  PUSH_STACK
00003FEC  1503                    4832              MOVE.B  D3,-(A2)
00003FEE  6100 0058               4833              BSR     INCREMENT
00003FF2  4E75                    4834              RTS
00003FF4                          4835  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003FF4                          4836  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003FF4                          4837  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003FF4                          4838  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003FF4                          4839  *         TRAP        #15             *ACTIVATES PRINT
00003FF4                          4840  POP_STACK
00003FF4  BECA                    4841              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003FF6  6700 0008               4842              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003FFA  121A                    4843              MOVE.B  (A2)+,D1 
00003FFC  6100 0052               4844              BSR     DECREMENT
00004000                          4845  POP_RETURN
00004000  4E75                    4846              RTS 
00004002                          4847        
00004002                          4848  *USE [A4] AS SECOND POINTER IN SHIFTING      
00004002  0C39 0000 00004974      4849  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000400A  6700 0030               4850              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000400E                          4851              
0000400E                          4852              
0000400E                          4853              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
0000400E  347C 7000               4854              MOVEA.W #STACK,A2   *START A2 AT STACK
00004012  0622 0000               4855              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00004016  384A                    4856              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00004018  0624 0000               4857              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
0000401C  1212                    4858              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
0000401E                          4859  POP_SHIFT_LOOP
0000401E  0C39 0000 00004974      4860              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00004026  6700 0014               4861              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000402A  1494                    4862              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
0000402C  0624 0000               4863              ADD.B   #0,-(A4)
00004030  0622 0000               4864              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00004034  5339 00004974           4865              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
0000403A                          4866              
0000403A  60E2                    4867              BRA     POP_SHIFT_LOOP
0000403C                          4868                          
0000403C                          4869  POP_FRONT_RETURN 
0000403C                          4870              *RESET A2 BACK TO SP
0000403C  347C 7000               4871              MOVEA.W #STACK,A2    
00004040  5339 00004972           4872              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00004046  4E75                    4873              RTS   
00004048                          4874  
00004048                          4875  INCREMENT
00004048  5239 00004972           4876              ADD.B   #1, COUNTER
0000404E  4E75                    4877              RTS           
00004050                          4878  DECREMENT
00004050  5339 00004972           4879              SUB.B   #1, COUNTER
00004056  4E75                    4880              RTS           
00004058                          4881  CLEAR_STACK
00004058  0C39 0000 00004972      4882              CMP.B     #0,COUNTER
00004060  6700 0006               4883              BEQ       CLEAR_RETURN
00004064  618E                    4884              BSR       POP_STACK
00004066  60F0                    4885              BRA       CLEAR_STACK
00004068                          4886   
00004068                          4887  CLEAR_RETURN
00004068  4E75                    4888              RTS    
0000406A                          4889              
0000406A                          4890  *---------------------------------------------------------------------------*
0000406A                          4891  * 8/16/32-bit Address getter
0000406A                          4892  *---------------------------------------------------------------------------*
0000406A                          4893  *get displacement value from bits 0 to 8
0000406A                          4894  *if displacement is not $00, than it is 8 otherwise check for word
0000406A                          4895  *if displacement is not $FF, than it is a long
0000406A                          4896  *add the displacement to the current address being processed + a word
0000406A                          4897  *place results into D3, so that it can be pushed to stack
0000406A                          4898  GET_DISPLACEMENT_ADDRESS
0000406A  2805                    4899              MOVE.L  D5,D4                   * COPIES DATA INTO D6
0000406C  0286 000000FF           4900              ANDI.L  #$00FF,D6               * MASKS DATA
00004072  0C84 00000000           4901              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
00004078  6700 0022               4902              BEQ     GET_DISPLACEMENT_WORD
0000407C  0C84 000000FF           4903              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00004082  6700 0030               4904              BEQ     GET_DISPLACEMENT_LONG
00004086                          4905              
00004086  2E3C 00000100           4906              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
0000408C  9E04                    4907              SUB.B   D4,D7
0000408E                          4908              
0000408E  280D                    4909              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004090  9807                    4910              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00004092  7404                    4911              MOVE.L  #4,D2
00004094  2204                    4912              MOVE.L  D4,D1  
00004096  6100 D1E0               4913              BSR     HEX2ASCII2STACK
0000409A  4E75                    4914              RTS
0000409C                          4915              
0000409C                          4916  GET_DISPLACEMENT_WORD
0000409C  2E3C 000000FF           4917              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000040A2  9E04                    4918              SUB.B   D4,D7
000040A4                          4919              
000040A4  280D                    4920              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040A6  9807                    4921              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040A8  7404                    4922              MOVE.L  #4,D2
000040AA  2604                    4923              MOVE.L  D4,D3
000040AC  2204                    4924              MOVE.L  D4,D1
000040AE  6100 D1C8               4925              BSR     HEX2ASCII2STACK
000040B2  4E75                    4926              RTS     
000040B4                          4927  GET_DISPLACEMENT_LONG   
000040B4  2E3C 000000FF           4928              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000040BA  9E04                    4929              SUB.B   D4,D7
000040BC                          4930              
000040BC  280D                    4931              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000040BE  9807                    4932              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000040C0  7408                    4933              MOVE.L  #8,D2
000040C2  2604                    4934              MOVE.L  D4,D3                   * PREPARE TO PUSH
000040C4  2204                    4935              MOVE.L  D4,D1
000040C6  6100 D1B0               4936              BSR     HEX2ASCII2STACK
000040CA                          4937  
000040CA  4284                    4938              CLR.L   D4
000040CC  4E75                    4939              RTS
000040CE                          4940  
000040CE                          4941  *---------------------------------------------------------------------------*
000040CE                          4942  * TERMINATE
000040CE                          4943  *---------------------------------------------------------------------------*
000040CE                          4944  TERMINATE   
000040CE  43F9 0000447E           4945              LEA     FINMSG,A1
000040D4  103C 000E               4946              MOVE.B  #14,D0
000040D8  4E4F                    4947              TRAP    #15
000040DA                          4948  
000040DA  103C 0009               4949              MOVE.B  #9,D0
000040DE  4E4F                    4950              TRAP    #15
000040E0                          4951  
000040E0                          4952  *---------------------------------------------------------------------------*
000040E0                          4953  * Data storage                                                 
000040E0                          4954  *---------------------------------------------------------------------------*  
000040E0                          4955  WELCOME
000040E0= 20 20 20 20 20 20 ...   4956              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00004130= 3D 3D 3D 3D 3D 20 ...   4957              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004180= 3D 3D 3D 3D 3D 20 ...   4958              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000041D0                          4959      
000041D0= 20 20 20 20 20 20 ...   4960              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00004220= 20 20 20 20 20 20 ...   4961              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004270= 20 20 20 20 20 20 ...   4962              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000042C0                          4963      
000042C0= 20 20 20 20 20 20 ...   4964              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00004310= 3D 3D 3D 3D 3D 20 ...   4965              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00004360= 3D 3D 3D 3D 3D 20 ...   4966              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
000043B5                          4967  
000043B5                          4968  PROMPT_START
000043B5= 50 6C 65 61 73 65 ...   4969              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000043E4                          4970      
000043E4                          4971  PROMPT_END
000043E4= 50 6C 65 61 73 65 ...   4972              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00004411= 0D 0A 48 69 74 20 ...   4973  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
0000443B= 57 6F 75 6C 64 20 ...   4974  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
0000447E= 54 68 61 6E 6B 20 ...   4975  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
000044A9= 45 72 72 6F 72 3A ...   4976  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000044C8= 45 72 72 6F 72 3A ...   4977  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
000044ED= 45 72 72 6F 72 3A ...   4978  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
0000451A                          4979  
0000451A                          4980  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
0000456A                          4981  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
000045BA                          4982  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000045BE                          4983  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000045C2= 0D 0A 00                4984  ENDLINE_M   DC.B    CR,LF,0
000045C5                          4985  TMPINPUT    DS.B    80                      * temp store user input
00004615                          4986  TMPOUTPUT   DS.B    80                      * temp store prog output
00004665= 20 20 20 4F 52 49 ...   4987  DISP_ORI_B  DC.B    '   ORI.B',0
0000466E= 20 20 20 4F 52 49 ...   4988  DISP_ORI_W  DC.B    '   ORI.W',0
00004677= 20 20 20 4F 52 49 ...   4989  DISP_ORI_L  DC.B    '   ORI.L',0
00004680= 20 20 20 45 4F 52 ...   4990  DISP_EORI_B  DC.B    '   EORI.B',0
0000468A= 20 20 20 45 4F 52 ...   4991  DISP_EORI_W  DC.B    '   EORI.W',0
00004694= 20 20 20 45 4F 52 ...   4992  DISP_EORI_L  DC.B    '   EORI.L',0
0000469E= 20 20 20 42 54 53 ...   4993  DISP_BTST   DC.B    '   BTST',0
000046A6= 20 20 20 43 4D 50 ...   4994  DISP_CMPI_B  DC.B    '   CMPI.B',0
000046B0= 20 20 20 43 4D 50 ...   4995  DISP_CMPI_W  DC.B    '   CMPI.W',0
000046BA= 20 20 20 43 4D 50 ...   4996  DISP_CMPI_L  DC.B    '   CMPI.L',0
000046C4= 20 20 20 44 41 54 ...   4997  DISP_DATA   DC.B    '   DATA',0
000046CC= 20 20 20 4D 4F 56 ...   4998  DISP_MOVE_B DC.B    '   MOVE.B',0
000046D6= 20 20 20 4D 4F 56 ...   4999  DISP_MOVE_W DC.B    '   MOVE.W',0
000046E0= 20 20 20 4D 4F 56 ...   5000  DISP_MOVE_L DC.B    '   MOVE.L',0
000046EA= 20 20 20 52 54 53 00    5001  DISP_RTS    DC.B    '   RTS',0
000046F1= 20 20 20 4A 53 52 00    5002  DISP_JSR    DC.B    '   JSR',0
000046F8= 20 20 20 4E 45 47 ...   5003  DISP_NEG_B    DC.B    '   NEG.B',0
00004701= 20 20 20 4E 45 47 ...   5004  DISP_NEG_W    DC.B    '   NEG.W',0
0000470A= 20 20 20 4E 45 47 ...   5005  DISP_NEG_L    DC.B    '   NEG.L',0
00004713= 20 20 20 4E 4F 54 ...   5006  DISP_NOT_B  DC.B    '   NOT.B',0
0000471C= 20 20 20 4E 4F 54 ...   5007  DISP_NOT_W  DC.B    '   NOT.W',0
00004725= 20 20 20 4E 4F 54 ...   5008  DISP_NOT_L  DC.B    '   NOT.L',0
0000472E= 20 20 20 4C 45 41 00    5009  DISP_LEA    DC.B    '   LEA',0
00004735= 20 20 20 4D 4F 56 ...   5010  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004740= 20 20 20 4D 4F 56 ...   5011  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
0000474B= 20 20 20 41 44 44 ...   5012  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00004755= 20 20 20 41 44 44 ...   5013  DISP_ADDQ_W DC.B    '   ADDQ.W',0
0000475F= 20 20 20 41 44 44 ...   5014  DISP_ADDQ_L DC.B    '   ADDQ.L',0
00004769= 20 20 20 44 49 56 ...   5015  DISP_DIVS   DC.B    '   DIVS',0
00004771= 20 20 20 53 55 42 ...   5016  DISP_SUB_B  DC.B    '   SUB.B',0
0000477A= 20 20 20 53 55 42 ...   5017  DISP_SUB_W  DC.B    '   SUB.W',0
00004783= 20 20 20 53 55 42 ...   5018  DISP_SUB_L  DC.B    '   SUB.L',0
0000478C= 20 20 20 53 55 42 ...   5019  DISP_SUBI_B  DC.B    '   SUBI.B',0
00004796= 20 20 20 53 55 42 ...   5020  DISP_SUBI_W  DC.B    '   SUBI.W',0
000047A0= 20 20 20 53 55 42 ...   5021  DISP_SUBI_L  DC.B    '   SUBI.L',0
000047AA= 20 20 20 53 55 42 ...   5022  DISP_SUBA_W  DC.B    '   SUBA.W',0
000047B4= 20 20 20 53 55 42 ...   5023  DISP_SUBA_L  DC.B    '   SUBA.L',0
000047BE= 20 20 20 45 4F 52 ...   5024  DISP_EOR_B  DC.B    '   EOR.B',0
000047C7= 20 20 20 45 4F 52 ...   5025  DISP_EOR_W  DC.B    '   EOR.W',0
000047D0= 20 20 20 45 4F 52 ...   5026  DISP_EOR_L  DC.B    '   EOR.L',0
000047D9= 20 20 20 43 4D 50 ...   5027  DISP_CMP_B  DC.B    '   CMP.B',0
000047E2= 20 20 20 43 4D 50 ...   5028  DISP_CMP_W  DC.B    '   CMP.W',0
000047EB= 20 20 20 43 4D 50 ...   5029  DISP_CMP_L  DC.B    '   CMP.L',0
000047F4= 20 20 20 43 4D 50 ...   5030  DISP_CMPA_W  DC.B    '   CMPA.W',0
000047FE= 20 20 20 43 4D 50 ...   5031  DISP_CMPA_L  DC.B    '   CMPA.L',0
00004808= 20 20 20 4D 55 4C ...   5032  DISP_MULS_W DC.B    '   MULS.W',0
00004812= 20 20 20 41 4E 44 ...   5033  DISP_AND_B  DC.B    '   AND.B',0
0000481B= 20 20 20 41 4E 44 ...   5034  DISP_AND_W  DC.B    '   AND.W',0
00004824= 20 20 20 41 4E 44 ...   5035  DISP_AND_L  DC.B    '   AND.L',0
0000482D= 20 20 20 41 44 44 ...   5036  DISP_ADD_B  DC.B    '   ADD.B',0
00004836= 20 20 20 41 44 44 ...   5037  DISP_ADD_W  DC.B    '   ADD.W',0
0000483F= 20 20 20 41 44 44 ...   5038  DISP_ADD_L  DC.B    '   ADD.L',0
00004848= 20 20 20 41 44 44 ...   5039  DISP_ADDA_W DC.B    '   ADDA.W',0
00004852= 20 20 20 41 44 44 ...   5040  DISP_ADDA_L DC.B    '   ADDA.L',0
0000485C= 20 20 20 4C 53 52 ...   5041  DISP_LSR_B  DC.B    '   LSR.B',0
00004865= 20 20 20 4C 53 4C ...   5042  DISP_LSL_B  DC.B    '   LSL.B',0
0000486E= 20 20 20 4C 53 52 ...   5043  DISP_LSR_W  DC.B    '   LSR.W',0
00004877= 20 20 20 4C 53 4C ...   5044  DISP_LSL_W  DC.B    '   LSL.W',0
00004880= 20 20 20 4C 53 52 ...   5045  DISP_LSR_L  DC.B    '   LSR.L',0
00004889= 20 20 20 4C 53 4C ...   5046  DISP_LSL_L  DC.B    '   LSL.L',0
00004892= 20 20 20 41 53 52 ...   5047  DISP_ASR_B  DC.B    '   ASR.B',0
0000489B= 20 20 20 41 53 4C ...   5048  DISP_ASL_B  DC.B    '   ASL.B',0
000048A4= 20 20 20 41 53 52 ...   5049  DISP_ASR_W  DC.B    '   ASR.W',0
000048AD= 20 20 20 41 53 4C ...   5050  DISP_ASL_W  DC.B    '   ASL.W',0
000048B6= 20 20 20 41 53 52 ...   5051  DISP_ASR_L  DC.B    '   ASR.L',0
000048BF= 20 20 20 41 53 4C ...   5052  DISP_ASL_L  DC.B    '   ASL.L',0
000048C8= 20 20 20 52 4F 52 ...   5053  DISP_ROR_B  DC.B    '   ROR.B',0
000048D1= 20 20 20 52 4F 4C ...   5054  DISP_ROL_B  DC.B    '   ROL.B',0
000048DA= 20 20 20 52 4F 52 ...   5055  DISP_ROR_W  DC.B    '   ROR.W',0
000048E3= 20 20 20 52 4F 4C ...   5056  DISP_ROL_W  DC.B    '   ROL.W',0
000048EC= 20 20 20 52 4F 52 ...   5057  DISP_ROR_L  DC.B    '   ROR.L',0
000048F5= 20 20 20 52 4F 4C ...   5058  DISP_ROL_L  DC.B    '   ROL.L',0
000048FE= 20 20 20 42 52 41 00    5059  DISP_BRA    DC.B    '   BRA',0
00004905= 20 20 20 42 4C 54 00    5060  DISP_BLT    DC.B    '   BLT',0
0000490C= 20 20 20 42 45 51 00    5061  DISP_BEQ    DC.B    '   BEQ',0
00004913= 20 20 20 42 4E 45 00    5062  DISP_BNE    DC.B    '   BNE',0
0000491A= 20 20 20 42 48 49 00    5063  DISP_BHI    DC.B    '   BHI',0
00004921= 20 20 20 4D 4F 56 ...   5064  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
0000492C= 20 20 20 4D 4F 56 ...   5065  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004937                          5066  
00004937= 20 20 20 24 00          5067  DISP_HEX     DC.B    '   $',0
0000493C= 20 20 20 44 00          5068  DISP_D  DC.B    '   D',0
00004941= 20 20 20 41 00          5069  DISP_A  DC.B    '   A',0
00004946= 20 20 20 28 00          5070  DISP_OP  DC.B    '   (',0
0000494B= 29 00                   5071  DISP_CP  DC.B   ')',0
0000494D= 20 20 20 28 41 00       5072  DISP_AOP  DC.B    '   (A',0
00004953                          5073  
00004953= 20 20 20 2D 28 41 00    5074  DISP_PRE    DC.B    '   -(A',0
0000495A= 29 2B 00                5075  DISP_POST   DC.B    ')+',0
0000495D= 20 20 20 23 00          5076  DISP_LB DC.B    '   #',0
00004962= 30 00                   5077  DISP_0  DC.B    '0',0
00004964= 31 00                   5078  DISP_1  DC.B    '1',0
00004966= 32 00                   5079  DISP_2  DC.B    '2',0
00004968= 33 00                   5080  DISP_3  DC.B    '3',0
0000496A= 34 00                   5081  DISP_4  DC.B    '4',0
0000496C= 35 00                   5082  DISP_5  DC.B    '5',0
0000496E= 36 00                   5083  DISP_6  DC.B    '6',0
00004970= 37 00                   5084  DISP_7  DC.B    '7',0
00004972                          5085  
00004972                          5086  *STACK INTERFACE VARIABLES*
00004972                          5087  COUNTER         DS.W    1
00004974                          5088  QUEUE_COUNTER   DS.W    1
00004976                          5089  
00004976                          5090  *EA DECODING INTERFACE VARIABLES* 
00004976                          5091  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004977                          5092  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004978                          5093  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004979                          5094  
00004979                          5095  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004979                          5096  * WORD + WORD = LONG
00004979                          5097  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004979                          5098  * A              + F            = AF         <= EXAMPLE
00004979                          5099  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004979                          5100  GET_DST_START_END    DS.B    1
0000497A                          5101  GET_SRC_START_END    DS.B    1
0000497B                          5102  
0000497B                          5103  *STORES THE START + END BITS HERE (FROM ABOVE)
0000497C                          5104  VAR_BYTE_START      DS.L    1
00004980                          5105  VAR_BYTE_END        DS.L    1
00004984                          5106  VAR_TEMP_CLEANCOPY  DS.L    1
00004988                          5107  
00004988                          5108  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
0000498C                          5109  
0000498C                          5110  *MORE FOR STACK USAGE*
0000498C= 2C 00                   5111  DISP_COMMA  DC.B    ',',0
0000498E= 20 20 20 00             5112  DISP_INDENT  DC.B    '   ',0
00004992                          5113  
00004992                          5114  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004992                          5115  POINTER_WORD    DS.W       1
00004994                          5116  
00004994                          5117  
00004994                          5118  
00004994                          5119  *---------------------------------------------------------------------------*
00004994                          5120  * Ends program
00004994                          5121  *---------------------------------------------------------------------------*
00004994                          5122              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            116C
ASC2HXLP2STACK      11D4
ASCII2HEX           1166
ASCII2HEX2STACK     11CE
ASC_ERR             11C8
ASC_ERR2STACK       1230
ASC_LOW             11AA
ASC_LOW2STACK       1212
ASC_NUM             11BA
ASC_NUM2STACK       1222
ASC_SFT             11C2
ASC_SFT2STACK       122A
ASC_UPP             11B2
ASC_UPP2STACK       121A
CHECK0              3760
CHECK1              37EA
CHECK2              3874
CHECK3              390E
CHECK4              39B0
CHECK7              3A52
CHECK_IMMEDIATE     3B32
CHECK_LONG          3AE4
CHECK_WORD          3A9E
CLEAR_RETURN        4068
CLEAR_STACK         4058
COUNTER             4972
CR                  D
DECREMENT           4050
DEST_CHECK0         3B90
DEST_CHECK1         3C1A
DEST_CHECK2         3CA4
DEST_CHECK3         3D3E
DEST_CHECK4         3DE0
DEST_CHECK7         3E82
DEST_CHECK_IMMEDIATE  3F62
DEST_CHECK_LONG     3F14
DEST_CHECK_WORD     3ECE
DEST_LOOP_SHIFTING  3BFA
DEST_LOOP_SHIFTING1  3C84
DEST_LOOP_SHIFTING2  3D16
DEST_LOOP_SHIFTING3  3DB0
DEST_LOOP_SHIFTING4  3E5A
DEST_LOOP_SHIFTING7  3EBA
DEST_MASKING_NEXT   3C08
DEST_MASKING_NEXT1  3C92
DEST_MASKING_NEXT2  3D24
DEST_MASKING_NEXT3  3DBE
DEST_MASKING_NEXT4  3E68
DEST_MASKING_NEXT7  3EC8
DEST_MODE           3318
DEST_REGISTER       35E8
DEST_REGISTER_FORMAT  4976
DISPLAY_30_LINES    137C
DISP_0              4962
DISP_1              4964
DISP_2              4966
DISP_3              4968
DISP_4              496A
DISP_5              496C
DISP_6              496E
DISP_7              4970
DISP_A              4941
DISP_ADDA_L         4852
DISP_ADDA_W         4848
DISP_ADDQ_B         474B
DISP_ADDQ_L         475F
DISP_ADDQ_W         4755
DISP_ADD_B          482D
DISP_ADD_L          483F
DISP_ADD_W          4836
DISP_AND_B          4812
DISP_AND_L          4824
DISP_AND_W          481B
DISP_AOP            494D
DISP_ASL_B          489B
DISP_ASL_L          48BF
DISP_ASL_W          48AD
DISP_ASR_B          4892
DISP_ASR_L          48B6
DISP_ASR_W          48A4
DISP_BEQ            490C
DISP_BHI            491A
DISP_BLT            4905
DISP_BNE            4913
DISP_BRA            48FE
DISP_BTST           469E
DISP_CMPA_L         47FE
DISP_CMPA_W         47F4
DISP_CMPI_B         46A6
DISP_CMPI_L         46BA
DISP_CMPI_W         46B0
DISP_CMP_B          47D9
DISP_CMP_L          47EB
DISP_CMP_W          47E2
DISP_COMMA          498C
DISP_CP             494B
DISP_D              493C
DISP_DATA           46C4
DISP_DIVS           4769
DISP_EORI_B         4680
DISP_EORI_L         4694
DISP_EORI_W         468A
DISP_EOR_B          47BE
DISP_EOR_L          47D0
DISP_EOR_W          47C7
DISP_HEX            4937
DISP_INDENT         498E
DISP_JSR            46F1
DISP_LB             495D
DISP_LEA            472E
DISP_LSL_B          4865
DISP_LSL_L          4889
DISP_LSL_W          4877
DISP_LSR_B          485C
DISP_LSR_L          4880
DISP_LSR_W          486E
DISP_MOVEA_L        492C
DISP_MOVEA_W        4921
DISP_MOVEM_L        4740
DISP_MOVEM_W        4735
DISP_MOVE_B         46CC
DISP_MOVE_L         46E0
DISP_MOVE_W         46D6
DISP_MULS_W         4808
DISP_NEG_B          46F8
DISP_NEG_L          470A
DISP_NEG_W          4701
DISP_NEXT           4411
DISP_NOT_B          4713
DISP_NOT_L          4725
DISP_NOT_W          471C
DISP_OP             4946
DISP_ORI_B          4665
DISP_ORI_L          4677
DISP_ORI_W          466E
DISP_POST           495A
DISP_PRE            4953
DISP_ROL_B          48D1
DISP_ROL_L          48F5
DISP_ROL_W          48E3
DISP_ROR_B          48C8
DISP_ROR_L          48EC
DISP_ROR_W          48DA
DISP_RTS            46EA
DISP_SUBA_L         47B4
DISP_SUBA_W         47AA
DISP_SUBI_B         478C
DISP_SUBI_L         47A0
DISP_SUBI_W         4796
DISP_SUB_B          4771
DISP_SUB_L          4783
DISP_SUB_W          477A
D_MODE000           33BA
D_MODE010           3402
D_MODE011           3462
D_MODE100           3482
D_MODE111           34D4
EA_ARITH            32B2
EA_DATA             178C
EA_GEN              32FE
EA_MOVEA            32D8
EA_NOSRC            329E
ENDLINE_M           45C2
END_ADDR            10B2
ERRMSG_1            44A9
ERRMSG_3            44C8
ERRMSG_5            44ED
ERROR_1             1116
ERROR_2             1126
ERROR_3             1136
ERROR_4             1146
ERROR_5             1156
E_ADDR_HX           45BE
FINMSG              447E
GET_DISPLACEMENT_ADDRESS  406A
GET_DISPLACEMENT_LONG  40B4
GET_DISPLACEMENT_WORD  409C
GET_DST_FAILED      3FA8
GET_DST_START_END   4979
GET_DST_SUCCESS     3FAC
GET_EA_EA_DEST      3B7E
GET_EA_EA_SRC       374E
GET_SRC_FAILED      3B78
GET_SRC_START_END   497A
GET_SRC_SUCCESS     3B7C
HEX2ASCII           1236
HEX2ASCII2STACK     1278
HEX_CHAR            1264
HEX_CONT            1268
HEX_LOOP            124A
IMMD_B              3588
IMMD_L              35C8
IMMD_W              35A8
IMMEDIATE           3558
INCREMENT           4048
INTRO               1028
IS_ODD              12BC
IS_ODD_ERR          12D2
JMPTABLE            13A8
LF                  A
LONGMODE            352C
LOOP_SHIFTING       37CA
LOOP_SHIFTING1      3854
LOOP_SHIFTING2      38E6
LOOP_SHIFTING3      3980
LOOP_SHIFTING4      3A2A
MAIN                12D8
MASKING_NEXT        37D8
MASKING_NEXT1       3862
MASKING_NEXT2       38F4
MASKING_NEXT3       398E
MASKING_NEXT4       3A38
MODE000             33A6
MODE001             33CE
MODE010             33E2
MODE011             3422
MODE100             3442
MODE111             34A2
NEXTLINES           138A
OP0000              1408
OP0000_BTST_B       1572
OP0000_CMPI         17B4
OP0000_CMPI_B       182A
OP0000_CMPI_L       187A
OP0000_CMPI_W       1852
OP0000_EOR_B        1620
OP0000_EOR_L        1650
OP0000_EOR_W        1638
OP0000_ORI_B        190E
OP0000_ORI_L        195E
OP0000_ORI_W        1936
OP0000_RETURN_BTST  15A2
OP0000_RETURN_CMPI  189E
OP0000_RETURN_EOR   1664
OP0000_RETURN_ORI   1982
OP0000_RETURN_SUBI  1746
OP0000_SUB_B        1702
OP0000_SUB_L        1732
OP0000_SUB_W        171A
OP0001              1984
OP0010              19F2
OP0011              1AF0
OP0100              1BEC
OP0101              1E42
OP0101_ADDQ_B       1EBE
OP0101_ADDQ_B_0     1F3A
OP0101_ADDQ_B_1     1F46
OP0101_ADDQ_B_2     1F52
OP0101_ADDQ_B_3     1F5E
OP0101_ADDQ_B_4     1F6A
OP0101_ADDQ_B_5     1F76
OP0101_ADDQ_B_6     1F82
OP0101_ADDQ_B_7     1F8E
OP0101_ADDQ_B_8     1F9A
OP0101_ADDQ_L       1ED6
OP0101_ADDQ_W       1ECA
OP0101_RETURN       1EDE
OP0101_RETURN2      1FA2
OP0110              1FE6
OP0111              20EC
OP1000              20F0
OP1000_DIVS_DN_EA_OR_EA_DN  20FE
OP1000_DIVS_RETURN  21E2
OP1000_EA_DN_DIVS   212C
OP1000_PRINT_L_DIVS  219A
OP1000_PRINT_W_DIVS  2152
OP1001              21F8
OP1001_ADD_RETURN   2546
OP1001_DETERMINE_DN_EA_OR_EA_DN  230E
OP1001_DN_EA        2346
OP1001_EA_DN        2446
OP1001_PRINT_B      246E
OP1001_PRINT_B2     236E
OP1001_PRINT_L      24FE
OP1001_PRINT_L2     23FE
OP1001_PRINT_W      24B6
OP1001_PRINT_W2     23B6
OP1001_SUBA_L       222A
OP1001_SUBA_W       229C
OP1010              25B4
OP1011              25B8
OP1011_CMP          2612
OP1011_CMPA         26C4
OP1011_CMPA_L       273E
OP1011_CMPA_W       2732
OP1011_CMP_B        2686
OP1011_CMP_L        269E
OP1011_CMP_W        2692
OP1011_EOR          2764
OP1011_EOR_B        27D8
OP1011_EOR_L        27F0
OP1011_EOR_W        27E4
OP1011_RETURN       27F8
OP1011_RETURN_CMP   26A6
OP1011_RETURN_CMPA  2746
OP1100              28B8
OP1100_AND_RETURN   2C08
OP1100_DETERMINE_DN_EA_OR_EA_DN  29CE
OP1100_DN_EA        2A08
OP1100_EA_DN        2B08
OP1100_EA_DN_MULS   2916
OP1100_MULS_DN_EA_OR_EA_DN  28E8
OP1100_MULS_RETURN  29CC
OP1100_PRINT_B      2B30
OP1100_PRINT_B2     2A30
OP1100_PRINT_L      2BC0
OP1100_PRINT_L2     2AC0
OP1100_PRINT_L_MULS  2984
OP1100_PRINT_W      2B78
OP1100_PRINT_W2     2A78
OP1100_PRINT_W_MULS  293C
OP1101              2C0A
OP1101_ADDA_L       2C3C
OP1101_ADDA_W       2CAE
OP1101_ADD_RETURN   2F58
OP1101_DETERMINE_DN_EA_OR_EA_DN  2D20
OP1101_DN_EA        2D58
OP1101_EA_DN        2E58
OP1101_PRINT_B      2E80
OP1101_PRINT_B2     2D80
OP1101_PRINT_L      2F10
OP1101_PRINT_L2     2E10
OP1101_PRINT_W      2EC8
OP1101_PRINT_W2     2DC8
OP1110              2FE6
OP1110_RETURN       305E
OP1111              329A
OP_ADDA_L           2FCE
OP_ADDA_W           2FB6
OP_ADDQ_B           1FB0
OP_ADDQ_L           1FD4
OP_ADDQ_W           1FC2
OP_ADD_B            2F6E
OP_ADD_L            2F9E
OP_ADD_W            2F86
OP_ASX              327A
OP_BEQ              207A
OP_BHI              202E
OP_BLT              20C6
OP_BNE              2054
OP_BRA              20A0
OP_BTST             1492
OP_BTST_IMMEDIATE   151C
OP_CMPA_L           2828
OP_CMPA_W           2816
OP_CMP_B            283A
OP_CMP_L            286A
OP_CMP_W            2852
OP_DATA             1768
OP_DIVS             21E4
OP_EORI             15A4
OP_EOR_B            2882
OP_EOR_L            28A6
OP_EOR_W            2894
OP_JSR              1E14
OP_LEA              1C9A
OP_LEA_DN_EA_OR_EA_DN  1CA8
OP_LEA_RETURN       1D06
OP_LSX              3060
OP_LSX_0            31D4
OP_LSX_1            31E0
OP_LSX_2            31EC
OP_LSX_3            31F8
OP_LSX_4            3204
OP_LSX_5            3210
OP_LSX_6            321C
OP_LSX_7            3228
OP_LSX_8            3234
OP_LSX_AFTER_IMMEDIATE  323C
OP_LSX_B            30DC
OP_LSX_CHECK_FORMAT  30E8
OP_LSX_DIR          3096
OP_LSX_INTERMEDIATE  314A
OP_LSX_L            30C4
OP_LSX_MEMORY       324E
OP_LSX_R            308E
OP_LSX_REGISTER     30FA
OP_LSX_RETURN       3276
OP_LSX_W            30D0
OP_MOVEA_L          1A80
OP_MOVEA_W          1B7C
OP_MOVEM_L          1C88
OP_MOVEM_W          1C76
OP_MOVE_B           198A
OP_MOVE_L           1A18
OP_MOVE_W           1B14
OP_MULS             28DA
OP_NEG              1D08
OP_NEG_B            1D54
OP_NEG_L            1D6C
OP_NEG_PRINT_EA     1D78
OP_NEG_W            1D60
OP_NOT              1D8E
OP_NOT_B            1DDA
OP_NOT_L            1DF2
OP_NOT_PRINT_EA     1DFE
OP_NOT_W            1DE6
OP_ORI              18A0
OP_PRINT_L_LEA      1CC6
OP_ROX              328A
OP_RTS              1E28
OP_SUBA_L           25A2
OP_SUBA_W           2590
OP_SUBI             1686
OP_SUB_B            2548
OP_SUB_L            2578
OP_SUB_W            2560
OUTPUT_PROCESSED_DATA  135C
POINTER_WORD        4992
POP_FRONT           4002
POP_FRONT_RETURN    403C
POP_RETURN          4000
POP_SHIFT_LOOP      401E
POP_STACK           3FF4
PRINT_QUEUE         3FC8
PRINT_QUEUE_HELPER  3FD4
PRINT_QUEUE_RETURN  3FEA
PRINT_STACK         3FAE
PRINT_STACK_HELPER  3FBA
PRINT_STACK_RETURN  3FC6
PROGLP              100A
PROMPT_END          43E4
PROMPT_START        43B5
PUSH_STACK          3FEC
QUEUE_COUNTER       4974
REG_0               369C
REG_1               36AA
REG_2               36B8
REG_3               36C6
REG_4               36D4
REG_5               36E2
REG_6               36F0
REG_7               36FE
REPEAT              370C
REPEATMSG           443B
RETURN              11CC
RETURN2STACK        1234
SRC_LOOP_SHIFTING   3A8A
SRC_MASKING_NEXT    3A98
SRC_MODE            335C
SRC_REGISTER        3644
SRC_REGISTER_FORMAT  4977
STACK               7000
STACK_HEX_CHAR      12A6
STACK_HEX_CONT      12AA
STACK_HEX_LOOP      128C
START               1004
START_ADDR          1060
S_ADDR_HX           45BA
TEMP_REGISTER_FORMAT  4978
TERMINATE           40CE
TESTING             1036
TMPINPUT            45C5
TMPOUTPUT           4615
VAR_BYTE_END        4980
VAR_BYTE_START      497C
VAR_LONG_ADDRESS_MODE_CHECK  4988
VAR_TEMP_CLEANCOPY  4984
VR_E_ADDR           456A
VR_S_ADDR           451A
WELCOME             40E0
WORDMODE            3500
