00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.15.02
Created On: 12/10/2014 9:54:07 AM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 00001090             37  PROGLP      JSR     START_ADDR
00001010  4EB9 000010E2             38              JSR     END_ADDR
00001016  43F9 0000441C             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012A0             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 00003F3A             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  0A13 00FF                 53              EORI.B  #255,(A3)
0000103A  0A1C 0025                 54              EORI.B  #$25,(A4)+
0000103E  0A25 00AA                 55              EORI.B  #%10101010,-(A5)
00001042  0A38 0080 3331            56              EORI.B  #128,$3331
00001048  0A39 0040 44444441        57              EORI.B  #64,$44444441
00001050                            58               
00001050  0A53 00FF                 59              EORI.W  #255,(A3)
00001054  0A5C 0025                 60              EORI.W  #$25,(A4)+
00001058  0A65 00AA                 61              EORI.W  #%10101010,-(A5)
0000105C  0A78 0080 3331            62              EORI.W  #128,$3331
00001062  0A79 0040 44444441        63              EORI.W  #64,$44444441
0000106A                            64              
0000106A  0A93 000000FF             65              EORI.L  #255,(A3)
00001070  0A9C 00000025             66              EORI.L  #$25,(A4)+
00001076  0AA5 000000AA             67              EORI.L  #%10101010,-(A5)
0000107C  0AB8 00000080 3331        68              EORI.L  #128,$3331
00001084  0AB9 00000040 44444441    69              EORI.L  #64,$44444441
0000108E                            70  
0000108E                            71  
0000108E                            72  
0000108E  4E75                      73              RTS
00001090                            74  *---------------------------------------------------------------------------*
00001090                            75  * START_ADDR: Compute the starting address
00001090                            76  *---------------------------------------------------------------------------*
00001090                            77  START_ADDR
00001090                            78              * Output
00001090  43F9 0000420F             79              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001096  103C 000E                 80              MOVE.B  #14,D0                  * Display PROMPT_START
0000109A  4E4F                      81              TRAP    #15
0000109C                            82      
0000109C                            83              * Input
0000109C  43F9 00004374             84              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
000010A2  103C 0002                 85              MOVE.B  #2,D0                   * Ask user for input
000010A6  4E4F                      86              TRAP    #15
000010A8                            87              
000010A8                            88              * Error Checking (length)
000010A8  0C01 0000                 89              CMPI.B  #0, D1                  * Check if input length <= 0
000010AC  6F00 0098                 90              BLE     ERROR_1
000010B0  0C01 0008                 91              CMPI.B  #8, D1                  * Check if input length > 8
000010B4  6E00 0090                 92              BGT     ERROR_1
000010B8                            93              
000010B8                            94              * Conversion & Storage
000010B8  4EB9 00001196             95              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010BE  0C07 0001                 96              CMPI.B  #1, D7                  * Check for error
000010C2  6700 0082                 97              BEQ     ERROR_1                 
000010C6  23C1 00004414             98              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
000010CC                            99              
000010CC                           100              * Error Checking (Odd)
000010CC  43F9 00004414            101              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
000010D2  4EB9 00001284            102              JSR     IS_ODD                  * Check if the input address is odd
000010D8  0C07 0001                103              CMPI.B  #1, D7                  * Check for error
000010DC  6700 0088                104              BEQ     ERROR_3
000010E0                           105              
000010E0                           106              * Return
000010E0  4E75                     107              RTS     
000010E2                           108  *---------------------------------------------------------------------------*
000010E2                           109  * END_ADDR: Compute the ending address
000010E2                           110  *---------------------------------------------------------------------------*
000010E2                           111  END_ADDR
000010E2                           112              * Output
000010E2  43F9 0000423E            113              LEA     PROMPT_END,A1           * Load PROMPT_END
000010E8  103C 000E                114              MOVE.B  #14,D0                  * Display PROMPT_END
000010EC  4E4F                     115              TRAP    #15
000010EE                           116  
000010EE                           117              * Input
000010EE  43F9 000043C4            118              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010F4  103C 0002                119              MOVE.B  #2,D0                   * Ask user for input
000010F8  4E4F                     120              TRAP    #15
000010FA                           121              
000010FA                           122              * Error Checking (length)
000010FA  0C01 0000                123              CMPI.B  #0, D1                  * Check if input length <= 0
000010FE  6F00 0056                124              BLE     ERROR_2
00001102  0C01 0008                125              CMPI.B  #8, D1                  * Check if input length > 8
00001106  6E00 004E                126              BGT     ERROR_2
0000110A                           127              
0000110A                           128              * Conversion & Storage
0000110A  4EB9 00001196            129              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001110  0C07 0001                130              CMPI.B  #1, D7                  * Check for error
00001114  6700 0040                131              BEQ     ERROR_2
00001118  23C1 00004418            132              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
0000111E                           133              
0000111E                           134              * Error Checking (start > end case)
0000111E  2439 00004414            135              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
00001124  B282                     136              CMP.L   D2, D1                  * Compare starting and ending address
00001126  6300 005E                137              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
0000112A                           138              
0000112A                           139              * Error Checking (Odd case)
0000112A  43F9 00004418            140              LEA     E_ADDR_HX, A1           * Move the ending address
00001130  4EB9 00001284            141              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
00001136  0C07 0001                142              CMPI.B  #1, D7                  * Check for an error flag
0000113A  6700 003A                143              BEQ     ERROR_4
0000113E                           144              
0000113E                           145              * Inputs are valid
0000113E  2A79 00004414            146              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
00001144                           147              
00001144  4E75                     148              RTS
00001146                           149              
00001146                           150  *---------------------------------------------------------------------------*
00001146                           151  * ERROR_1: Address error (Invalid starting address)
00001146                           152  *---------------------------------------------------------------------------*
00001146                           153  ERROR_1
00001146  43F9 00004303            154              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000114C  103C 000E                155              MOVE.B  #14, D0                 * Display ERRMSG_1
00001150  4E4F                     156              TRAP    #15
00001152  4EF8 1090                157              JMP     START_ADDR              * Jump to START_ADDR
00001156                           158      
00001156                           159  *---------------------------------------------------------------------------*
00001156                           160  * ERROR_2: Address error (Invalid ending address)
00001156                           161  *---------------------------------------------------------------------------*
00001156                           162  ERROR_2
00001156  43F9 00004303            163              LEA     ERRMSG_1, A1            * Load ERRMSG_1
0000115C  103C 000E                164              MOVE.B  #14, D0                 * Display ERRMSG_1
00001160  4E4F                     165              TRAP    #15
00001162  4EF8 10E2                166              JMP     END_ADDR                * Jump to END_ADDR
00001166                           167  
00001166                           168  *---------------------------------------------------------------------------*
00001166                           169  * ERROR_3: Address error (Odd starting address)
00001166                           170  *---------------------------------------------------------------------------*
00001166                           171  ERROR_3
00001166  43F9 00004322            172              LEA     ERRMSG_3, A1
0000116C  103C 000E                173              MOVE.B  #14, D0
00001170  4E4F                     174              TRAP    #15
00001172  4EF8 1090                175              JMP     START_ADDR
00001176                           176     
00001176                           177  *---------------------------------------------------------------------------*
00001176                           178  * ERROR_4: Address error (Odd ending address)
00001176                           179  *---------------------------------------------------------------------------*         
00001176                           180  ERROR_4
00001176  43F9 00004322            181              LEA     ERRMSG_3, A1
0000117C  103C 000E                182              MOVE.B  #14, D0
00001180  4E4F                     183              TRAP    #15
00001182  4EF8 10E2                184              JMP     END_ADDR
00001186                           185            
00001186                           186  *---------------------------------------------------------------------------*
00001186                           187  * ERROR_3: Address error (Ending address is less than starting address)
00001186                           188  *---------------------------------------------------------------------------*
00001186                           189  ERROR_5
00001186  43F9 00004347            190              LEA     ERRMSG_5, A1
0000118C  103C 000E                191              MOVE.B  #14, D0
00001190  4E4F                     192              TRAP    #15
00001192  4EF8 10E2                193              JMP     END_ADDR
00001196                           194    
00001196                           195  *---------------------------------------------------------------------------*
00001196                           196  * ASCII2HEX: Convert ASCii to Hexadecimal
00001196                           197  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001196                           198  *---------------------------------------------------------------------------*
00001196  4281                     199  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001198  4287                     200              CLR.L   D7                      * Set the error flag to 0
0000119A  4282                     201              CLR.L   D2                      * Clear D2 for temp storage
0000119C                           202              
0000119C  1419                     203  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
0000119E  0C02 0000                204              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011A2  6700 0058                205              BEQ     RETURN                  * If it's NULL, go to return
000011A6  0C02 0066                206              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011AA  6E00 004C                207              BGT     ASC_ERR                 * ASCII > f (invalid input) 
000011AE  0C02 0061                208              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011B2  6C00 0026                209              BGE     ASC_LOW                 * ASCII >= a (valid input)
000011B6  0C02 0046                210              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011BA  6E00 003C                211              BGT     ASC_ERR                 * ASCII > F (invalid input)
000011BE  0C02 0041                212              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011C2  6C00 001E                213              BGE     ASC_UPP                 * ASCII >= A (valid input)
000011C6  0C02 0039                214              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011CA  6E00 002C                215              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
000011CE  0C02 0030                216              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011D2  6C00 0016                217              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
000011D6  6000 0020                218              BRA     ASC_ERR                 * Invalid input
000011DA                           219  
000011DA  0442 0057                220  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
000011DE  6000 0012                221              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011E2                           222              
000011E2  0442 0037                223  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011E6  6000 000A                224              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011EA                           225              
000011EA  0442 0030                226  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011EE  6000 0002                227              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011F2                           228              
000011F2  E981                     229  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011F4  D202                     230              ADD.B   D2, D1                  * Add the converted input to D1
000011F6  60A4                     231              BRA     ASC2HXLP                * Loop
000011F8                           232  
000011F8  1E3C 0001                233  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011FC  4E75                     234  RETURN      RTS     
000011FE                           235  
000011FE                           236  *---------------------------------------------------------------------------*
000011FE                           237  * HEX2ASCII: Convert Hexadecimal to ASCii 
000011FE                           238  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
000011FE                           239  *---------------------------------------------------------------------------*
000011FE  0C02 0008                240  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001202  6700 000E                241              BEQ     HEX_LOOP
00001206  4841                     242              SWAP    D1
00001208  0C02 0002                243              CMPI.B  #2,D2
0000120C  6600 0004                244              BNE     HEX_LOOP
00001210  E189                     245              LSL.L   #8,D1
00001212                           246             
00001212  E999                     247  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001214  2601                     248              MOVE.L  D1, D3                  * Move D1 to D3
00001216  0283 0000000F            249              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000121C  0C03 0009                250              CMPI.B  #9, D3                  * Compare te digit
00001220  6E00 000A                251              BGT     HEX_CHAR              
00001224  0603 0030                252              ADDI.B  #48,D3                  * Add 48 for numerical output
00001228  6000 0006                253              BRA     HEX_CONT
0000122C                           254              
0000122C  0603 0037                255  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001230                           256  
00001230  12C3                     257  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001232  5342                     258              SUBI    #1, D2                  * Decrement the size
00001234  0C02 0000                259              CMPI.B  #0, D2                  * Check if D2 is 0
00001238  66D8                     260              BNE     HEX_LOOP                * Loop
0000123A  12BC 0000                261              MOVE.B  #$0,(A1)                * Null terminator
0000123E  4E75                     262              RTS
00001240                           263  *---------------------------------------------------------------------------*
00001240                           264  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001240                           265  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001240                           266  *---------------------------------------------------------------------------*
00001240                           267  HEX2ASCII2STACK
00001240  0C02 0008                268              CMPI.B  #8, D2                  * Check to see if the size is long
00001244  6700 000E                269              BEQ     STACK_HEX_LOOP
00001248  4841                     270              SWAP    D1
0000124A  0C02 0002                271              CMPI.B  #2,D2
0000124E  6600 0004                272              BNE     STACK_HEX_LOOP
00001252  E189                     273              LSL.L   #8,D1
00001254                           274             
00001254                           275  STACK_HEX_LOOP    
00001254  E999                     276              ROL.L   #4, D1                  * Roll D1 to left
00001256  2601                     277              MOVE.L  D1, D3                  * Move D1 to D3
00001258  0283 0000000F            278              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000125E  0C03 0009                279              CMPI.B  #9, D3                  * Compare te digit
00001262  6E00 000A                280              BGT     STACK_HEX_CHAR              
00001266  0603 0030                281              ADDI.B  #48,D3                  * Add 48 for numerical output
0000126A  6000 0006                282              BRA     STACK_HEX_CONT
0000126E                           283              
0000126E                           284  STACK_HEX_CHAR    
0000126E  0603 0037                285              ADDI.B  #55,D3                  * Add 55 for character output
00001272                           286  
00001272                           287  STACK_HEX_CONT    
00001272  6100 2C36                288              BSR     PUSH_STACK              *PLACE INTO STACK
00001276  5342                     289              SUBI    #1, D2                  * Decrement the size
00001278  0C02 0000                290              CMPI.B  #0, D2                  * Check if D2 is 0
0000127C  66D6                     291              BNE     STACK_HEX_LOOP                * Loop
0000127E  12BC 0000                292              MOVE.B  #$0,(A1)                * Null terminator
00001282  4E75                     293              RTS
00001284                           294  
00001284                           295  
00001284                           296  *---------------------------------------------------------------------------*
00001284                           297  * IS_ODD: Check whether the source address is odd
00001284                           298  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
00001284                           299  *---------------------------------------------------------------------------*
00001284  4281                     300  IS_ODD      CLR.L   D1                      * Clear the result
00001286  4287                     301              CLR.L   D7                      * Set the error flag to 0
00001288  2211                     302              MOVE.L  (A1),D1                * Temp store the checking address to D1
0000128A  82FC 0002                303              DIVU    #2, D1                  * Divide the result by 2
0000128E  4841                     304              SWAP    D1                      * Swap remainder with quotient
00001290  0C01 0001                305              CMPI.B  #1, D1                  * Check for error
00001294  6700 0004                306              BEQ     IS_ODD_ERR
00001298  4E75                     307              RTS
0000129A                           308              
0000129A  1E3C 0001                309  IS_ODD_ERR  MOVE.B  #1, D7
0000129E  4E75                     310              RTS
000012A0                           311  
000012A0                           312  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012A0                           313  * MAINDEBUG                    
000012A0                           314  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012A0                           315  * A5: Processing address
000012A0                           316  *
000012A0                           317  * D3: USED FOR PUSHING INTO STACK
000012A0                           318  *     To push into stack => MOVE.W #DATA,D3 
000012A0                           319  *                           BSR    PUSH_STACK
000012A0                           320  *     To print stack     => BSR    PRINT_STACK 
000012A0                           321  *     To clear stack     => BSR    CLEAR_STACK
000012A0                           322  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012A0                           323  MAIN        
000012A0                           324              *initialize stack pointer
000012A0  33FC 0000 000047CC       325              MOVE.W  #0,COUNTER
000012A8  347C 7000                326              MOVEA.W #STACK,A2
000012AC  163C 0020                327              MOVE.B  #' ',D3
000012B0  6100 2BF8                328              BSR     PUSH_STACK
000012B4  6100 2BF4                329              BSR     PUSH_STACK
000012B8  6100 2BF0                330              BSR     PUSH_STACK
000012BC                           331              
000012BC                           332              * clear registers for temp storage
000012BC  4280                     333              CLR.L   D0                   
000012BE  4281                     334              CLR.L   D1                   
000012C0  227C 00000000            335              MOVEA.L #0, A1                
000012C6                           336              
000012C6  220D                     337              MOVE.L  A5,D1                   * check to see if the address is fully read
000012C8  23CD 00004414            338              MOVE.L  A5,S_ADDR_HX
000012CE  B2B9 00004418            339              CMP.L   E_ADDR_HX,D1
000012D4  6C00 22F4                340              BGE     REPEAT                  * go to repeat for user action
000012D8                           341  
000012D8  43F9 0000446F            342              LEA     TMPOUTPUT,A1            * allocate storage to hold output
000012DE  143C 0008                343              MOVE.B  #8,D2                   * set the output size
000012E2  4EB8 11FE                344              JSR     HEX2ASCII               
000012E6  43F9 0000446F            345              LEA     TMPOUTPUT,A1
000012EC  103C 000E                346              MOVE.B  #14,D0
000012F0  4E4F                     347              TRAP    #15
000012F2                           348              
000012F2  4285                     349              CLR.L    D5                      * clear the processing data
000012F4  3A1D                     350              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
000012F6                           351                                               * advance the current instruction pointer to the next
000012F6                           352                                               * instruction in memory
000012F6                           353  *----------------------------------------*
000012F6                           354  * Registers          
000012F6                           355  * [D1] - COPY OF D5
000012F6                           356  * [D5] - DATA TO BE PROCESSED
000012F6                           357  * [D6] - COUNTER FOR LINES PROCESSED
000012F6                           358  *
000012F6                           359  * [D4]      - ERROR FLAG BEFORE PRINTING
000012F6                           360  * [STACK]   - PRINTS PROCESS DATA
000012F6                           361  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
000012F6                           362  *
000012F6                           363  * [A1] - USED FOR JUMPING/PRINTING
000012F6                           364  *
000012F6                           365  *----------------------------------------*
000012F6                           366  
000012F6                           367              
000012F6                           368              *Processing the first 4 most significant bits 
000012F6  2205                     369              MOVE.L  D5,D1                    * copy the current processing data to D1
000012F8  143C 000C                370              MOVE.B  #12,D2                   * shift to right by 12 bits
000012FC  E469                     371              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
000012FE  C2FC 0006                372              MULU    #6,D1                    * form offset
00001302  43F9 00001370            373              LEA     JMPTABLE,A1              * index into table
00001308  4EB1 1000                374              JSR     0(A1,D1)                 * jump indirect with index
0000130C                           375              
0000130C                           376              *SECURED EA*
0000130C  B83C 0001                377              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001310  6600 0012                378              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001314  6100 038E                379              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
00001318  6100 2BFC                380              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000131C  183C 0000                381              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001320  6000 0022                382              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001324                           383             
00001324                           384  OUTPUT_PROCESSED_DATA       
00001324  163C 000D                385              MOVE.B  #$D,D3                  *carriage return
00001328  6100 2B80                386              BSR     PUSH_STACK
0000132C  163C 000A                387              MOVE.B  #$A,D3                  *new line feed
00001330  6100 2B78                388              BSR     PUSH_STACK
00001334  163C 0000                389              MOVE.B  #$0,D3                  *null
00001338  6100 2B70                390              BSR     PUSH_STACK
0000133C                           391       
0000133C  6100 2B48                392              BSR     PRINT_QUEUE
00001340  183C 0000                393              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001344                           394  DISPLAY_30_LINES
00001344                           395              * display 30 lines per page
00001344  5206                     396              ADDI.B  #1,D6
00001346  0C06 001E                397              CMPI.B  #30,D6
0000134A  6C00 0006                398              BGE     NEXTLINES
0000134E  6000 FF50                399              BRA     MAIN
00001352                           400            
00001352                           401  *---------------------------------------------------------------------------*
00001352                           402  * NEXTLINES: receive input from user to print the next 30 lines
00001352                           403  *---------------------------------------------------------------------------*  
00001352  4206                     404  NEXTLINES   CLR.B   D6
00001354  43F9 0000426B            405              LEA     DISP_NEXT,A1
0000135A  103C 000E                406              MOVE.B  #14,D0
0000135E  4E4F                     407              TRAP    #15
00001360  43F9 0000441F            408              LEA     TMPINPUT,A1
00001366  103C 0002                409              MOVE.B  #2,D0
0000136A  4E4F                     410              TRAP    #15
0000136C  4EF8 12A0                411              JMP     MAIN
00001370                           412    
00001370                           413  *---------------------------------------------------------------------------*
00001370                           414  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001370                           415  *---------------------------------------------------------------------------*  
00001370  4EF9 000013D0            416  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *CMPI/ORI/BTST -
00001376  4EF9 000018C0            417              JMP     OP0001  * MOVE.B                                        *FINISHED - JOSEPH
0000137C  4EF9 0000192E            418              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - JOSEPH
00001382  4EF9 00001A2C            419              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - JOSEPH
00001388  4EF9 00001B28            420              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - JOSEPH
0000138E  4EF9 00001D7E            421              JMP     OP0101  * ADDQ                                          *FINISHED - JOSEPH
00001394  4EF9 00001F22            422              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *NOT FINISHED - LYN
0000139A  4EF9 00001FB0            423              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013A0  4EF9 00001FB4            424              JMP     OP1000  * DIVS                                          *FINISHED - JOSEPH
000013A6  4EF9 000020BC            425              JMP     OP1001  * SUB/SUBA                                      *FINISHED - JOSEPH
000013AC  4EF9 00002478            426              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013B2  4EF9 0000247C            427              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - JOSEPH
000013B8  4EF9 0000277C            428              JMP     OP1100  * MULS/AND                                      *FINISHED - JOSEPH
000013BE  4EF9 00002ACE            429              JMP     OP1101  * ADD/ADDA                                      *FINISHED - JOSEPH
000013C4  4EF9 00002EAA            430              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR
000013CA  4EF9 00003158            431              JMP     OP1111  * Special/Reserved
000013D0                           432              
000013D0                           433  *---------------------------------------------------------------------------*
000013D0                           434  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013D0                           435  *---------------------------------------------------------------------------*           
000013D0                           436  OP0000                                                                                  
000013D0  4281                     437              CLR.L   D1          * to temporarily store the address to process
000013D2  4280                     438              CLR.L   D0  
000013D4  4284                     439              CLR.L   D4                 
000013D6  227C 00000000            440              MOVEA.L #0, A1                
000013DC                           441              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013DC                           442              * Check if bit 11,10,9,8 are 0000)
000013DC  2205                     443              MOVE.L  D5,D1
000013DE  0281 00000F00            444              ANDI.L  #$0F00,D1
000013E4  0C81 00000000            445              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
000013EA  6700 03F0                446              BEQ     OP_ORI
000013EE                           447  
000013EE                           448              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
000013EE                           449              * check if bit 11,10,9,8 are 1100
000013EE  4281                     450              CLR.L   D1
000013F0  2205                     451              MOVE.L  D5,D1
000013F2  0281 00000F00            452              ANDI.L  #$0F00,D1
000013F8  0C81 00000C00            453              CMPI.L  #$0C00,D1
000013FE  6700 02F0                454              BEQ     OP0000_CMPI
00001402                           455              
00001402                           456              * check for SUBI
00001402  4281                     457              CLR.L   D1
00001404  2205                     458              MOVE.L  D5,D1
00001406  0281 00000F00            459              ANDI.L  #$0F00,D1
0000140C  0C81 00000400            460              CMPI.L  #$0400,D1
00001412  6700 023A                461              BEQ     OP_SUBI
00001416                           462              
00001416                           463              * check for EORI
00001416  4281                     464              CLR.L   D1
00001418  2205                     465              MOVE.L  D5,D1
0000141A  0281 00000F00            466              ANDI.L  #$0F00,D1
00001420  0C81 00000A00            467              CMPI.L  #$0A00,D1
00001426  6700 0144                468              BEQ     OP_EORI
0000142A                           469              
0000142A                           470              * check for BTST
0000142A  4281                     471              CLR.L   D1
0000142C  2205                     472              MOVE.L  D5,D1
0000142E  E099                     473              ROR.L   #8,D1
00001430  0281 00000001            474              ANDI.L  #$1,D1
00001436  0C01 0001                475              CMPI.B  #$1,D1
0000143A  6700 001E                476              BEQ     OP_BTST
0000143E  4281                     477              CLR.L   D1
00001440  2205                     478              MOVE.L  D5,D1
00001442  EC99                     479              ROR.L   #6,D1
00001444  0281 000003FF            480              ANDI.L  #$03FF,D1
0000144A  0C81 00000020            481              CMPI.L  #%000100000,D1
00001450  6700 0008                482              BEQ     OP_BTST
00001454                           483  
00001454                           484  
00001454                           485              * OP0000 series other than ORI/CMPI/BTST/EORI
00001454  4EF9 000016A4            486              JMP     OP_DATA
0000145A                           487              
0000145A                           488  *---------------------------------------------------------------------------*
0000145A                           489  * OP_BTST: display BTST
0000145A                           490  *---------------------------------------------------------------------------* 
0000145A                           491  OP_BTST       
0000145A                           492              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000145A                           493              *bits #8 indicates which
0000145A                           494              *0 - #immediate format
0000145A                           495              *1 - Dn format
0000145A  4281                     496              CLR.L   D1
0000145C  2205                     497              MOVE.L  D5,D1
0000145E  E099                     498              ROR.L   #8,D1
00001460  0281 00000001            499              ANDI.L  #1,D1
00001466  0C01 0001                500              CMPI.B  #1,D1
0000146A  6600 0078                501              BNE     OP_BTST_IMMEDIATE
0000146E                           502  
0000146E                           503             
0000146E                           504             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000146E  13FC 0000 000047D0       505             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001476  13FC 0002 000047D1       506             MOVE.B   #$02,SRC_REGISTER_FORMAT
0000147E                           507             
0000147E                           508             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000147E  13FC 00B9 000047D3       509             MOVE.B   #$B9,GET_DST_START_END
00001486  13FC 0020 000047D4       510             MOVE.B   #$20,GET_SRC_START_END
0000148E                           511             
0000148E  0285 0000FE3F            512             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001494  0685 00000000            513             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000149A                           514              
0000149A                           515              *CLEAR D3
0000149A  4283                     516              CLR.L   D3
0000149C                           517              *LOAD STACK WITH THIS OPMODE
0000149C  6100 2A0C                518              BSR     PUSH_STACK
000014A0  163C 0042                519              MOVE.B  #'B',D3
000014A4  6100 2A04                520              BSR     PUSH_STACK
000014A8  163C 0054                521              MOVE.B  #'T',D3
000014AC  6100 29FC                522              BSR     PUSH_STACK
000014B0  163C 0053                523              MOVE.B  #'S',D3
000014B4  6100 29F4                524              BSR     PUSH_STACK
000014B8  163C 0054                525              MOVE.B  #'T',D3
000014BC  6100 29EC                526              BSR     PUSH_STACK
000014C0  163C 002E                527              MOVE.B  #'.',D3
000014C4  6100 29E4                528              BSR     PUSH_STACK
000014C8  163C 0042                529              MOVE.B  #'B',D3
000014CC  6100 29DC                530              BSR     PUSH_STACK
000014D0                           531              
000014D0  6100 256A                532              BSR     GET_EA_EA_DEST
000014D4  163C 002C                533              MOVE.B  #',',D3
000014D8  6100 29D0                534              BSR     PUSH_STACK
000014DC  6100 212E                535              BSR     GET_EA_EA_SRC
000014E0                           536              
000014E0  6000 0088                537              BRA     OP0000_RETURN_BTST
000014E4                           538              
000014E4                           539              
000014E4                           540              *MOVE **** OR **** CMPI
000014E4                           541              
000014E4                           542  OP_BTST_IMMEDIATE              
000014E4                           543   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000014E4  13FC 0000 000047D0       544             MOVE.B   #$00,DEST_REGISTER_FORMAT
000014EC  13FC 0082 000047D1       545             MOVE.B   #$82,SRC_REGISTER_FORMAT
000014F4                           546             
000014F4                           547             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014F4  13FC 00B9 000047D3       548             MOVE.B   #$B9,GET_DST_START_END
000014FC  13FC 0020 000047D4       549             MOVE.B   #$20,GET_SRC_START_END
00001504                           550             
00001504                           551              *CLEAR D3
00001504  4283                     552              CLR.L   D3
00001506                           553              *LOAD STACK WITH THIS OPMODE
00001506  6100 29A2                554              BSR     PUSH_STACK
0000150A  163C 0042                555              MOVE.B  #'B',D3
0000150E  6100 299A                556              BSR     PUSH_STACK
00001512  163C 0054                557              MOVE.B  #'T',D3
00001516  6100 2992                558              BSR     PUSH_STACK
0000151A  163C 0053                559              MOVE.B  #'S',D3
0000151E  6100 298A                560              BSR     PUSH_STACK
00001522  163C 0054                561              MOVE.B  #'T',D3
00001526  6100 2982                562              BSR     PUSH_STACK
0000152A  163C 002E                563              MOVE.B  #'.',D3
0000152E  6100 297A                564              BSR     PUSH_STACK
00001532  163C 0042                565              MOVE.B  #'B',D3
00001536  6100 2972                566              BSR     PUSH_STACK
0000153A                           567  
0000153A                           568  OP0000_BTST_B
0000153A                           569              *GET DATA FROM ADDQ AND PRINT #0-8
0000153A                           570              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000153A  0285 0000F03F            571              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001540  0685 000001C0            572              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001546                           573  
00001546                           574              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001546                           575             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001546                           576             * MOVE.W    (A5)+,D1
00001546                           577             * MOVE.B  #' ',D3
00001546                           578             * BSR     PUSH_STACK
00001546                           579             * MOVE.B  #'#',D3
00001546                           580             * BSR     PUSH_STACK
00001546                           581             * BSR     HEX2ASCII2STACK
00001546                           582             * BSR     PUSH_STACK
00001546                           583              
00001546  163C 0020                584              MOVE.B  #' ',D3
0000154A  6100 295E                585              BSR     PUSH_STACK
0000154E  163C 0023                586              MOVE.B  #'#',D3
00001552  6100 2956                587              BSR     PUSH_STACK
00001556  6100 24E4                588              BSR     GET_EA_EA_DEST
0000155A  163C 002C                589              MOVE.B  #',',D3
0000155E  6100 294A                590              BSR     PUSH_STACK
00001562  6100 20A8                591              BSR     GET_EA_EA_SRC
00001566  6000 0002                592              BRA     OP0000_RETURN_BTST
0000156A                           593  OP0000_RETURN_BTST
0000156A                           594              
0000156A  4E75                     595              RTS
0000156C                           596  
0000156C                           597  
0000156C                           598  *---------------------------------------------------------------------------*
0000156C                           599  * OP_EORI: decode and display EORI
0000156C                           600  *---------------------------------------------------------------------------* 
0000156C                           601  OP_EORI
0000156C                           602                         
0000156C                           603  
0000156C                           604   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000156C  13FC 0000 000047D0       605             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001574  13FC 0080 000047D1       606             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000157C                           607             
0000157C                           608             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000157C  13FC 00B9 000047D3       609             MOVE.B   #$B9,GET_DST_START_END
00001584  13FC 0020 000047D4       610             MOVE.B   #$20,GET_SRC_START_END
0000158C                           611             
0000158C                           612              *CLEAR D3
0000158C  4283                     613              CLR.L   D3
0000158E                           614              *LOAD STACK WITH THIS OPMODE
0000158E  6100 291A                615              BSR     PUSH_STACK
00001592  163C 0045                616              MOVE.B  #'E',D3
00001596  6100 2912                617              BSR     PUSH_STACK
0000159A  163C 004F                618              MOVE.B  #'O',D3
0000159E  6100 290A                619              BSR     PUSH_STACK
000015A2  163C 0052                620              MOVE.B  #'R',D3
000015A6  6100 2902                621              BSR     PUSH_STACK
000015AA  163C 0049                622              MOVE.B  #'I',D3
000015AE  6100 28FA                623              BSR     PUSH_STACK
000015B2  163C 002E                624              MOVE.B  #'.',D3
000015B6  6100 28F2                625              BSR     PUSH_STACK
000015BA                           626              
000015BA                           627              *FIGURE OUT SIZE*
000015BA                           628              *00 = BYTE
000015BA                           629              *01 = WORD
000015BA                           630              *10 = LONG
000015BA                           631              * BITS 7&6
000015BA                           632              
000015BA                           633              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015BA  2205                     634              MOVE.L  D5,D1
000015BC  EC99                     635              ROR.L   #6,D1
000015BE  0281 00000003            636              ANDI.L  #$03,D1
000015C4  0C01 0000                637              CMPI.B  #%00,D1
000015C8  6700 001E                638              BEQ     OP0000_EOR_B
000015CC  0281 00000003            639              ANDI.L  #$03,D1
000015D2  0C01 0001                640              CMPI.B  #%01,D1
000015D6  6700 0028                641              BEQ     OP0000_EOR_W
000015DA  0281 00000003            642              ANDI.L  #$03,D1
000015E0  0C01 0002                643              CMPI.B  #%10,D1
000015E4  6700 0032                644              BEQ     OP0000_EOR_L
000015E8                           645            
000015E8                           646  OP0000_EOR_B
000015E8                           647              
000015E8  163C 0042                648              MOVE.B  #'B',D3
000015EC  6100 28BC                649              BSR     PUSH_STACK
000015F0                           650              
000015F0                           651              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000015F0  0285 0000F03F            652              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000015F6  0685 000001C0            653              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
000015FC                           654  
000015FC                           655              
000015FC  6000 002E                656              BRA     OP0000_RETURN
00001600                           657  OP0000_EOR_W
00001600                           658              
00001600  163C 0057                659              MOVE.B  #'W',D3
00001604  6100 28A4                660              BSR     PUSH_STACK
00001608                           661              
00001608                           662              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001608  0285 0000F03F            663              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000160E  0685 000001C0            664              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001614                           665  
00001614                           666              
00001614  6000 0016                667              BRA     OP0000_RETURN
00001618                           668  OP0000_EOR_L
00001618                           669              
00001618  163C 004C                670              MOVE.B  #'L',D3
0000161C  6100 288C                671              BSR     PUSH_STACK
00001620                           672              
00001620                           673              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001620  0285 0000FE3F            674              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001626  0685 000009C0            675              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000162C                           676  
0000162C                           677  
0000162C                           678  OP0000_RETURN            
0000162C  163C 0020                679              MOVE.B  #' ',D3
00001630  6100 2878                680              BSR     PUSH_STACK
00001634  163C 0023                681              MOVE.B  #'#',D3
00001638  6100 2870                682              BSR     PUSH_STACK
0000163C  6100 23FE                683              BSR     GET_EA_EA_DEST
00001640  163C 002C                684              MOVE.B  #',',D3
00001644  6100 2864                685              BSR     PUSH_STACK
00001648  6100 1FC2                686              BSR     GET_EA_EA_SRC
0000164C                           687              
0000164C  4E75                     688              RTS
0000164E                           689  
0000164E                           690  *---------------------------------------------------------------------------*
0000164E                           691  * OP_SUBI: decode SUBI.B/.W/.L
0000164E                           692  *---------------------------------------------------------------------------* 
0000164E                           693  OP_SUBI
0000164E  4281                     694              CLR.L   D1
00001650  4284                     695              CLR.L   D4
00001652  2205                     696              MOVE.L  D5,D1
00001654  EC99                     697              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001656  0C01 0000                698              CMPI.B  #0,D1
0000165A  6700 0012                699              BEQ     OP_SUBI_B    * size is byte
0000165E  0C01 0001                700              CMPI.B  #1,D1
00001662  6700 001C                701              BEQ     OP_SUBI_W    * size is word
00001666  0C01 0002                702              CMPI.B  #2,D1
0000166A  6700 0026                703              BEQ     OP_SUBI_L    * size is long
0000166E                           704  
0000166E                           705  OP_SUBI_B    * size is byte    
0000166E  183C 0000                706              MOVE.B  #0,D4
00001672  43F9 000045E6            707              LEA     DISP_SUBI_B,A1
00001678  103C 000E                708              MOVE.B  #14,D0
0000167C  4E4F                     709              TRAP    #15
0000167E  4E75                     710              RTS
00001680                           711              
00001680                           712  OP_SUBI_W    * size is word
00001680  183C 0001                713              MOVE.B  #1,D4
00001684  43F9 000045F0            714              LEA     DISP_SUBI_W,A1
0000168A  103C 000E                715              MOVE.B  #14,D0
0000168E  4E4F                     716              TRAP    #15
00001690  4E75                     717              RTS
00001692                           718              
00001692                           719  OP_SUBI_L    * size is long
00001692  183C 0002                720              MOVE.B  #2,D4
00001696  43F9 000045FA            721              LEA     DISP_SUBI_L,A1
0000169C  103C 000E                722              MOVE.B  #14,D0
000016A0  4E4F                     723              TRAP    #15
000016A2  4E75                     724              RTS
000016A4                           725              
000016A4                           726  *---------------------------------------------------------------------------*
000016A4                           727  * OP_DATA : unidentified opcode
000016A4                           728  *---------------------------------------------------------------------------* 
000016A4                           729  OP_DATA
000016A4  4280                     730              CLR.L   D0                   
000016A6  4281                     731              CLR.L   D1     
000016A8  4284                     732              CLR.L   D4                    
000016AA  227C 00000000            733              MOVEA.L #0, A1             
000016B0  4287                     734              CLR.L   D7
000016B2  1E3C 0001                735              MOVE.B  #1,D7                   * error flag is true
000016B6                           736              
000016B6  43F9 0000451E            737              LEA     DISP_DATA,A1
000016BC  103C 000E                738              MOVE.B  #14,D0
000016C0  4E4F                     739              TRAP    #15
000016C2                           740              
000016C2  4EF9 000016C8            741              JMP     EA_DATA
000016C8                           742             
000016C8                           743             
000016C8                           744  *---------------------------------------------------------------------------*
000016C8                           745  * EA_DATA
000016C8                           746  *---------------------------------------------------------------------------*       
000016C8  43F9 0000446F            747  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
000016CE  2205                     748              MOVE.L  D5,D1           * transfer the processing data to D1
000016D0  7404                     749              MOVE.L  #4,D2           * set to word size
000016D2  4EB8 11FE                750              JSR     HEX2ASCII       * prepare output in ascii
000016D6  43F9 00004791            751              LEA     DISP_HEX,A1     * display $ symbol
000016DC  103C 000E                752              MOVE.B  #14,D0      
000016E0  4E4F                     753              TRAP    #15
000016E2  43F9 0000446F            754              LEA     TMPOUTPUT,A1    * display with a new line
000016E8  103C 000D                755              MOVE.B  #13,D0
000016EC  4E4F                     756              TRAP    #15
000016EE                           757  
000016EE  4E75                     758              RTS
000016F0                           759              
000016F0                           760  *---------------------------------------------------------------------------*
000016F0                           761  * OP_CMPI : decode CMPI and its size
000016F0                           762  *---------------------------------------------------------------------------*          
000016F0                           763  OP0000_CMPI
000016F0                           764  
000016F0                           765              
000016F0                           766   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000016F0  13FC 0000 000047D0       767             MOVE.B   #$00,DEST_REGISTER_FORMAT
000016F8  13FC 0082 000047D1       768             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001700                           769             
00001700                           770             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001700  13FC 00B9 000047D3       771             MOVE.B   #$B9,GET_DST_START_END
00001708  13FC 0020 000047D4       772             MOVE.B   #$20,GET_SRC_START_END
00001710                           773             
00001710                           774              *CLEAR D3
00001710  4283                     775              CLR.L   D3
00001712                           776              *LOAD STACK WITH THIS OPMODE
00001712  6100 2796                777              BSR     PUSH_STACK
00001716  163C 0043                778              MOVE.B  #'C',D3
0000171A  6100 278E                779              BSR     PUSH_STACK
0000171E  163C 004D                780              MOVE.B  #'M',D3
00001722  6100 2786                781              BSR     PUSH_STACK
00001726  163C 0050                782              MOVE.B  #'P',D3
0000172A  6100 277E                783              BSR     PUSH_STACK
0000172E  163C 0049                784              MOVE.B  #'I',D3
00001732  6100 2776                785              BSR     PUSH_STACK
00001736  163C 002E                786              MOVE.B  #'.',D3
0000173A  6100 276E                787              BSR     PUSH_STACK
0000173E                           788              
0000173E                           789              *FIGURE OUT SIZE*
0000173E                           790              *00 = BYTE
0000173E                           791              *01 = WORD
0000173E                           792              *10 = LONG
0000173E                           793              * BITS 7&6
0000173E                           794              
0000173E                           795              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000173E  2205                     796              MOVE.L  D5,D1
00001740  EC99                     797              ROR.L   #6,D1
00001742  0281 00000003            798              ANDI.L  #$03,D1
00001748  0C01 0000                799              CMPI.B  #%00,D1
0000174C  6700 0018                800              BEQ     OP0000_CMPI_B
00001750  0C01 0001                801              CMPI.B  #%01,D1
00001754  6700 0038                802              BEQ     OP0000_CMPI_W
00001758  0281 00000003            803              ANDI.L  #$03,D1
0000175E  0C01 0002                804              CMPI.B  #%10,D1
00001762  6700 0052                805              BEQ     OP0000_CMPI_L
00001766                           806  
00001766                           807  OP0000_CMPI_B
00001766  163C 0042                808              MOVE.B  #'B',D3
0000176A  6100 273E                809              BSR     PUSH_STACK
0000176E                           810  *GET DATA FROM ADDQ AND PRINT #0-8
0000176E                           811              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000176E  0285 0000F03F            812              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001774  0685 000001C0            813              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000177A  6100 22C0                814              BSR     GET_EA_EA_DEST
0000177E  163C 002C                815              MOVE.B  #',',D3
00001782  6100 2726                816              BSR     PUSH_STACK
00001786  6100 1E84                817              BSR     GET_EA_EA_SRC
0000178A  6000 004E                818              BRA     OP0000_RETURN_CMPI
0000178E                           819  
0000178E                           820  OP0000_CMPI_W
0000178E  163C 0057                821              MOVE.B  #'W',D3
00001792  6100 2716                822              BSR     PUSH_STACK
00001796                           823  *GET DATA FROM ADDQ AND PRINT #0-8
00001796                           824              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001796  0285 0000F03F            825              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000179C  0685 000001C0            826              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000017A2  6100 2298                827              BSR     GET_EA_EA_DEST
000017A6  163C 002C                828              MOVE.B  #',',D3
000017AA  6100 26FE                829              BSR     PUSH_STACK
000017AE  6100 1E5C                830              BSR     GET_EA_EA_SRC
000017B2  6000 0026                831              BRA     OP0000_RETURN_CMPI
000017B6                           832  
000017B6                           833  OP0000_CMPI_L
000017B6  163C 004C                834              MOVE.B  #'L',D3
000017BA  6100 26EE                835              BSR     PUSH_STACK
000017BE                           836              *GET DATA FROM ADDQ AND PRINT #0-8
000017BE                           837              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000017BE  0285 0000F03F            838              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000017C4  0685 000003C0            839              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000017CA  6100 2270                840              BSR     GET_EA_EA_DEST
000017CE  163C 002C                841              MOVE.B  #',',D3
000017D2  6100 26D6                842              BSR     PUSH_STACK
000017D6  6100 1E34                843              BSR     GET_EA_EA_SRC
000017DA                           844              
000017DA                           845  OP0000_RETURN_CMPI
000017DA                           846  
000017DA                           847  
000017DA                           848              
000017DA  4E75                     849              RTS
000017DC                           850   
000017DC                           851  *---------------------------------------------------------------------------*
000017DC                           852  * OP_ORI : decode ORI and its size
000017DC                           853  *---------------------------------------------------------------------------* 
000017DC                           854  OP_ORI      
000017DC                           855           
000017DC                           856   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000017DC  13FC 0000 000047D0       857             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017E4  13FC 0082 000047D1       858             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017EC                           859             
000017EC                           860             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017EC  13FC 00B9 000047D3       861             MOVE.B   #$B9,GET_DST_START_END
000017F4  13FC 0020 000047D4       862             MOVE.B   #$20,GET_SRC_START_END
000017FC                           863             
000017FC                           864              *CLEAR D3
000017FC  4283                     865              CLR.L   D3
000017FE                           866              *LOAD STACK WITH THIS OPMODE
000017FE  6100 26AA                867              BSR     PUSH_STACK
00001802  163C 004F                868              MOVE.B  #'O',D3
00001806  6100 26A2                869              BSR     PUSH_STACK
0000180A  163C 0052                870              MOVE.B  #'R',D3
0000180E  6100 269A                871              BSR     PUSH_STACK
00001812  163C 0049                872              MOVE.B  #'I',D3
00001816  6100 2692                873              BSR     PUSH_STACK
0000181A  163C 002E                874              MOVE.B  #'.',D3
0000181E  6100 268A                875              BSR     PUSH_STACK
00001822                           876              
00001822                           877              *FIGURE OUT SIZE*
00001822                           878              *00 = BYTE
00001822                           879              *01 = WORD
00001822                           880              *10 = LONG
00001822                           881              * BITS 7&6
00001822                           882              
00001822                           883              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001822  2205                     884              MOVE.L  D5,D1
00001824  EC99                     885              ROR.L   #6,D1
00001826  0281 00000003            886              ANDI.L  #$03,D1
0000182C  0C01 0000                887              CMPI.B  #%00,D1
00001830  6700 0018                888              BEQ     OP0000_ORI_B
00001834  0C01 0001                889              CMPI.B  #%01,D1
00001838  6700 0038                890              BEQ     OP0000_ORI_W
0000183C  0281 00000003            891              ANDI.L  #$03,D1
00001842  0C01 0002                892              CMPI.B  #%10,D1
00001846  6700 0052                893              BEQ     OP0000_ORI_L
0000184A                           894  
0000184A                           895  OP0000_ORI_B
0000184A  163C 0042                896              MOVE.B  #'B',D3
0000184E  6100 265A                897              BSR     PUSH_STACK
00001852                           898  *GET DATA FROM ADDQ AND PRINT #0-8
00001852                           899              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001852  0285 0000F03F            900              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001858  0685 000001C0            901              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000185E  6100 21DC                902              BSR     GET_EA_EA_DEST
00001862  163C 002C                903              MOVE.B  #',',D3
00001866  6100 2642                904              BSR     PUSH_STACK
0000186A  6100 1DA0                905              BSR     GET_EA_EA_SRC
0000186E  6000 004E                906              BRA     OP0000_RETURN_ORI
00001872                           907  
00001872                           908  OP0000_ORI_W
00001872  163C 0057                909              MOVE.B  #'W',D3
00001876  6100 2632                910              BSR     PUSH_STACK
0000187A                           911  *GET DATA FROM ADDQ AND PRINT #0-8
0000187A                           912              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000187A  0285 0000F03F            913              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001880  0685 000001C0            914              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001886  6100 21B4                915              BSR     GET_EA_EA_DEST
0000188A  163C 002C                916              MOVE.B  #',',D3
0000188E  6100 261A                917              BSR     PUSH_STACK
00001892  6100 1D78                918              BSR     GET_EA_EA_SRC
00001896  6000 0026                919              BRA     OP0000_RETURN_ORI
0000189A                           920  
0000189A                           921  OP0000_ORI_L
0000189A  163C 004C                922              MOVE.B  #'L',D3
0000189E  6100 260A                923              BSR     PUSH_STACK
000018A2                           924              *GET DATA FROM ADDQ AND PRINT #0-8
000018A2                           925              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000018A2  0285 0000F03F            926              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000018A8  0685 000003C0            927              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000018AE  6100 218C                928              BSR     GET_EA_EA_DEST
000018B2  163C 002C                929              MOVE.B  #',',D3
000018B6  6100 25F2                930              BSR     PUSH_STACK
000018BA  6100 1D50                931              BSR     GET_EA_EA_SRC
000018BE                           932              
000018BE                           933  OP0000_RETURN_ORI
000018BE                           934  
000018BE                           935  
000018BE                           936              
000018BE  4E75                     937              RTS
000018C0                           938  
000018C0                           939          
000018C0                           940  *---------------------------------------------------------------------------*
000018C0                           941  * OP0001: MOVE.B
000018C0                           942  *---------------------------------------------------------------------------*
000018C0                           943  OP0001      
000018C0  4EF9 000018C6            944              JMP     OP_MOVE_B   * display MOVE.B
000018C6                           945              
000018C6                           946  *---------------------------------------------------------------------------*
000018C6                           947  * OP_MOVE_B: display MOVE_B and proceed to EA
000018C6                           948  *---------------------------------------------------------------------------*
000018C6                           949  OP_MOVE_B                                                                       
000018C6                           950             
000018C6                           951             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000018C6  13FC 0082 000047D0       952             MOVE.B   #$82,DEST_REGISTER_FORMAT
000018CE  13FC 0000 000047D1       953             MOVE.B   #$00,SRC_REGISTER_FORMAT
000018D6                           954             
000018D6                           955             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000018D6  13FC 00B9 000047D3       956             MOVE.B   #$B9,GET_DST_START_END
000018DE  13FC 0020 000047D4       957             MOVE.B   #$20,GET_SRC_START_END
000018E6                           958             
000018E6                           959              *CLEAR D3
000018E6  4283                     960              CLR.L   D3
000018E8                           961              *LOAD STACK WITH THIS OPMODE
000018E8  6100 25C0                962              BSR     PUSH_STACK
000018EC  163C 004D                963              MOVE.B  #'M',D3
000018F0  6100 25B8                964              BSR     PUSH_STACK
000018F4  163C 004F                965              MOVE.B  #'O',D3
000018F8  6100 25B0                966              BSR     PUSH_STACK
000018FC  163C 0056                967              MOVE.B  #'V',D3
00001900  6100 25A8                968              BSR     PUSH_STACK
00001904  163C 0045                969              MOVE.B  #'E',D3
00001908  6100 25A0                970              BSR     PUSH_STACK
0000190C  163C 002E                971              MOVE.B  #'.',D3
00001910  6100 2598                972              BSR     PUSH_STACK
00001914  163C 0042                973              MOVE.B  #'B',D3
00001918  6100 2590                974              BSR     PUSH_STACK
0000191C                           975              
0000191C  6100 1CEE                976              BSR     GET_EA_EA_SRC
00001920  163C 002C                977              MOVE.B  #',',D3
00001924  6100 2584                978              BSR     PUSH_STACK
00001928  6100 2112                979              BSR     GET_EA_EA_DEST
0000192C                           980              
0000192C  4E75                     981              RTS
0000192E                           982              
0000192E                           983             
0000192E                           984  *---------------------------------------------------------------------------*
0000192E                           985  * OP0010: decode MOVE.L/MOVEA.L
0000192E                           986  *---------------------------------------------------------------------------*
0000192E                           987  OP0010      
0000192E  183C 0002                988              MOVE.B  #2,D4
00001932  4280                     989              CLR.L   D0                     
00001934  4281                     990              CLR.L   D1                      
00001936  227C 00000000            991              MOVEA.L #0, A1                 
0000193C                           992              
0000193C  2205                     993              MOVE.L  D5,D1
0000193E  EA99                     994              ROR.L   #5,D1
00001940  0281 0000000E            995              ANDI.L  #$E,D1
00001946  0C01 0002                996              CMPI.B  #2,D1
0000194A  6700 0070                997              BEQ     OP_MOVEA_L
0000194E                           998  
0000194E  4EF9 00001954            999              JMP     OP_MOVE_L
00001954                          1000             
00001954                          1001  
00001954                          1002  *---------------------------------------------------------------------------*
00001954                          1003  * OP_MOVE_L: display MOVE_L and proceed to EA
00001954                          1004  *---------------------------------------------------------------------------*
00001954                          1005  OP_MOVE_L   
00001954                          1006             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001954  13FC 0082 000047D0      1007             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000195C  13FC 0000 000047D1      1008             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001964                          1009             
00001964                          1010             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001964  13FC 00B9 000047D3      1011             MOVE.B   #$B9,GET_DST_START_END
0000196C  13FC 0020 000047D4      1012             MOVE.B   #$20,GET_SRC_START_END
00001974                          1013             
00001974                          1014              *CLEAR D3
00001974  4283                    1015              CLR.L   D3
00001976                          1016              *LOAD STACK WITH THIS OPMODE
00001976  6100 2532               1017              BSR     PUSH_STACK
0000197A  163C 004D               1018              MOVE.B  #'M',D3
0000197E  6100 252A               1019              BSR     PUSH_STACK
00001982  163C 004F               1020              MOVE.B  #'O',D3
00001986  6100 2522               1021              BSR     PUSH_STACK
0000198A  163C 0056               1022              MOVE.B  #'V',D3
0000198E  6100 251A               1023              BSR     PUSH_STACK
00001992  163C 0045               1024              MOVE.B  #'E',D3
00001996  6100 2512               1025              BSR     PUSH_STACK
0000199A  163C 002E               1026              MOVE.B  #'.',D3
0000199E  6100 250A               1027              BSR     PUSH_STACK
000019A2  163C 004C               1028              MOVE.B  #'L',D3
000019A6  6100 2502               1029              BSR     PUSH_STACK
000019AA                          1030              
000019AA  6100 1C60               1031              BSR     GET_EA_EA_SRC
000019AE  163C 002C               1032              MOVE.B  #',',D3
000019B2  6100 24F6               1033              BSR     PUSH_STACK
000019B6  6100 2084               1034              BSR     GET_EA_EA_DEST
000019BA                          1035              
000019BA  4E75                    1036              RTS
000019BC                          1037  
000019BC                          1038  
000019BC                          1039  *---------------------------------------------------------------------------*
000019BC                          1040  * OP_MOVEA_L: display MOVEA_L and proceed to EA
000019BC                          1041  *---------------------------------------------------------------------------*
000019BC                          1042  OP_MOVEA_L 
000019BC                          1043             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000019BC  13FC 00FD 000047D0      1044             MOVE.B   #$FD,DEST_REGISTER_FORMAT
000019C4  13FC 0000 000047D1      1045             MOVE.B   #$00,SRC_REGISTER_FORMAT
000019CC                          1046             
000019CC                          1047             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000019CC  13FC 00B9 000047D3      1048             MOVE.B   #$B9,GET_DST_START_END
000019D4  13FC 0020 000047D4      1049             MOVE.B   #$20,GET_SRC_START_END
000019DC                          1050             
000019DC                          1051              *CLEAR D3
000019DC  4283                    1052              CLR.L   D3
000019DE                          1053              *LOAD STACK WITH THIS OPMODE
000019DE  6100 24CA               1054              BSR     PUSH_STACK
000019E2  163C 004D               1055              MOVE.B  #'M',D3
000019E6  6100 24C2               1056              BSR     PUSH_STACK
000019EA  163C 004F               1057              MOVE.B  #'O',D3
000019EE  6100 24BA               1058              BSR     PUSH_STACK
000019F2  163C 0056               1059              MOVE.B  #'V',D3
000019F6  6100 24B2               1060              BSR     PUSH_STACK
000019FA  163C 0045               1061              MOVE.B  #'E',D3
000019FE  6100 24AA               1062              BSR     PUSH_STACK           
00001A02  163C 0041               1063              MOVE.B  #'A',D3
00001A06  6100 24A2               1064              BSR     PUSH_STACK
00001A0A  163C 002E               1065              MOVE.B  #'.',D3
00001A0E  6100 249A               1066              BSR     PUSH_STACK
00001A12  163C 004C               1067              MOVE.B  #'L',D3
00001A16  6100 2492               1068              BSR     PUSH_STACK
00001A1A                          1069              
00001A1A  6100 1BF0               1070              BSR     GET_EA_EA_SRC
00001A1E  163C 002C               1071              MOVE.B  #',',D3
00001A22  6100 2486               1072              BSR     PUSH_STACK
00001A26  6100 2014               1073              BSR     GET_EA_EA_DEST
00001A2A                          1074              
00001A2A  4E75                    1075              RTS
00001A2C                          1076  
00001A2C                          1077              
00001A2C                          1078  *---------------------------------------------------------------------------*
00001A2C                          1079  * OP0011: decode MOVE.W/MOVEA.W
00001A2C                          1080  *---------------------------------------------------------------------------*
00001A2C                          1081  OP0011      
00001A2C  4280                    1082              CLR.L   D0                      
00001A2E  4281                    1083              CLR.L   D1  
00001A30  4284                    1084              CLR.L   D4                   
00001A32  227C 00000000           1085              MOVEA.L #0, A1 
00001A38                          1086                
00001A38  2205                    1087              MOVE.L  D5,D1
00001A3A  EC99                    1088              ROR.L   #6,D1
00001A3C  0281 00000007           1089              ANDI.L  #$07,D1
00001A42  0C01 0001               1090              CMPI.B  #1,D1
00001A46  6700 0070               1091              BEQ     OP_MOVEA_W
00001A4A                          1092              
00001A4A  4EF9 00001A50           1093              JMP     OP_MOVE_W
00001A50                          1094            
00001A50                          1095  *---------------------------------------------------------------------------*
00001A50                          1096  * OP_MOVE_W: display MOVE_W and proceed to EA
00001A50                          1097  *---------------------------------------------------------------------------*
00001A50                          1098  OP_MOVE_W   
00001A50                          1099             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A50  13FC 0082 000047D0      1100             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A58  13FC 0000 000047D1      1101             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A60                          1102             
00001A60                          1103             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A60  13FC 00B9 000047D3      1104             MOVE.B   #$B9,GET_DST_START_END
00001A68  13FC 0020 000047D4      1105             MOVE.B   #$20,GET_SRC_START_END
00001A70                          1106             
00001A70                          1107              *CLEAR D3
00001A70  4283                    1108              CLR.L   D3
00001A72                          1109              *LOAD STACK WITH THIS OPMODE
00001A72  6100 2436               1110              BSR     PUSH_STACK
00001A76  163C 004D               1111              MOVE.B  #'M',D3
00001A7A  6100 242E               1112              BSR     PUSH_STACK
00001A7E  163C 004F               1113              MOVE.B  #'O',D3
00001A82  6100 2426               1114              BSR     PUSH_STACK
00001A86  163C 0056               1115              MOVE.B  #'V',D3
00001A8A  6100 241E               1116              BSR     PUSH_STACK
00001A8E  163C 0045               1117              MOVE.B  #'E',D3
00001A92  6100 2416               1118              BSR     PUSH_STACK
00001A96  163C 002E               1119              MOVE.B  #'.',D3
00001A9A  6100 240E               1120              BSR     PUSH_STACK
00001A9E  163C 0057               1121              MOVE.B  #'W',D3
00001AA2  6100 2406               1122              BSR     PUSH_STACK
00001AA6                          1123              
00001AA6  6100 1B64               1124              BSR     GET_EA_EA_SRC
00001AAA  163C 002C               1125              MOVE.B  #',',D3
00001AAE  6100 23FA               1126              BSR     PUSH_STACK
00001AB2  6100 1F88               1127              BSR     GET_EA_EA_DEST
00001AB6                          1128              
00001AB6  4E75                    1129              RTS
00001AB8                          1130  
00001AB8                          1131  *---------------------------------------------------------------------------*
00001AB8                          1132  * OP_MOVEA_W: display MOVEA and proceed to EA
00001AB8                          1133  *---------------------------------------------------------------------------*
00001AB8                          1134  OP_MOVEA_W 
00001AB8                          1135             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001AB8  13FC 00FD 000047D0      1136             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001AC0  13FC 0000 000047D1      1137             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001AC8                          1138             
00001AC8                          1139             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001AC8  13FC 00B9 000047D3      1140             MOVE.B   #$B9,GET_DST_START_END
00001AD0  13FC 0020 000047D4      1141             MOVE.B   #$20,GET_SRC_START_END
00001AD8                          1142             
00001AD8                          1143              *CLEAR D3
00001AD8  4283                    1144              CLR.L   D3
00001ADA                          1145              *LOAD STACK WITH THIS OPMODE
00001ADA  6100 23CE               1146              BSR     PUSH_STACK
00001ADE  163C 004D               1147              MOVE.B  #'M',D3
00001AE2  6100 23C6               1148              BSR     PUSH_STACK
00001AE6  163C 004F               1149              MOVE.B  #'O',D3
00001AEA  6100 23BE               1150              BSR     PUSH_STACK
00001AEE  163C 0056               1151              MOVE.B  #'V',D3
00001AF2  6100 23B6               1152              BSR     PUSH_STACK
00001AF6  163C 0045               1153              MOVE.B  #'E',D3
00001AFA  6100 23AE               1154              BSR     PUSH_STACK           
00001AFE  163C 0041               1155              MOVE.B  #'A',D3
00001B02  6100 23A6               1156              BSR     PUSH_STACK
00001B06  163C 002E               1157              MOVE.B  #'.',D3
00001B0A  6100 239E               1158              BSR     PUSH_STACK
00001B0E  163C 0057               1159              MOVE.B  #'W',D3
00001B12  6100 2396               1160              BSR     PUSH_STACK
00001B16                          1161              
00001B16  6100 1AF4               1162              BSR     GET_EA_EA_SRC
00001B1A  163C 002C               1163              MOVE.B  #',',D3
00001B1E  6100 238A               1164              BSR     PUSH_STACK
00001B22  6100 1F18               1165              BSR     GET_EA_EA_DEST
00001B26                          1166            
00001B26  4E75                    1167              RTS
00001B28                          1168  *---------------------------------------------------------------------------*
00001B28                          1169  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001B28                          1170  *---------------------------------------------------------------------------*
00001B28                          1171  OP0100
00001B28  4280                    1172              CLR.L   D0                      
00001B2A  4281                    1173              CLR.L   D1  
00001B2C  4284                    1174              CLR.L   D4                      
00001B2E  227C 00000000           1175              MOVEA.L #0, A1                  
00001B34  2205                    1176              MOVE.L  D5,D1  
00001B36                          1177              
00001B36                          1178              * check for RTS
00001B36  0C41 4E75               1179              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001B3A  6700 0228               1180              BEQ     OP_RTS
00001B3E                          1181              
00001B3E                          1182              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001B3E  4281                    1183              CLR.L   D1 
00001B40  2205                    1184              MOVE.L  D5,D1  
00001B42  0241 0F00               1185              ANDI.W  #$0F00,D1
00001B46  0C41 0E00               1186              CMPI.W  #$0E00,D1
00001B4A  6700 0204               1187              BEQ     OP_JSR
00001B4E                          1188  
00001B4E                          1189              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001B4E  4281                    1190              CLR.L   D1 
00001B50  2205                    1191              MOVE.L  D5,D1  
00001B52  0241 0F00               1192              ANDI.W  #$0F00,D1
00001B56  0C41 0400               1193              CMPI.W  #$0400,D1
00001B5A  6700 00E8               1194              BEQ     OP_NEG
00001B5E                          1195              
00001B5E                          1196              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001B5E  4281                    1197              CLR.L   D1 
00001B60  2205                    1198              MOVE.L  D5,D1  
00001B62  0241 0F00               1199              ANDI.W  #$0F00,D1
00001B66  0C41 0600               1200              CMPI.W  #$0600,D1
00001B6A  6700 015E               1201              BEQ     OP_NOT
00001B6E                          1202              
00001B6E                          1203              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001B6E  4281                    1204              CLR.L   D1 
00001B70  2205                    1205              MOVE.L  D5,D1  
00001B72  EC99                    1206              ROR.L   #6,D1
00001B74  0281 00000007           1207              ANDI.L  #7,D1
00001B7A  0C81 00000007           1208              CMPI.L  #7,D1
00001B80  6700 0054               1209              BEQ     OP_LEA
00001B84                          1210              
00001B84                          1211              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001B84  4281                    1212              CLR.L   D1 
00001B86  2205                    1213              MOVE.L  D5,D1  
00001B88  EB59                    1214              ROL.W   #5,D1
00001B8A  0C01 0001               1215              CMPI.B  #1,D1
00001B8E  6600 FB14               1216              BNE     OP_DATA
00001B92  E959                    1217              ROL.W   #4,D1
00001B94  0C01 0001               1218              CMPI.B  #1,D1
00001B98  6600 FB0A               1219              BNE     OP_DATA
00001B9C  E359                    1220              ROL.W   #1,D1
00001B9E  0C01 0000               1221              CMPI.B  #0,D1
00001BA2  6700 000E               1222              BEQ     OP_MOVEM_W
00001BA6  0C01 0001               1223              CMPI.B  #1,D1
00001BAA  6700 0018               1224              BEQ     OP_MOVEM_L
00001BAE  4EF8 16A4               1225              JMP     OP_DATA
00001BB2                          1226  
00001BB2                          1227  *---------------------------------------------------------------------------*
00001BB2                          1228  * OP_MOVEM_W: display MOVEM_W
00001BB2                          1229  *---------------------------------------------------------------------------*    
00001BB2                          1230  OP_MOVEM_W  
00001BB2  183C 0001               1231              MOVE.B  #1,D4
00001BB6  43F9 0000458F           1232              LEA     DISP_MOVEM_W,A1
00001BBC  103C 000E               1233              MOVE.B  #14,D0
00001BC0  4E4F                    1234              TRAP    #15
00001BC2  4E75                    1235              RTS
00001BC4                          1236  
00001BC4                          1237  *---------------------------------------------------------------------------*
00001BC4                          1238  * OP_MOVEM_L: display MOVEM_L
00001BC4                          1239  *---------------------------------------------------------------------------*
00001BC4                          1240  OP_MOVEM_L  
00001BC4  183C 0002               1241              MOVE.B  #2,D4
00001BC8  43F9 0000459A           1242              LEA     DISP_MOVEM_L,A1
00001BCE  103C 000E               1243              MOVE.B  #14,D0
00001BD2  4E4F                    1244              TRAP    #15
00001BD4  4E75                    1245              RTS
00001BD6                          1246     
00001BD6                          1247  *---------------------------------------------------------------------------*
00001BD6                          1248  * OP_LEA: decode and display LEA
00001BD6                          1249  *---------------------------------------------------------------------------*
00001BD6                          1250  OP_LEA      
00001BD6  4281                    1251               CLR.L   D1       
00001BD8  4284                    1252              CLR.L   D4                   
00001BDA  227C 00000000           1253              MOVEA.L #0, A1              
00001BE0  2205                    1254              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001BE2                          1255              *CLEAR D3
00001BE2  4283                    1256              CLR.L   D3
00001BE4                          1257  
00001BE4                          1258  OP_LEA_DN_EA_OR_EA_DN 
00001BE4                          1259              *LOAD STACK WITH THIS OPMODE
00001BE4  6100 22C4               1260              BSR     PUSH_STACK
00001BE8  163C 004C               1261              MOVE.B  #'L',D3
00001BEC  6100 22BC               1262              BSR     PUSH_STACK
00001BF0  163C 0045               1263              MOVE.B  #'E',D3
00001BF4  6100 22B4               1264              BSR     PUSH_STACK
00001BF8  163C 0041               1265              MOVE.B  #'A',D3
00001BFC  6100 22AC               1266              BSR     PUSH_STACK
00001C00  2205                    1267              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001C02                          1268          
00001C02                          1269  
00001C02                          1270  OP_PRINT_L_LEA
00001C02                          1271                          
00001C02                          1272              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001C02  13FC 0000 000047D0      1273              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001C0A  13FC 009B 000047D1      1274              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001C12                          1275             
00001C12                          1276              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001C12  13FC 00B9 000047D3      1277              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001C1A  13FC 0020 000047D4      1278              MOVE.B   #$20,GET_SRC_START_END
00001C22                          1279  
00001C22                          1280              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001C22  0285 0000FE3F           1281              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001C28  0685 00000040           1282              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001C2E                          1283  
00001C2E  6100 19DC               1284              BSR     GET_EA_EA_SRC      *GETS <ea>
00001C32  163C 002C               1285              MOVE.B  #',',D3
00001C36  6100 2272               1286              BSR     PUSH_STACK           
00001C3A  6100 1E00               1287              BSR     GET_EA_EA_DEST       *GETS Dn    
00001C3E                          1288  
00001C3E                          1289              
00001C3E  6000 0002               1290              BRA     OP_LEA_RETURN
00001C42                          1291              
00001C42                          1292  OP_LEA_RETURN
00001C42  4E75                    1293              RTS
00001C44                          1294              
00001C44                          1295  
00001C44                          1296  
00001C44                          1297  *---------------------------------------------------------------------------*
00001C44                          1298  * OP_NEG: decode and display NEG 
00001C44                          1299  *---------------------------------------------------------------------------*
00001C44                          1300  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001C44  4281                    1301              CLR.L   D1
00001C46  4284                    1302              CLR.L   D4
00001C48  2205                    1303              MOVE.L  D5,D1
00001C4A                          1304              
00001C4A                          1305              *CLEAR D3
00001C4A  4283                    1306              CLR.L   D3
00001C4C                          1307              *LOAD STACK WITH THIS OPMODE
00001C4C  6100 225C               1308              BSR     PUSH_STACK
00001C50  163C 004E               1309              MOVE.B  #'N',D3
00001C54  6100 2254               1310              BSR     PUSH_STACK
00001C58  163C 0045               1311              MOVE.B  #'E',D3
00001C5C  6100 224C               1312              BSR     PUSH_STACK
00001C60  163C 0047               1313              MOVE.B  #'G',D3
00001C64  6100 2244               1314              BSR     PUSH_STACK
00001C68  163C 002E               1315              MOVE.B  #'.',D3
00001C6C  6100 223C               1316              BSR     PUSH_STACK
00001C70                          1317              
00001C70                          1318              
00001C70  EC99                    1319              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001C72  0281 00000007           1320              ANDI.L  #$07,D1
00001C78                          1321              
00001C78  0C01 0000               1322              CMPI.B  #0,D1
00001C7C  6700 0012               1323              BEQ     OP_NEG_B    * size is byte
00001C80  0C01 0001               1324              CMPI.B  #1,D1
00001C84  6700 0016               1325              BEQ     OP_NEG_W    * size is word
00001C88  0C01 0002               1326              CMPI.B  #2,D1
00001C8C  6700 001A               1327              BEQ     OP_NEG_L    * size is long
00001C90                          1328                         
00001C90                          1329  
00001C90                          1330  OP_NEG_B    * size is byte   
00001C90  163C 0042               1331              MOVE.B  #'B',D3
00001C94  6100 2214               1332              BSR     PUSH_STACK
00001C98  6000 001A               1333              BRA     OP_NEG_PRINT_EA
00001C9C                          1334  
00001C9C                          1335              
00001C9C                          1336  OP_NEG_W    * size is word
00001C9C  163C 0057               1337              MOVE.B  #'W',D3
00001CA0  6100 2208               1338              BSR     PUSH_STACK
00001CA4  6000 000E               1339              BRA     OP_NEG_PRINT_EA
00001CA8                          1340  
00001CA8                          1341              
00001CA8                          1342  OP_NEG_L    * size is long
00001CA8  163C 004C               1343              MOVE.B  #'L',D3
00001CAC  6100 21FC               1344              BSR     PUSH_STACK
00001CB0  6000 0002               1345              BRA     OP_NEG_PRINT_EA
00001CB4                          1346  
00001CB4                          1347  
00001CB4                          1348  OP_NEG_PRINT_EA
00001CB4                          1349   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CB4  13FC 0082 000047D1      1350             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001CBC                          1351             
00001CBC                          1352             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CBC  13FC 0020 000047D4      1353             MOVE.B   #$20,GET_SRC_START_END
00001CC4                          1354                         
00001CC4                          1355  
00001CC4  6100 1946               1356              BSR     GET_EA_EA_SRC
00001CC8                          1357              
00001CC8  4E75                    1358              RTS
00001CCA                          1359  
00001CCA                          1360  *---------------------------------------------------------------------------*
00001CCA                          1361  * OP_NOT: decode and display NOT 
00001CCA                          1362  *---------------------------------------------------------------------------*
00001CCA                          1363  OP_NOT
00001CCA  4281                    1364              CLR.L   D1
00001CCC  4284                    1365              CLR.L   D4
00001CCE  2205                    1366              MOVE.L  D5,D1
00001CD0                          1367              
00001CD0                          1368              *CLEAR D3
00001CD0  4283                    1369              CLR.L   D3
00001CD2                          1370              *LOAD STACK WITH THIS OPMODE
00001CD2  6100 21D6               1371              BSR     PUSH_STACK
00001CD6  163C 004E               1372              MOVE.B  #'N',D3
00001CDA  6100 21CE               1373              BSR     PUSH_STACK
00001CDE  163C 004F               1374              MOVE.B  #'O',D3
00001CE2  6100 21C6               1375              BSR     PUSH_STACK
00001CE6  163C 0054               1376              MOVE.B  #'T',D3
00001CEA  6100 21BE               1377              BSR     PUSH_STACK
00001CEE  163C 002E               1378              MOVE.B  #'.',D3
00001CF2  6100 21B6               1379              BSR     PUSH_STACK
00001CF6                          1380              
00001CF6                          1381              
00001CF6  EC99                    1382              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001CF8  0281 00000007           1383              ANDI.L  #$07,D1
00001CFE                          1384              
00001CFE  0C01 0000               1385              CMPI.B  #0,D1
00001D02  6700 0012               1386              BEQ     OP_NOT_B    * size is byte
00001D06  0C01 0001               1387              CMPI.B  #1,D1
00001D0A  6700 0016               1388              BEQ     OP_NOT_W    * size is word
00001D0E  0C01 0002               1389              CMPI.B  #2,D1
00001D12  6700 001A               1390              BEQ     OP_NOT_L    * size is long
00001D16                          1391                         
00001D16                          1392  
00001D16                          1393  OP_NOT_B    * size is byte   
00001D16  163C 0042               1394              MOVE.B  #'B',D3
00001D1A  6100 218E               1395              BSR     PUSH_STACK
00001D1E  6000 001A               1396              BRA     OP_NOT_PRINT_EA
00001D22                          1397  
00001D22                          1398              
00001D22                          1399  OP_NOT_W    * size is word
00001D22  163C 0057               1400              MOVE.B  #'W',D3
00001D26  6100 2182               1401              BSR     PUSH_STACK
00001D2A  6000 000E               1402              BRA     OP_NOT_PRINT_EA
00001D2E                          1403  
00001D2E                          1404              
00001D2E                          1405  OP_NOT_L    * size is long
00001D2E  163C 004C               1406              MOVE.B  #'L',D3
00001D32  6100 2176               1407              BSR     PUSH_STACK
00001D36  6000 0002               1408              BRA     OP_NOT_PRINT_EA
00001D3A                          1409  
00001D3A                          1410  
00001D3A                          1411  OP_NOT_PRINT_EA
00001D3A                          1412   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D3A  13FC 0082 000047D1      1413             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D42                          1414             
00001D42                          1415             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D42  13FC 0020 000047D4      1416             MOVE.B   #$20,GET_SRC_START_END
00001D4A  6100 18C0               1417              BSR     GET_EA_EA_SRC
00001D4E                          1418              
00001D4E  4E75                    1419              RTS
00001D50                          1420  
00001D50                          1421  
00001D50                          1422  *---------------------------------------------------------------------------*
00001D50                          1423  * OP_JSR: display JSR     
00001D50                          1424  *---------------------------------------------------------------------------*
00001D50  43F9 0000454B           1425  OP_JSR      LEA     DISP_JSR,A1
00001D56  103C 000E               1426              MOVE.B  #14,D0
00001D5A  4E4F                    1427              TRAP    #15
00001D5C  4EB9 0000315C           1428              JSR     EA_NOSRC
00001D62                          1429  
00001D62  4E75                    1430              RTS
00001D64                          1431  
00001D64                          1432  *---------------------------------------------------------------------------*
00001D64                          1433  * OP_RTS: display RTS     
00001D64                          1434  *---------------------------------------------------------------------------* 
00001D64                          1435  OP_RTS      
00001D64  163C 0052               1436              MOVE.B #'R',D3
00001D68  6100 2140               1437              BSR     PUSH_STACK
00001D6C  163C 0054               1438              MOVE.B #'T',D3
00001D70  6100 2138               1439              BSR     PUSH_STACK
00001D74  163C 0053               1440              MOVE.B #'S',D3
00001D78  6100 2130               1441              BSR     PUSH_STACK
00001D7C  4E75                    1442              RTS
00001D7E                          1443  
00001D7E                          1444  *---------------------------------------------------------------------------*
00001D7E                          1445  * OP0101: decode ADDQ
00001D7E                          1446  *---------------------------------------------------------------------------* 
00001D7E                          1447  OP0101      
00001D7E                          1448             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D7E  13FC 0082 000047D0      1449             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001D86  13FC 0080 000047D1      1450             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001D8E                          1451             
00001D8E                          1452             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D8E  13FC 00B9 000047D3      1453             MOVE.B   #$B9,GET_DST_START_END
00001D96  13FC 0020 000047D4      1454             MOVE.B   #$20,GET_SRC_START_END
00001D9E                          1455             
00001D9E                          1456              *CLEAR D3
00001D9E  4283                    1457              CLR.L   D3
00001DA0                          1458              *LOAD STACK WITH THIS OPMODE
00001DA0  6100 2108               1459              BSR     PUSH_STACK
00001DA4  163C 0041               1460              MOVE.B  #'A',D3
00001DA8  6100 2100               1461              BSR     PUSH_STACK
00001DAC  163C 0044               1462              MOVE.B  #'D',D3
00001DB0  6100 20F8               1463              BSR     PUSH_STACK
00001DB4  163C 0044               1464              MOVE.B  #'D',D3
00001DB8  6100 20F0               1465              BSR     PUSH_STACK
00001DBC  163C 0051               1466              MOVE.B  #'Q',D3
00001DC0  6100 20E8               1467              BSR     PUSH_STACK
00001DC4  163C 002E               1468              MOVE.B  #'.',D3
00001DC8  6100 20E0               1469              BSR     PUSH_STACK
00001DCC                          1470              
00001DCC                          1471              *FIGURE OUT SIZE*
00001DCC                          1472              *00 = BYTE
00001DCC                          1473              *01 = WORD
00001DCC                          1474              *10 = LONG
00001DCC                          1475              * BITS 7&6
00001DCC                          1476              
00001DCC                          1477              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001DCC  2205                    1478              MOVE.L  D5,D1
00001DCE  EC99                    1479              ROR.L   #6,D1
00001DD0  0281 00000003           1480              ANDI.L  #$03,D1
00001DD6  0C01 0000               1481              CMPI.B  #%00,D1
00001DDA  6700 001E               1482              BEQ     OP0101_ADDQ_B
00001DDE  0281 00000003           1483              ANDI.L  #$03,D1
00001DE4  0C01 0001               1484              CMPI.B  #%01,D1
00001DE8  6700 001C               1485              BEQ     OP0101_ADDQ_W
00001DEC  0281 00000003           1486              ANDI.L  #$03,D1
00001DF2  0C01 0002               1487              CMPI.B  #%10,D1
00001DF6  6700 001A               1488              BEQ     OP0101_ADDQ_L
00001DFA                          1489            
00001DFA                          1490  OP0101_ADDQ_B
00001DFA                          1491              
00001DFA  163C 0042               1492              MOVE.B  #'B',D3
00001DFE  6100 20AA               1493              BSR     PUSH_STACK
00001E02  6000 0016               1494              BRA     OP0101_RETURN
00001E06                          1495  OP0101_ADDQ_W
00001E06                          1496              
00001E06  163C 0057               1497              MOVE.B  #'W',D3
00001E0A  6100 209E               1498              BSR     PUSH_STACK
00001E0E  6000 000A               1499              BRA     OP0101_RETURN
00001E12                          1500  OP0101_ADDQ_L
00001E12                          1501              
00001E12  163C 004C               1502              MOVE.B  #'L',D3
00001E16  6100 2092               1503              BSR     PUSH_STACK
00001E1A                          1504  OP0101_RETURN            
00001E1A                          1505  
00001E1A                          1506              
00001E1A                          1507  *GET DATA FROM ADDQ AND PRINT #0-8
00001E1A  163C 0020               1508              MOVE.B  #' ',D3
00001E1E  6100 208A               1509              BSR     PUSH_STACK
00001E22  163C 0023               1510              MOVE.B  #'#',D3
00001E26  6100 2082               1511              BSR     PUSH_STACK 
00001E2A                          1512  
00001E2A                          1513                       
00001E2A                          1514              *GET DATA #   
00001E2A  2205                    1515              MOVE.L  D5,D1
00001E2C  EC99                    1516              ROR.L   #6,D1            
00001E2E  E699                    1517              ROR.L   #3,D1
00001E30  0281 00000007           1518              ANDI.L  #$07,D1
00001E36                          1519              
00001E36  0C01 0000               1520              CMPI.B  #%000,D1
00001E3A  6700 009A               1521              BEQ     OP0101_ADDQ_B_8
00001E3E  0C01 0001               1522              CMPI.B  #%001,D1
00001E42  6700 003E               1523              BEQ     OP0101_ADDQ_B_1
00001E46  0C01 0002               1524              CMPI.B  #%010,D1
00001E4A  6700 0042               1525              BEQ     OP0101_ADDQ_B_2
00001E4E  0C01 0003               1526              CMPI.B  #%011,D1
00001E52  6700 0046               1527              BEQ     OP0101_ADDQ_B_3
00001E56  0C01 0004               1528              CMPI.B  #%100,D1
00001E5A  6700 004A               1529              BEQ     OP0101_ADDQ_B_4
00001E5E  0C01 0005               1530              CMPI.B  #%101,D1
00001E62  6700 004E               1531              BEQ     OP0101_ADDQ_B_5
00001E66  0C01 0006               1532              CMPI.B  #%110,D1
00001E6A  6700 0052               1533              BEQ     OP0101_ADDQ_B_6
00001E6E  0C01 0007               1534              CMPI.B  #%111,D1
00001E72  6700 0056               1535              BEQ     OP0101_ADDQ_B_7
00001E76                          1536              
00001E76                          1537  OP0101_ADDQ_B_0
00001E76  163C 0030               1538              MOVE.B  #'0',D3
00001E7A  6100 202E               1539              BSR     PUSH_STACK
00001E7E  6000 005E               1540              BRA     OP0101_RETURN2            
00001E82                          1541  OP0101_ADDQ_B_1
00001E82  163C 0031               1542              MOVE.B  #'1',D3
00001E86  6100 2022               1543              BSR     PUSH_STACK
00001E8A  6000 0052               1544              BRA     OP0101_RETURN2            
00001E8E                          1545  OP0101_ADDQ_B_2
00001E8E  163C 0032               1546              MOVE.B  #'2',D3
00001E92  6100 2016               1547              BSR     PUSH_STACK
00001E96  6000 0046               1548              BRA     OP0101_RETURN2            
00001E9A                          1549  OP0101_ADDQ_B_3
00001E9A  163C 0033               1550              MOVE.B  #'3',D3
00001E9E  6100 200A               1551              BSR     PUSH_STACK
00001EA2  6000 003A               1552              BRA     OP0101_RETURN2            
00001EA6                          1553  OP0101_ADDQ_B_4
00001EA6  163C 0034               1554              MOVE.B  #'4',D3
00001EAA  6100 1FFE               1555              BSR     PUSH_STACK
00001EAE  6000 002E               1556              BRA     OP0101_RETURN2            
00001EB2                          1557  OP0101_ADDQ_B_5
00001EB2  163C 0035               1558              MOVE.B  #'5',D3
00001EB6  6100 1FF2               1559              BSR     PUSH_STACK
00001EBA  6000 0022               1560              BRA     OP0101_RETURN2
00001EBE                          1561  OP0101_ADDQ_B_6
00001EBE  163C 0036               1562              MOVE.B  #'6',D3
00001EC2  6100 1FE6               1563              BSR     PUSH_STACK
00001EC6  6000 0016               1564              BRA     OP0101_RETURN2
00001ECA                          1565  OP0101_ADDQ_B_7
00001ECA  163C 0037               1566              MOVE.B  #'7',D3
00001ECE  6100 1FDA               1567              BSR     PUSH_STACK
00001ED2  6000 000A               1568              BRA     OP0101_RETURN2
00001ED6                          1569  
00001ED6                          1570  OP0101_ADDQ_B_8
00001ED6  163C 0038               1571              MOVE.B  #'8',D3
00001EDA  6100 1FCE               1572              BSR     PUSH_STACK
00001EDE                          1573              
00001EDE                          1574  OP0101_RETURN2            
00001EDE  163C 002C               1575              MOVE.B  #',',D3
00001EE2  6100 1FC6               1576              BSR     PUSH_STACK
00001EE6  6100 1724               1577              BSR     GET_EA_EA_SRC
00001EEA                          1578              
00001EEA  4E75                    1579              RTS
00001EEC                          1580  
00001EEC                          1581  
00001EEC                          1582              
00001EEC                          1583  *---------------------------------------------------------------------------*
00001EEC                          1584  * OP_ADDQ: display ADDQ
00001EEC                          1585  *---------------------------------------------------------------------------*              
00001EEC                          1586  OP_ADDQ_B    * size is byte   
00001EEC  183C 0000               1587              MOVE.B  #0,D4 
00001EF0  43F9 000045A5           1588              LEA     DISP_ADDQ_B,A1
00001EF6  103C 000E               1589              MOVE.B  #14,D0
00001EFA  4E4F                    1590              TRAP    #15
00001EFC  4E75                    1591              RTS
00001EFE                          1592              
00001EFE                          1593  OP_ADDQ_W    * size is word
00001EFE  183C 0001               1594              MOVE.B  #1,D4
00001F02  43F9 000045AF           1595              LEA     DISP_ADDQ_W,A1
00001F08  103C 000E               1596              MOVE.B  #14,D0
00001F0C  4E4F                    1597              TRAP    #15
00001F0E  4E75                    1598              RTS
00001F10                          1599              
00001F10                          1600  OP_ADDQ_L    * size is long
00001F10  183C 0002               1601              MOVE.B  #2,D4
00001F14  43F9 000045B9           1602              LEA     DISP_ADDQ_L,A1
00001F1A  103C 000E               1603              MOVE.B  #14,D0
00001F1E  4E4F                    1604              TRAP    #15
00001F20  4E75                    1605              RTS
00001F22                          1606  
00001F22                          1607  *---------------------------------------------------------------------------*
00001F22                          1608  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001F22                          1609  *---------------------------------------------------------------------------*              
00001F22  4280                    1610  OP0110      CLR.L   D0                  
00001F24  4281                    1611              CLR.L   D1   
00001F26  4284                    1612              CLR.L   D4                 
00001F28  227C 00000000           1613              MOVEA.L #0,A1
00001F2E  2205                    1614              MOVE.L  D5, D1                
00001F30  0281 000000FF           1615              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001F36  2205                    1616              MOVE.L  D5,D1                  
00001F38  0281 00000F00           1617              ANDI.L  #$0F00,D1
00001F3E                          1618                 
00001F3E  0C41 0000               1619              CMPI.W  #$0000,D1               * Check for BRA
00001F42  6700 0050               1620              BEQ     OP_BRA                  
00001F46                          1621                          
00001F46  0C41 0D00               1622              CMPI.W  #$0D00,D1               * Check for BLT
00001F4A  6700 0056               1623              BEQ     OP_BLT      
00001F4E                          1624  
00001F4E  0C41 0700               1625              CMPI.W  #$0700,D1               * Check for BEQ
00001F52  6700 0032               1626              BEQ     OP_BEQ      
00001F56                          1627  
00001F56  0C41 0600               1628              CMPI.W  #$0600,D1               * Check for BNE
00001F5A  6700 001C               1629              BEQ     OP_BNE  
00001F5E                          1630              
00001F5E  0C41 0200               1631              CMPI.W  #$0200,D1               * Check for BHI
00001F62  6700 0006               1632              BEQ     OP_BHI
00001F66                          1633  
00001F66  4EF8 16A4               1634              JMP     OP_DATA
00001F6A                          1635              
00001F6A  43F9 00004774           1636  OP_BHI      LEA     DISP_BHI,A1             
00001F70  103C 000E               1637              MOVE.B  #14,D0
00001F74  4E4F                    1638              TRAP    #15
00001F76  4E75                    1639              RTS
00001F78                          1640  
00001F78  43F9 0000476D           1641  OP_BNE      LEA     DISP_BNE,A1             
00001F7E  103C 000E               1642              MOVE.B  #14,D0
00001F82  4E4F                    1643              TRAP    #15
00001F84  4E75                    1644              RTS
00001F86                          1645  
00001F86  43F9 00004766           1646  OP_BEQ      LEA     DISP_BEQ,A1             
00001F8C  103C 000E               1647              MOVE.B  #14,D0
00001F90  4E4F                    1648              TRAP    #15
00001F92  4E75                    1649              RTS          
00001F94                          1650                          
00001F94  43F9 00004758           1651  OP_BRA      LEA     DISP_BRA,A1             
00001F9A  103C 000E               1652              MOVE.B  #14,D0
00001F9E  4E4F                    1653              TRAP    #15
00001FA0  4E75                    1654              RTS
00001FA2                          1655              
00001FA2  43F9 0000475F           1656  OP_BLT      LEA     DISP_BLT,A1          
00001FA8  103C 000E               1657              MOVE.B  #14,D0
00001FAC  4E4F                    1658              TRAP    #15
00001FAE  4E75                    1659              RTS
00001FB0                          1660     
00001FB0                          1661  *---------------------------------------------------------------------------*
00001FB0                          1662  * OP0111 : MOVEQ not required
00001FB0                          1663  *---------------------------------------------------------------------------*           
00001FB0  4EF8 16A4               1664  OP0111      JMP     OP_DATA
00001FB4                          1665             
00001FB4                          1666  *---------------------------------------------------------------------------*
00001FB4                          1667  * OP1000 : decode DIVS
00001FB4                          1668  *---------------------------------------------------------------------------*           
00001FB4                          1669  OP1000                           
00001FB4  4281                    1670              CLR.L   D1       
00001FB6  4284                    1671              CLR.L   D4                   
00001FB8  227C 00000000           1672              MOVEA.L #0, A1              
00001FBE  2205                    1673              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001FC0                          1674              *CLEAR D3
00001FC0  4283                    1675              CLR.L   D3
00001FC2                          1676  
00001FC2                          1677  OP1000_DIVS_DN_EA_OR_EA_DN 
00001FC2                          1678              *LOAD STACK WITH THIS OPMODE
00001FC2  6100 1EE6               1679              BSR     PUSH_STACK
00001FC6  163C 0044               1680              MOVE.B  #'D',D3
00001FCA  6100 1EDE               1681              BSR     PUSH_STACK
00001FCE  163C 0049               1682              MOVE.B  #'I',D3
00001FD2  6100 1ED6               1683              BSR     PUSH_STACK
00001FD6  163C 0056               1684              MOVE.B  #'V',D3
00001FDA  6100 1ECE               1685              BSR     PUSH_STACK
00001FDE  163C 0053               1686              MOVE.B  #'S',D3
00001FE2  6100 1EC6               1687              BSR     PUSH_STACK
00001FE6  163C 002E               1688              MOVE.B  #'.',D3
00001FEA  6100 1EBE               1689              BSR     PUSH_STACK
00001FEE                          1690              
00001FEE  2205                    1691              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001FF0                          1692              
00001FF0                          1693  OP1000_EA_DN_DIVS
00001FF0                          1694              *BITS (7 TO 6) 
00001FF0                          1695              *00 = .B
00001FF0                          1696              *01 = .W
00001FF0                          1697              *10 = .L 
00001FF0  2205                    1698              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00001FF2  EC99                    1699              ROR.L   #6,D1
00001FF4  0281 00000003           1700              ANDI.L  #$03,D1
00001FFA  0C81 00000003           1701              CMPI.L  #%11,D1 *EQUALS .W
00002000  6700 0014               1702              BEQ     OP1000_PRINT_W_DIVS
00002004  0C81 00000000           1703              CMPI.L  #%00,D1 *EQUALS .L
0000200A  6700 0052               1704              BEQ     OP1000_PRINT_L_DIVS
0000200E                          1705              
0000200E  183C 0001               1706              MOVE.B  #1,D4               *ERROR READ
00002012  6000 0092               1707              BRA     OP1000_DIVS_RETURN
00002016                          1708  OP1000_PRINT_W_DIVS
00002016  163C 0057               1709              MOVE.B  #'W',D3
0000201A  6100 1E8E               1710              BSR     PUSH_STACK
0000201E                          1711  
0000201E                          1712              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000201E  13FC 0000 000047D0      1713              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002026  13FC 0000 000047D1      1714              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000202E                          1715             
0000202E                          1716              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000202E  13FC 00B9 000047D3      1717              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002036  13FC 0020 000047D4      1718              MOVE.B   #$20,GET_SRC_START_END
0000203E                          1719  
0000203E                          1720             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000203E  0285 0000FE3F           1721              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002044  0685 00000000           1722              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000204A                          1723  
0000204A                          1724              
0000204A  6100 15C0               1725              BSR     GET_EA_EA_SRC      *GETS <ea>
0000204E  163C 002C               1726              MOVE.B  #',',D3
00002052  6100 1E56               1727              BSR     PUSH_STACK
00002056  6100 19E4               1728              BSR     GET_EA_EA_DEST       *GETS Dn    
0000205A                          1729              
0000205A  6000 004A               1730              BRA     OP1000_DIVS_RETURN
0000205E                          1731  OP1000_PRINT_L_DIVS
0000205E  163C 004C               1732              MOVE.B  #'L',D3
00002062  6100 1E46               1733              BSR     PUSH_STACK
00002066                          1734              
00002066                          1735              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002066  13FC 0000 000047D0      1736              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000206E  13FC 0000 000047D1      1737              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002076                          1738             
00002076                          1739              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002076  13FC 00B9 000047D3      1740              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000207E  13FC 0020 000047D4      1741              MOVE.B   #$20,GET_SRC_START_END
00002086                          1742  
00002086                          1743              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002086  0285 0000FE3F           1744              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000208C  0685 00000000           1745              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002092                          1746  
00002092                          1747                     
00002092  6100 1578               1748              BSR     GET_EA_EA_SRC      *GETS <ea>
00002096  163C 002C               1749              MOVE.B  #',',D3
0000209A  6100 1E0E               1750              BSR     PUSH_STACK                  
0000209E  6100 199C               1751              BSR     GET_EA_EA_DEST       *GETS Dn    
000020A2                          1752  
000020A2                          1753              
000020A2  6000 0002               1754              BRA     OP1000_DIVS_RETURN
000020A6                          1755              
000020A6                          1756  OP1000_DIVS_RETURN
000020A6  4E75                    1757              RTS
000020A8                          1758              
000020A8                          1759  
000020A8                          1760  
000020A8                          1761  *---------------------------------------------------------------------------*
000020A8                          1762  * OP_DIVS: display DIVS and proceed to EA
000020A8                          1763  *---------------------------------------------------------------------------*  
000020A8  43F9 000045C3           1764  OP_DIVS     LEA     DISP_DIVS,A1
000020AE  103C 000E               1765              MOVE.B  #14,D0
000020B2  4E4F                    1766              TRAP    #15
000020B4  4EF9 00003170           1767              JMP     EA_ARITH
000020BA                          1768  
000020BA  4E75                    1769              RTS
000020BC                          1770              
000020BC                          1771  *---------------------------------------------------------------------------*
000020BC                          1772  * OP1001: decode SUB/SUBA
000020BC                          1773  *---------------------------------------------------------------------------*      
000020BC                          1774  OP1001      
000020BC  4280                    1775              CLR.L   D0                  
000020BE  4281                    1776              CLR.L   D1       
000020C0  4284                    1777              CLR.L   D4                   
000020C2  227C 00000000           1778              MOVEA.L #0, A1              
000020C8  2205                    1779              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020CA                          1780              
000020CA                          1781              *CLEAR D3
000020CA  4283                    1782              CLR.L   D3
000020CC                          1783              
000020CC                          1784              
000020CC                          1785              
000020CC                          1786              **INTEGRATING SUB.W/.L INTO THIS CODE**
000020CC  2205                    1787              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000020CE                          1788              *BITS (INDEX 8) 
000020CE                          1789              *0 = ADD.B/W/L <EA>,Dn
000020CE                          1790              *1 = ADD.B/W/L Dn,<EA> 
000020CE  EC99                    1791              ROR.L   #6,D1
000020D0  0281 00000007           1792              ANDI.L  #$07,D1                 *MASKS WITH 00000111
000020D6  0C81 00000007           1793              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
000020DC  6700 0010               1794              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
000020E0  0C81 00000003           1795              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
000020E6  6700 0078               1796              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
000020EA  6000 00E6               1797              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
000020EE                          1798              
000020EE                          1799  OP1001_SUBA_L
000020EE                          1800              *LOAD STACK WITH THIS OPMODE
000020EE  6100 1DBA               1801              BSR     PUSH_STACK
000020F2  163C 0053               1802              MOVE.B  #'S',D3
000020F6  6100 1DB2               1803              BSR     PUSH_STACK
000020FA  163C 0055               1804              MOVE.B  #'U',D3
000020FE  6100 1DAA               1805              BSR     PUSH_STACK
00002102  163C 0042               1806              MOVE.B  #'B',D3
00002106  6100 1DA2               1807              BSR     PUSH_STACK
0000210A  163C 0041               1808              MOVE.B  #'A',D3
0000210E  6100 1D9A               1809              BSR     PUSH_STACK
00002112  163C 002E               1810              MOVE.B  #'.',D3
00002116  6100 1D92               1811              BSR     PUSH_STACK
0000211A  163C 004C               1812              MOVE.B  #'L',D3
0000211E  6100 1D8A               1813              BSR     PUSH_STACK
00002122                          1814              
00002122                          1815             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002122  13FC 0000 000047D0      1816             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000212A  13FC 0000 000047D1      1817             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002132                          1818             
00002132                          1819             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002132  13FC 00B9 000047D3      1820             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000213A  13FC 0020 000047D4      1821             MOVE.B   #$20,GET_SRC_START_END
00002142                          1822  
00002142                          1823              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002142  0285 0000FE3F           1824              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002148  0685 00000040           1825              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000214E                          1826       
0000214E                          1827              *PRINT <EA>,AN
0000214E  6100 14BC               1828              BSR     GET_EA_EA_SRC       *GETS <ea>
00002152  163C 002C               1829              MOVE.B  #',',D3
00002156  6100 1D52               1830              BSR     PUSH_STACK                     
0000215A  6100 18E0               1831              BSR     GET_EA_EA_DEST      *GETS Dn
0000215E                          1832  
0000215E                          1833              
0000215E                          1834              
0000215E  4E75                    1835              RTS
00002160                          1836  OP1001_SUBA_W
00002160                          1837              *LOAD STACK WITH THIS OPMODE
00002160  6100 1D48               1838              BSR     PUSH_STACK
00002164  163C 0053               1839              MOVE.B  #'S',D3
00002168  6100 1D40               1840              BSR     PUSH_STACK
0000216C  163C 0055               1841              MOVE.B  #'U',D3
00002170  6100 1D38               1842              BSR     PUSH_STACK
00002174  163C 0042               1843              MOVE.B  #'B',D3
00002178  6100 1D30               1844              BSR     PUSH_STACK
0000217C  163C 0041               1845              MOVE.B  #'A',D3
00002180  6100 1D28               1846              BSR     PUSH_STACK
00002184  163C 002E               1847              MOVE.B  #'.',D3
00002188  6100 1D20               1848              BSR     PUSH_STACK
0000218C  163C 0057               1849              MOVE.B  #'W',D3
00002190  6100 1D18               1850              BSR     PUSH_STACK
00002194                          1851              
00002194                          1852             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002194  13FC 0000 000047D0      1853             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000219C  13FC 0000 000047D1      1854             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000021A4                          1855             
000021A4                          1856             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000021A4  13FC 00B9 000047D3      1857             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021AC  13FC 0020 000047D4      1858             MOVE.B   #$20,GET_SRC_START_END
000021B4                          1859  
000021B4                          1860              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021B4  0285 0000FE3F           1861              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021BA  0685 00000040           1862              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000021C0                          1863       
000021C0                          1864              *PRINT <EA>,AN
000021C0  6100 144A               1865              BSR     GET_EA_EA_SRC       *GETS <ea>
000021C4  163C 002C               1866              MOVE.B  #',',D3
000021C8  6100 1CE0               1867              BSR     PUSH_STACK                     
000021CC  6100 186E               1868              BSR     GET_EA_EA_DEST      *GETS Dn
000021D0                          1869  
000021D0  4E75                    1870              RTS
000021D2                          1871  
000021D2                          1872  OP1001_DETERMINE_DN_EA_OR_EA_DN 
000021D2                          1873              *LOAD STACK WITH THIS OPMODE
000021D2  6100 1CD6               1874              BSR     PUSH_STACK
000021D6  163C 0053               1875              MOVE.B  #'S',D3
000021DA  6100 1CCE               1876              BSR     PUSH_STACK
000021DE  163C 0055               1877              MOVE.B  #'U',D3
000021E2  6100 1CC6               1878              BSR     PUSH_STACK
000021E6  163C 0042               1879              MOVE.B  #'B',D3
000021EA  6100 1CBE               1880              BSR     PUSH_STACK
000021EE  163C 002E               1881              MOVE.B  #'.',D3
000021F2  6100 1CB6               1882              BSR     PUSH_STACK
000021F6                          1883              
000021F6  2205                    1884              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021F8                          1885              
000021F8                          1886              *BITS (INDEX 8) 
000021F8                          1887              *0 = ADD.B/W/L <EA>,Dn
000021F8                          1888              *1 = ADD.B/W/L Dn,<EA> 
000021F8  E099                    1889              ROR.L   #8,D1
000021FA  0281 00000001           1890              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002200  0C81 00000000           1891              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002206  6700 0102               1892              BEQ     OP1001_EA_DN
0000220A                          1893              *else procede to Dn_EA
0000220A                          1894              
0000220A                          1895  OP1001_DN_EA
0000220A                          1896              *BITS (7 TO 6) 
0000220A                          1897              *00 = .B
0000220A                          1898              *01 = .W
0000220A                          1899              *10 = .L 
0000220A  2205                    1900              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000220C  EC99                    1901              ROR.L   #6,D1
0000220E  0281 00000003           1902              ANDI.L  #$03,D1
00002214  0C81 00000000           1903              CMPI.L  #$00,D1 *EQUALS .B
0000221A  6700 0016               1904              BEQ     OP1001_PRINT_B2
0000221E  0C81 00000001           1905              CMPI.L  #$01,D1 *EQUALS .W
00002224  6700 0054               1906              BEQ     OP1001_PRINT_W2
00002228  0C81 00000002           1907              CMPI.L  #$02,D1 *EQUALS .L
0000222E  6700 0092               1908              BEQ     OP1001_PRINT_L2
00002232                          1909  OP1001_PRINT_B2
00002232                          1910              *PUSH 'B'
00002232  163C 0042               1911              MOVE.B  #'B',D3
00002236  6100 1C72               1912              BSR     PUSH_STACK
0000223A                          1913             
0000223A                          1914              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000223A  13FC 0000 000047D0      1915             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002242  13FC 0083 000047D1      1916             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000224A                          1917             
0000224A                          1918             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000224A  13FC 00B9 000047D3      1919             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002252  13FC 0020 000047D4      1920             MOVE.B   #$20,GET_SRC_START_END
0000225A                          1921  
0000225A                          1922              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000225A  0285 0000FE3F           1923              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002260  0685 00000040           1924              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002266                          1925       
00002266  6100 17D4               1926              BSR     GET_EA_EA_DEST      *GETS Dn
0000226A  163C 002C               1927              MOVE.B  #',',D3
0000226E  6100 1C3A               1928              BSR     PUSH_STACK                     
00002272  6100 1398               1929              BSR     GET_EA_EA_SRC       *GETS <ea>
00002276                          1930  
00002276                          1931              
00002276  6000 0BA4               1932              BRA     OP1101_ADD_RETURN
0000227A                          1933  OP1001_PRINT_W2
0000227A  163C 0057               1934              MOVE.B  #'W',D3
0000227E  6100 1C2A               1935              BSR     PUSH_STACK
00002282                          1936  
00002282                          1937              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002282  13FC 0000 000047D0      1938              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000228A  13FC 0083 000047D1      1939              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002292                          1940             
00002292                          1941              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002292  13FC 00B9 000047D3      1942              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000229A  13FC 0020 000047D4      1943              MOVE.B   #$20,GET_SRC_START_END
000022A2                          1944  
000022A2                          1945              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022A2  0285 0000FE3F           1946              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022A8  0685 00000040           1947              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000022AE                          1948  
000022AE                          1949        
000022AE  6100 178C               1950              BSR     GET_EA_EA_DEST      *GETS Dn
000022B2  163C 002C               1951              MOVE.B  #',',D3
000022B6  6100 1BF2               1952              BSR     PUSH_STACK               
000022BA  6100 1350               1953              BSR     GET_EA_EA_SRC       *GETS <ea>       
000022BE                          1954  
000022BE                          1955  
000022BE                          1956  
000022BE  6000 0B5C               1957              BRA     OP1101_ADD_RETURN
000022C2                          1958  OP1001_PRINT_L2 
000022C2  163C 004C               1959              MOVE.B  #'L',D3
000022C6  6100 1BE2               1960              BSR     PUSH_STACK
000022CA                          1961              
000022CA                          1962              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022CA  13FC 0000 000047D0      1963              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022D2  13FC 0083 000047D1      1964              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022DA                          1965             
000022DA                          1966              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022DA  13FC 00B9 000047D3      1967              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022E2  13FC 0020 000047D4      1968              MOVE.B   #$20,GET_SRC_START_END
000022EA                          1969  
000022EA                          1970             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022EA  0285 0000FE3F           1971              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022F0  0685 00000040           1972              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022F6                          1973  
000022F6                          1974               
000022F6  6100 1744               1975              BSR     GET_EA_EA_DEST       *GETS Dn
000022FA  163C 002C               1976              MOVE.B  #',',D3
000022FE  6100 1BAA               1977              BSR     PUSH_STACK          
00002302  6100 1308               1978              BSR     GET_EA_EA_SRC        *GETS <ea>
00002306                          1979  
00002306  6000 0B14               1980              BRA     OP1101_ADD_RETURN
0000230A                          1981              
0000230A                          1982  OP1001_EA_DN           
0000230A                          1983              *BITS (7 TO 6) 
0000230A                          1984              *00 = .B
0000230A                          1985              *01 = .W
0000230A                          1986              *10 = .L 
0000230A  2205                    1987              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
0000230C  EC99                    1988              ROR.L   #6,D1
0000230E  0281 00000003           1989              ANDI.L  #$03,D1
00002314  0C81 00000000           1990              CMPI.L  #$00,D1 *EQUALS .B
0000231A  6700 0016               1991              BEQ     OP1001_PRINT_B
0000231E  0C81 00000001           1992              CMPI.L  #$01,D1 *EQUALS .W
00002324  6700 0054               1993              BEQ     OP1001_PRINT_W
00002328  0C81 00000002           1994              CMPI.L  #$02,D1 *EQUALS .L
0000232E  6700 0092               1995              BEQ     OP1001_PRINT_L
00002332                          1996  OP1001_PRINT_B
00002332  163C 0042               1997              MOVE.B  #'B',D3
00002336  6100 1B72               1998              BSR     PUSH_STACK
0000233A                          1999                
0000233A                          2000              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000233A  13FC 0000 000047D0      2001              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002342  13FC 0002 000047D1      2002              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000234A                          2003             
0000234A                          2004              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000234A  13FC 00B9 000047D3      2005              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002352  13FC 0020 000047D4      2006              MOVE.B   #$20,GET_SRC_START_END
0000235A                          2007  
0000235A                          2008             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000235A  0285 0000FE3F           2009              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002360  0685 00000040           2010              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002366                          2011  
00002366                          2012              
00002366  6100 12A4               2013              BSR     GET_EA_EA_SRC      *GETS <ea>
0000236A  163C 002C               2014              MOVE.B  #',',D3
0000236E  6100 1B3A               2015              BSR     PUSH_STACK          
00002372  6100 16C8               2016              BSR     GET_EA_EA_DEST       *GETS Dn
00002376                          2017              
00002376  6000 0AA4               2018              BRA     OP1101_ADD_RETURN
0000237A                          2019  OP1001_PRINT_W
0000237A  163C 0057               2020              MOVE.B  #'W',D3
0000237E  6100 1B2A               2021              BSR     PUSH_STACK
00002382                          2022  
00002382                          2023              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002382  13FC 0000 000047D0      2024              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000238A  13FC 0000 000047D1      2025              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002392                          2026             
00002392                          2027              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002392  13FC 00B9 000047D3      2028              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000239A  13FC 0020 000047D4      2029              MOVE.B   #$20,GET_SRC_START_END
000023A2                          2030  
000023A2                          2031             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023A2  0285 0000FE3F           2032              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023A8  0685 00000040           2033              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023AE                          2034  
000023AE                          2035              
000023AE  6100 125C               2036              BSR     GET_EA_EA_SRC      *GETS <ea>
000023B2  163C 002C               2037              MOVE.B  #',',D3
000023B6  6100 1AF2               2038              BSR     PUSH_STACK
000023BA  6100 1680               2039              BSR     GET_EA_EA_DEST       *GETS Dn    
000023BE                          2040              
000023BE  6000 004A               2041              BRA     OP1001_ADD_RETURN
000023C2                          2042  OP1001_PRINT_L 
000023C2  163C 004C               2043              MOVE.B  #'L',D3
000023C6  6100 1AE2               2044              BSR     PUSH_STACK
000023CA                          2045              
000023CA                          2046              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023CA  13FC 0000 000047D0      2047              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023D2  13FC 0000 000047D1      2048              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023DA                          2049             
000023DA                          2050              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023DA  13FC 00B9 000047D3      2051              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023E2  13FC 0020 000047D4      2052              MOVE.B   #$20,GET_SRC_START_END
000023EA                          2053  
000023EA                          2054              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023EA  0285 0000FE3F           2055              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023F0  0685 00000040           2056              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000023F6                          2057  
000023F6                          2058                     
000023F6  6100 1214               2059              BSR     GET_EA_EA_SRC      *GETS <ea>
000023FA  163C 002C               2060              MOVE.B  #',',D3
000023FE  6100 1AAA               2061              BSR     PUSH_STACK                  
00002402  6100 1638               2062              BSR     GET_EA_EA_DEST       *GETS Dn    
00002406                          2063  
00002406                          2064              
00002406  6000 0002               2065              BRA     OP1001_ADD_RETURN
0000240A                          2066              
0000240A                          2067  OP1001_ADD_RETURN
0000240A  4E75                    2068              RTS
0000240C                          2069  
0000240C                          2070    
0000240C                          2071  *---------------------------------------------------------------------------*
0000240C                          2072  * OP_SUB: display SUB and proceed to EA
0000240C                          2073  *---------------------------------------------------------------------------*            
0000240C  43F9 000045CB           2074  OP_SUB_B    LEA     DISP_SUB_B,A1
00002412  103C 000E               2075              MOVE.B  #14,D0
00002416  4E4F                    2076              TRAP    #15
00002418  183C 0000               2077              MOVE.B  #0,D4
0000241C  4EF9 000031BC           2078              JMP     EA_GEN
00002422                          2079  
00002422  4E75                    2080              RTS
00002424                          2081  
00002424  43F9 000045D4           2082  OP_SUB_W    LEA     DISP_SUB_W,A1
0000242A  103C 000E               2083              MOVE.B  #14,D0
0000242E  4E4F                    2084              TRAP    #15
00002430  183C 0001               2085              MOVE.B  #1,D4
00002434  4EF9 000031BC           2086              JMP     EA_GEN
0000243A                          2087  
0000243A  4E75                    2088              RTS
0000243C                          2089  
0000243C  43F9 000045DD           2090  OP_SUB_L    LEA     DISP_SUB_L,A1
00002442  103C 000E               2091              MOVE.B  #14,D0
00002446  4E4F                    2092              TRAP    #15
00002448  183C 0002               2093              MOVE.B  #2,D4
0000244C  4EF9 000031BC           2094              JMP     EA_GEN
00002452                          2095  
00002452  4E75                    2096              RTS
00002454                          2097  
00002454                          2098  *---------------------------------------------------------------------------*
00002454                          2099  * OP_SUBA: display SUBA
00002454                          2100  *---------------------------------------------------------------------------*  
00002454  43F9 00004604           2101  OP_SUBA_W   LEA     DISP_SUBA_W,A1
0000245A  103C 000E               2102              MOVE.B  #14,D0
0000245E  4E4F                    2103              TRAP    #15
00002460  183C 0001               2104              MOVE.B  #1,D4
00002464  4E75                    2105              RTS
00002466                          2106  
00002466  43F9 0000460E           2107  OP_SUBA_L   LEA     DISP_SUBA_L,A1
0000246C  103C 000E               2108              MOVE.B  #14,D0
00002470  4E4F                    2109              TRAP    #15
00002472  183C 0002               2110              MOVE.B  #2,D4
00002476  4E75                    2111              RTS         
00002478                          2112  *---------------------------------------------------------------------------*
00002478                          2113  * OP1010 : unassigned
00002478                          2114  *---------------------------------------------------------------------------*           
00002478  4EF8 16A4               2115  OP1010      JMP     OP_DATA
0000247C                          2116              
0000247C                          2117  *---------------------------------------------------------------------------*
0000247C                          2118  * OP1011 : decode CMP/EOR/CMPA
0000247C                          2119  *---------------------------------------------------------------------------*           
0000247C  4280                    2120  OP1011      CLR.L   D0                
0000247E  4281                    2121              CLR.L   D1            
00002480  4284                    2122              CLR.L   D4                   
00002482  227C 00000000           2123              MOVEA.L #0, A1               
00002488  2205                    2124              MOVE.L  D5,D1
0000248A  EA99                    2125              ROR.L   #5,D1
0000248C  0281 0000000E           2126              ANDI.L  #$E,D1
00002492  0C01 0000               2127              CMPI.B  #$0,D1
00002496  6700 003E               2128              BEQ     OP1011_CMP
0000249A  0C01 0002               2129              CMPI.B  #$2,D1
0000249E  6700 0036               2130              BEQ     OP1011_CMP
000024A2  0C01 0004               2131              CMPI.B  #$4,D1
000024A6  6700 002E               2132              BEQ     OP1011_CMP
000024AA  0C01 0008               2133              CMPI.B  #$8,D1
000024AE  6700 0178               2134              BEQ     OP1011_EOR
000024B2  0C01 000A               2135              CMPI.B  #$A,D1
000024B6  6700 0170               2136              BEQ     OP1011_EOR
000024BA  0C01 000C               2137              CMPI.B  #$C,D1
000024BE  6700 0168               2138              BEQ     OP1011_EOR  
000024C2  0C01 0006               2139              CMPI.B  #$6,D1
000024C6  6700 00C0               2140              BEQ     OP1011_CMPA
000024CA  0C01 000E               2141              CMPI.B  #$E,D1
000024CE  6700 00B8               2142              BEQ     OP1011_CMPA 
000024D2                          2143  
000024D2  4EF8 16A4               2144              JMP     OP_DATA          
000024D6                          2145  
000024D6                          2146  
000024D6                          2147  
000024D6                          2148  
000024D6                          2149  OP1011_CMP
000024D6                          2150             
000024D6                          2151   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024D6  13FC 0082 000047D0      2152             MOVE.B   #$82,DEST_REGISTER_FORMAT
000024DE  13FC 0000 000047D1      2153             MOVE.B   #$00,SRC_REGISTER_FORMAT
000024E6                          2154             
000024E6                          2155             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024E6  13FC 00B9 000047D3      2156             MOVE.B   #$B9,GET_DST_START_END
000024EE  13FC 0020 000047D4      2157             MOVE.B   #$20,GET_SRC_START_END
000024F6                          2158             
000024F6                          2159              *CLEAR D3
000024F6  4283                    2160              CLR.L   D3
000024F8                          2161              *LOAD STACK WITH THIS OPMODE
000024F8  6100 19B0               2162              BSR     PUSH_STACK
000024FC  163C 0043               2163              MOVE.B  #'C',D3
00002500  6100 19A8               2164              BSR     PUSH_STACK
00002504  163C 004D               2165              MOVE.B  #'M',D3
00002508  6100 19A0               2166              BSR     PUSH_STACK
0000250C  163C 0050               2167              MOVE.B  #'P',D3
00002510  6100 1998               2168              BSR     PUSH_STACK
00002514  163C 002E               2169              MOVE.B  #'.',D3
00002518  6100 1990               2170              BSR     PUSH_STACK
0000251C                          2171              
0000251C                          2172              *FIGURE OUT SIZE*
0000251C                          2173              *00 = BYTE
0000251C                          2174              *01 = WORD
0000251C                          2175              *10 = LONG
0000251C                          2176              * BITS 7&6
0000251C                          2177              
0000251C                          2178              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000251C  2205                    2179              MOVE.L  D5,D1
0000251E  EC99                    2180              ROR.L   #6,D1
00002520  0281 00000003           2181              ANDI.L  #$03,D1
00002526  0C01 0000               2182              CMPI.B  #%00,D1
0000252A  6700 001E               2183              BEQ     OP1011_CMP_B
0000252E  0281 00000003           2184              ANDI.L  #$03,D1
00002534  0C01 0001               2185              CMPI.B  #%01,D1
00002538  6700 001C               2186              BEQ     OP1011_CMP_W
0000253C  0281 00000003           2187              ANDI.L  #$03,D1
00002542  0C01 0002               2188              CMPI.B  #%10,D1
00002546  6700 001A               2189              BEQ     OP1011_CMP_L
0000254A                          2190            
0000254A                          2191  OP1011_CMP_B
0000254A                          2192              
0000254A  163C 0042               2193              MOVE.B  #'B',D3
0000254E  6100 195A               2194              BSR     PUSH_STACK
00002552  6000 0016               2195              BRA     OP1011_RETURN_CMP  
00002556                          2196  OP1011_CMP_W
00002556                          2197              
00002556  163C 0057               2198              MOVE.B  #'W',D3
0000255A  6100 194E               2199              BSR     PUSH_STACK
0000255E  6000 000A               2200              BRA     OP1011_RETURN_CMP  
00002562                          2201  OP1011_CMP_L
00002562                          2202              
00002562  163C 004C               2203              MOVE.B  #'L',D3
00002566  6100 1942               2204              BSR     PUSH_STACK
0000256A                          2205  OP1011_RETURN_CMP            
0000256A                          2206  
0000256A                          2207              
0000256A                          2208  *GET DATA FROM ADDQ AND PRINT #0-8
0000256A                          2209       
0000256A                          2210              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000256A  0285 0000FE3F           2211              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002570  0685 00000000           2212              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002576                          2213  
00002576  6100 1094               2214              BSR     GET_EA_EA_SRC
0000257A  163C 002C               2215              MOVE.B  #',',D3
0000257E  6100 192A               2216              BSR     PUSH_STACK
00002582  6100 14B8               2217              BSR     GET_EA_EA_DEST
00002586                          2218              
00002586  4E75                    2219              RTS
00002588                          2220              
00002588                          2221  
00002588                          2222  
00002588                          2223  OP1011_CMPA
00002588                          2224              
00002588                          2225   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002588  13FC 0080 000047D0      2226             MOVE.B   #$80,DEST_REGISTER_FORMAT
00002590  13FC 0000 000047D1      2227             MOVE.B   #$00,SRC_REGISTER_FORMAT
00002598                          2228             
00002598                          2229             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002598  13FC 00B9 000047D3      2230             MOVE.B   #$B9,GET_DST_START_END
000025A0  13FC 0020 000047D4      2231             MOVE.B   #$20,GET_SRC_START_END
000025A8                          2232             
000025A8                          2233              *CLEAR D3
000025A8  4283                    2234              CLR.L   D3
000025AA                          2235              *LOAD STACK WITH THIS OPMODE
000025AA  6100 18FE               2236              BSR     PUSH_STACK
000025AE  163C 0043               2237              MOVE.B  #'C',D3
000025B2  6100 18F6               2238              BSR     PUSH_STACK
000025B6  163C 004D               2239              MOVE.B  #'M',D3
000025BA  6100 18EE               2240              BSR     PUSH_STACK
000025BE  163C 0050               2241              MOVE.B  #'P',D3
000025C2  6100 18E6               2242              BSR     PUSH_STACK
000025C6  163C 0041               2243              MOVE.B  #'A',D3
000025CA  6100 18DE               2244              BSR     PUSH_STACK
000025CE  163C 002E               2245              MOVE.B  #'.',D3
000025D2  6100 18D6               2246              BSR     PUSH_STACK
000025D6                          2247              
000025D6                          2248              *FIGURE OUT SIZE*
000025D6                          2249              *00 = BYTE
000025D6                          2250              *01 = WORD
000025D6                          2251              *10 = LONG
000025D6                          2252              * BITS 7&6
000025D6                          2253              
000025D6                          2254              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000025D6  2205                    2255              MOVE.L  D5,D1
000025D8  EC99                    2256              ROR.L   #6,D1
000025DA  0281 00000003           2257              ANDI.L  #$03,D1
000025E0  0C01 0001               2258              CMPI.B  #%01,D1
000025E4  6700 0010               2259              BEQ     OP1011_CMPA_W
000025E8  0281 00000003           2260              ANDI.L  #$03,D1
000025EE  0C01 0002               2261              CMPI.B  #%10,D1
000025F2  6700 000E               2262              BEQ     OP1011_CMPA_L
000025F6                          2263  OP1011_CMPA_W
000025F6                          2264              
000025F6  163C 0057               2265              MOVE.B  #'W',D3
000025FA  6100 18AE               2266              BSR     PUSH_STACK
000025FE  6000 000A               2267              BRA     OP1011_RETURN_CMPA 
00002602                          2268  OP1011_CMPA_L
00002602                          2269              
00002602  163C 004C               2270              MOVE.B  #'L',D3
00002606  6100 18A2               2271              BSR     PUSH_STACK
0000260A                          2272  OP1011_RETURN_CMPA            
0000260A                          2273  
0000260A                          2274              
0000260A                          2275  *GET DATA FROM ADDQ AND PRINT #0-8
0000260A                          2276       
0000260A                          2277              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000260A  0285 0000FE3F           2278              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002610  0685 00000040           2279              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00002616                          2280  
00002616  6100 0FF4               2281              BSR     GET_EA_EA_SRC
0000261A  163C 002C               2282              MOVE.B  #',',D3
0000261E  6100 188A               2283              BSR     PUSH_STACK
00002622  6100 1418               2284              BSR     GET_EA_EA_DEST
00002626                          2285              
00002626  4E75                    2286              RTS
00002628                          2287  
00002628                          2288  OP1011_EOR
00002628                          2289  
00002628                          2290   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002628  13FC 0082 000047D0      2291             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002630  13FC 0080 000047D1      2292             MOVE.B   #$80,SRC_REGISTER_FORMAT
00002638                          2293             
00002638                          2294             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002638  13FC 00B9 000047D3      2295             MOVE.B   #$B9,GET_DST_START_END
00002640  13FC 0020 000047D4      2296             MOVE.B   #$20,GET_SRC_START_END
00002648                          2297             
00002648                          2298              *CLEAR D3
00002648  4283                    2299              CLR.L   D3
0000264A                          2300              *LOAD STACK WITH THIS OPMODE
0000264A  6100 185E               2301              BSR     PUSH_STACK
0000264E  163C 0045               2302              MOVE.B  #'E',D3
00002652  6100 1856               2303              BSR     PUSH_STACK
00002656  163C 004F               2304              MOVE.B  #'O',D3
0000265A  6100 184E               2305              BSR     PUSH_STACK
0000265E  163C 0052               2306              MOVE.B  #'R',D3
00002662  6100 1846               2307              BSR     PUSH_STACK
00002666  163C 002E               2308              MOVE.B  #'.',D3
0000266A  6100 183E               2309              BSR     PUSH_STACK
0000266E                          2310              
0000266E                          2311              *FIGURE OUT SIZE*
0000266E                          2312              *00 = BYTE
0000266E                          2313              *01 = WORD
0000266E                          2314              *10 = LONG
0000266E                          2315              * BITS 7&6
0000266E                          2316              
0000266E                          2317              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
0000266E  2205                    2318              MOVE.L  D5,D1
00002670  EC99                    2319              ROR.L   #6,D1
00002672  0281 00000003           2320              ANDI.L  #$03,D1
00002678  0C01 0000               2321              CMPI.B  #%00,D1
0000267C  6700 001E               2322              BEQ     OP1011_EOR_B
00002680  0281 00000003           2323              ANDI.L  #$03,D1
00002686  0C01 0001               2324              CMPI.B  #%01,D1
0000268A  6700 001C               2325              BEQ     OP1011_EOR_W
0000268E  0281 00000003           2326              ANDI.L  #$03,D1
00002694  0C01 0002               2327              CMPI.B  #%10,D1
00002698  6700 001A               2328              BEQ     OP1011_EOR_L
0000269C                          2329            
0000269C                          2330  OP1011_EOR_B
0000269C                          2331              
0000269C  163C 0042               2332              MOVE.B  #'B',D3
000026A0  6100 1808               2333              BSR     PUSH_STACK
000026A4  6000 0016               2334              BRA     OP1011_RETURN
000026A8                          2335  OP1011_EOR_W
000026A8                          2336              
000026A8  163C 0057               2337              MOVE.B  #'W',D3
000026AC  6100 17FC               2338              BSR     PUSH_STACK
000026B0  6000 000A               2339              BRA     OP1011_RETURN
000026B4                          2340  OP1011_EOR_L
000026B4                          2341              
000026B4  163C 004C               2342              MOVE.B  #'L',D3
000026B8  6100 17F0               2343              BSR     PUSH_STACK
000026BC                          2344  OP1011_RETURN            
000026BC                          2345  
000026BC                          2346              
000026BC                          2347  *GET DATA FROM ADDQ AND PRINT #0-8
000026BC                          2348       
000026BC                          2349              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000026BC  0285 0000FE3F           2350              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000026C2  0685 00000000           2351              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000026C8                          2352  
000026C8  6100 1372               2353              BSR     GET_EA_EA_DEST
000026CC  163C 002C               2354              MOVE.B  #',',D3
000026D0  6100 17D8               2355              BSR     PUSH_STACK
000026D4  6100 0F36               2356              BSR     GET_EA_EA_SRC
000026D8                          2357              
000026D8  4E75                    2358              RTS
000026DA                          2359              
000026DA                          2360              
000026DA                          2361              
000026DA                          2362              
000026DA                          2363  
000026DA                          2364  *---------------------------------------------------------------------------*
000026DA                          2365  * OP_CMPA: display CMPA 
000026DA                          2366  *---------------------------------------------------------------------------
000026DA  43F9 0000464E           2367  OP_CMPA_W   LEA     DISP_CMPA_W,A1
000026E0  103C 000E               2368              MOVE.B  #14,D0
000026E4  4E4F                    2369              TRAP    #15
000026E6  183C 0001               2370              MOVE.B  #1,D4
000026EA  4E75                    2371              RTS
000026EC                          2372  
000026EC  43F9 00004658           2373  OP_CMPA_L   LEA     DISP_CMPA_L,A1
000026F2  103C 000E               2374              MOVE.B  #14,D0
000026F6  4E4F                    2375              TRAP    #15
000026F8  183C 0002               2376              MOVE.B  #2,D4
000026FC  4E75                    2377              RTS
000026FE                          2378  
000026FE                          2379  *---------------------------------------------------------------------------*
000026FE                          2380  * OP_CMP: display CMP and proceed to EA
000026FE                          2381  *---------------------------------------------------------------------------*  
000026FE  43F9 00004633           2382  OP_CMP_B    LEA     DISP_CMP_B,A1
00002704  103C 000E               2383              MOVE.B  #14,D0
00002708  4E4F                    2384              TRAP    #15
0000270A  183C 0000               2385              MOVE.B  #0,D4
0000270E  4EF9 000031BC           2386              JMP     EA_GEN
00002714                          2387  
00002714  4E75                    2388              RTS
00002716                          2389              
00002716  43F9 0000463C           2390  OP_CMP_W    LEA     DISP_CMP_W,A1
0000271C  103C 000E               2391              MOVE.B  #14,D0
00002720  4E4F                    2392              TRAP    #15
00002722  183C 0001               2393              MOVE.B  #1,D4
00002726  4EF9 000031BC           2394              JMP     EA_GEN
0000272C                          2395  
0000272C  4E75                    2396              RTS
0000272E                          2397              
0000272E  43F9 00004645           2398  OP_CMP_L    LEA     DISP_CMP_L,A1
00002734  103C 000E               2399              MOVE.B  #14,D0
00002738  4E4F                    2400              TRAP    #15
0000273A  183C 0002               2401              MOVE.B  #2,D4
0000273E  4EF9 000031BC           2402              JMP     EA_GEN
00002744                          2403  
00002744  4E75                    2404              RTS
00002746                          2405              
00002746                          2406  *---------------------------------------------------------------------------*
00002746                          2407  * OP_EOR: display EOR
00002746                          2408  *---------------------------------------------------------------------------*  
00002746  43F9 00004618           2409  OP_EOR_B    LEA     DISP_EOR_B,A1
0000274C  103C 000E               2410              MOVE.B  #14,D0
00002750  4E4F                    2411              TRAP    #15
00002752  183C 0000               2412              MOVE.B  #0,D4
00002756  4E75                    2413              RTS
00002758                          2414              
00002758  43F9 00004621           2415  OP_EOR_W    LEA     DISP_EOR_W,A1
0000275E  103C 000E               2416              MOVE.B  #14,D0
00002762  4E4F                    2417              TRAP    #15
00002764  183C 0001               2418              MOVE.B  #1,D4
00002768  4E75                    2419              RTS
0000276A                          2420              
0000276A  43F9 0000462A           2421  OP_EOR_L    LEA     DISP_EOR_L,A1
00002770  103C 000E               2422              MOVE.B  #14,D0
00002774  4E4F                    2423              TRAP    #15
00002776  183C 0002               2424              MOVE.B  #2,D4
0000277A  4E75                    2425              RTS    
0000277C                          2426  
0000277C                          2427  *---------------------------------------------------------------------------*
0000277C                          2428  * OP1100: Decode and display MULS/AND and proceed to EA
0000277C                          2429  *---------------------------------------------------------------------------* 
0000277C  4280                    2430  OP1100      CLR.L   D0                 
0000277E  4281                    2431              CLR.L   D1    
00002780  4284                    2432              CLR.L   D4                
00002782  227C 00000000           2433              MOVEA.L #0, A1        
00002788  2205                    2434              MOVE.L  D5,D1
0000278A  EA89                    2435              LSR.L   #5,D1
0000278C  0281 0000000E           2436              ANDI.L  #$E,D1
00002792  0C41 000E               2437              CMPI.W  #$E,D1
00002796  6700 0006               2438              BEQ     OP_MULS
0000279A  6000 00F6               2439              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
0000279E                          2440  
0000279E                          2441  OP_MULS                      
0000279E  4281                    2442              CLR.L   D1       
000027A0  4284                    2443              CLR.L   D4                   
000027A2  227C 00000000           2444              MOVEA.L #0, A1              
000027A8  2205                    2445              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000027AA                          2446              *CLEAR D3
000027AA  4283                    2447              CLR.L   D3
000027AC                          2448  
000027AC                          2449  OP1100_MULS_DN_EA_OR_EA_DN 
000027AC                          2450              *LOAD STACK WITH THIS OPMODE
000027AC  6100 16FC               2451              BSR     PUSH_STACK
000027B0  163C 004D               2452              MOVE.B  #'M',D3
000027B4  6100 16F4               2453              BSR     PUSH_STACK
000027B8  163C 0055               2454              MOVE.B  #'U',D3
000027BC  6100 16EC               2455              BSR     PUSH_STACK
000027C0  163C 004C               2456              MOVE.B  #'L',D3
000027C4  6100 16E4               2457              BSR     PUSH_STACK
000027C8  163C 0053               2458              MOVE.B  #'S',D3
000027CC  6100 16DC               2459              BSR     PUSH_STACK
000027D0  163C 002E               2460              MOVE.B  #'.',D3
000027D4  6100 16D4               2461              BSR     PUSH_STACK
000027D8                          2462              
000027D8  2205                    2463              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000027DA                          2464              
000027DA                          2465  OP1100_EA_DN_MULS           
000027DA                          2466              *BITS (7 TO 6) 
000027DA                          2467              *00 = .B
000027DA                          2468              *01 = .W
000027DA                          2469              *10 = .L 
000027DA  2205                    2470              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000027DC  EC99                    2471              ROR.L   #6,D1
000027DE  0281 00000003           2472              ANDI.L  #$03,D1
000027E4  0C81 00000003           2473              CMPI.L  #%11,D1 *EQUALS .W
000027EA  6700 0014               2474              BEQ     OP1100_PRINT_W_MULS
000027EE  0C81 00000000           2475              CMPI.L  #%00,D1 *EQUALS .L
000027F4  6700 0052               2476              BEQ     OP1100_PRINT_L_MULS
000027F8                          2477              
000027F8  183C 0001               2478              MOVE.B  #1,D4               *ERROR READ
000027FC  6000 0092               2479              BRA     OP1100_MULS_RETURN
00002800                          2480  OP1100_PRINT_W_MULS
00002800  163C 0057               2481              MOVE.B  #'W',D3
00002804  6100 16A4               2482              BSR     PUSH_STACK
00002808                          2483  
00002808                          2484              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002808  13FC 0000 000047D0      2485              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002810  13FC 0000 000047D1      2486              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002818                          2487             
00002818                          2488              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002818  13FC 00B9 000047D3      2489              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002820  13FC 0020 000047D4      2490              MOVE.B   #$20,GET_SRC_START_END
00002828                          2491  
00002828                          2492             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002828  0285 0000FE3F           2493              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000282E  0685 00000000           2494              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002834                          2495  
00002834                          2496              
00002834  6100 0DD6               2497              BSR     GET_EA_EA_SRC      *GETS <ea>
00002838  163C 002C               2498              MOVE.B  #',',D3
0000283C  6100 166C               2499              BSR     PUSH_STACK
00002840  6100 11FA               2500              BSR     GET_EA_EA_DEST       *GETS Dn    
00002844                          2501              
00002844  6000 004A               2502              BRA     OP1100_MULS_RETURN
00002848                          2503  OP1100_PRINT_L_MULS 
00002848  163C 004C               2504              MOVE.B  #'L',D3
0000284C  6100 165C               2505              BSR     PUSH_STACK
00002850                          2506              
00002850                          2507              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002850  13FC 0000 000047D0      2508              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002858  13FC 0000 000047D1      2509              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002860                          2510             
00002860                          2511              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002860  13FC 00B9 000047D3      2512              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002868  13FC 0020 000047D4      2513              MOVE.B   #$20,GET_SRC_START_END
00002870                          2514  
00002870                          2515              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002870  0285 0000FE3F           2516              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002876  0685 00000000           2517              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000287C                          2518  
0000287C                          2519                     
0000287C  6100 0D8E               2520              BSR     GET_EA_EA_SRC      *GETS <ea>
00002880  163C 002C               2521              MOVE.B  #',',D3
00002884  6100 1624               2522              BSR     PUSH_STACK                  
00002888  6100 11B2               2523              BSR     GET_EA_EA_DEST       *GETS Dn    
0000288C                          2524  
0000288C                          2525              
0000288C  6000 0002               2526              BRA     OP1100_MULS_RETURN
00002890                          2527              
00002890                          2528  OP1100_MULS_RETURN
00002890  4E75                    2529              RTS
00002892                          2530              
00002892                          2531  
00002892                          2532  
00002892                          2533  
00002892                          2534  
00002892                          2535  
00002892                          2536  
00002892                          2537  
00002892                          2538  
00002892                          2539  
00002892                          2540  
00002892                          2541  
00002892                          2542  
00002892                          2543  OP1100_DETERMINE_DN_EA_OR_EA_DN 
00002892                          2544              *LOAD STACK WITH THIS OPMODE
00002892  4283                    2545              CLR.L   D3
00002894  6100 1614               2546              BSR     PUSH_STACK
00002898  163C 0041               2547              MOVE.B  #'A',D3
0000289C  6100 160C               2548              BSR     PUSH_STACK
000028A0  163C 004E               2549              MOVE.B  #'N',D3
000028A4  6100 1604               2550              BSR     PUSH_STACK
000028A8  163C 0044               2551              MOVE.B  #'D',D3
000028AC  6100 15FC               2552              BSR     PUSH_STACK
000028B0  163C 002E               2553              MOVE.B  #'.',D3
000028B4  6100 15F4               2554              BSR     PUSH_STACK
000028B8                          2555              
000028B8  2205                    2556              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000028BA                          2557              
000028BA                          2558              *BITS (INDEX 8) 
000028BA                          2559              *0 = ADD.B/W/L <EA>,Dn
000028BA                          2560              *1 = ADD.B/W/L Dn,<EA> 
000028BA  E099                    2561              ROR.L   #8,D1
000028BC  0281 00000001           2562              ANDI.L  #$01,D1     *MASKS WITH 00000001
000028C2  0C81 00000000           2563              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000028C8  6700 0102               2564              BEQ     OP1100_EA_DN
000028CC                          2565              *else procede to Dn_EA
000028CC                          2566              
000028CC                          2567  OP1100_DN_EA
000028CC                          2568              *BITS (7 TO 6) 
000028CC                          2569              *00 = .B
000028CC                          2570              *01 = .W
000028CC                          2571              *10 = .L 
000028CC  2205                    2572              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000028CE  EC99                    2573              ROR.L   #6,D1
000028D0  0281 00000003           2574              ANDI.L  #$03,D1
000028D6  0C81 00000000           2575              CMPI.L  #$00,D1 *EQUALS .B
000028DC  6700 0016               2576              BEQ     OP1100_PRINT_B2
000028E0  0C81 00000001           2577              CMPI.L  #$01,D1 *EQUALS .W
000028E6  6700 0054               2578              BEQ     OP1100_PRINT_W2
000028EA  0C81 00000002           2579              CMPI.L  #$02,D1 *EQUALS .L
000028F0  6700 0092               2580              BEQ     OP1100_PRINT_L2
000028F4                          2581  OP1100_PRINT_B2
000028F4                          2582              *PUSH 'B'
000028F4  163C 0042               2583              MOVE.B  #'B',D3
000028F8  6100 15B0               2584              BSR     PUSH_STACK
000028FC                          2585             
000028FC                          2586              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000028FC  13FC 0000 000047D0      2587             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002904  13FC 0083 000047D1      2588             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000290C                          2589             
0000290C                          2590             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000290C  13FC 00B9 000047D3      2591             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002914  13FC 0020 000047D4      2592             MOVE.B   #$20,GET_SRC_START_END
0000291C                          2593  
0000291C                          2594              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000291C  0285 0000FE3F           2595              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002922  0685 00000000           2596              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002928                          2597       
00002928  6100 1112               2598              BSR     GET_EA_EA_DEST      *GETS Dn
0000292C  163C 002C               2599              MOVE.B  #',',D3
00002930  6100 1578               2600              BSR     PUSH_STACK                     
00002934  6100 0CD6               2601              BSR     GET_EA_EA_SRC       *GETS <ea>
00002938                          2602  
00002938                          2603              
00002938  6000 0192               2604              BRA     OP1100_AND_RETURN
0000293C                          2605  OP1100_PRINT_W2
0000293C  163C 0057               2606              MOVE.B  #'W',D3
00002940  6100 1568               2607              BSR     PUSH_STACK
00002944                          2608  
00002944                          2609              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002944  13FC 0000 000047D0      2610              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000294C  13FC 0083 000047D1      2611              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002954                          2612             
00002954                          2613              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002954  13FC 00B9 000047D3      2614              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000295C  13FC 0020 000047D4      2615              MOVE.B   #$20,GET_SRC_START_END
00002964                          2616  
00002964                          2617              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002964  0285 0000FE3F           2618              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000296A  0685 00000000           2619              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002970                          2620  
00002970                          2621        
00002970  6100 10CA               2622              BSR     GET_EA_EA_DEST      *GETS Dn
00002974  163C 002C               2623              MOVE.B  #',',D3
00002978  6100 1530               2624              BSR     PUSH_STACK               
0000297C  6100 0C8E               2625              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002980                          2626  
00002980                          2627  
00002980                          2628  
00002980  6000 049A               2629              BRA     OP1101_ADD_RETURN
00002984                          2630  OP1100_PRINT_L2 
00002984  163C 004C               2631              MOVE.B  #'L',D3
00002988  6100 1520               2632              BSR     PUSH_STACK
0000298C                          2633              
0000298C                          2634              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000298C  13FC 0000 000047D0      2635              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002994  13FC 0083 000047D1      2636              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000299C                          2637             
0000299C                          2638              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000299C  13FC 00B9 000047D3      2639              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000029A4  13FC 0020 000047D4      2640              MOVE.B   #$20,GET_SRC_START_END
000029AC                          2641  
000029AC                          2642             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000029AC  0285 0000FE3F           2643              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000029B2  0685 00000000           2644              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000029B8                          2645  
000029B8                          2646               
000029B8  6100 1082               2647              BSR     GET_EA_EA_DEST       *GETS Dn
000029BC  163C 002C               2648              MOVE.B  #',',D3
000029C0  6100 14E8               2649              BSR     PUSH_STACK          
000029C4  6100 0C46               2650              BSR     GET_EA_EA_SRC        *GETS <ea>
000029C8                          2651  
000029C8  6000 0102               2652              BRA     OP1100_AND_RETURN
000029CC                          2653              
000029CC                          2654  OP1100_EA_DN           
000029CC                          2655              *BITS (7 TO 6) 
000029CC                          2656              *00 = .B
000029CC                          2657              *01 = .W
000029CC                          2658              *10 = .L 
000029CC  2205                    2659              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000029CE  EC99                    2660              ROR.L   #6,D1
000029D0  0281 00000003           2661              ANDI.L  #$03,D1
000029D6  0C81 00000000           2662              CMPI.L  #$00,D1 *EQUALS .B
000029DC  6700 0016               2663              BEQ     OP1100_PRINT_B
000029E0  0C81 00000001           2664              CMPI.L  #$01,D1 *EQUALS .W
000029E6  6700 0054               2665              BEQ     OP1100_PRINT_W
000029EA  0C81 00000002           2666              CMPI.L  #$02,D1 *EQUALS .L
000029F0  6700 0092               2667              BEQ     OP1100_PRINT_L
000029F4                          2668  OP1100_PRINT_B
000029F4  163C 0042               2669              MOVE.B  #'B',D3
000029F8  6100 14B0               2670              BSR     PUSH_STACK
000029FC                          2671                
000029FC                          2672              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000029FC  13FC 0000 000047D0      2673              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A04  13FC 0002 000047D1      2674              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A0C                          2675             
00002A0C                          2676              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A0C  13FC 00B9 000047D3      2677              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A14  13FC 0020 000047D4      2678              MOVE.B   #$20,GET_SRC_START_END
00002A1C                          2679  
00002A1C                          2680             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A1C  0285 0000FE3F           2681              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A22  0685 00000000           2682              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002A28                          2683  
00002A28                          2684              
00002A28  6100 0BE2               2685              BSR     GET_EA_EA_SRC      *GETS <ea>
00002A2C  163C 002C               2686              MOVE.B  #',',D3
00002A30  6100 1478               2687              BSR     PUSH_STACK          
00002A34  6100 1006               2688              BSR     GET_EA_EA_DEST       *GETS Dn
00002A38                          2689              
00002A38  6000 03E2               2690              BRA     OP1101_ADD_RETURN
00002A3C                          2691  OP1100_PRINT_W
00002A3C  163C 0057               2692              MOVE.B  #'W',D3
00002A40  6100 1468               2693              BSR     PUSH_STACK
00002A44                          2694  
00002A44                          2695              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A44  13FC 0000 000047D0      2696              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A4C  13FC 0002 000047D1      2697              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A54                          2698             
00002A54                          2699              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A54  13FC 00B9 000047D3      2700              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A5C  13FC 0020 000047D4      2701              MOVE.B   #$20,GET_SRC_START_END
00002A64                          2702  
00002A64                          2703             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A64  0285 0000FE3F           2704              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A6A  0685 00000000           2705              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A70                          2706  
00002A70                          2707              
00002A70  6100 0B9A               2708              BSR     GET_EA_EA_SRC      *GETS <ea>
00002A74  163C 002C               2709              MOVE.B  #',',D3
00002A78  6100 1430               2710              BSR     PUSH_STACK
00002A7C  6100 0FBE               2711              BSR     GET_EA_EA_DEST       *GETS Dn    
00002A80                          2712              
00002A80  6000 F988               2713              BRA     OP1001_ADD_RETURN
00002A84                          2714  OP1100_PRINT_L 
00002A84  163C 004C               2715              MOVE.B  #'L',D3
00002A88  6100 1420               2716              BSR     PUSH_STACK
00002A8C                          2717              
00002A8C                          2718              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A8C  13FC 0000 000047D0      2719              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A94  13FC 0002 000047D1      2720              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A9C                          2721             
00002A9C                          2722              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A9C  13FC 00B9 000047D3      2723              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002AA4  13FC 0020 000047D4      2724              MOVE.B   #$20,GET_SRC_START_END
00002AAC                          2725  
00002AAC                          2726              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AAC  0285 0000FE3F           2727              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AB2  0685 00000000           2728              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002AB8                          2729  
00002AB8                          2730                     
00002AB8  6100 0B52               2731              BSR     GET_EA_EA_SRC      *GETS <ea>
00002ABC  163C 002C               2732              MOVE.B  #',',D3
00002AC0  6100 13E8               2733              BSR     PUSH_STACK                  
00002AC4  6100 0F76               2734              BSR     GET_EA_EA_DEST       *GETS Dn    
00002AC8                          2735  
00002AC8                          2736              
00002AC8  6000 0002               2737              BRA     OP1100_AND_RETURN
00002ACC                          2738              
00002ACC                          2739  OP1100_AND_RETURN
00002ACC  4E75                    2740              RTS
00002ACE                          2741  
00002ACE                          2742  
00002ACE                          2743  *---------------------------------------------------------------------------*
00002ACE                          2744  * OP1101: Decode ADD/ADDA
00002ACE                          2745  *---------------------------------------------------------------------------* 
00002ACE  4280                    2746  OP1101      CLR.L   D0                  
00002AD0  4281                    2747              CLR.L   D1       
00002AD2  4284                    2748              CLR.L   D4                   
00002AD4  227C 00000000           2749              MOVEA.L #0, A1              
00002ADA  2205                    2750              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002ADC                          2751              
00002ADC                          2752              *CLEAR D3
00002ADC  4283                    2753              CLR.L   D3
00002ADE                          2754              
00002ADE                          2755              
00002ADE                          2756              
00002ADE                          2757              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002ADE  2205                    2758              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002AE0                          2759              *BITS (INDEX 8) 
00002AE0                          2760              *0 = ADD.B/W/L <EA>,Dn
00002AE0                          2761              *1 = ADD.B/W/L Dn,<EA> 
00002AE0  EC99                    2762              ROR.L   #6,D1
00002AE2  0281 00000007           2763              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002AE8  0C81 00000007           2764              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002AEE  6700 0010               2765              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002AF2  0C81 00000003           2766              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002AF8  6700 0078               2767              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002AFC  6000 00E6               2768              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002B00                          2769              
00002B00                          2770  OP1101_ADDA_L
00002B00                          2771              *LOAD STACK WITH THIS OPMODE
00002B00  6100 13A8               2772              BSR     PUSH_STACK
00002B04  163C 0041               2773              MOVE.B  #'A',D3
00002B08  6100 13A0               2774              BSR     PUSH_STACK
00002B0C  163C 0044               2775              MOVE.B  #'D',D3
00002B10  6100 1398               2776              BSR     PUSH_STACK
00002B14  163C 0044               2777              MOVE.B  #'D',D3
00002B18  6100 1390               2778              BSR     PUSH_STACK
00002B1C  163C 0041               2779              MOVE.B  #'A',D3
00002B20  6100 1388               2780              BSR     PUSH_STACK
00002B24  163C 002E               2781              MOVE.B  #'.',D3
00002B28  6100 1380               2782              BSR     PUSH_STACK
00002B2C  163C 004C               2783              MOVE.B  #'L',D3
00002B30  6100 1378               2784              BSR     PUSH_STACK
00002B34                          2785              
00002B34                          2786             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B34  13FC 0000 000047D0      2787             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B3C  13FC 0000 000047D1      2788             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B44                          2789             
00002B44                          2790             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B44  13FC 00B9 000047D3      2791             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B4C  13FC 0020 000047D4      2792             MOVE.B   #$20,GET_SRC_START_END
00002B54                          2793  
00002B54                          2794              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B54  0285 0000FE3F           2795              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B5A  0685 00000040           2796              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B60                          2797       
00002B60                          2798              *PRINT <EA>,AN
00002B60  6100 0AAA               2799              BSR     GET_EA_EA_SRC       *GETS <ea>
00002B64  163C 002C               2800              MOVE.B  #',',D3
00002B68  6100 1340               2801              BSR     PUSH_STACK                     
00002B6C  6100 0ECE               2802              BSR     GET_EA_EA_DEST      *GETS Dn
00002B70                          2803  
00002B70                          2804              
00002B70                          2805              
00002B70  4E75                    2806              RTS
00002B72                          2807  OP1101_ADDA_W
00002B72                          2808              *LOAD STACK WITH THIS OPMODE
00002B72  6100 1336               2809              BSR     PUSH_STACK
00002B76  163C 0041               2810              MOVE.B  #'A',D3
00002B7A  6100 132E               2811              BSR     PUSH_STACK
00002B7E  163C 0044               2812              MOVE.B  #'D',D3
00002B82  6100 1326               2813              BSR     PUSH_STACK
00002B86  163C 0044               2814              MOVE.B  #'D',D3
00002B8A  6100 131E               2815              BSR     PUSH_STACK
00002B8E  163C 0041               2816              MOVE.B  #'A',D3
00002B92  6100 1316               2817              BSR     PUSH_STACK
00002B96  163C 002E               2818              MOVE.B  #'.',D3
00002B9A  6100 130E               2819              BSR     PUSH_STACK
00002B9E  163C 0057               2820              MOVE.B  #'W',D3
00002BA2  6100 1306               2821              BSR     PUSH_STACK
00002BA6                          2822              
00002BA6                          2823             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BA6  13FC 0000 000047D0      2824             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BAE  13FC 0000 000047D1      2825             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BB6                          2826             
00002BB6                          2827             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BB6  13FC 00B9 000047D3      2828             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BBE  13FC 0020 000047D4      2829             MOVE.B   #$20,GET_SRC_START_END
00002BC6                          2830  
00002BC6                          2831              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BC6  0285 0000FE3F           2832              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BCC  0685 00000040           2833              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BD2                          2834       
00002BD2                          2835              *PRINT <EA>,AN
00002BD2  6100 0A38               2836              BSR     GET_EA_EA_SRC       *GETS <ea>
00002BD6  163C 002C               2837              MOVE.B  #',',D3
00002BDA  6100 12CE               2838              BSR     PUSH_STACK                     
00002BDE  6100 0E5C               2839              BSR     GET_EA_EA_DEST      *GETS Dn
00002BE2                          2840  
00002BE2  4E75                    2841              RTS
00002BE4                          2842  
00002BE4                          2843  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002BE4                          2844              *LOAD STACK WITH THIS OPMODE
00002BE4  6100 12C4               2845              BSR     PUSH_STACK
00002BE8  163C 0041               2846              MOVE.B  #'A',D3
00002BEC  6100 12BC               2847              BSR     PUSH_STACK
00002BF0  163C 0044               2848              MOVE.B  #'D',D3
00002BF4  6100 12B4               2849              BSR     PUSH_STACK
00002BF8  163C 0044               2850              MOVE.B  #'D',D3
00002BFC  6100 12AC               2851              BSR     PUSH_STACK
00002C00  163C 002E               2852              MOVE.B  #'.',D3
00002C04  6100 12A4               2853              BSR     PUSH_STACK
00002C08                          2854              
00002C08  2205                    2855              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C0A                          2856              
00002C0A                          2857              *BITS (INDEX 8) 
00002C0A                          2858              *0 = ADD.B/W/L <EA>,Dn
00002C0A                          2859              *1 = ADD.B/W/L Dn,<EA> 
00002C0A  E099                    2860              ROR.L   #8,D1
00002C0C  0281 00000001           2861              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002C12  0C81 00000000           2862              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002C18  6700 0102               2863              BEQ     OP1101_EA_DN
00002C1C                          2864              *else procede to Dn_EA
00002C1C                          2865              
00002C1C                          2866  OP1101_DN_EA
00002C1C                          2867              *BITS (7 TO 6) 
00002C1C                          2868              *00 = .B
00002C1C                          2869              *01 = .W
00002C1C                          2870              *10 = .L 
00002C1C  2205                    2871              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002C1E  EC99                    2872              ROR.L   #6,D1
00002C20  0281 00000003           2873              ANDI.L  #$03,D1
00002C26  0C81 00000000           2874              CMPI.L  #$00,D1 *EQUALS .B
00002C2C  6700 0016               2875              BEQ     OP1101_PRINT_B2
00002C30  0C81 00000001           2876              CMPI.L  #$01,D1 *EQUALS .W
00002C36  6700 0054               2877              BEQ     OP1101_PRINT_W2
00002C3A  0C81 00000002           2878              CMPI.L  #$02,D1 *EQUALS .L
00002C40  6700 0092               2879              BEQ     OP1101_PRINT_L2
00002C44                          2880  OP1101_PRINT_B2
00002C44                          2881              *PUSH 'B'
00002C44  163C 0042               2882              MOVE.B  #'B',D3
00002C48  6100 1260               2883              BSR     PUSH_STACK
00002C4C                          2884             
00002C4C                          2885              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C4C  13FC 0002 000047D0      2886             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C54  13FC 0083 000047D1      2887             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C5C                          2888             
00002C5C                          2889             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C5C  13FC 00B9 000047D3      2890             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C64  13FC 0020 000047D4      2891             MOVE.B   #$20,GET_SRC_START_END
00002C6C                          2892  
00002C6C                          2893              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C6C  0285 0000FE3F           2894              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C72  0685 00000000           2895              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002C78                          2896       
00002C78  6100 0DC2               2897              BSR     GET_EA_EA_DEST      *GETS Dn
00002C7C  163C 002C               2898              MOVE.B  #',',D3
00002C80  6100 1228               2899              BSR     PUSH_STACK                     
00002C84  6100 0986               2900              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C88                          2901  
00002C88                          2902              
00002C88  6000 0192               2903              BRA     OP1101_ADD_RETURN
00002C8C                          2904  OP1101_PRINT_W2
00002C8C  163C 0057               2905              MOVE.B  #'W',D3
00002C90  6100 1218               2906              BSR     PUSH_STACK
00002C94                          2907  
00002C94                          2908              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C94  13FC 0000 000047D0      2909              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C9C  13FC 0083 000047D1      2910              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CA4                          2911             
00002CA4                          2912              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CA4  13FC 00B9 000047D3      2913              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CAC  13FC 0020 000047D4      2914              MOVE.B   #$20,GET_SRC_START_END
00002CB4                          2915  
00002CB4                          2916              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CB4  0285 0000FE3F           2917              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CBA  0685 00000000           2918              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002CC0                          2919  
00002CC0                          2920        
00002CC0  6100 0D7A               2921              BSR     GET_EA_EA_DEST      *GETS Dn
00002CC4  163C 002C               2922              MOVE.B  #',',D3
00002CC8  6100 11E0               2923              BSR     PUSH_STACK               
00002CCC  6100 093E               2924              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002CD0                          2925  
00002CD0                          2926  
00002CD0                          2927  
00002CD0  6000 014A               2928              BRA     OP1101_ADD_RETURN
00002CD4                          2929  OP1101_PRINT_L2 
00002CD4  163C 004C               2930              MOVE.B  #'L',D3
00002CD8  6100 11D0               2931              BSR     PUSH_STACK
00002CDC                          2932              
00002CDC                          2933              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CDC  13FC 0000 000047D0      2934              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CE4  13FC 0083 000047D1      2935              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CEC                          2936             
00002CEC                          2937              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CEC  13FC 00B9 000047D3      2938              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CF4  13FC 0020 000047D4      2939              MOVE.B   #$20,GET_SRC_START_END
00002CFC                          2940  
00002CFC                          2941             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CFC  0285 0000FE3F           2942              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D02  0685 00000000           2943              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D08                          2944  
00002D08                          2945               
00002D08  6100 0D32               2946              BSR     GET_EA_EA_DEST       *GETS Dn
00002D0C  163C 002C               2947              MOVE.B  #',',D3
00002D10  6100 1198               2948              BSR     PUSH_STACK          
00002D14  6100 08F6               2949              BSR     GET_EA_EA_SRC        *GETS <ea>
00002D18                          2950  
00002D18  6000 0102               2951              BRA     OP1101_ADD_RETURN
00002D1C                          2952              
00002D1C                          2953  OP1101_EA_DN           
00002D1C                          2954              *BITS (7 TO 6) 
00002D1C                          2955              *00 = .B
00002D1C                          2956              *01 = .W
00002D1C                          2957              *10 = .L 
00002D1C  2205                    2958              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002D1E  EC99                    2959              ROR.L   #6,D1
00002D20  0281 00000003           2960              ANDI.L  #$03,D1
00002D26  0C81 00000000           2961              CMPI.L  #$00,D1 *EQUALS .B
00002D2C  6700 0016               2962              BEQ     OP1101_PRINT_B
00002D30  0C81 00000001           2963              CMPI.L  #$01,D1 *EQUALS .W
00002D36  6700 0054               2964              BEQ     OP1101_PRINT_W
00002D3A  0C81 00000002           2965              CMPI.L  #$02,D1 *EQUALS .L
00002D40  6700 0092               2966              BEQ     OP1101_PRINT_L
00002D44                          2967  OP1101_PRINT_B
00002D44  163C 0042               2968              MOVE.B  #'B',D3
00002D48  6100 1160               2969              BSR     PUSH_STACK
00002D4C                          2970                
00002D4C                          2971              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D4C  13FC 0002 000047D0      2972              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D54  13FC 0002 000047D1      2973              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D5C                          2974             
00002D5C                          2975              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D5C  13FC 00B9 000047D3      2976              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D64  13FC 0020 000047D4      2977              MOVE.B   #$20,GET_SRC_START_END
00002D6C                          2978  
00002D6C                          2979             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D6C  0285 0000FE3F           2980              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D72  0685 00000000           2981              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D78                          2982  
00002D78                          2983              
00002D78  6100 0892               2984              BSR     GET_EA_EA_SRC      *GETS <ea>
00002D7C  163C 002C               2985              MOVE.B  #',',D3
00002D80  6100 1128               2986              BSR     PUSH_STACK          
00002D84  6100 0CB6               2987              BSR     GET_EA_EA_DEST       *GETS Dn
00002D88                          2988              
00002D88  6000 0092               2989              BRA     OP1101_ADD_RETURN
00002D8C                          2990  OP1101_PRINT_W
00002D8C  163C 0057               2991              MOVE.B  #'W',D3
00002D90  6100 1118               2992              BSR     PUSH_STACK
00002D94                          2993  
00002D94                          2994              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D94  13FC 0000 000047D0      2995              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D9C  13FC 0000 000047D1      2996              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DA4                          2997             
00002DA4                          2998              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DA4  13FC 00B9 000047D3      2999              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DAC  13FC 0020 000047D4      3000              MOVE.B   #$20,GET_SRC_START_END
00002DB4                          3001  
00002DB4                          3002             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DB4  0285 0000FE3F           3003              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DBA  0685 00000000           3004              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DC0                          3005  
00002DC0                          3006              
00002DC0  6100 084A               3007              BSR     GET_EA_EA_SRC      *GETS <ea>
00002DC4  163C 002C               3008              MOVE.B  #',',D3
00002DC8  6100 10E0               3009              BSR     PUSH_STACK
00002DCC  6100 0C6E               3010              BSR     GET_EA_EA_DEST       *GETS Dn    
00002DD0                          3011              
00002DD0  6000 004A               3012              BRA     OP1101_ADD_RETURN
00002DD4                          3013  OP1101_PRINT_L 
00002DD4  163C 004C               3014              MOVE.B  #'L',D3
00002DD8  6100 10D0               3015              BSR     PUSH_STACK
00002DDC                          3016              
00002DDC                          3017              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DDC  13FC 0000 000047D0      3018              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DE4  13FC 0000 000047D1      3019              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DEC                          3020             
00002DEC                          3021              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DEC  13FC 00B9 000047D3      3022              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DF4  13FC 0020 000047D4      3023              MOVE.B   #$20,GET_SRC_START_END
00002DFC                          3024  
00002DFC                          3025              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DFC  0285 0000FE3F           3026              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E02  0685 00000000           3027              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E08                          3028  
00002E08                          3029                     
00002E08  6100 0802               3030              BSR     GET_EA_EA_SRC      *GETS <ea>
00002E0C  163C 002C               3031              MOVE.B  #',',D3
00002E10  6100 1098               3032              BSR     PUSH_STACK                  
00002E14  6100 0C26               3033              BSR     GET_EA_EA_DEST       *GETS Dn    
00002E18                          3034  
00002E18                          3035              
00002E18  6000 0002               3036              BRA     OP1101_ADD_RETURN
00002E1C                          3037              
00002E1C                          3038  OP1101_ADD_RETURN
00002E1C  4E75                    3039              RTS
00002E1E                          3040              
00002E1E                          3041              *ADDW
00002E1E  0C01 0006               3042              CMPI.B  #$6,D1
00002E22  6700 0056               3043              BEQ     OP_ADDA_W
00002E26  0C01 000E               3044              CMPI.B  #$E,D1
00002E2A  6700 0066               3045              BEQ     OP_ADDA_L 
00002E2E                          3046  
00002E2E  4EF8 16A4               3047              JMP     OP_DATA  
00002E32                          3048            
00002E32                          3049  *---------------------------------------------------------------------------*
00002E32                          3050  * OP_ADD: display ADD and proceed to EA
00002E32                          3051  *---------------------------------------------------------------------------*  
00002E32  43F9 00004687           3052  OP_ADD_B    LEA     DISP_ADD_B,A1
00002E38  103C 000E               3053              MOVE.B  #14,D0
00002E3C  4E4F                    3054              TRAP    #15
00002E3E  183C 0000               3055              MOVE.B  #0,D4
00002E42  4EF9 000031BC           3056              JMP     EA_GEN
00002E48                          3057  
00002E48  4E75                    3058              RTS
00002E4A                          3059  
00002E4A  43F9 00004690           3060  OP_ADD_W    LEA     DISP_ADD_W,A1
00002E50  103C 000E               3061              MOVE.B  #14,D0
00002E54  4E4F                    3062              TRAP    #15
00002E56  183C 0001               3063              MOVE.B  #1,D4
00002E5A  4EF9 000031BC           3064              JMP     EA_GEN
00002E60                          3065  
00002E60  4E75                    3066              RTS
00002E62                          3067  
00002E62  43F9 00004699           3068  OP_ADD_L    LEA     DISP_ADD_L,A1
00002E68  103C 000E               3069              MOVE.B  #14,D0
00002E6C  4E4F                    3070              TRAP    #15
00002E6E  183C 0002               3071              MOVE.B  #2,D4
00002E72  4EF9 000031BC           3072              JMP     EA_GEN
00002E78                          3073  
00002E78  4E75                    3074              RTS
00002E7A                          3075  
00002E7A                          3076  *---------------------------------------------------------------------------*
00002E7A                          3077  * OP_ADDA: display ADDA and proceed to EA
00002E7A                          3078  *---------------------------------------------------------------------------*  
00002E7A  43F9 000046A2           3079  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002E80  103C 000E               3080              MOVE.B  #14,D0
00002E84  4E4F                    3081              TRAP    #15
00002E86  183C 0001               3082              MOVE.B  #1,D4
00002E8A  4EF9 000031BC           3083              JMP     EA_GEN
00002E90                          3084  
00002E90  4E75                    3085              RTS
00002E92                          3086  
00002E92  43F9 000046AC           3087  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002E98  103C 000E               3088              MOVE.B  #14,D0
00002E9C  4E4F                    3089              TRAP    #15
00002E9E  183C 0002               3090              MOVE.B  #2,D4
00002EA2  4EF9 000031BC           3091              JMP     EA_GEN
00002EA8                          3092  
00002EA8  4E75                    3093              RTS
00002EAA                          3094              
00002EAA                          3095  *---------------------------------------------------------------------------*
00002EAA                          3096  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002EAA                          3097  *---------------------------------------------------------------------------* 
00002EAA  4280                    3098  OP1110      CLR.L   D0                  
00002EAC  4281                    3099              CLR.L   D1   
00002EAE  4284                    3100              CLR.L   D4                   
00002EB0  227C 00000000           3101              MOVEA.L #0, A1                 
00002EB6  2205                    3102              MOVE.L  D5,D1
00002EB8                          3103              
00002EB8                          3104              * check for LSX
00002EB8  E699                    3105              ROR.L   #3,D1
00002EBA  0281 00000001           3106              ANDI.L  #$1,D1
00002EC0  0C01 0001               3107              CMPI.B  #1,D1
00002EC4  6700 002E               3108              BEQ     OP_LSX
00002EC8                          3109              
00002EC8                          3110              * reset D1 and check for ASX
00002EC8  4281                    3111              CLR.L   D1
00002ECA  2205                    3112              MOVE.L  D5,D1
00002ECC  E699                    3113              ROR.L   #3,D1
00002ECE  0281 00000001           3114              ANDI.L  #$1,D1
00002ED4  0C01 0000               3115              CMPI.B  #0,D1
00002ED8  6700 0032               3116              BEQ     OP_ASX
00002EDC                          3117  
00002EDC                          3118              * reset D1 and check for ROX
00002EDC  4281                    3119              CLR.L   D1
00002EDE  2205                    3120              MOVE.L  D5,D1
00002EE0  E699                    3121              ROR.L   #3,D1
00002EE2  0281 00000001           3122              ANDI.L  #$1,D1
00002EE8  0C01 0003               3123              CMPI.B  #3,D1
00002EEC  6700 0036               3124              BEQ     OP_ROX
00002EF0                          3125              
00002EF0  4EF8 16A4               3126              JMP     OP_DATA
00002EF4                          3127  
00002EF4                          3128  *---------------------------------------------------------------------------*
00002EF4                          3129  * OP_LSX: process LSR/LSL
00002EF4                          3130  *---------------------------------------------------------------------------*            
00002EF4  EA99                    3131  OP_LSX      ROR.L   #5,D1
00002EF6  0281 00000001           3132              ANDI.L  #$1,D1
00002EFC  0C01 0000               3133              CMPI.B  #0,D1
00002F00  6700 003A               3134              BEQ     OP_LSR
00002F04  0C01 0001               3135              CMPI.B  #1,D1
00002F08  6700 008C               3136              BEQ     OP_LSL
00002F0C                          3137              
00002F0C                          3138  *---------------------------------------------------------------------------*
00002F0C                          3139  * OP_ASX: process ASR/ASL
00002F0C                          3140  *---------------------------------------------------------------------------*  
00002F0C  EA99                    3141  OP_ASX      ROR.L   #5,D1
00002F0E  0281 00000001           3142              ANDI.L  #$1,D1
00002F14  0C01 0000               3143              CMPI.B  #0,D1
00002F18  6700 00D6               3144              BEQ     OP_ASR
00002F1C  0C01 0001               3145              CMPI.B  #1,D1
00002F20  6700 0128               3146              BEQ     OP_ASL
00002F24                          3147              
00002F24                          3148  *---------------------------------------------------------------------------*
00002F24                          3149  * OP_ROX: process ROR/ROL
00002F24                          3150  *---------------------------------------------------------------------------*  
00002F24  EA99                    3151  OP_ROX      ROR.L   #5,D1
00002F26  0281 00000001           3152              ANDI.L  #$1,D1
00002F2C  0C01 0000               3153              CMPI.B  #0,D1
00002F30  6700 0172               3154              BEQ     OP_ROR
00002F34  0C01 0001               3155              CMPI.B  #1,D1
00002F38  6700 01C4               3156              BEQ     OP_ROL
00002F3C                          3157  
00002F3C                          3158  *---------------------------------------------------------------------------*
00002F3C                          3159  * OP_LSR: decode and display LSR
00002F3C                          3160  *---------------------------------------------------------------------------*        
00002F3C  E599                    3161  OP_LSR      ROL.L   #2,D1
00002F3E  0281 00000003           3162              ANDI.L  #$3,D1
00002F44  0C01 0000               3163              CMPI.B  #0,D1
00002F48  6700 0016               3164              BEQ     OP_LSR_B
00002F4C  0C01 0001               3165              CMPI.B  #$1,D1
00002F50  6700 0032               3166              BEQ     OP_LSR_W
00002F54  0C01 0002               3167              CMPI.B  #$2,D1
00002F58  6700 0018               3168              BEQ     OP_LSR_L
00002F5C                          3169              
00002F5C  4EF8 16A4               3170              JMP     OP_DATA
00002F60                          3171  
00002F60  43F9 000046B6           3172  OP_LSR_B    LEA     DISP_LSR_B,A1
00002F66  103C 000E               3173              MOVE.B  #14,D0
00002F6A  4E4F                    3174              TRAP    #15
00002F6C  183C 0000               3175              MOVE.B  #0,D4
00002F70  4E75                    3176              RTS
00002F72                          3177  
00002F72  43F9 000046DA           3178  OP_LSR_L    LEA     DISP_LSR_L,A1
00002F78  103C 000E               3179              MOVE.B  #14,D0
00002F7C  4E4F                    3180              TRAP    #15
00002F7E  183C 0002               3181              MOVE.B  #2,D4
00002F82  4E75                    3182              RTS
00002F84                          3183  
00002F84  43F9 000046C8           3184  OP_LSR_W    LEA     DISP_LSR_W,A1
00002F8A  103C 000E               3185              MOVE.B  #14,D0
00002F8E  4E4F                    3186              TRAP    #15
00002F90  183C 0001               3187              MOVE.B  #1,D4
00002F94  4E75                    3188              RTS
00002F96                          3189   
00002F96                          3190  *---------------------------------------------------------------------------*
00002F96                          3191  * OP_LSL: decode and display LSL
00002F96                          3192  *---------------------------------------------------------------------------*             
00002F96  E599                    3193  OP_LSL      ROL.L   #2,D1
00002F98  0281 00000003           3194              ANDI.L  #$3,D1
00002F9E  0C01 0000               3195              CMPI.B  #0,D1
00002FA2  6700 0016               3196              BEQ     OP_LSL_B
00002FA6  0C01 0001               3197              CMPI.B  #$1,D1
00002FAA  6700 0032               3198              BEQ     OP_LSL_W
00002FAE  0C01 0002               3199              CMPI.B  #$2,D1
00002FB2  6700 0018               3200              BEQ     OP_LSL_L
00002FB6                          3201              
00002FB6  4EF8 16A4               3202              JMP OP_DATA
00002FBA                          3203  
00002FBA  43F9 000046BF           3204  OP_LSL_B    LEA     DISP_LSL_B,A1
00002FC0  103C 000E               3205              MOVE.B  #14,D0
00002FC4  4E4F                    3206              TRAP    #15
00002FC6  183C 0000               3207              MOVE.B  #0,D4
00002FCA  4E75                    3208              RTS
00002FCC                          3209  
00002FCC  43F9 000046E3           3210  OP_LSL_L    LEA     DISP_LSL_L,A1
00002FD2  103C 000E               3211              MOVE.B  #14,D0
00002FD6  4E4F                    3212              TRAP    #15
00002FD8  183C 0002               3213              MOVE.B  #2,D4
00002FDC  4E75                    3214              RTS
00002FDE                          3215  
00002FDE  43F9 000046D1           3216  OP_LSL_W    LEA     DISP_LSL_W,A1
00002FE4  103C 000E               3217              MOVE.B  #14,D0
00002FE8  4E4F                    3218              TRAP    #15
00002FEA  183C 0001               3219              MOVE.B  #1,D4
00002FEE  4E75                    3220              RTS
00002FF0                          3221   
00002FF0                          3222  *---------------------------------------------------------------------------*
00002FF0                          3223  * OP_ASR: decode and display ASR
00002FF0                          3224  *---------------------------------------------------------------------------*             
00002FF0  E599                    3225  OP_ASR      ROL.L   #2,D1
00002FF2  0281 00000003           3226              ANDI.L  #$3,D1
00002FF8  0C01 0000               3227              CMPI.B  #0,D1
00002FFC  6700 0016               3228              BEQ     OP_ASR_B
00003000  0C01 0001               3229              CMPI.B  #$1,D1
00003004  6700 0032               3230              BEQ     OP_ASR_W
00003008  0C01 0002               3231              CMPI.B  #$2,D1
0000300C  6700 0018               3232              BEQ     OP_ASR_L
00003010                          3233              
00003010  4EF8 16A4               3234              JMP OP_DATA
00003014                          3235  
00003014  43F9 000046EC           3236  OP_ASR_B    LEA     DISP_ASR_B,A1
0000301A  103C 000E               3237              MOVE.B  #14,D0
0000301E  4E4F                    3238              TRAP    #15
00003020  183C 0000               3239              MOVE.B  #0,D4
00003024  4E75                    3240              RTS
00003026                          3241  
00003026  43F9 00004710           3242  OP_ASR_L    LEA     DISP_ASR_L,A1
0000302C  103C 000E               3243              MOVE.B  #14,D0
00003030  4E4F                    3244              TRAP    #15
00003032  183C 0002               3245              MOVE.B  #2,D4
00003036  4E75                    3246              RTS
00003038                          3247  
00003038  43F9 000046FE           3248  OP_ASR_W    LEA     DISP_ASR_W,A1
0000303E  103C 000E               3249              MOVE.B  #14,D0
00003042  4E4F                    3250              TRAP    #15
00003044  183C 0001               3251              MOVE.B  #1,D4
00003048  4E75                    3252              RTS
0000304A                          3253       
0000304A                          3254  *---------------------------------------------------------------------------*
0000304A                          3255  * OP_ASL: decode and display ASL
0000304A                          3256  *---------------------------------------------------------------------------*         
0000304A  E599                    3257  OP_ASL      ROL.L   #2,D1
0000304C  0281 00000003           3258              ANDI.L  #$3,D1
00003052  0C01 0000               3259              CMPI.B  #0,D1
00003056  6700 0016               3260              BEQ     OP_ASL_B
0000305A  0C01 0001               3261              CMPI.B  #$1,D1
0000305E  6700 0032               3262              BEQ     OP_ASL_W
00003062  0C01 0002               3263              CMPI.B  #$2,D1
00003066  6700 0018               3264              BEQ     OP_ASL_L
0000306A                          3265              
0000306A  4EF8 16A4               3266              JMP OP_DATA
0000306E                          3267  
0000306E  43F9 000046F5           3268  OP_ASL_B    LEA     DISP_ASL_B,A1
00003074  103C 000E               3269              MOVE.B  #14,D0
00003078  4E4F                    3270              TRAP    #15
0000307A  183C 0000               3271              MOVE.B  #0,D4
0000307E  4E75                    3272              RTS
00003080                          3273  
00003080  43F9 00004719           3274  OP_ASL_L    LEA     DISP_ASL_L,A1
00003086  103C 000E               3275              MOVE.B  #14,D0
0000308A  4E4F                    3276              TRAP    #15
0000308C  183C 0002               3277              MOVE.B  #2,D4
00003090  4E75                    3278              RTS
00003092                          3279  
00003092  43F9 00004707           3280  OP_ASL_W    LEA     DISP_ASL_W,A1
00003098  103C 000E               3281              MOVE.B  #14,D0
0000309C  4E4F                    3282              TRAP    #15
0000309E  183C 0001               3283              MOVE.B  #1,D4
000030A2  4E75                    3284              RTS
000030A4                          3285   
000030A4                          3286  *---------------------------------------------------------------------------*
000030A4                          3287  * OP_ROR: decode and display ROR
000030A4                          3288  *---------------------------------------------------------------------------*             
000030A4  E599                    3289  OP_ROR      ROL.L   #2,D1
000030A6  0281 00000003           3290              ANDI.L  #$3,D1
000030AC  0C01 0000               3291              CMPI.B  #0,D1
000030B0  6700 0016               3292              BEQ     OP_ROR_B
000030B4  0C01 0001               3293              CMPI.B  #$1,D1
000030B8  6700 0032               3294              BEQ     OP_ROR_W
000030BC  0C01 0002               3295              CMPI.B  #$2,D1
000030C0  6700 0018               3296              BEQ     OP_ROR_L
000030C4                          3297              
000030C4  4EF8 16A4               3298              JMP OP_DATA
000030C8                          3299  
000030C8  43F9 00004722           3300  OP_ROR_B    LEA     DISP_ROR_B,A1
000030CE  103C 000E               3301              MOVE.B  #14,D0
000030D2  4E4F                    3302              TRAP    #15
000030D4  183C 0000               3303              MOVE.B  #0,D4
000030D8  4E75                    3304              RTS
000030DA                          3305  
000030DA  43F9 00004746           3306  OP_ROR_L    LEA     DISP_ROR_L,A1
000030E0  103C 000E               3307              MOVE.B  #14,D0
000030E4  4E4F                    3308              TRAP    #15
000030E6  183C 0002               3309              MOVE.B  #2,D4
000030EA  4E75                    3310              RTS
000030EC                          3311  
000030EC  43F9 00004734           3312  OP_ROR_W    LEA     DISP_ROR_W,A1
000030F2  103C 000E               3313              MOVE.B  #14,D0
000030F6  4E4F                    3314              TRAP    #15
000030F8  183C 0001               3315              MOVE.B  #1,D4
000030FC  4E75                    3316              RTS
000030FE                          3317  
000030FE                          3318  *---------------------------------------------------------------------------*
000030FE                          3319  * OP_ROL: decode and display ROL
000030FE                          3320  *---------------------------------------------------------------------------*             
000030FE  E599                    3321  OP_ROL      ROL.L   #2,D1
00003100  0281 00000003           3322              ANDI.L  #$3,D1
00003106  0C01 0000               3323              CMPI.B  #0,D1
0000310A  6700 0016               3324              BEQ     OP_ROL_B
0000310E  0C01 0001               3325              CMPI.B  #$1,D1
00003112  6700 0032               3326              BEQ     OP_ROL_W
00003116  0C01 0002               3327              CMPI.B  #$2,D1
0000311A  6700 0018               3328              BEQ     OP_ROL_L
0000311E                          3329              
0000311E  4EF8 16A4               3330              JMP OP_DATA
00003122                          3331  
00003122                          3332  
00003122  43F9 0000472B           3333  OP_ROL_B    LEA     DISP_ROL_B,A1
00003128  103C 000E               3334              MOVE.B  #14,D0
0000312C  4E4F                    3335              TRAP    #15
0000312E  183C 0000               3336              MOVE.B  #0,D4
00003132  4E75                    3337              RTS
00003134                          3338  
00003134  43F9 0000474F           3339  OP_ROL_L    LEA     DISP_ROL_L,A1
0000313A  103C 000E               3340              MOVE.B  #14,D0
0000313E  4E4F                    3341              TRAP    #15
00003140  183C 0002               3342              MOVE.B  #2,D4
00003144  4E75                    3343              RTS
00003146                          3344  
00003146  43F9 0000473D           3345  OP_ROL_W    LEA     DISP_ROL_W,A1
0000314C  103C 000E               3346              MOVE.B  #14,D0
00003150  4E4F                    3347              TRAP    #15
00003152  183C 0001               3348              MOVE.B  #1,D4
00003156  4E75                    3349              RTS
00003158                          3350              
00003158                          3351  *---------------------------------------------------------------------------*
00003158                          3352  * OP1111 : Special reserved
00003158                          3353  *---------------------------------------------------------------------------*           
00003158  4EF8 16A4               3354  OP1111      JMP     OP_DATA
0000315C                          3355  
0000315C                          3356  *---------------------------------------------------------------------------*
0000315C                          3357  * EA_NOSRC: decode and display effective addresses for NEG/JSR
0000315C                          3358  *---------------------------------------------------------------------------*
0000315C                          3359  EA_NOSRC    
0000315C  4EB9 0000321A           3360              JSR     SRC_MODE
00003162  43F9 0000441C           3361              LEA     ENDLINE_M,A1
00003168  103C 000E               3362              MOVE.B  #14,D0
0000316C  4E4F                    3363              TRAP    #15
0000316E  4E75                    3364              RTS
00003170                          3365              
00003170                          3366  *---------------------------------------------------------------------------*
00003170                          3367  * EA_ARITH: decode and display effective addresses for DIVS/MULS
00003170                          3368  *---------------------------------------------------------------------------*
00003170                          3369  EA_ARITH
00003170  4EB9 0000321A           3370              JSR     SRC_MODE
00003176  43F9 00004796           3371              LEA     DISP_D,A1
0000317C  103C 000E               3372              MOVE.B  #14,D0
00003180  4E4F                    3373              TRAP    #15
00003182  4EB9 000034A6           3374              JSR     DEST_REGISTER
00003188  43F9 0000441C           3375              LEA     ENDLINE_M,A1
0000318E  103C 000E               3376              MOVE.B  #14,D0
00003192  4E4F                    3377              TRAP    #15
00003194  4E75                    3378              RTS
00003196                          3379              
00003196                          3380  *---------------------------------------------------------------------------*
00003196                          3381  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
00003196                          3382  *---------------------------------------------------------------------------*
00003196                          3383  EA_MOVEA
00003196  4EB9 0000321A           3384              JSR     SRC_MODE
0000319C  43F9 000047A7           3385              LEA     DISP_AOP,A1
000031A2  103C 000E               3386              MOVE.B  #14,D0
000031A6  4E4F                    3387              TRAP    #15
000031A8  4EB9 000034A6           3388              JSR     DEST_REGISTER
000031AE  43F9 000047A5           3389              LEA     DISP_CP,A1
000031B4  103C 000D               3390              MOVE.B  #13,D0
000031B8  4E4F                    3391              TRAP    #15
000031BA  4E75                    3392              RTS
000031BC                          3393              
000031BC                          3394  *---------------------------------------------------------------------------*
000031BC                          3395  * EA_GEN: decode and display effective addresses for MOVE
000031BC                          3396  *---------------------------------------------------------------------------*
000031BC                          3397  EA_GEN          
000031BC                          3398              * retrieve/display source mode/register
000031BC  4EB9 0000321A           3399              JSR     SRC_MODE
000031C2                          3400              
000031C2                          3401              * retrieve/display destination mode/register
000031C2  4EB9 000031D6           3402              JSR     DEST_MODE
000031C8                          3403              
000031C8  43F9 0000441C           3404              LEA     ENDLINE_M,A1
000031CE  103C 000E               3405              MOVE.B  #14,D0
000031D2  4E4F                    3406              TRAP    #15
000031D4                          3407              
000031D4  4E75                    3408              RTS
000031D6                          3409  
000031D6                          3410  *---------------------------------------------------------------------------*
000031D6                          3411  * DEST_MODE: decode and display destination mode (bit 8 - 6)
000031D6                          3412  *---------------------------------------------------------------------------*           
000031D6                          3413  DEST_MODE   
000031D6                          3414              * clear registers to store temp data
000031D6  4280                    3415              CLR.L   D0                      
000031D8  4281                    3416              CLR.L   D1                      
000031DA  207C 00000000           3417              MOVEA.L #0, A0                  
000031E0  227C 00000000           3418              MOVEA.L #0, A1                  
000031E6  2205                    3419              MOVE.L  D5,D1
000031E8  EC89                    3420              LSR.L   #6,D1
000031EA  0281 00000007           3421              ANDI.L  #$7,D1
000031F0  0C01 0000               3422              CMPI.B  #0,D1   * Dn
000031F4  6700 0082               3423              BEQ     D_MODE000
000031F8  0C01 0002               3424              CMPI.B  #2,D1   * (An)
000031FC  6700 00C2               3425              BEQ     D_MODE010
00003200  0C01 0003               3426              CMPI.B  #3,D1   * (An)+
00003204  6700 011A               3427              BEQ     D_MODE011
00003208  0C01 0004               3428              CMPI.B  #4,D1   * -(An)
0000320C  6700 0132               3429              BEQ     D_MODE100
00003210  0C01 0007               3430              CMPI.B  #7,D1  * abs
00003214  6700 017C               3431              BEQ     D_MODE111 
00003218  4E75                    3432              RTS
0000321A                          3433  
0000321A                          3434  *---------------------------------------------------------------------------*
0000321A                          3435  * SRC_MODE: decode and display source mode (bit 5 - 3)
0000321A                          3436  *---------------------------------------------------------------------------*  
0000321A                          3437  SRC_MODE    
0000321A                          3438              * clear registers to store temp data
0000321A  4280                    3439              CLR.L   D0                      
0000321C  4281                    3440              CLR.L   D1                      
0000321E  207C 00000000           3441              MOVEA.L #0, A0                  
00003224  227C 00000000           3442              MOVEA.L #0, A1                  
0000322A  2205                    3443              MOVE.L  D5,D1
0000322C  E489                    3444              LSR.L   #2,D1
0000322E  0281 0000000E           3445              ANDI.L  #$E,D1
00003234                          3446              
00003234  0C01 0000               3447              CMPI.B  #0,D1   * Dn
00003238  6700 002A               3448              BEQ     MODE000
0000323C  0C01 0002               3449              CMPI.B  #2,D1   * An 
00003240  6700 004A               3450              BEQ     MODE001
00003244  0C01 0004               3451              CMPI.B  #4,D1   * (An)
00003248  6700 0056               3452              BEQ     MODE010
0000324C  0C01 0006               3453              CMPI.B  #6,D1   * (An)+
00003250  6700 008E               3454              BEQ     MODE011
00003254  0C01 0008               3455              CMPI.B  #8,D1   * -(An)
00003258  6700 00A6               3456              BEQ     MODE100
0000325C  0C01 000F               3457              CMPI.B  #15,D1  * abs/immediate
00003260  6700 00FE               3458              BEQ     MODE111 
00003264                          3459        
00003264                          3460  *---------------------------------------------------------------------------*
00003264                          3461  * MODE000: decode and display source mode Dn
00003264                          3462  *---------------------------------------------------------------------------*           
00003264                          3463  MODE000     *Dn
00003264  43F9 00004796           3464              LEA     DISP_D,A1
0000326A  103C 000E               3465              MOVE.B  #14,D0
0000326E  4E4F                    3466              TRAP    #15
00003270  4EB9 00003502           3467              JSR     SRC_REGISTER
00003276  4E75                    3468              RTS
00003278                          3469  
00003278                          3470  *---------------------------------------------------------------------------*
00003278                          3471  * D_MODE000: decode and display dest mode Dn
00003278                          3472  *---------------------------------------------------------------------------*
00003278                          3473  D_MODE000     *Dn
00003278  43F9 00004796           3474              LEA     DISP_D,A1
0000327E  103C 000E               3475              MOVE.B  #14,D0
00003282  4E4F                    3476              TRAP    #15
00003284  4EB9 000034A6           3477              JSR     DEST_REGISTER
0000328A  4E75                    3478              RTS
0000328C                          3479  
0000328C                          3480  *---------------------------------------------------------------------------*
0000328C                          3481  * MODE001: decode and display source mode An
0000328C                          3482  *---------------------------------------------------------------------------* 
0000328C                          3483  MODE001 *An
0000328C  43F9 0000479B           3484              LEA     DISP_A,A1
00003292  103C 000E               3485              MOVE.B  #14,D0
00003296  4E4F                    3486              TRAP    #15
00003298  4EB9 00003502           3487              JSR     SRC_REGISTER
0000329E                          3488          
0000329E  4E75                    3489              RTS
000032A0                          3490  
000032A0                          3491  *---------------------------------------------------------------------------*
000032A0                          3492  * MODE010: decode and display source mode (An)
000032A0                          3493  *---------------------------------------------------------------------------*    
000032A0                          3494  MODE010 *(An)
000032A0  43F9 000047A7           3495              LEA     DISP_AOP,A1  *display (A
000032A6  103C 000E               3496              MOVE.B  #14,D0
000032AA  4E4F                    3497              TRAP    #15
000032AC                          3498  
000032AC  4EB9 00003502           3499              JSR     SRC_REGISTER * display register
000032B2                          3500  
000032B2  43F9 000047A5           3501              LEA     DISP_CP,A1   *display )
000032B8  103C 000E               3502              MOVE.B  #14,D0
000032BC  4E4F                    3503              TRAP    #15
000032BE                          3504              
000032BE  4E75                    3505              RTS
000032C0                          3506  
000032C0                          3507  *---------------------------------------------------------------------------*
000032C0                          3508  * D_MODE010: decode and display dest mode (An)
000032C0                          3509  *---------------------------------------------------------------------------*
000032C0                          3510  D_MODE010 *(An)
000032C0  43F9 000047A7           3511              LEA     DISP_AOP,A1  *display (A
000032C6  103C 000E               3512              MOVE.B  #14,D0
000032CA  4E4F                    3513              TRAP    #15
000032CC                          3514     
000032CC  4EB9 000034A6           3515              JSR     DEST_REGISTER * display register
000032D2                          3516  
000032D2  43F9 000047A5           3517              LEA     DISP_CP,A1   *display )
000032D8  103C 000E               3518              MOVE.B  #14,D0
000032DC  4E4F                    3519              TRAP    #15
000032DE                          3520              
000032DE  4E75                    3521              RTS
000032E0                          3522  
000032E0                          3523  *---------------------------------------------------------------------------*
000032E0                          3524  * MODE011: decode and display source mode (An)+
000032E0                          3525  *---------------------------------------------------------------------------*
000032E0                          3526  MODE011 *(An)+
000032E0  43F9 000047A7           3527              LEA     DISP_AOP,A1      *display (A
000032E6  103C 000E               3528              MOVE.B  #14,D0
000032EA  4E4F                    3529              TRAP    #15
000032EC                          3530              
000032EC  4EB9 00003502           3531              JSR     SRC_REGISTER    * display register
000032F2                          3532  
000032F2  43F9 000047B4           3533              LEA     DISP_POST,A1    *display )+
000032F8  103C 000E               3534              MOVE.B  #14,D0
000032FC  4E4F                    3535              TRAP    #15
000032FE                          3536              
000032FE  4E75                    3537              RTS
00003300                          3538              
00003300                          3539  *---------------------------------------------------------------------------*
00003300                          3540  * MODE100: decode and display source mode -(An)
00003300                          3541  *---------------------------------------------------------------------------*
00003300                          3542  MODE100 *-(An)
00003300  43F9 000047AD           3543              LEA     DISP_PRE,A1    *display -(A
00003306  103C 000E               3544              MOVE.B  #14,D0
0000330A  4E4F                    3545              TRAP    #15
0000330C                          3546  
0000330C  4EB9 00003502           3547              JSR     SRC_REGISTER    *display register
00003312                          3548  
00003312  43F9 000047A5           3549              LEA     DISP_CP,A1   *display )
00003318  103C 000E               3550              MOVE.B  #14,D0
0000331C  4E4F                    3551              TRAP    #15
0000331E                          3552              
0000331E  4E75                    3553              RTS
00003320                          3554  
00003320                          3555  *---------------------------------------------------------------------------*
00003320                          3556  * D_MODE011: decode and display dest mode (An)+
00003320                          3557  *---------------------------------------------------------------------------*
00003320                          3558  D_MODE011 *(An)+
00003320  43F9 000047A7           3559              LEA     DISP_AOP,A1      *display (A
00003326  103C 000E               3560              MOVE.B  #14,D0
0000332A  4E4F                    3561              TRAP    #15
0000332C                          3562  
0000332C  4EB9 000034A6           3563              JSR     DEST_REGISTER    * display register
00003332                          3564  
00003332  43F9 000047B4           3565              LEA     DISP_POST,A1    *display )+
00003338  103C 000E               3566              MOVE.B  #14,D0
0000333C  4E4F                    3567              TRAP    #15
0000333E                          3568              
0000333E  4E75                    3569              RTS
00003340                          3570              
00003340                          3571  *---------------------------------------------------------------------------*
00003340                          3572  * D_MODE100: decode and display dest mode -(An)
00003340                          3573  *---------------------------------------------------------------------------*            
00003340                          3574  D_MODE100 *-(An)
00003340  43F9 000047AD           3575              LEA     DISP_PRE,A1    *display -(A
00003346  103C 000E               3576              MOVE.B  #14,D0
0000334A  4E4F                    3577              TRAP    #15
0000334C                          3578              
0000334C  4EB9 000034A6           3579              JSR     DEST_REGISTER    *display register
00003352                          3580  
00003352  43F9 000047A5           3581              LEA     DISP_CP,A1   *display )
00003358  103C 000E               3582              MOVE.B  #14,D0
0000335C  4E4F                    3583              TRAP    #15
0000335E                          3584              
0000335E  4E75                    3585              RTS
00003360                          3586  
00003360                          3587  *---------------------------------------------------------------------------*
00003360                          3588  * MODE111: decode and display source mode absolute/immediate
00003360                          3589  *---------------------------------------------------------------------------*
00003360                          3590  MODE111     * abs/immediate
00003360                          3591              * clear registers to store temp data
00003360  4280                    3592              CLR.L   D0                      
00003362  4281                    3593              CLR.L   D1                      
00003364  207C 00000000           3594              MOVEA.L #0, A0                  
0000336A  227C 00000000           3595              MOVEA.L #0, A1                  
00003370  2205                    3596              MOVE.L  D5,D1
00003372                          3597              
00003372                          3598              * retrieve source register for MODE 111
00003372  E389                    3599              LSL.L   #1,D1   * shift the bits to left by 1
00003374  0281 0000000E           3600              ANDI.L  #$E,D1  * mask the first 4 bits 
0000337A  0C01 0000               3601              CMPI.B  #0, D1  * if it's 0000, absolute word address
0000337E  6700 003E               3602              BEQ     WORDMODE
00003382  0C01 0002               3603              CMPI.B  #2, D1  * if it's 0010, absolute long address
00003386  6700 0062               3604              BEQ     LONGMODE
0000338A  0C01 0008               3605              CMPI.B  #8, D1  * if it's 1000, immediate data
0000338E  6700 0086               3606              BEQ     IMMEDIATE
00003392                          3607       
00003392                          3608  *---------------------------------------------------------------------------*
00003392                          3609  * D_MODE111: decode and display dest mode absolute/immediate
00003392                          3610  *---------------------------------------------------------------------------*           
00003392                          3611  D_MODE111   * abs
00003392                          3612              * clear registers to store temp data
00003392  4280                    3613              CLR.L   D0                      
00003394  4281                    3614              CLR.L   D1                      
00003396  207C 00000000           3615              MOVEA.L #0, A0                  
0000339C  227C 00000000           3616              MOVEA.L #0, A1                  
000033A2  2205                    3617              MOVE.L  D5,D1
000033A4                          3618              
000033A4                          3619              * retrieve dest register for MODE 111
000033A4  EC89                    3620              LSR.L   #6,D1   * shift the bits to right by 6
000033A6  E689                    3621              LSR.L   #3,D1   * shift the bits to right by extra 3
000033A8  0201 0001               3622              ANDI.B  #1,D1   * mask the first 2 bits 
000033AC  0C01 0000               3623              CMPI.B  #0, D1  * if it's 000, absolute word address
000033B0  6700 000C               3624              BEQ     WORDMODE
000033B4  0C01 0001               3625              CMPI.B  #1, D1  * if it's 001, absolute long address
000033B8  6700 0030               3626              BEQ     LONGMODE
000033BC                          3627              *JSR     OP_DATA *not sure..
000033BC  4E75                    3628              RTS
000033BE                          3629  
000033BE                          3630  
000033BE                          3631  *---------------------------------------------------------------------------*
000033BE                          3632  * WORDMODE: absolute word address
000033BE                          3633  *---------------------------------------------------------------------------*
000033BE  43F9 00004791           3634  WORDMODE    LEA     DISP_HEX,A1
000033C4  103C 000E               3635              MOVE.B  #14,D0
000033C8  4E4F                    3636              TRAP    #15
000033CA                          3637              
000033CA  4285                    3638              CLR.L   D5
000033CC  3A1D                    3639              MOVE.W  (A5)+,D5
000033CE                          3640              
000033CE  43F9 0000446F           3641              LEA     TMPOUTPUT,A1
000033D4  2205                    3642              MOVE.L  D5,D1
000033D6  7404                    3643              MOVE.L  #4,D2       *move word size 4
000033D8  4EB8 11FE               3644              JSR     HEX2ASCII
000033DC  43F9 0000446F           3645              LEA     TMPOUTPUT,A1
000033E2  103C 000E               3646              MOVE.B  #14,D0
000033E6  4E4F                    3647              TRAP    #15
000033E8                          3648              
000033E8  4E75                    3649              RTS
000033EA                          3650  
000033EA                          3651  *---------------------------------------------------------------------------*
000033EA                          3652  * LONGMODE: absolute long address
000033EA                          3653  *---------------------------------------------------------------------------*
000033EA  43F9 00004791           3654  LONGMODE    LEA     DISP_HEX,A1
000033F0  103C 000E               3655              MOVE.B  #14,D0
000033F4  4E4F                    3656              TRAP    #15
000033F6                          3657              
000033F6  4285                    3658              CLR.L   D5
000033F8  2A1D                    3659              MOVE.L  (A5)+,D5
000033FA                          3660              
000033FA  43F9 0000446F           3661              LEA     TMPOUTPUT,A1
00003400  2205                    3662              MOVE.L  D5,D1
00003402  7408                    3663              MOVE.L  #8,D2           *move longword size 8
00003404  4EB8 11FE               3664              JSR     HEX2ASCII
00003408  43F9 0000446F           3665              LEA     TMPOUTPUT,A1
0000340E  103C 000E               3666              MOVE.B  #14,D0
00003412  4E4F                    3667              TRAP    #15
00003414                          3668              
00003414  4E75                    3669              RTS
00003416                          3670  
00003416                          3671  
00003416                          3672  *---------------------------------------------------------------------------*
00003416                          3673  * IMMEDIATE: immediate address
00003416                          3674  *---------------------------------------------------------------------------*
00003416  43F9 000047B7           3675  IMMEDIATE   LEA     DISP_LB,A1
0000341C  103C 000E               3676              MOVE.B  #14,D0
00003420  4E4F                    3677              TRAP    #15
00003422  43F9 00004791           3678              LEA     DISP_HEX,A1
00003428  103C 000E               3679              MOVE.B  #14,D0
0000342C  4E4F                    3680              TRAP    #15
0000342E                          3681              
0000342E                          3682              * check for size
0000342E  0C04 0000               3683              CMPI.B  #0,D4
00003432  6700 0012               3684              BEQ     IMMD_B
00003436  0C04 0001               3685              CMPI.B  #1,D4
0000343A  6700 002A               3686              BEQ     IMMD_W
0000343E  0C04 0002               3687              CMPI.B  #2,D4
00003442  6700 0042               3688              BEQ     IMMD_L
00003446                          3689  
00003446                          3690  IMMD_B
00003446  4285                    3691              CLR.L   D5
00003448  3A1D                    3692              MOVE.W  (A5)+,D5
0000344A                          3693              
0000344A  43F9 0000446F           3694              LEA     TMPOUTPUT,A1
00003450  2205                    3695              MOVE.L  D5,D1
00003452  7402                    3696              MOVE.L  #2,D2
00003454  4EB8 11FE               3697              JSR     HEX2ASCII
00003458  43F9 0000446F           3698              LEA     TMPOUTPUT,A1
0000345E  103C 000E               3699              MOVE.B  #14,D0
00003462  4E4F                    3700              TRAP    #15
00003464  4E75                    3701              RTS
00003466                          3702              
00003466                          3703  IMMD_W
00003466  4285                    3704              CLR.L   D5
00003468  3A1D                    3705              MOVE.W  (A5)+,D5
0000346A                          3706              
0000346A  43F9 0000446F           3707              LEA     TMPOUTPUT,A1
00003470  2205                    3708              MOVE.L  D5,D1
00003472  7404                    3709              MOVE.L  #4,D2
00003474  4EB8 11FE               3710              JSR     HEX2ASCII
00003478  43F9 0000446F           3711              LEA     TMPOUTPUT,A1
0000347E  103C 000E               3712              MOVE.B  #14,D0
00003482  4E4F                    3713              TRAP    #15
00003484  4E75                    3714              RTS
00003486                          3715              
00003486                          3716  
00003486                          3717  IMMD_L
00003486  4285                    3718              CLR.L   D5
00003488  3A1D                    3719              MOVE.W  (A5)+,D5
0000348A                          3720              
0000348A  43F9 0000446F           3721              LEA     TMPOUTPUT,A1
00003490  2205                    3722              MOVE.L  D5,D1
00003492  7408                    3723              MOVE.L  #8,D2
00003494  4EB8 11FE               3724              JSR     HEX2ASCII
00003498  43F9 0000446F           3725              LEA     TMPOUTPUT,A1
0000349E  103C 000E               3726              MOVE.B  #14,D0
000034A2  4E4F                    3727              TRAP    #15
000034A4  4E75                    3728              RTS
000034A6                          3729  
000034A6                          3730  
000034A6                          3731  *---------------------------------------------------------------------------*
000034A6                          3732  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000034A6                          3733  *---------------------------------------------------------------------------*
000034A6                          3734  DEST_REGISTER
000034A6                          3735              * clear registers to store temp data
000034A6  4280                    3736              CLR.L   D0                      
000034A8  4281                    3737              CLR.L   D1                      
000034AA  207C 00000000           3738              MOVEA.L #0, A0                  
000034B0  227C 00000000           3739              MOVEA.L #0, A1 
000034B6                          3740              
000034B6  2205                    3741              MOVE.L  D5,D1
000034B8  EC89                    3742              LSR.L   #6,D1
000034BA  E689                    3743              LSR.L   #3,D1
000034BC  0281 00000007           3744              ANDI.L  #7,D1
000034C2                          3745              
000034C2  0C01 0000               3746              CMPI.B  #0,D1
000034C6  6700 0092               3747              BEQ     REG_0
000034CA  0C01 0001               3748              CMPI.B  #1,D1
000034CE  6700 0098               3749              BEQ     REG_1
000034D2  0C01 0002               3750              CMPI.B  #2,D1
000034D6  6700 009E               3751              BEQ     REG_2
000034DA  0C01 0003               3752              CMPI.B  #3,D1
000034DE  6700 00A4               3753              BEQ     REG_3
000034E2  0C01 0004               3754              CMPI.B  #4,D1
000034E6  6700 00AA               3755              BEQ     REG_4
000034EA  0C01 0005               3756              CMPI.B  #5,D1
000034EE  6700 00B0               3757              BEQ     REG_5
000034F2  0C01 0006               3758              CMPI.B  #6,D1
000034F6  6700 00B6               3759              BEQ     REG_6
000034FA  0C01 0007               3760              CMPI.B  #7,D1
000034FE  6700 00BC               3761              BEQ     REG_7
00003502                          3762  
00003502                          3763  *---------------------------------------------------------------------------*
00003502                          3764  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003502                          3765  *---------------------------------------------------------------------------*           
00003502                          3766  SRC_REGISTER 
00003502                          3767              * clear registers to store temp data
00003502  4280                    3768              CLR.L   D0                      
00003504  4281                    3769              CLR.L   D1                      
00003506  207C 00000000           3770              MOVEA.L #0, A0                  
0000350C  227C 00000000           3771              MOVEA.L #0, A1                  
00003512                          3772              
00003512  2205                    3773              MOVE.L  D5,D1   * temp store the processing data
00003514  0281 00000007           3774              ANDI.L  #7,D1   * mask the first 4 bits with 0111
0000351A                          3775              
0000351A  0C01 0000               3776              CMPI.B  #0,D1
0000351E  6700 003A               3777              BEQ     REG_0
00003522  0C01 0001               3778              CMPI.B  #1,D1
00003526  6700 0040               3779              BEQ     REG_1
0000352A  0C01 0002               3780              CMPI.B  #2,D1
0000352E  6700 0046               3781              BEQ     REG_2
00003532  0C01 0003               3782              CMPI.B  #3,D1
00003536  6700 004C               3783              BEQ     REG_3
0000353A  0C01 0004               3784              CMPI.B  #4,D1
0000353E  6700 0052               3785              BEQ     REG_4
00003542  0C01 0005               3786              CMPI.B  #5,D1
00003546  6700 0058               3787              BEQ     REG_5
0000354A  0C01 0006               3788              CMPI.B  #6,D1
0000354E  6700 005E               3789              BEQ     REG_6
00003552  0C01 0007               3790              CMPI.B  #7,D1
00003556  6700 0064               3791              BEQ     REG_7
0000355A                          3792  
0000355A                          3793  *---------------------------------------------------------------------------*
0000355A                          3794  * REG_0 ~ REG_7: display register 0 to 7
0000355A                          3795  *---------------------------------------------------------------------------*
0000355A  43F9 000047BC           3796  REG_0       LEA     DISP_0,A1
00003560  103C 000E               3797              MOVE.B  #14,D0
00003564  4E4F                    3798              TRAP    #15
00003566  4E75                    3799              RTS
00003568                          3800              
00003568  43F9 000047BE           3801  REG_1       LEA     DISP_1,A1
0000356E  103C 000E               3802              MOVE.B  #14,D0
00003572  4E4F                    3803              TRAP    #15
00003574  4E75                    3804              RTS
00003576                          3805              
00003576                          3806  
00003576  43F9 000047C0           3807  REG_2       LEA     DISP_2,A1
0000357C  103C 000E               3808              MOVE.B  #14,D0
00003580  4E4F                    3809              TRAP    #15
00003582  4E75                    3810              RTS
00003584                          3811            
00003584  43F9 000047C2           3812  REG_3       LEA     DISP_3,A1
0000358A  103C 000E               3813              MOVE.B  #14,D0
0000358E  4E4F                    3814              TRAP    #15
00003590  4E75                    3815              RTS
00003592                          3816              
00003592  43F9 000047C4           3817  REG_4       LEA     DISP_4,A1
00003598  103C 000E               3818              MOVE.B  #14,D0
0000359C  4E4F                    3819              TRAP    #15
0000359E  4E75                    3820              RTS
000035A0                          3821              
000035A0  43F9 000047C6           3822  REG_5       LEA     DISP_5,A1
000035A6  103C 000E               3823              MOVE.B  #14,D0
000035AA  4E4F                    3824              TRAP    #15
000035AC  4E75                    3825              RTS
000035AE                          3826              
000035AE  43F9 000047C8           3827  REG_6       LEA     DISP_6,A1
000035B4  103C 000E               3828              MOVE.B  #14,D0
000035B8  4E4F                    3829              TRAP    #15
000035BA  4E75                    3830              RTS
000035BC                          3831              
000035BC  43F9 000047CA           3832  REG_7       LEA     DISP_7,A1
000035C2  103C 000E               3833              MOVE.B  #14,D0
000035C6  4E4F                    3834              TRAP    #15
000035C8  4E75                    3835              RTS
000035CA                          3836              
000035CA                          3837  *---------------------------------------------------------------------------*
000035CA                          3838  * REPEAT : Ask user whether they wish to run the program again
000035CA                          3839  *---------------------------------------------------------------------------*           
000035CA  4246                    3840  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
000035CC  43F9 00004295           3841              LEA     REPEATMSG,A1
000035D2  103C 000E               3842              MOVE.B  #14,D0
000035D6  4E4F                    3843              TRAP    #15
000035D8                          3844              
000035D8  43F9 0000441F           3845              LEA     TMPINPUT,A1             * allocate space to temp store user input
000035DE  103C 0002               3846              MOVE.B  #2,D0
000035E2  4E4F                    3847              TRAP    #15
000035E4                          3848  
000035E4  0C01 0001               3849              CMPI.B  #1,D1                   * check for length of user input
000035E8  66E0                    3850              BNE     REPEAT                  * return to the beginning of the function if unequal
000035EA                          3851              
000035EA  0C11 0059               3852              CMPI.B  #$59,(A1)               * compare the input with Y    
000035EE  6700 DA1A               3853              BEQ     PROGLP                  * repeat the program
000035F2                          3854              
000035F2  0C11 0079               3855              CMPI.B  #$79,(A1)               * compare the input with y    
000035F6  6700 DA12               3856              BEQ     PROGLP                  * repeat the program
000035FA                          3857              
000035FA  0C11 004E               3858              CMPI.B  #$4E,(A1)               * compare the input with N    
000035FE  6700 0928               3859              BEQ     TERMINATE               * finish program
00003602                          3860              
00003602  0C11 006E               3861              CMPI.B  #$6E,(A1)               * compare the input with n    
00003606  6700 0920               3862              BEQ     TERMINATE               * finish program
0000360A                          3863              
0000360A  60BE                    3864              BRA     REPEAT                  * invalid input/repeat the function
0000360C                          3865  
0000360C                          3866  *---------------------------------------------------------------------------*
0000360C                          3867  * EA DECODING INTERFACE
0000360C                          3868  * [A0] - RESERVED FOR USE
0000360C                          3869  * [D2] - RESERVED FOR USE
0000360C                          3870  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
0000360C                          3871  *---------------------------------------------------------------------------*
0000360C                          3872  GET_EA_EA_SRC
0000360C                          3873      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
0000360C                          3874      
0000360C                          3875      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
0000360C  2405                    3876      MOVE.L  D5,D2                           * CLEAN COPY TO D2
0000360E  E68A                    3877      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00003610  23C2 000047E2           3878      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003616  7407                    3879      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003618  C5B9 000047E2           3880      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
0000361E                          3881                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
0000361E                          3882      
0000361E                          3883      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
0000361E                          3884      *DESTINATION REGISTER FORMAT STANDARD         *
0000361E                          3885      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
0000361E                          3886      *WHEN BIT = 0(VALID ADDRESS MODE)             *
0000361E                          3887      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
0000361E                          3888      *0 - Dn                                       *
0000361E                          3889      *1 - An                                       *
0000361E                          3890      *2 - (An)                                     *
0000361E                          3891      *3 - (An)+                                    *
0000361E                          3892      *4 - -(An)                                    *
0000361E                          3893      *5 - (XXX).W                                  *
0000361E                          3894      *6 - (XXX).L                                  *
0000361E                          3895      *7 - #<data>                                  *
0000361E                          3896      ***********************************************
0000361E                          3897      
0000361E                          3898      *** Check if source ...  <ea> = Dn
0000361E                          3899  CHECK0    
0000361E  41F9 000047D2           3900            LEA     TEMP_REGISTER_FORMAT,A0
00003624  1439 000047D1           3901            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000362A  1082                    3902            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000362C  0239 0001 000047D2      3903            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003634  0C39 0001 000047D2      3904            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
0000363C  6700 006A               3905            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003640  0CB9 00000000 000047E2  3906            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
0000364A  6600 005C               3907            BNE     CHECK1
0000364E                          3908            
0000364E                          3909            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
0000364E  163C 0020               3910            MOVE.B    #' ',D3
00003652  6100 0856               3911            BSR       PUSH_STACK
00003656  163C 0044               3912            MOVE.B    #'D',D3
0000365A  6100 084E               3913            BSR       PUSH_STACK
0000365E                          3914  
0000365E                          3915            *FIND REGISTER NUMBER END LOCATION*  
0000365E  13F9 000047D4 000047DA  3916            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003668  0239 000F 000047DA      3917            AND.B   #$0F,VAR_BYTE_END
00003670                          3918            
00003670                          3919            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003670  23C5 000047DE           3920            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003676  1439 000047DA           3921            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000367C                          3922            
0000367C                          3923            *INTITIALIZE FOR BIT SHIFTING
0000367C  41F9 000047DE           3924            LEA     VAR_TEMP_CLEANCOPY,A0
00003682  2639 000047DE           3925            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003688                          3926  LOOP_SHIFTING
00003688  0C02 0000               3927            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000368C  6700 0008               3928            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003690  E24B                    3929            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003692  5302                    3930            SUB.B   #1,D2                     *DECREMENT COUNTER
00003694  60F2                    3931            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
00003696                          3932  MASKING_NEXT
00003696  C6BC 00000007           3933            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
0000369C  0603 0030               3934            ADD.B   #$30,D3                   *CONVERT TO CHAR
000036A0  6100 0808               3935            BSR     PUSH_STACK                *PUSH TO STACK
000036A4                          3936            
000036A4  6000 0394               3937            BRA     GET_SRC_SUCCESS           *RETURN          
000036A8                          3938            
000036A8                          3939            
000036A8                          3940            *** Check if source ...  <ea> = An
000036A8  41F9 000047D2           3941  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000036AE  1439 000047D1           3942            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000036B4  1082                    3943            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000036B6  0239 0002 000047D2      3944            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000036BE  0C39 0002 000047D2      3945            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000036C6  6700 006A               3946            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
000036CA  0CB9 00000001 000047E2  3947            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
000036D4  6600 005C               3948            BNE     CHECK2
000036D8                          3949            
000036D8                          3950            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000036D8  163C 0020               3951            MOVE.B    #' ',D3
000036DC  6100 07CC               3952            BSR       PUSH_STACK
000036E0  163C 0041               3953            MOVE.B    #'A',D3
000036E4  6100 07C4               3954            BSR       PUSH_STACK
000036E8                          3955  
000036E8                          3956            
000036E8                          3957            *FIND REGISTER NUMBER END LOCATION*  
000036E8  13F9 000047D4 000047DA  3958            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000036F2  0239 000F 000047DA      3959            AND.B   #$0F,VAR_BYTE_END
000036FA                          3960            
000036FA                          3961            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000036FA  23C5 000047DE           3962            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003700  1439 000047DA           3963            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003706                          3964            
00003706                          3965            *INTITIALIZE FOR BIT SHIFTING
00003706  41F9 000047DE           3966            LEA     VAR_TEMP_CLEANCOPY,A0
0000370C  2639 000047DE           3967            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003712                          3968  LOOP_SHIFTING1
00003712  0C02 0000               3969            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003716  6700 0008               3970            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
0000371A  E24B                    3971            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
0000371C  5302                    3972            SUB.B   #1,D2                     *DECREMENT COUNTER
0000371E  60F2                    3973            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003720                          3974  MASKING_NEXT1
00003720  C6BC 00000007           3975            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003726  0603 0030               3976            ADD.B   #$30,D3                   *CONVERT TO CHAR
0000372A  6100 077E               3977            BSR     PUSH_STACK                *PUSH TO STACK
0000372E                          3978            
0000372E  6000 030A               3979            BRA     GET_SRC_SUCCESS                   *RETURN 
00003732                          3980            
00003732                          3981            
00003732                          3982            
00003732                          3983            
00003732                          3984            *** Check if source ...  <ea> = (An)       
00003732  41F9 000047D2           3985  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003738  1439 000047D1           3986            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000373E  1082                    3987            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003740  0239 0004 000047D2      3988            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003748  0C39 0004 000047D2      3989            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003750  6700 007A               3990            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003754  0CB9 00000002 000047E2  3991            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
0000375E  6600 006C               3992            BNE     CHECK3
00003762                          3993            
00003762                          3994            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003762  163C 0020               3995            MOVE.B    #' ',D3
00003766  6100 0742               3996            BSR       PUSH_STACK
0000376A  163C 0028               3997            MOVE.B    #'(',D3
0000376E  6100 073A               3998            BSR       PUSH_STACK
00003772  163C 0041               3999            MOVE.B    #'A',D3
00003776  6100 0732               4000            BSR       PUSH_STACK
0000377A                          4001  
0000377A                          4002            
0000377A                          4003            *FIND REGISTER NUMBER END LOCATION*  
0000377A  13F9 000047D4 000047DA  4004            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003784  0239 000F 000047DA      4005            AND.B   #$0F,VAR_BYTE_END
0000378C                          4006            
0000378C                          4007            *GET INDEX OF THE END OF SRC REGISTER NUMBER
0000378C  23C5 000047DE           4008            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003792  1439 000047DA           4009            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003798                          4010            
00003798                          4011            *INTITIALIZE FOR BIT SHIFTING
00003798  41F9 000047DE           4012            LEA     VAR_TEMP_CLEANCOPY,A0
0000379E  2639 000047DE           4013            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000037A4                          4014  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
000037A4  0C02 0000               4015            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000037A8  6700 0008               4016            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000037AC  E24B                    4017            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000037AE  5302                    4018            SUB.B   #1,D2                     *DECREMENT COUNTER
000037B0  60F2                    4019            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
000037B2                          4020  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
000037B2  0283 00000007           4021            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000037B8  0603 0030               4022            ADDI.B   #$30,D3                   *CONVERT TO CHAR
000037BC  6100 06EC               4023            BSR     PUSH_STACK                *PUSH TO STACK
000037C0                          4024            
000037C0  163C 0029               4025            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
000037C4  6100 06E4               4026            BSR       PUSH_STACK
000037C8                          4027            
000037C8  6000 0270               4028            BRA     GET_SRC_SUCCESS                   *RETURN 
000037CC                          4029  
000037CC                          4030            
000037CC                          4031            
000037CC                          4032                      
000037CC                          4033  *** Check if source ...  <ea> = (An)+       
000037CC  41F9 000047D2           4034  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
000037D2  1439 000047D1           4035            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000037D8  1082                    4036            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000037DA  0239 0008 000047D2      4037            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
000037E2  0C39 0008 000047D2      4038            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
000037EA  6700 0082               4039            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
000037EE  0CB9 00000003 000047E2  4040            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
000037F8  6600 0074               4041            BNE     CHECK4
000037FC                          4042            
000037FC                          4043            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
000037FC  163C 0020               4044            MOVE.B    #' ',D3
00003800  6100 06A8               4045            BSR       PUSH_STACK
00003804  163C 0028               4046            MOVE.B    #'(',D3
00003808  6100 06A0               4047            BSR       PUSH_STACK
0000380C  163C 0041               4048            MOVE.B    #'A',D3
00003810  6100 0698               4049            BSR       PUSH_STACK
00003814                          4050  
00003814                          4051            
00003814                          4052            *FIND REGISTER NUMBER END LOCATION*  
00003814  13F9 000047D4 000047DA  4053            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000381E  0239 000F 000047DA      4054            ANDI.B   #$0F,VAR_BYTE_END
00003826                          4055            
00003826                          4056            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003826  23C5 000047DE           4057            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000382C  1439 000047DA           4058            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003832                          4059            
00003832                          4060            *INTITIALIZE FOR BIT SHIFTING
00003832  41F9 000047DE           4061            LEA     VAR_TEMP_CLEANCOPY,A0
00003838  2639 000047DE           4062            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000383E                          4063            
0000383E                          4064  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
0000383E  0C02 0000               4065            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003842  6700 0008               4066            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003846  E24B                    4067            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003848  5302                    4068            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000384A  60F2                    4069            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
0000384C                          4070                                               *change: NAME OF LABEL*
0000384C                          4071  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
0000384C  0283 00000007           4072            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003852  0603 0030               4073            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003856  6100 0652               4074            BSR     PUSH_STACK                *PUSH TO STACK
0000385A                          4075            
0000385A  163C 0029               4076            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000385E  6100 064A               4077            BSR       PUSH_STACK
00003862  163C 002B               4078            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003866  6100 0642               4079            BSR       PUSH_STACK
0000386A                          4080            
0000386A  6000 01CE               4081            BRA       GET_SRC_SUCCESS                   *RETURN 
0000386E                          4082  
0000386E                          4083            
0000386E                          4084            
0000386E                          4085                      
0000386E                          4086            *** Check if source ...  <ea> = -(An)       
0000386E  41F9 000047D2           4087  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003874  1439 000047D1           4088            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
0000387A  1082                    4089            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000387C  0239 0010 000047D2      4090            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003884  0C39 0010 000047D2      4091            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000388C  6700 0082               4092            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003890  0CB9 00000004 000047E2  4093            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
0000389A  6600 0074               4094            BNE     CHECK7
0000389E                          4095            
0000389E                          4096            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
0000389E  163C 0020               4097            MOVE.B    #' ',D3
000038A2  6100 0606               4098            BSR       PUSH_STACK
000038A6  163C 002D               4099            MOVE.B    #'-',D3
000038AA  6100 05FE               4100            BSR       PUSH_STACK
000038AE  163C 0028               4101            MOVE.B    #'(',D3
000038B2  6100 05F6               4102            BSR       PUSH_STACK
000038B6  163C 0041               4103            MOVE.B    #'A',D3
000038BA  6100 05EE               4104            BSR       PUSH_STACK
000038BE                          4105  
000038BE                          4106            
000038BE                          4107            *FIND REGISTER NUMBER END LOCATION*  
000038BE  13F9 000047D4 000047DA  4108            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
000038C8  0239 000F 000047DA      4109            AND.B   #$0F,VAR_BYTE_END
000038D0                          4110            
000038D0                          4111            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000038D0  23C5 000047DE           4112            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000038D6  1439 000047DA           4113            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000038DC                          4114            
000038DC                          4115            *INTITIALIZE FOR BIT SHIFTING
000038DC  41F9 000047DE           4116            LEA     VAR_TEMP_CLEANCOPY,A0
000038E2  2639 000047DE           4117            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000038E8                          4118            
000038E8                          4119  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
000038E8  0C02 0000               4120            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000038EC  6700 0008               4121            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
000038F0  E24B                    4122            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000038F2  5302                    4123            SUBI.B   #1,D2                     *DECREMENT COUNTER
000038F4  60F2                    4124            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
000038F6                          4125                                               *change: NAME OF LABEL*
000038F6                          4126  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
000038F6  0283 00000007           4127            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000038FC  0603 0030               4128            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003900  6100 05A8               4129            BSR     PUSH_STACK                *PUSH TO STACK
00003904                          4130            
00003904  163C 0029               4131            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003908  6100 05A0               4132            BSR       PUSH_STACK
0000390C                          4133            
0000390C  6000 012C               4134            BRA     GET_SRC_SUCCESS                   *RETURN
00003910                          4135            
00003910                          4136                      
00003910                          4137            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003910  0CB9 00000007 000047E2  4138  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
0000391A  6600 011A               4139            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
0000391E                          4140                   
0000391E                          4141            *NEXT: (MODE == 111) 
0000391E                          4142            *NOW: CHECK FOR SRC REGISTER 
0000391E                          4143                  *(000 = (xxx).W)
0000391E                          4144                  *(001 = (xxx).L)
0000391E                          4145                  *(010 = #<data>)
0000391E                          4146                  
0000391E                          4147            *FIND REGISTER NUMBER END LOCATION*  
0000391E  13F9 000047D4 000047DA  4148            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003928  0239 000F 000047DA      4149            AND.B   #$0F,VAR_BYTE_END
00003930                          4150            
00003930                          4151            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003930  23C5 000047DE           4152            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003936  1439 000047DA           4153            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
0000393C                          4154            
0000393C                          4155            *INTITIALIZE FOR BIT SHIFTING
0000393C  41F9 000047DE           4156            LEA     VAR_TEMP_CLEANCOPY,A0
00003942  2C39 000047DE           4157            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003948                          4158  SRC_LOOP_SHIFTING
00003948  0C02 0000               4159            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
0000394C  6700 0008               4160            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003950  E24E                    4161            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003952  5302                    4162            SUB.B   #1,D2                     *DECREMENT COUNTER
00003954  60F2                    4163            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003956                          4164  SRC_MASKING_NEXT
00003956  CCBC 00000007           4165            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
0000395C                          4166           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
0000395C                          4167           
0000395C                          4168  CHECK_WORD  
0000395C  41F9 000047D2           4169            LEA     TEMP_REGISTER_FORMAT,A0
00003962  1439 000047D1           4170            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003968  1082                    4171            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
0000396A  0239 0020 000047D2      4172            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003972  0C39 0020 000047D2      4173            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
0000397A  6700 0026               4174            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000397E  0C06 0000               4175            CMPI.B  #0,D6                          
00003982  6600 001E               4176            BNE     CHECK_LONG 
00003986                          4177            
00003986                          4178            *IT IS A WORD AT THIS POINT*
00003986                          4179            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003986  163C 0020               4180            MOVE.B    #' ',D3
0000398A  6100 051E               4181            BSR       PUSH_STACK
0000398E  163C 0024               4182            MOVE.B    #'$',D3
00003992  6100 0516               4183            BSR       PUSH_STACK
00003996  321D                    4184            MOVE.W    (A5)+,D1
00003998  7404                    4185            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
0000399A  6100 D8A4               4186            BSR       HEX2ASCII2STACK
0000399E  6000 009A               4187            BRA     GET_SRC_SUCCESS
000039A2                          4188  
000039A2                          4189  CHECK_LONG
000039A2  41F9 000047D2           4190            LEA     TEMP_REGISTER_FORMAT,A0
000039A8  1439 000047D1           4191            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039AE  1082                    4192            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039B0  0239 0040 000047D2      4193            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
000039B8  0C39 0040 000047D2      4194            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000039C0  6700 002E               4195            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000039C4  0C06 0001               4196            CMPI.B  #1,D6                          
000039C8  6600 0026               4197            BNE     CHECK_IMMEDIATE  
000039CC                          4198  
000039CC                          4199            *IT IS A WORD AT THIS POINT*
000039CC                          4200            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000039CC  163C 0020               4201            MOVE.B    #' ',D3
000039D0  6100 04D8               4202            BSR       PUSH_STACK
000039D4  163C 0024               4203            MOVE.B    #'$',D3
000039D8  6100 04D0               4204            BSR       PUSH_STACK
000039DC  321D                    4205            MOVE.W    (A5)+,D1
000039DE  7404                    4206            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000039E0  6100 D85E               4207            BSR       HEX2ASCII2STACK
000039E4  321D                    4208            MOVE.W    (A5)+,D1
000039E6  7404                    4209            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
000039E8  6100 D856               4210            BSR       HEX2ASCII2STACK
000039EC  6000 004C               4211            BRA     GET_SRC_SUCCESS
000039F0                          4212            
000039F0                          4213  CHECK_IMMEDIATE
000039F0  41F9 000047D2           4214            LEA     TEMP_REGISTER_FORMAT,A0
000039F6  1439 000047D1           4215            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039FC  1082                    4216            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039FE  0239 0080 000047D2      4217            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003A06  0C39 0080 000047D2      4218            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A0E  6700 0026               4219            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003A12  0C06 0004               4220            CMPI.B  #4,D6                          
00003A16  6600 001E               4221            BNE     GET_SRC_FAILED 
00003A1A                          4222  
00003A1A                          4223            *IT IS A WORD AT THIS POINT*
00003A1A                          4224            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A1A  163C 0020               4225            MOVE.B    #' ',D3
00003A1E  6100 048A               4226            BSR       PUSH_STACK
00003A22  163C 0023               4227            MOVE.B    #'#',D3
00003A26  6100 0482               4228            BSR       PUSH_STACK
00003A2A  321D                    4229            MOVE.W    (A5)+,D1
00003A2C  7404                    4230            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003A2E  6100 D810               4231            BSR       HEX2ASCII2STACK
00003A32  6000 0006               4232            BRA     GET_SRC_SUCCESS
00003A36                          4233            
00003A36                          4234  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003A36  7801                    4235            MOVE.L #1,D4
00003A38  4E75                    4236            RTS
00003A3A                          4237  GET_SRC_SUCCESS 
00003A3A  4E75                    4238            RTS
00003A3C                          4239                                 
00003A3C                          4240      
00003A3C                          4241  
00003A3C                          4242  
00003A3C                          4243  
00003A3C                          4244  
00003A3C                          4245  
00003A3C                          4246  
00003A3C                          4247  GET_EA_EA_DEST
00003A3C                          4248  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003A3C                          4249      
00003A3C                          4250      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003A3C  2405                    4251      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003A3E  EC8A                    4252      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003A40  23C2 000047E2           4253      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003A46  7407                    4254      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003A48  C5B9 000047E2           4255      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003A4E                          4256                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003A4E                          4257      
00003A4E                          4258      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003A4E                          4259      *DESTINATION REGISTER FORMAT STANDARD         *
00003A4E                          4260      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003A4E                          4261      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003A4E                          4262      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003A4E                          4263      *0 - Dn                                       *
00003A4E                          4264      *1 - An                                       *
00003A4E                          4265      *2 - (An)                                     *
00003A4E                          4266      *3 - (An)+                                    *
00003A4E                          4267      *4 - -(An)                                    *
00003A4E                          4268      *5 - (XXX).W                                  *
00003A4E                          4269      *6 - (XXX).L                                  *
00003A4E                          4270      *7 - #<data>                                  *
00003A4E                          4271      ***********************************************
00003A4E                          4272      
00003A4E                          4273      *** Check if source ...  <ea> = Dn
00003A4E                          4274  DEST_CHECK0    
00003A4E  41F9 000047D2           4275            LEA     TEMP_REGISTER_FORMAT,A0
00003A54  1439 000047D0           4276            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A5A  1082                    4277            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A5C  0239 0001 000047D2      4278            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003A64  0C39 0001 000047D2      4279            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003A6C  6700 006A               4280            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003A70  0CB9 00000000 000047E2  4281            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003A7A  6600 005C               4282            BNE     DEST_CHECK1
00003A7E                          4283            
00003A7E                          4284            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A7E  163C 0020               4285            MOVE.B    #' ',D3
00003A82  6100 0426               4286            BSR       PUSH_STACK
00003A86  163C 0044               4287            MOVE.B    #'D',D3
00003A8A  6100 041E               4288            BSR       PUSH_STACK
00003A8E                          4289  
00003A8E                          4290            *FIND REGISTER NUMBER END LOCATION*  
00003A8E  13F9 000047D3 000047DA  4291            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A98  0239 000F 000047DA      4292            AND.B   #$0F,VAR_BYTE_END
00003AA0                          4293            
00003AA0                          4294            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003AA0  23C5 000047DE           4295            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003AA6  1439 000047DA           4296            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003AAC                          4297            
00003AAC                          4298            *INTITIALIZE FOR BIT SHIFTING
00003AAC  41F9 000047DE           4299            LEA     VAR_TEMP_CLEANCOPY,A0
00003AB2  2639 000047DE           4300            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003AB8                          4301  DEST_LOOP_SHIFTING
00003AB8  0C02 0000               4302            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003ABC  6700 0008               4303            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003AC0  E24B                    4304            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003AC2  5302                    4305            SUB.B   #1,D2                     *DECREMENT COUNTER
00003AC4  60F2                    4306            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003AC6                          4307  DEST_MASKING_NEXT
00003AC6  C6BC 00000007           4308            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003ACC  0603 0030               4309            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003AD0  6100 03D8               4310            BSR     PUSH_STACK                *PUSH TO STACK
00003AD4                          4311            
00003AD4  6000 0394               4312            BRA     GET_DST_SUCCESS           *RETURN          
00003AD8                          4313            
00003AD8                          4314            
00003AD8                          4315            *** Check if source ...  <ea> = An
00003AD8                          4316  DEST_CHECK1    
00003AD8  41F9 000047D2           4317            LEA     TEMP_REGISTER_FORMAT,A0
00003ADE  1439 000047D0           4318            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003AE4  1082                    4319            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003AE6  0239 0002 000047D2      4320            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003AEE  0C39 0002 000047D2      4321            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003AF6  6700 006A               4322            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003AFA  0CB9 00000001 000047E2  4323            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003B04  6600 005C               4324            BNE     DEST_CHECK2
00003B08                          4325            
00003B08                          4326            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003B08  163C 0020               4327            MOVE.B    #' ',D3
00003B0C  6100 039C               4328            BSR       PUSH_STACK
00003B10  163C 0041               4329            MOVE.B    #'A',D3
00003B14  6100 0394               4330            BSR       PUSH_STACK
00003B18                          4331  
00003B18                          4332            
00003B18                          4333            *FIND REGISTER NUMBER END LOCATION*  
00003B18  13F9 000047D3 000047DA  4334            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B22  0239 000F 000047DA      4335            AND.B   #$0F,VAR_BYTE_END
00003B2A                          4336            
00003B2A                          4337            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B2A  23C5 000047DE           4338            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B30  1439 000047DA           4339            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003B36                          4340            
00003B36                          4341            *INTITIALIZE FOR BIT SHIFTING
00003B36  41F9 000047DE           4342            LEA     VAR_TEMP_CLEANCOPY,A0
00003B3C  2639 000047DE           4343            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B42                          4344  DEST_LOOP_SHIFTING1
00003B42  0C02 0000               4345            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B46  6700 0008               4346            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003B4A  E24B                    4347            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B4C  5302                    4348            SUB.B   #1,D2                     *DECREMENT COUNTER
00003B4E  60F2                    4349            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003B50                          4350  DEST_MASKING_NEXT1
00003B50  C6BC 00000007           4351            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B56  0603 0030               4352            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003B5A  6100 034E               4353            BSR     PUSH_STACK                *PUSH TO STACK
00003B5E                          4354            
00003B5E  6000 030A               4355            BRA     GET_DST_SUCCESS                   *RETURN 
00003B62                          4356            
00003B62                          4357            
00003B62                          4358            
00003B62                          4359            
00003B62                          4360            *** Check if source ...  <ea> = (An)       
00003B62                          4361  DEST_CHECK2    
00003B62  41F9 000047D2           4362            LEA     TEMP_REGISTER_FORMAT,A0
00003B68  1439 000047D0           4363            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B6E  1082                    4364            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B70  0239 0004 000047D2      4365            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003B78  0C39 0004 000047D2      4366            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B80  6700 007A               4367            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003B84  0CB9 00000002 000047E2  4368            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003B8E  6600 006C               4369            BNE     DEST_CHECK3
00003B92                          4370            
00003B92                          4371            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003B92  163C 0020               4372            MOVE.B    #' ',D3
00003B96  6100 0312               4373            BSR       PUSH_STACK
00003B9A  163C 0028               4374            MOVE.B    #'(',D3
00003B9E  6100 030A               4375            BSR       PUSH_STACK
00003BA2  163C 0041               4376            MOVE.B    #'A',D3
00003BA6  6100 0302               4377            BSR       PUSH_STACK
00003BAA                          4378  
00003BAA                          4379            
00003BAA                          4380            *FIND REGISTER NUMBER END LOCATION*  
00003BAA  13F9 000047D3 000047DA  4381            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BB4  0239 000F 000047DA      4382            AND.B   #$0F,VAR_BYTE_END
00003BBC                          4383            
00003BBC                          4384            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003BBC  23C5 000047DE           4385            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003BC2  1439 000047DA           4386            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003BC8                          4387            
00003BC8                          4388            *INTITIALIZE FOR BIT SHIFTING
00003BC8  41F9 000047DE           4389            LEA     VAR_TEMP_CLEANCOPY,A0
00003BCE  2639 000047DE           4390            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003BD4                          4391  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003BD4  0C02 0000               4392            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003BD8  6700 0008               4393            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003BDC  E24B                    4394            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003BDE  5302                    4395            SUB.B   #1,D2                     *DECREMENT COUNTER
00003BE0  60F2                    4396            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003BE2                          4397  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003BE2  0283 00000007           4398            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003BE8  0603 0030               4399            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003BEC  6100 02BC               4400            BSR     PUSH_STACK                *PUSH TO STACK
00003BF0                          4401            
00003BF0  163C 0029               4402            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003BF4  6100 02B4               4403            BSR       PUSH_STACK
00003BF8                          4404            
00003BF8  6000 0270               4405            BRA     GET_DST_SUCCESS                   *RETURN 
00003BFC                          4406  
00003BFC                          4407            
00003BFC                          4408            
00003BFC                          4409                      
00003BFC                          4410  *** Check if source ...  <ea> = (An)+       
00003BFC  41F9 000047D2           4411  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003C02  1439 000047D0           4412            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C08  1082                    4413            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003C0A  0239 0008 000047D2      4414            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003C12  0C39 0008 000047D2      4415            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003C1A  6700 0082               4416            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003C1E  0CB9 00000003 000047E2  4417            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003C28  6600 0074               4418            BNE     DEST_CHECK4
00003C2C                          4419            
00003C2C                          4420            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003C2C  163C 0020               4421            MOVE.B    #' ',D3
00003C30  6100 0278               4422            BSR       PUSH_STACK
00003C34  163C 0028               4423            MOVE.B    #'(',D3
00003C38  6100 0270               4424            BSR       PUSH_STACK
00003C3C  163C 0041               4425            MOVE.B    #'A',D3
00003C40  6100 0268               4426            BSR       PUSH_STACK
00003C44                          4427  
00003C44                          4428            
00003C44                          4429            *FIND REGISTER NUMBER END LOCATION*  
00003C44  13F9 000047D3 000047DA  4430            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C4E  0239 000F 000047DA      4431            ANDI.B   #$0F,VAR_BYTE_END
00003C56                          4432            
00003C56                          4433            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C56  23C5 000047DE           4434            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C5C  1439 000047DA           4435            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C62                          4436            
00003C62                          4437            *INTITIALIZE FOR BIT SHIFTING
00003C62  41F9 000047DE           4438            LEA     VAR_TEMP_CLEANCOPY,A0
00003C68  2639 000047DE           4439            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C6E                          4440            
00003C6E                          4441  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003C6E  0C02 0000               4442            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C72  6700 0008               4443            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003C76  E24B                    4444            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C78  5302                    4445            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003C7A  60F2                    4446            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003C7C                          4447                                               *change: NAME OF LABEL*
00003C7C                          4448  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003C7C  0283 00000007           4449            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C82  0603 0030               4450            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003C86  6100 0222               4451            BSR     PUSH_STACK                *PUSH TO STACK
00003C8A                          4452            
00003C8A  163C 0029               4453            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C8E  6100 021A               4454            BSR       PUSH_STACK
00003C92  163C 002B               4455            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C96  6100 0212               4456            BSR       PUSH_STACK
00003C9A                          4457            
00003C9A  6000 01CE               4458            BRA       GET_DST_SUCCESS                   *RETURN 
00003C9E                          4459  
00003C9E                          4460            
00003C9E                          4461            
00003C9E                          4462                      
00003C9E                          4463            *** Check if source ...  <ea> = -(An)       
00003C9E                          4464  DEST_CHECK4    
00003C9E  41F9 000047D2           4465            LEA     TEMP_REGISTER_FORMAT,A0
00003CA4  1439 000047D0           4466            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CAA  1082                    4467            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CAC  0239 0010 000047D2      4468            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003CB4  0C39 0010 000047D2      4469            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CBC  6700 0082               4470            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003CC0  0CB9 00000004 000047E2  4471            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003CCA  6600 0074               4472            BNE     DEST_CHECK7
00003CCE                          4473            
00003CCE                          4474            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003CCE  163C 0020               4475            MOVE.B    #' ',D3
00003CD2  6100 01D6               4476            BSR       PUSH_STACK
00003CD6  163C 002D               4477            MOVE.B    #'-',D3
00003CDA  6100 01CE               4478            BSR       PUSH_STACK
00003CDE  163C 0028               4479            MOVE.B    #'(',D3
00003CE2  6100 01C6               4480            BSR       PUSH_STACK
00003CE6  163C 0041               4481            MOVE.B    #'A',D3
00003CEA  6100 01BE               4482            BSR       PUSH_STACK
00003CEE                          4483  
00003CEE                          4484            
00003CEE                          4485            *FIND REGISTER NUMBER END LOCATION*  
00003CEE  13F9 000047D3 000047DA  4486            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003CF8  0239 000F 000047DA      4487            AND.B   #$0F,VAR_BYTE_END
00003D00                          4488            
00003D00                          4489            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D00  23C5 000047DE           4490            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D06  1439 000047DA           4491            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D0C                          4492            
00003D0C                          4493            *INTITIALIZE FOR BIT SHIFTING
00003D0C  41F9 000047DE           4494            LEA     VAR_TEMP_CLEANCOPY,A0
00003D12  2639 000047DE           4495            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003D18                          4496            
00003D18                          4497  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003D18  0C02 0000               4498            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D1C  6700 0008               4499            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003D20  E24B                    4500            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D22  5302                    4501            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003D24  60F2                    4502            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003D26                          4503                                               *change: NAME OF LABEL*
00003D26                          4504  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003D26  0283 00000007           4505            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003D2C  0603 0030               4506            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003D30  6100 0178               4507            BSR     PUSH_STACK                *PUSH TO STACK
00003D34                          4508            
00003D34  163C 0029               4509            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003D38  6100 0170               4510            BSR       PUSH_STACK
00003D3C                          4511            
00003D3C  6000 012C               4512            BRA     GET_DST_SUCCESS                   *RETURN
00003D40                          4513            
00003D40                          4514                      
00003D40                          4515            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003D40                          4516  DEST_CHECK7    
00003D40  0CB9 00000007 000047E2  4517            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003D4A  6600 011A               4518            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003D4E                          4519                   
00003D4E                          4520            *NEXT: (MODE == 111) 
00003D4E                          4521            *NOW: CHECK FOR SRC REGISTER 
00003D4E                          4522                  *(000 = (xxx).W)
00003D4E                          4523                  *(001 = (xxx).L)
00003D4E                          4524                  *(010 = #<data>)
00003D4E                          4525                  
00003D4E                          4526            *FIND REGISTER NUMBER END LOCATION*  
00003D4E  13F9 000047D3 000047DA  4527            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003D58  0239 000F 000047DA      4528            AND.B   #$0F,VAR_BYTE_END
00003D60                          4529            
00003D60                          4530            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003D60  23C5 000047DE           4531            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003D66  1439 000047DA           4532            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003D6C                          4533            
00003D6C                          4534            *INTITIALIZE FOR BIT SHIFTING
00003D6C  41F9 000047DE           4535            LEA     VAR_TEMP_CLEANCOPY,A0
00003D72  2C39 000047DE           4536            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003D78                          4537  DEST_LOOP_SHIFTING7
00003D78  0C02 0000               4538            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003D7C  6700 0008               4539            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003D80  E24E                    4540            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003D82  5302                    4541            SUB.B   #1,D2                     *DECREMENT COUNTER
00003D84  60F2                    4542            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
00003D86                          4543  DEST_MASKING_NEXT7
00003D86  CCBC 00000007           4544            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003D8C                          4545           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003D8C                          4546            
00003D8C                          4547  DEST_CHECK_WORD  
00003D8C  41F9 000047D2           4548            LEA     TEMP_REGISTER_FORMAT,A0
00003D92  1439 000047D0           4549            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D98  1082                    4550            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D9A  0239 0020 000047D2      4551            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003DA2  0C39 0020 000047D2      4552            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003DAA  6700 0026               4553            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003DAE  0C06 0000               4554            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
00003DB2  6600 001E               4555            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
00003DB6                          4556            *IT IS A WORD AT THIS POINT*
00003DB6                          4557            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003DB6  163C 0020               4558            MOVE.B    #' ',D3
00003DBA  6100 00EE               4559            BSR       PUSH_STACK
00003DBE  163C 0024               4560            MOVE.B    #'$',D3
00003DC2  6100 00E6               4561            BSR       PUSH_STACK
00003DC6  321D                    4562            MOVE.W    (A5)+,D1
00003DC8  7404                    4563            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003DCA  6100 D474               4564            BSR       HEX2ASCII2STACK
00003DCE  6000 009A               4565            BRA       GET_DST_SUCCESS
00003DD2                          4566  
00003DD2                          4567  DEST_CHECK_LONG
00003DD2  41F9 000047D2           4568            LEA     TEMP_REGISTER_FORMAT,A0
00003DD8  1439 000047D0           4569            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003DDE  1082                    4570            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003DE0  0239 0040 000047D2      4571            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003DE8  0C39 0040 000047D2      4572            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003DF0  6700 002E               4573            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003DF4  0C06 0001               4574            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
00003DF8  6600 0026               4575            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00003DFC                          4576            *IT IS A WORD AT THIS POINT*
00003DFC                          4577            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003DFC  163C 0020               4578            MOVE.B    #' ',D3
00003E00  6100 00A8               4579            BSR       PUSH_STACK
00003E04  163C 0024               4580            MOVE.B    #'$',D3
00003E08  6100 00A0               4581            BSR       PUSH_STACK
00003E0C  321D                    4582            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003E0E  7404                    4583            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00003E10  6100 D42E               4584            BSR       HEX2ASCII2STACK
00003E14  321D                    4585            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00003E16  7404                    4586            MOVE.L    #4,D2          
00003E18  6100 D426               4587            BSR       HEX2ASCII2STACK
00003E1C  6000 004C               4588            BRA     GET_DST_SUCCESS
00003E20                          4589            
00003E20                          4590  DEST_CHECK_IMMEDIATE
00003E20  41F9 000047D2           4591            LEA     TEMP_REGISTER_FORMAT,A0
00003E26  1439 000047D0           4592            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E2C  1082                    4593            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E2E  0239 0080 000047D2      4594            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003E36  0C39 0080 000047D2      4595            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003E3E  6700 0026               4596            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003E42  0C06 0004               4597            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
00003E46  6600 001E               4598            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00003E4A                          4599            
00003E4A                          4600            *IT IS A WORD AT THIS POINT*
00003E4A                          4601            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E4A  163C 0020               4602            MOVE.B    #' ',D3
00003E4E  6100 005A               4603            BSR       PUSH_STACK
00003E52  163C 0023               4604            MOVE.B    #'#',D3
00003E56  6100 0052               4605            BSR       PUSH_STACK
00003E5A  321D                    4606            MOVE.W    (A5)+,D1
00003E5C  7404                    4607            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003E5E  6100 D3E0               4608            BSR       HEX2ASCII2STACK
00003E62  6000 0006               4609            BRA       GET_DST_SUCCESS
00003E66                          4610            
00003E66                          4611  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003E66  7801                    4612            MOVE.L #1,D4
00003E68  4E75                    4613            RTS
00003E6A                          4614  GET_DST_SUCCESS 
00003E6A  4E75                    4615            RTS
00003E6C                          4616  
00003E6C                          4617  
00003E6C                          4618  *---------------------------------------------------------------------------*
00003E6C                          4619  * STACK/QUEUE INTERFACE
00003E6C                          4620  *---------------------------------------------------------------------------*
00003E6C                          4621  PRINT_STACK
00003E6C  0C39 0000 000047CC      4622            CMP.B     #0,COUNTER
00003E74  6700 000E               4623            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
00003E78                          4624            
00003E78                          4625  PRINT_STACK_HELPER
00003E78  6100 0038               4626            BSR      POP_STACK          *PRINTS ADDRESS
00003E7C  103C 0006               4627            MOVE.B   #6,D0              *Display single character in D1.B. 
00003E80  4E4F                    4628            TRAP     #15             *ACTIVATES PRINT
00003E82                          4629  
00003E82  60E8                    4630            BRA       PRINT_STACK
00003E84                          4631  PRINT_STACK_RETURN
00003E84  4E75                    4632            RTS
00003E86                          4633            
00003E86                          4634            
00003E86                          4635  PRINT_QUEUE
00003E86  0C39 0000 000047CC      4636            CMP.B     #0,COUNTER
00003E8E  6700 0018               4637            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
00003E92                          4638            
00003E92                          4639  PRINT_QUEUE_HELPER
00003E92  33F9 000047CC 000047CE  4640            MOVE.W   COUNTER,QUEUE_COUNTER
00003E9C  6100 0022               4641            BSR      POP_FRONT          *PRINTS ADDRESS
00003EA0  103C 0006               4642            MOVE.B   #6,D0              *Display single character in D1.B. 
00003EA4  4E4F                    4643            TRAP     #15             *ACTIVATES PRINT
00003EA6                          4644  
00003EA6  60DE                    4645            BRA       PRINT_QUEUE
00003EA8                          4646  PRINT_QUEUE_RETURN
00003EA8  4E75                    4647            RTS
00003EAA                          4648            
00003EAA                          4649  *PUSHES.W CONTENTS OF [D3] INTO STACK          
00003EAA                          4650  PUSH_STACK
00003EAA  1503                    4651              MOVE.B  D3,-(A2)
00003EAC  6100 0058               4652              BSR     INCREMENT
00003EB0  4E75                    4653              RTS
00003EB2                          4654  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
00003EB2                          4655  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
00003EB2                          4656  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
00003EB2                          4657  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
00003EB2                          4658  *         TRAP        #15             *ACTIVATES PRINT
00003EB2                          4659  POP_STACK
00003EB2  BECA                    4660              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
00003EB4  6700 0008               4661              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
00003EB8  121A                    4662              MOVE.B  (A2)+,D1 
00003EBA  6100 0052               4663              BSR     DECREMENT
00003EBE                          4664  POP_RETURN
00003EBE  4E75                    4665              RTS 
00003EC0                          4666        
00003EC0                          4667  *USE [A4] AS SECOND POINTER IN SHIFTING      
00003EC0  0C39 0000 000047CE      4668  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003EC8  6700 0030               4669              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003ECC                          4670              
00003ECC                          4671              
00003ECC                          4672              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00003ECC  347C 7000               4673              MOVEA.W #STACK,A2   *START A2 AT STACK
00003ED0  0622 0000               4674              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
00003ED4  384A                    4675              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
00003ED6  0624 0000               4676              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00003EDA  1212                    4677              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00003EDC                          4678  POP_SHIFT_LOOP
00003EDC  0C39 0000 000047CE      4679              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
00003EE4  6700 0014               4680              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00003EE8  1494                    4681              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00003EEA  0624 0000               4682              ADD.B   #0,-(A4)
00003EEE  0622 0000               4683              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00003EF2  5339 000047CE           4684              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
00003EF8                          4685              
00003EF8  60E2                    4686              BRA     POP_SHIFT_LOOP
00003EFA                          4687                          
00003EFA                          4688  POP_FRONT_RETURN 
00003EFA                          4689              *RESET A2 BACK TO SP
00003EFA  347C 7000               4690              MOVEA.W #STACK,A2    
00003EFE  5339 000047CC           4691              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
00003F04  4E75                    4692              RTS   
00003F06                          4693  
00003F06                          4694  INCREMENT
00003F06  5239 000047CC           4695              ADD.B   #1, COUNTER
00003F0C  4E75                    4696              RTS           
00003F0E                          4697  DECREMENT
00003F0E  5339 000047CC           4698              SUB.B   #1, COUNTER
00003F14  4E75                    4699              RTS           
00003F16                          4700  CLEAR_STACK
00003F16  0C39 0000 000047CC      4701              CMP.B     #0,COUNTER
00003F1E  6700 0006               4702              BEQ       CLEAR_RETURN
00003F22  618E                    4703              BSR       POP_STACK
00003F24  60F0                    4704              BRA       CLEAR_STACK
00003F26                          4705   
00003F26                          4706  CLEAR_RETURN
00003F26  4E75                    4707              RTS    
00003F28                          4708  *---------------------------------------------------------------------------*
00003F28                          4709  * TERMINATE
00003F28                          4710  *---------------------------------------------------------------------------*
00003F28                          4711  TERMINATE   
00003F28  43F9 000042D8           4712              LEA     FINMSG,A1
00003F2E  103C 000E               4713              MOVE.B  #14,D0
00003F32  4E4F                    4714              TRAP    #15
00003F34                          4715  
00003F34  103C 0009               4716              MOVE.B  #9,D0
00003F38  4E4F                    4717              TRAP    #15
00003F3A                          4718  
00003F3A                          4719  *---------------------------------------------------------------------------*
00003F3A                          4720  * Data storage                                                 
00003F3A                          4721  *---------------------------------------------------------------------------*  
00003F3A                          4722  WELCOME
00003F3A= 20 20 20 20 20 20 ...   4723              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00003F8A= 3D 3D 3D 3D 3D 20 ...   4724              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00003FDA= 3D 3D 3D 3D 3D 20 ...   4725              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
0000402A                          4726      
0000402A= 20 20 20 20 20 20 ...   4727              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
0000407A= 20 20 20 20 20 20 ...   4728              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
000040CA= 20 20 20 20 20 20 ...   4729              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
0000411A                          4730      
0000411A= 20 20 20 20 20 20 ...   4731              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
0000416A= 3D 3D 3D 3D 3D 20 ...   4732              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
000041BA= 3D 3D 3D 3D 3D 20 ...   4733              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
0000420F                          4734  
0000420F                          4735  PROMPT_START
0000420F= 50 6C 65 61 73 65 ...   4736              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
0000423E                          4737      
0000423E                          4738  PROMPT_END
0000423E= 50 6C 65 61 73 65 ...   4739              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
0000426B= 0D 0A 48 69 74 20 ...   4740  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
00004295= 57 6F 75 6C 64 20 ...   4741  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
000042D8= 54 68 61 6E 6B 20 ...   4742  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
00004303= 45 72 72 6F 72 3A ...   4743  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
00004322= 45 72 72 6F 72 3A ...   4744  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
00004347= 45 72 72 6F 72 3A ...   4745  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
00004374                          4746  
00004374                          4747  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
000043C4                          4748  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
00004414                          4749  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
00004418                          4750  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
0000441C= 0D 0A 00                4751  ENDLINE_M   DC.B    CR,LF,0
0000441F                          4752  TMPINPUT    DS.B    80                      * temp store user input
0000446F                          4753  TMPOUTPUT   DS.B    80                      * temp store prog output
000044BF= 20 20 20 4F 52 49 ...   4754  DISP_ORI_B  DC.B    '   ORI.B',0
000044C8= 20 20 20 4F 52 49 ...   4755  DISP_ORI_W  DC.B    '   ORI.W',0
000044D1= 20 20 20 4F 52 49 ...   4756  DISP_ORI_L  DC.B    '   ORI.L',0
000044DA= 20 20 20 45 4F 52 ...   4757  DISP_EORI_B  DC.B    '   EORI.B',0
000044E4= 20 20 20 45 4F 52 ...   4758  DISP_EORI_W  DC.B    '   EORI.W',0
000044EE= 20 20 20 45 4F 52 ...   4759  DISP_EORI_L  DC.B    '   EORI.L',0
000044F8= 20 20 20 42 54 53 ...   4760  DISP_BTST   DC.B    '   BTST',0
00004500= 20 20 20 43 4D 50 ...   4761  DISP_CMPI_B  DC.B    '   CMPI.B',0
0000450A= 20 20 20 43 4D 50 ...   4762  DISP_CMPI_W  DC.B    '   CMPI.W',0
00004514= 20 20 20 43 4D 50 ...   4763  DISP_CMPI_L  DC.B    '   CMPI.L',0
0000451E= 20 20 20 44 41 54 ...   4764  DISP_DATA   DC.B    '   DATA',0
00004526= 20 20 20 4D 4F 56 ...   4765  DISP_MOVE_B DC.B    '   MOVE.B',0
00004530= 20 20 20 4D 4F 56 ...   4766  DISP_MOVE_W DC.B    '   MOVE.W',0
0000453A= 20 20 20 4D 4F 56 ...   4767  DISP_MOVE_L DC.B    '   MOVE.L',0
00004544= 20 20 20 52 54 53 00    4768  DISP_RTS    DC.B    '   RTS',0
0000454B= 20 20 20 4A 53 52 00    4769  DISP_JSR    DC.B    '   JSR',0
00004552= 20 20 20 4E 45 47 ...   4770  DISP_NEG_B    DC.B    '   NEG.B',0
0000455B= 20 20 20 4E 45 47 ...   4771  DISP_NEG_W    DC.B    '   NEG.W',0
00004564= 20 20 20 4E 45 47 ...   4772  DISP_NEG_L    DC.B    '   NEG.L',0
0000456D= 20 20 20 4E 4F 54 ...   4773  DISP_NOT_B  DC.B    '   NOT.B',0
00004576= 20 20 20 4E 4F 54 ...   4774  DISP_NOT_W  DC.B    '   NOT.W',0
0000457F= 20 20 20 4E 4F 54 ...   4775  DISP_NOT_L  DC.B    '   NOT.L',0
00004588= 20 20 20 4C 45 41 00    4776  DISP_LEA    DC.B    '   LEA',0
0000458F= 20 20 20 4D 4F 56 ...   4777  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
0000459A= 20 20 20 4D 4F 56 ...   4778  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
000045A5= 20 20 20 41 44 44 ...   4779  DISP_ADDQ_B DC.B    '   ADDQ.B',0
000045AF= 20 20 20 41 44 44 ...   4780  DISP_ADDQ_W DC.B    '   ADDQ.W',0
000045B9= 20 20 20 41 44 44 ...   4781  DISP_ADDQ_L DC.B    '   ADDQ.L',0
000045C3= 20 20 20 44 49 56 ...   4782  DISP_DIVS   DC.B    '   DIVS',0
000045CB= 20 20 20 53 55 42 ...   4783  DISP_SUB_B  DC.B    '   SUB.B',0
000045D4= 20 20 20 53 55 42 ...   4784  DISP_SUB_W  DC.B    '   SUB.W',0
000045DD= 20 20 20 53 55 42 ...   4785  DISP_SUB_L  DC.B    '   SUB.L',0
000045E6= 20 20 20 53 55 42 ...   4786  DISP_SUBI_B  DC.B    '   SUBI.B',0
000045F0= 20 20 20 53 55 42 ...   4787  DISP_SUBI_W  DC.B    '   SUBI.W',0
000045FA= 20 20 20 53 55 42 ...   4788  DISP_SUBI_L  DC.B    '   SUBI.L',0
00004604= 20 20 20 53 55 42 ...   4789  DISP_SUBA_W  DC.B    '   SUBA.W',0
0000460E= 20 20 20 53 55 42 ...   4790  DISP_SUBA_L  DC.B    '   SUBA.L',0
00004618= 20 20 20 45 4F 52 ...   4791  DISP_EOR_B  DC.B    '   EOR.B',0
00004621= 20 20 20 45 4F 52 ...   4792  DISP_EOR_W  DC.B    '   EOR.W',0
0000462A= 20 20 20 45 4F 52 ...   4793  DISP_EOR_L  DC.B    '   EOR.L',0
00004633= 20 20 20 43 4D 50 ...   4794  DISP_CMP_B  DC.B    '   CMP.B',0
0000463C= 20 20 20 43 4D 50 ...   4795  DISP_CMP_W  DC.B    '   CMP.W',0
00004645= 20 20 20 43 4D 50 ...   4796  DISP_CMP_L  DC.B    '   CMP.L',0
0000464E= 20 20 20 43 4D 50 ...   4797  DISP_CMPA_W  DC.B    '   CMPA.W',0
00004658= 20 20 20 43 4D 50 ...   4798  DISP_CMPA_L  DC.B    '   CMPA.L',0
00004662= 20 20 20 4D 55 4C ...   4799  DISP_MULS_W DC.B    '   MULS.W',0
0000466C= 20 20 20 41 4E 44 ...   4800  DISP_AND_B  DC.B    '   AND.B',0
00004675= 20 20 20 41 4E 44 ...   4801  DISP_AND_W  DC.B    '   AND.W',0
0000467E= 20 20 20 41 4E 44 ...   4802  DISP_AND_L  DC.B    '   AND.L',0
00004687= 20 20 20 41 44 44 ...   4803  DISP_ADD_B  DC.B    '   ADD.B',0
00004690= 20 20 20 41 44 44 ...   4804  DISP_ADD_W  DC.B    '   ADD.W',0
00004699= 20 20 20 41 44 44 ...   4805  DISP_ADD_L  DC.B    '   ADD.L',0
000046A2= 20 20 20 41 44 44 ...   4806  DISP_ADDA_W DC.B    '   ADDA.W',0
000046AC= 20 20 20 41 44 44 ...   4807  DISP_ADDA_L DC.B    '   ADDA.L',0
000046B6= 20 20 20 4C 53 52 ...   4808  DISP_LSR_B  DC.B    '   LSR.B',0
000046BF= 20 20 20 4C 53 4C ...   4809  DISP_LSL_B  DC.B    '   LSL.B',0
000046C8= 20 20 20 4C 53 52 ...   4810  DISP_LSR_W  DC.B    '   LSR.W',0
000046D1= 20 20 20 4C 53 4C ...   4811  DISP_LSL_W  DC.B    '   LSL.W',0
000046DA= 20 20 20 4C 53 52 ...   4812  DISP_LSR_L  DC.B    '   LSR.L',0
000046E3= 20 20 20 4C 53 4C ...   4813  DISP_LSL_L  DC.B    '   LSL.L',0
000046EC= 20 20 20 41 53 52 ...   4814  DISP_ASR_B  DC.B    '   ASR.B',0
000046F5= 20 20 20 41 53 4C ...   4815  DISP_ASL_B  DC.B    '   ASL.B',0
000046FE= 20 20 20 41 53 52 ...   4816  DISP_ASR_W  DC.B    '   ASR.W',0
00004707= 20 20 20 41 53 4C ...   4817  DISP_ASL_W  DC.B    '   ASL.W',0
00004710= 20 20 20 41 53 52 ...   4818  DISP_ASR_L  DC.B    '   ASR.L',0
00004719= 20 20 20 41 53 4C ...   4819  DISP_ASL_L  DC.B    '   ASL.L',0
00004722= 20 20 20 52 4F 52 ...   4820  DISP_ROR_B  DC.B    '   ROR.B',0
0000472B= 20 20 20 52 4F 4C ...   4821  DISP_ROL_B  DC.B    '   ROL.B',0
00004734= 20 20 20 52 4F 52 ...   4822  DISP_ROR_W  DC.B    '   ROR.W',0
0000473D= 20 20 20 52 4F 4C ...   4823  DISP_ROL_W  DC.B    '   ROL.W',0
00004746= 20 20 20 52 4F 52 ...   4824  DISP_ROR_L  DC.B    '   ROR.L',0
0000474F= 20 20 20 52 4F 4C ...   4825  DISP_ROL_L  DC.B    '   ROL.L',0
00004758= 20 20 20 42 52 41 00    4826  DISP_BRA    DC.B    '   BRA',0
0000475F= 20 20 20 42 4C 54 00    4827  DISP_BLT    DC.B    '   BLT',0
00004766= 20 20 20 42 45 51 00    4828  DISP_BEQ    DC.B    '   BEQ',0
0000476D= 20 20 20 42 4E 45 00    4829  DISP_BNE    DC.B    '   BNE',0
00004774= 20 20 20 42 48 49 00    4830  DISP_BHI    DC.B    '   BHI',0
0000477B= 20 20 20 4D 4F 56 ...   4831  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004786= 20 20 20 4D 4F 56 ...   4832  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004791                          4833  
00004791= 20 20 20 24 00          4834  DISP_HEX     DC.B    '   $',0
00004796= 20 20 20 44 00          4835  DISP_D  DC.B    '   D',0
0000479B= 20 20 20 41 00          4836  DISP_A  DC.B    '   A',0
000047A0= 20 20 20 28 00          4837  DISP_OP  DC.B    '   (',0
000047A5= 29 00                   4838  DISP_CP  DC.B   ')',0
000047A7= 20 20 20 28 41 00       4839  DISP_AOP  DC.B    '   (A',0
000047AD                          4840  
000047AD= 20 20 20 2D 28 41 00    4841  DISP_PRE    DC.B    '   -(A',0
000047B4= 29 2B 00                4842  DISP_POST   DC.B    ')+',0
000047B7= 20 20 20 23 00          4843  DISP_LB DC.B    '   #',0
000047BC= 30 00                   4844  DISP_0  DC.B    '0',0
000047BE= 31 00                   4845  DISP_1  DC.B    '1',0
000047C0= 32 00                   4846  DISP_2  DC.B    '2',0
000047C2= 33 00                   4847  DISP_3  DC.B    '3',0
000047C4= 34 00                   4848  DISP_4  DC.B    '4',0
000047C6= 35 00                   4849  DISP_5  DC.B    '5',0
000047C8= 36 00                   4850  DISP_6  DC.B    '6',0
000047CA= 37 00                   4851  DISP_7  DC.B    '7',0
000047CC                          4852  
000047CC                          4853  *STACK INTERFACE VARIABLES*
000047CC                          4854  COUNTER         DS.W    1
000047CE                          4855  QUEUE_COUNTER   DS.W    1
000047D0                          4856  
000047D0                          4857  *EA DECODING INTERFACE VARIABLES* 
000047D0                          4858  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
000047D1                          4859  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
000047D2                          4860  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
000047D3                          4861  
000047D3                          4862  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
000047D3                          4863  * WORD + WORD = LONG
000047D3                          4864  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
000047D3                          4865  * A              + F            = AF         <= EXAMPLE
000047D3                          4866  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
000047D3                          4867  GET_DST_START_END    DS.B    1
000047D4                          4868  GET_SRC_START_END    DS.B    1
000047D5                          4869  
000047D5                          4870  *STORES THE START + END BITS HERE (FROM ABOVE)
000047D6                          4871  VAR_BYTE_START      DS.L    1
000047DA                          4872  VAR_BYTE_END        DS.L    1
000047DE                          4873  VAR_TEMP_CLEANCOPY  DS.L    1
000047E2                          4874  
000047E2                          4875  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
000047E6                          4876  
000047E6                          4877  *MORE FOR STACK USAGE*
000047E6= 2C 00                   4878  DISP_COMMA  DC.B    ',',0
000047E8= 20 20 20 00             4879  DISP_INDENT  DC.B    '   ',0
000047EC                          4880  
000047EC                          4881  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
000047EC                          4882  POINTER_WORD    DS.W       1
000047EE                          4883  
000047EE                          4884  
000047EE                          4885  
000047EE                          4886  *---------------------------------------------------------------------------*
000047EE                          4887  * Ends program
000047EE                          4888  *---------------------------------------------------------------------------*
000047EE                          4889              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            119C
ASCII2HEX           1196
ASC_ERR             11F8
ASC_LOW             11DA
ASC_NUM             11EA
ASC_SFT             11F2
ASC_UPP             11E2
CHECK0              361E
CHECK1              36A8
CHECK2              3732
CHECK3              37CC
CHECK4              386E
CHECK7              3910
CHECK_IMMEDIATE     39F0
CHECK_LONG          39A2
CHECK_WORD          395C
CLEAR_RETURN        3F26
CLEAR_STACK         3F16
COUNTER             47CC
CR                  D
DECREMENT           3F0E
DEST_CHECK0         3A4E
DEST_CHECK1         3AD8
DEST_CHECK2         3B62
DEST_CHECK3         3BFC
DEST_CHECK4         3C9E
DEST_CHECK7         3D40
DEST_CHECK_IMMEDIATE  3E20
DEST_CHECK_LONG     3DD2
DEST_CHECK_WORD     3D8C
DEST_LOOP_SHIFTING  3AB8
DEST_LOOP_SHIFTING1  3B42
DEST_LOOP_SHIFTING2  3BD4
DEST_LOOP_SHIFTING3  3C6E
DEST_LOOP_SHIFTING4  3D18
DEST_LOOP_SHIFTING7  3D78
DEST_MASKING_NEXT   3AC6
DEST_MASKING_NEXT1  3B50
DEST_MASKING_NEXT2  3BE2
DEST_MASKING_NEXT3  3C7C
DEST_MASKING_NEXT4  3D26
DEST_MASKING_NEXT7  3D86
DEST_MODE           31D6
DEST_REGISTER       34A6
DEST_REGISTER_FORMAT  47D0
DISPLAY_30_LINES    1344
DISP_0              47BC
DISP_1              47BE
DISP_2              47C0
DISP_3              47C2
DISP_4              47C4
DISP_5              47C6
DISP_6              47C8
DISP_7              47CA
DISP_A              479B
DISP_ADDA_L         46AC
DISP_ADDA_W         46A2
DISP_ADDQ_B         45A5
DISP_ADDQ_L         45B9
DISP_ADDQ_W         45AF
DISP_ADD_B          4687
DISP_ADD_L          4699
DISP_ADD_W          4690
DISP_AND_B          466C
DISP_AND_L          467E
DISP_AND_W          4675
DISP_AOP            47A7
DISP_ASL_B          46F5
DISP_ASL_L          4719
DISP_ASL_W          4707
DISP_ASR_B          46EC
DISP_ASR_L          4710
DISP_ASR_W          46FE
DISP_BEQ            4766
DISP_BHI            4774
DISP_BLT            475F
DISP_BNE            476D
DISP_BRA            4758
DISP_BTST           44F8
DISP_CMPA_L         4658
DISP_CMPA_W         464E
DISP_CMPI_B         4500
DISP_CMPI_L         4514
DISP_CMPI_W         450A
DISP_CMP_B          4633
DISP_CMP_L          4645
DISP_CMP_W          463C
DISP_COMMA          47E6
DISP_CP             47A5
DISP_D              4796
DISP_DATA           451E
DISP_DIVS           45C3
DISP_EORI_B         44DA
DISP_EORI_L         44EE
DISP_EORI_W         44E4
DISP_EOR_B          4618
DISP_EOR_L          462A
DISP_EOR_W          4621
DISP_HEX            4791
DISP_INDENT         47E8
DISP_JSR            454B
DISP_LB             47B7
DISP_LEA            4588
DISP_LSL_B          46BF
DISP_LSL_L          46E3
DISP_LSL_W          46D1
DISP_LSR_B          46B6
DISP_LSR_L          46DA
DISP_LSR_W          46C8
DISP_MOVEA_L        4786
DISP_MOVEA_W        477B
DISP_MOVEM_L        459A
DISP_MOVEM_W        458F
DISP_MOVE_B         4526
DISP_MOVE_L         453A
DISP_MOVE_W         4530
DISP_MULS_W         4662
DISP_NEG_B          4552
DISP_NEG_L          4564
DISP_NEG_W          455B
DISP_NEXT           426B
DISP_NOT_B          456D
DISP_NOT_L          457F
DISP_NOT_W          4576
DISP_OP             47A0
DISP_ORI_B          44BF
DISP_ORI_L          44D1
DISP_ORI_W          44C8
DISP_POST           47B4
DISP_PRE            47AD
DISP_ROL_B          472B
DISP_ROL_L          474F
DISP_ROL_W          473D
DISP_ROR_B          4722
DISP_ROR_L          4746
DISP_ROR_W          4734
DISP_RTS            4544
DISP_SUBA_L         460E
DISP_SUBA_W         4604
DISP_SUBI_B         45E6
DISP_SUBI_L         45FA
DISP_SUBI_W         45F0
DISP_SUB_B          45CB
DISP_SUB_L          45DD
DISP_SUB_W          45D4
D_MODE000           3278
D_MODE010           32C0
D_MODE011           3320
D_MODE100           3340
D_MODE111           3392
EA_ARITH            3170
EA_DATA             16C8
EA_GEN              31BC
EA_MOVEA            3196
EA_NOSRC            315C
ENDLINE_M           441C
END_ADDR            10E2
ERRMSG_1            4303
ERRMSG_3            4322
ERRMSG_5            4347
ERROR_1             1146
ERROR_2             1156
ERROR_3             1166
ERROR_4             1176
ERROR_5             1186
E_ADDR_HX           4418
FINMSG              42D8
GET_DST_FAILED      3E66
GET_DST_START_END   47D3
GET_DST_SUCCESS     3E6A
GET_EA_EA_DEST      3A3C
GET_EA_EA_SRC       360C
GET_SRC_FAILED      3A36
GET_SRC_START_END   47D4
GET_SRC_SUCCESS     3A3A
HEX2ASCII           11FE
HEX2ASCII2STACK     1240
HEX_CHAR            122C
HEX_CONT            1230
HEX_LOOP            1212
IMMD_B              3446
IMMD_L              3486
IMMD_W              3466
IMMEDIATE           3416
INCREMENT           3F06
INTRO               1028
IS_ODD              1284
IS_ODD_ERR          129A
JMPTABLE            1370
LF                  A
LONGMODE            33EA
LOOP_SHIFTING       3688
LOOP_SHIFTING1      3712
LOOP_SHIFTING2      37A4
LOOP_SHIFTING3      383E
LOOP_SHIFTING4      38E8
MAIN                12A0
MASKING_NEXT        3696
MASKING_NEXT1       3720
MASKING_NEXT2       37B2
MASKING_NEXT3       384C
MASKING_NEXT4       38F6
MODE000             3264
MODE001             328C
MODE010             32A0
MODE011             32E0
MODE100             3300
MODE111             3360
NEXTLINES           1352
OP0000              13D0
OP0000_BTST_B       153A
OP0000_CMPI         16F0
OP0000_CMPI_B       1766
OP0000_CMPI_L       17B6
OP0000_CMPI_W       178E
OP0000_EOR_B        15E8
OP0000_EOR_L        1618
OP0000_EOR_W        1600
OP0000_ORI_B        184A
OP0000_ORI_L        189A
OP0000_ORI_W        1872
OP0000_RETURN       162C
OP0000_RETURN_BTST  156A
OP0000_RETURN_CMPI  17DA
OP0000_RETURN_ORI   18BE
OP0001              18C0
OP0010              192E
OP0011              1A2C
OP0100              1B28
OP0101              1D7E
OP0101_ADDQ_B       1DFA
OP0101_ADDQ_B_0     1E76
OP0101_ADDQ_B_1     1E82
OP0101_ADDQ_B_2     1E8E
OP0101_ADDQ_B_3     1E9A
OP0101_ADDQ_B_4     1EA6
OP0101_ADDQ_B_5     1EB2
OP0101_ADDQ_B_6     1EBE
OP0101_ADDQ_B_7     1ECA
OP0101_ADDQ_B_8     1ED6
OP0101_ADDQ_L       1E12
OP0101_ADDQ_W       1E06
OP0101_RETURN       1E1A
OP0101_RETURN2      1EDE
OP0110              1F22
OP0111              1FB0
OP1000              1FB4
OP1000_DIVS_DN_EA_OR_EA_DN  1FC2
OP1000_DIVS_RETURN  20A6
OP1000_EA_DN_DIVS   1FF0
OP1000_PRINT_L_DIVS  205E
OP1000_PRINT_W_DIVS  2016
OP1001              20BC
OP1001_ADD_RETURN   240A
OP1001_DETERMINE_DN_EA_OR_EA_DN  21D2
OP1001_DN_EA        220A
OP1001_EA_DN        230A
OP1001_PRINT_B      2332
OP1001_PRINT_B2     2232
OP1001_PRINT_L      23C2
OP1001_PRINT_L2     22C2
OP1001_PRINT_W      237A
OP1001_PRINT_W2     227A
OP1001_SUBA_L       20EE
OP1001_SUBA_W       2160
OP1010              2478
OP1011              247C
OP1011_CMP          24D6
OP1011_CMPA         2588
OP1011_CMPA_L       2602
OP1011_CMPA_W       25F6
OP1011_CMP_B        254A
OP1011_CMP_L        2562
OP1011_CMP_W        2556
OP1011_EOR          2628
OP1011_EOR_B        269C
OP1011_EOR_L        26B4
OP1011_EOR_W        26A8
OP1011_RETURN       26BC
OP1011_RETURN_CMP   256A
OP1011_RETURN_CMPA  260A
OP1100              277C
OP1100_AND_RETURN   2ACC
OP1100_DETERMINE_DN_EA_OR_EA_DN  2892
OP1100_DN_EA        28CC
OP1100_EA_DN        29CC
OP1100_EA_DN_MULS   27DA
OP1100_MULS_DN_EA_OR_EA_DN  27AC
OP1100_MULS_RETURN  2890
OP1100_PRINT_B      29F4
OP1100_PRINT_B2     28F4
OP1100_PRINT_L      2A84
OP1100_PRINT_L2     2984
OP1100_PRINT_L_MULS  2848
OP1100_PRINT_W      2A3C
OP1100_PRINT_W2     293C
OP1100_PRINT_W_MULS  2800
OP1101              2ACE
OP1101_ADDA_L       2B00
OP1101_ADDA_W       2B72
OP1101_ADD_RETURN   2E1C
OP1101_DETERMINE_DN_EA_OR_EA_DN  2BE4
OP1101_DN_EA        2C1C
OP1101_EA_DN        2D1C
OP1101_PRINT_B      2D44
OP1101_PRINT_B2     2C44
OP1101_PRINT_L      2DD4
OP1101_PRINT_L2     2CD4
OP1101_PRINT_W      2D8C
OP1101_PRINT_W2     2C8C
OP1110              2EAA
OP1111              3158
OP_ADDA_L           2E92
OP_ADDA_W           2E7A
OP_ADDQ_B           1EEC
OP_ADDQ_L           1F10
OP_ADDQ_W           1EFE
OP_ADD_B            2E32
OP_ADD_L            2E62
OP_ADD_W            2E4A
OP_ASL              304A
OP_ASL_B            306E
OP_ASL_L            3080
OP_ASL_W            3092
OP_ASR              2FF0
OP_ASR_B            3014
OP_ASR_L            3026
OP_ASR_W            3038
OP_ASX              2F0C
OP_BEQ              1F86
OP_BHI              1F6A
OP_BLT              1FA2
OP_BNE              1F78
OP_BRA              1F94
OP_BTST             145A
OP_BTST_IMMEDIATE   14E4
OP_CMPA_L           26EC
OP_CMPA_W           26DA
OP_CMP_B            26FE
OP_CMP_L            272E
OP_CMP_W            2716
OP_DATA             16A4
OP_DIVS             20A8
OP_EORI             156C
OP_EOR_B            2746
OP_EOR_L            276A
OP_EOR_W            2758
OP_JSR              1D50
OP_LEA              1BD6
OP_LEA_DN_EA_OR_EA_DN  1BE4
OP_LEA_RETURN       1C42
OP_LSL              2F96
OP_LSL_B            2FBA
OP_LSL_L            2FCC
OP_LSL_W            2FDE
OP_LSR              2F3C
OP_LSR_B            2F60
OP_LSR_L            2F72
OP_LSR_W            2F84
OP_LSX              2EF4
OP_MOVEA_L          19BC
OP_MOVEA_W          1AB8
OP_MOVEM_L          1BC4
OP_MOVEM_W          1BB2
OP_MOVE_B           18C6
OP_MOVE_L           1954
OP_MOVE_W           1A50
OP_MULS             279E
OP_NEG              1C44
OP_NEG_B            1C90
OP_NEG_L            1CA8
OP_NEG_PRINT_EA     1CB4
OP_NEG_W            1C9C
OP_NOT              1CCA
OP_NOT_B            1D16
OP_NOT_L            1D2E
OP_NOT_PRINT_EA     1D3A
OP_NOT_W            1D22
OP_ORI              17DC
OP_PRINT_L_LEA      1C02
OP_ROL              30FE
OP_ROL_B            3122
OP_ROL_L            3134
OP_ROL_W            3146
OP_ROR              30A4
OP_ROR_B            30C8
OP_ROR_L            30DA
OP_ROR_W            30EC
OP_ROX              2F24
OP_RTS              1D64
OP_SUBA_L           2466
OP_SUBA_W           2454
OP_SUBI             164E
OP_SUBI_B           166E
OP_SUBI_L           1692
OP_SUBI_W           1680
OP_SUB_B            240C
OP_SUB_L            243C
OP_SUB_W            2424
OUTPUT_PROCESSED_DATA  1324
POINTER_WORD        47EC
POP_FRONT           3EC0
POP_FRONT_RETURN    3EFA
POP_RETURN          3EBE
POP_SHIFT_LOOP      3EDC
POP_STACK           3EB2
PRINT_QUEUE         3E86
PRINT_QUEUE_HELPER  3E92
PRINT_QUEUE_RETURN  3EA8
PRINT_STACK         3E6C
PRINT_STACK_HELPER  3E78
PRINT_STACK_RETURN  3E84
PROGLP              100A
PROMPT_END          423E
PROMPT_START        420F
PUSH_STACK          3EAA
QUEUE_COUNTER       47CE
REG_0               355A
REG_1               3568
REG_2               3576
REG_3               3584
REG_4               3592
REG_5               35A0
REG_6               35AE
REG_7               35BC
REPEAT              35CA
REPEATMSG           4295
RETURN              11FC
SRC_LOOP_SHIFTING   3948
SRC_MASKING_NEXT    3956
SRC_MODE            321A
SRC_REGISTER        3502
SRC_REGISTER_FORMAT  47D1
STACK               7000
STACK_HEX_CHAR      126E
STACK_HEX_CONT      1272
STACK_HEX_LOOP      1254
START               1004
START_ADDR          1090
S_ADDR_HX           4414
TEMP_REGISTER_FORMAT  47D2
TERMINATE           3F28
TESTING             1036
TMPINPUT            441F
TMPOUTPUT           446F
VAR_BYTE_END        47DA
VAR_BYTE_START      47D6
VAR_LONG_ADDRESS_MODE_CHECK  47E2
VAR_TEMP_CLEANCOPY  47DE
VR_E_ADDR           43C4
VR_S_ADDR           4374
WELCOME             3F3A
WORDMODE            33BE
