00001004 Starting Address
Assembler used: EASy68K Editor/Assembler v5.12.29
Created On: 12/10/2014 9:16:23 PM

00000000                             1  *---------------------------------------------------------------------------*
00000000                             2  * Title      : 68K Disassembler
00000000                             3  * Written by : Team Circle
00000000                             4  * Date       : 12/05/14
00000000                             5  * Description: Scans a section of memory and converts its
00000000                             6  *              contents to a listing of valid assembly 
00000000                             7  *              language instructions
00000000                             8  *---------------------------------------------------------------------------*
00000000                             9  
00000000                            10  *---------------------------------------------------------------------------*
00000000                            11  * System Equates                                                 
00000000                            12  *---------------------------------------------------------------------------*
00000000  =0000000D                 13  CR          EQU     $0D                     * ASCII for Carriage Return
00000000  =0000000A                 14  LF          EQU     $0A                     * ASCII for Line Feed 
00000000  =00007000                 15  STACK       EQU     $7000                   * Initial Stack Pointer                         
00000000                            16              
00000000                            17  *---------------------------------------------------------------------------*
00000000                            18  * Reserved Registers
00000000                            19  *---------------------------------------------------------------------------*  
00000000                            20  * D0 - I/O
00000000                            21  * D1 - Temporary storage of processing data
00000000                            22  * D3 - [PUSH_STACK]
00000000                            23  * D4 - Opcode size (0 - byte; 1- word; 2-long)
00000000                            24  * D5 - Processing data
00000000                            25  * D6 - Loop counter to print 30 lines
00000000                            26  * D7 - Error flag
00000000                            27  * A2 - [STACK POINTER]
00000000                            28  * A5 - Processing address in hex
00000000                            29  
00000000                            30  *---------------------------------------------------------------------------*
00000000                            31  * Start and loop program
00000000                            32  *---------------------------------------------------------------------------*  
00001000                            33              ORG     $1000
00001000  4FF8 7000                 34              LEA     STACK,SP
00001004                            35  START:            
00001004  4EB9 00001028             36              JSR     INTRO                 
0000100A  4EB9 0000104A             37  PROGLP      JSR     START_ADDR
00001010  4EB9 0000109C             38              JSR     END_ADDR
00001016  43F9 000047B6             39              LEA     ENDLINE_M,A1           * Add a new line
0000101C  103C 000E                 40              MOVE.B  #14, D0                  * Display A1
00001020  4E4F                      41              TRAP    #15
00001022                            42              
00001022  4EF9 000012C2             43              JMP     MAIN
00001028                            44              
00001028                            45  *---------------------------------------------------------------------------*
00001028                            46  * INTRO: Display the introduction of the program
00001028                            47  *---------------------------------------------------------------------------*
00001028  43F9 000042D4             48  INTRO       LEA     WELCOME,A1              * Load PROMPT_START
0000102E  103C 000E                 49              MOVE.B  #14,D0                  * Display A1
00001032  4E4F                      50              TRAP    #15
00001034  4E75                      51              RTS
00001036                            52  TESTING     
00001036  EA40                      53              ASR.W   #5,D0
00001038  E0D1                      54              ASR.W   (A1)
0000103A  E0DA                      55              ASR.W   (A2)+
0000103C  E0E3                      56              ASR.W   -(A3)
0000103E  E0F8 1234                 57              ASR.W   $1234
00001042  E0F9 12345678             58              ASR.W   $12345678 
00001048                            59  
00001048  4E75                      60              RTS
0000104A                            61  *---------------------------------------------------------------------------*
0000104A                            62  * START_ADDR: Compute the starting address
0000104A                            63  *---------------------------------------------------------------------------*
0000104A                            64  START_ADDR
0000104A                            65              * Output
0000104A  43F9 000045A9             66              LEA     PROMPT_START,A1         * Load PROMPT_START 
00001050  103C 000E                 67              MOVE.B  #14,D0                  * Display PROMPT_START
00001054  4E4F                      68              TRAP    #15
00001056                            69      
00001056                            70              * Input
00001056  43F9 0000470E             71              LEA     VR_S_ADDR,A1            * Load VR_S_ADDR
0000105C  103C 0002                 72              MOVE.B  #2,D0                   * Ask user for input
00001060  4E4F                      73              TRAP    #15
00001062                            74              
00001062                            75              * Error Checking (length)
00001062  0C01 0000                 76              CMPI.B  #0, D1                  * Check if input length <= 0
00001066  6F00 0098                 77              BLE     ERROR_1
0000106A  0C01 0008                 78              CMPI.B  #8, D1                  * Check if input length > 8
0000106E  6E00 0090                 79              BGT     ERROR_1
00001072                            80              
00001072                            81              * Conversion & Storage
00001072  4EB9 00001150             82              JSR     ASCII2HEX               * Jump to ASCII2HEX
00001078  0C07 0001                 83              CMPI.B  #1, D7                  * Check for error
0000107C  6700 0082                 84              BEQ     ERROR_1                 
00001080  23C1 000047AE             85              MOVE.L  D1, S_ADDR_HX           * Move the result to S_ADDR_HX 
00001086                            86              
00001086                            87              * Error Checking (Odd)
00001086  43F9 000047AE             88              LEA     S_ADDR_HX, A1           * Load 'S_ADDR_HX' for odd error
0000108C  4EB9 000012A6             89              JSR     IS_ODD                  * Check if the input address is odd
00001092  0C07 0001                 90              CMPI.B  #1, D7                  * Check for error
00001096  6700 0088                 91              BEQ     ERROR_3
0000109A                            92              
0000109A                            93              * Return
0000109A  4E75                      94              RTS     
0000109C                            95  *---------------------------------------------------------------------------*
0000109C                            96  * END_ADDR: Compute the ending address
0000109C                            97  *---------------------------------------------------------------------------*
0000109C                            98  END_ADDR
0000109C                            99              * Output
0000109C  43F9 000045D8            100              LEA     PROMPT_END,A1           * Load PROMPT_END
000010A2  103C 000E                101              MOVE.B  #14,D0                  * Display PROMPT_END
000010A6  4E4F                     102              TRAP    #15
000010A8                           103  
000010A8                           104              * Input
000010A8  43F9 0000475E            105              LEA     VR_E_ADDR,A1            * Load VR_E_ADDR
000010AE  103C 0002                106              MOVE.B  #2,D0                   * Ask user for input
000010B2  4E4F                     107              TRAP    #15
000010B4                           108              
000010B4                           109              * Error Checking (length)
000010B4  0C01 0000                110              CMPI.B  #0, D1                  * Check if input length <= 0
000010B8  6F00 0056                111              BLE     ERROR_2
000010BC  0C01 0008                112              CMPI.B  #8, D1                  * Check if input length > 8
000010C0  6E00 004E                113              BGT     ERROR_2
000010C4                           114              
000010C4                           115              * Conversion & Storage
000010C4  4EB9 00001150            116              JSR     ASCII2HEX               * Jump to ASCII2HEX
000010CA  0C07 0001                117              CMPI.B  #1, D7                  * Check for error
000010CE  6700 0040                118              BEQ     ERROR_2
000010D2  23C1 000047B2            119              MOVE.L  D1, E_ADDR_HX           * Move the result to E_ADDR_HX
000010D8                           120              
000010D8                           121              * Error Checking (start > end case)
000010D8  2439 000047AE            122              MOVE.L  S_ADDR_HX, D2           * Move the starting address to D2
000010DE  B282                     123              CMP.L   D2, D1                  * Compare starting and ending address
000010E0  6300 005E                124              BLS     ERROR_5                 * Go to ERROR_5 if ending < starting
000010E4                           125              
000010E4                           126              * Error Checking (Odd case)
000010E4  43F9 000047B2            127              LEA     E_ADDR_HX, A1           * Move the ending address
000010EA  4EB9 000012A6            128              JSR     IS_ODD                  * Go to IS_ODD for odd address checking
000010F0  0C07 0001                129              CMPI.B  #1, D7                  * Check for an error flag
000010F4  6700 003A                130              BEQ     ERROR_4
000010F8                           131              
000010F8                           132              * Inputs are valid
000010F8  2A79 000047AE            133              MOVE.L  S_ADDR_HX, A5           * Store the valid input in A5
000010FE                           134              
000010FE  4E75                     135              RTS
00001100                           136              
00001100                           137  *---------------------------------------------------------------------------*
00001100                           138  * ERROR_1: Address error (Invalid starting address)
00001100                           139  *---------------------------------------------------------------------------*
00001100                           140  ERROR_1
00001100  43F9 0000469D            141              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001106  103C 000E                142              MOVE.B  #14, D0                 * Display ERRMSG_1
0000110A  4E4F                     143              TRAP    #15
0000110C  4EF8 104A                144              JMP     START_ADDR              * Jump to START_ADDR
00001110                           145      
00001110                           146  *---------------------------------------------------------------------------*
00001110                           147  * ERROR_2: Address error (Invalid ending address)
00001110                           148  *---------------------------------------------------------------------------*
00001110                           149  ERROR_2
00001110  43F9 0000469D            150              LEA     ERRMSG_1, A1            * Load ERRMSG_1
00001116  103C 000E                151              MOVE.B  #14, D0                 * Display ERRMSG_1
0000111A  4E4F                     152              TRAP    #15
0000111C  4EF8 109C                153              JMP     END_ADDR                * Jump to END_ADDR
00001120                           154  
00001120                           155  *---------------------------------------------------------------------------*
00001120                           156  * ERROR_3: Address error (Odd starting address)
00001120                           157  *---------------------------------------------------------------------------*
00001120                           158  ERROR_3
00001120  43F9 000046BC            159              LEA     ERRMSG_3, A1
00001126  103C 000E                160              MOVE.B  #14, D0
0000112A  4E4F                     161              TRAP    #15
0000112C  4EF8 104A                162              JMP     START_ADDR
00001130                           163     
00001130                           164  *---------------------------------------------------------------------------*
00001130                           165  * ERROR_4: Address error (Odd ending address)
00001130                           166  *---------------------------------------------------------------------------*         
00001130                           167  ERROR_4
00001130  43F9 000046BC            168              LEA     ERRMSG_3, A1
00001136  103C 000E                169              MOVE.B  #14, D0
0000113A  4E4F                     170              TRAP    #15
0000113C  4EF8 109C                171              JMP     END_ADDR
00001140                           172            
00001140                           173  *---------------------------------------------------------------------------*
00001140                           174  * ERROR_3: Address error (Ending address is less than starting address)
00001140                           175  *---------------------------------------------------------------------------*
00001140                           176  ERROR_5
00001140  43F9 000046E1            177              LEA     ERRMSG_5, A1
00001146  103C 000E                178              MOVE.B  #14, D0
0000114A  4E4F                     179              TRAP    #15
0000114C  4EF8 109C                180              JMP     END_ADDR
00001150                           181    
00001150                           182  *---------------------------------------------------------------------------*
00001150                           183  * ASCII2HEX: Convert ASCii to Hexadecimal
00001150                           184  * Reserved registers: A1 = Source, D1 = Destination, D2 = Byte, D7 = Error
00001150                           185  *---------------------------------------------------------------------------*
00001150  4281                     186  ASCII2HEX   CLR.L   D1                      * Clear the destination 
00001152  4287                     187              CLR.L   D7                      * Set the error flag to 0
00001154  4282                     188              CLR.L   D2                      * Clear D2 for temp storage
00001156                           189              
00001156  1419                     190  ASC2HXLP    MOVE.B  (A1)+, D2               * Read a byte to D2
00001158  0C02 0000                191              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
0000115C  6700 0058                192              BEQ     RETURN                  * If it's NULL, go to return
00001160  0C02 0066                193              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
00001164  6E00 004C                194              BGT     ASC_ERR                 * ASCII > f (invalid input) 
00001168  0C02 0061                195              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
0000116C  6C00 0026                196              BGE     ASC_LOW                 * ASCII >= a (valid input)
00001170  0C02 0046                197              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
00001174  6E00 003C                198              BGT     ASC_ERR                 * ASCII > F (invalid input)
00001178  0C02 0041                199              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
0000117C  6C00 001E                200              BGE     ASC_UPP                 * ASCII >= A (valid input)
00001180  0C02 0039                201              CMPI.B  #57, D2                 * Decimal value of 9 is 57
00001184  6E00 002C                202              BGT     ASC_ERR                 * ASCII > 9 (invalid input)
00001188  0C02 0030                203              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
0000118C  6C00 0016                204              BGE     ASC_NUM                 * ASCII >= 0 (valid input)
00001190  6000 0020                205              BRA     ASC_ERR                 * Invalid input
00001194                           206  
00001194  0442 0057                207  ASC_LOW     SUBI    #87, D2                 * Convert the ASCII input to Hex
00001198  6000 0012                208              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
0000119C                           209              
0000119C  0442 0037                210  ASC_UPP     SUBI    #55, D2                 * Convert the ASCII input to Hex
000011A0  6000 000A                211              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011A4                           212              
000011A4  0442 0030                213  ASC_NUM     SUBI    #48, D2                 * Convert the ASCII input to Hex
000011A8  6000 0002                214              BRA     ASC_SFT                 * Go to ASC_SFT to shift the bits
000011AC                           215              
000011AC  E981                     216  ASC_SFT     ASL.L   #4, D1                  * Shift the dest to left by 4 bits
000011AE  D202                     217              ADD.B   D2, D1                  * Add the converted input to D1
000011B0  60A4                     218              BRA     ASC2HXLP                * Loop
000011B2                           219  
000011B2  1E3C 0001                220  ASC_ERR     MOVE.B  #1, D7                  * Set the error flag to 1            
000011B6  4E75                     221  RETURN      RTS     
000011B8                           222  
000011B8                           223  *---------------------------------------------------------------------------*
000011B8                           224  * ASCII2HEX: Convert ASCii to Hexadecimal
000011B8                           225  * Reserved registers: A1 = Source, D3 = Destination, D2 = Byte, D7 = Error
000011B8                           226  *---------------------------------------------------------------------------*
000011B8                           227  ASCII2HEX2STACK
000011B8  4283                     228              CLR.L   D3                      * Clear the destination 
000011BA  4287                     229              CLR.L   D7                      * Set the error flag to 0
000011BC  4282                     230              CLR.L   D2                      * Clear D2 for temp storage
000011BE                           231              
000011BE                           232  ASC2HXLP2STACK
000011BE  1419                     233              MOVE.B  (A1)+, D2               * Read a byte to D2
000011C0  0C02 0000                234              CMPI.B  #0, D2                  * Check for NULL (indicates the end of source)
000011C4  6700 0058                235              BEQ     RETURN2STACK                  * If it's NULL, go to return
000011C8  0C02 0066                236              CMPI.B  #102, D2                * Decimal ASCII value of f is 102
000011CC  6E00 004C                237              BGT     ASC_ERR2STACK                 * ASCII > f (invalid input) 
000011D0  0C02 0061                238              CMPI.B  #97, D2                 * Decimal ASCII value of a is 97
000011D4  6C00 0026                239              BGE     ASC_LOW2STACK                 * ASCII >= a (valid input)
000011D8  0C02 0046                240              CMPI.B  #70, D2                 * Decimal ASCII value of F is 70
000011DC  6E00 003C                241              BGT     ASC_ERR2STACK                 * ASCII > F (invalid input)
000011E0  0C02 0041                242              CMPI.B  #65, D2                 * Decimal ASCII value of A is 65
000011E4  6C00 001E                243              BGE     ASC_UPP2STACK                 * ASCII >= A (valid input)
000011E8  0C02 0039                244              CMPI.B  #57, D2                 * Decimal value of 9 is 57
000011EC  6E00 002C                245              BGT     ASC_ERR2STACK                 * ASCII > 9 (invalid input)
000011F0  0C02 0030                246              CMPI.B  #48, D2                 * Decimal ASCII value of 0 is 48
000011F4  6C00 0016                247              BGE     ASC_NUM2STACK                 * ASCII >= 0 (valid input)
000011F8  6000 0020                248              BRA     ASC_ERR2STACK                 * Invalid input
000011FC                           249  
000011FC                           250  ASC_LOW2STACK
000011FC  0442 0057                251              SUBI    #87, D2                 * Convert the ASCII input to Hex
00001200  6000 0012                252              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
00001204                           253              
00001204                           254  ASC_UPP2STACK
00001204  0442 0037                255              SUBI    #55, D2                 * Convert the ASCII input to Hex
00001208  6000 000A                256              BRA     ASC_SFT2STACK                 * Go to ASC_SFT to shift the bits
0000120C                           257              
0000120C                           258  ASC_NUM2STACK
0000120C  0442 0030                259              SUBI    #48, D2                 * Convert the ASCII input to Hex
00001210  6000 0002                260              BRA     ASC_SFT2STACK                * Go to ASC_SFT to shift the bits
00001214                           261              
00001214                           262  ASC_SFT2STACK
00001214  E983                     263              ASL.L   #4, D3                  * Shift the dest to left by 4 bits
00001216  D602                     264              ADD.B   D2, D3                  * Add the converted input to D1
00001218  60A4                     265              BRA     ASC2HXLP2STACK                * Loop
0000121A                           266  
0000121A                           267  ASC_ERR2STACK
0000121A  1E3C 0001                268              MOVE.B  #1, D7                  * Set the error flag to 1            
0000121E                           269  RETURN2STACK
0000121E  4E75                     270              RTS  
00001220                           271  *---------------------------------------------------------------------------*
00001220                           272  * HEX2ASCII: Convert Hexadecimal to ASCii 
00001220                           273  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001220                           274  *---------------------------------------------------------------------------*
00001220  0C02 0008                275  HEX2ASCII   CMPI.B  #8, D2                  * Check to see if the size is long
00001224  6700 000E                276              BEQ     HEX_LOOP
00001228  4841                     277              SWAP    D1
0000122A  0C02 0002                278              CMPI.B  #2,D2
0000122E  6600 0004                279              BNE     HEX_LOOP
00001232  E189                     280              LSL.L   #8,D1
00001234                           281             
00001234  E999                     282  HEX_LOOP    ROL.L   #4, D1                  * Roll D1 to left
00001236  2601                     283              MOVE.L  D1, D3                  * Move D1 to D3
00001238  0283 0000000F            284              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
0000123E  0C03 0009                285              CMPI.B  #9, D3                  * Compare te digit
00001242  6E00 000A                286              BGT     HEX_CHAR              
00001246  0603 0030                287              ADDI.B  #48,D3                  * Add 48 for numerical output
0000124A  6000 0006                288              BRA     HEX_CONT
0000124E                           289              
0000124E  0603 0037                290  HEX_CHAR    ADDI.B  #55,D3                  * Add 55 for character output
00001252                           291  
00001252  12C3                     292  HEX_CONT    MOVE.B  D3, (A1)+               * Place into A1
00001254  5342                     293              SUBI    #1, D2                  * Decrement the size
00001256  0C02 0000                294              CMPI.B  #0, D2                  * Check if D2 is 0
0000125A  66D8                     295              BNE     HEX_LOOP                * Loop
0000125C  12BC 0000                296              MOVE.B  #$0,(A1)                * Null terminator
00001260  4E75                     297              RTS
00001262                           298  *---------------------------------------------------------------------------*
00001262                           299  * HEX2ASCII2STACK: Convert Hexadecimal to ASCii 
00001262                           300  * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte, PUSHES FROM D3 INTO STACK
00001262                           301  *---------------------------------------------------------------------------*
00001262                           302  HEX2ASCII2STACK
00001262  0C02 0008                303              CMPI.B  #8, D2                  * Check to see if the size is long
00001266  6700 000E                304              BEQ     STACK_HEX_LOOP
0000126A  4841                     305              SWAP    D1
0000126C  0C02 0002                306              CMPI.B  #2,D2
00001270  6600 0004                307              BNE     STACK_HEX_LOOP
00001274  E189                     308              LSL.L   #8,D1
00001276                           309             
00001276                           310  STACK_HEX_LOOP    
00001276  E999                     311              ROL.L   #4, D1                  * Roll D1 to left
00001278  2601                     312              MOVE.L  D1, D3                  * Move D1 to D3
0000127A  0283 0000000F            313              ANDI.L  #$F,D3                  * Retrieve the right most 4 bits
00001280  0C03 0009                314              CMPI.B  #9, D3                  * Compare te digit
00001284  6E00 000A                315              BGT     STACK_HEX_CHAR              
00001288  0603 0030                316              ADDI.B  #48,D3                  * Add 48 for numerical output
0000128C  6000 0006                317              BRA     STACK_HEX_CONT
00001290                           318              
00001290                           319  STACK_HEX_CHAR    
00001290  0603 0037                320              ADDI.B  #55,D3                  * Add 55 for character output
00001294                           321  
00001294                           322  STACK_HEX_CONT    
00001294  6100 2F4A                323              BSR     PUSH_STACK              *PLACE INTO STACK
00001298  5342                     324              SUBI    #1, D2                  * Decrement the size
0000129A  0C02 0000                325              CMPI.B  #0, D2                  * Check if D2 is 0
0000129E  66D6                     326              BNE     STACK_HEX_LOOP                * Loop
000012A0  12BC 0000                327              MOVE.B  #$0,(A1)                * Null terminator
000012A4  4E75                     328              RTS
000012A6                           329  
000012A6                           330  
000012A6                           331  *---------------------------------------------------------------------------*
000012A6                           332  * IS_ODD: Check whether the source address is odd
000012A6                           333  * Reserved registers: A1 = Source, D1 = Result, D7 = error flag
000012A6                           334  *---------------------------------------------------------------------------*
000012A6  4281                     335  IS_ODD      CLR.L   D1                      * Clear the result
000012A8  4287                     336              CLR.L   D7                      * Set the error flag to 0
000012AA  2211                     337              MOVE.L  (A1),D1                * Temp store the checking address to D1
000012AC  82FC 0002                338              DIVU    #2, D1                  * Divide the result by 2
000012B0  4841                     339              SWAP    D1                      * Swap remainder with quotient
000012B2  0C01 0001                340              CMPI.B  #1, D1                  * Check for error
000012B6  6700 0004                341              BEQ     IS_ODD_ERR
000012BA  4E75                     342              RTS
000012BC                           343              
000012BC  1E3C 0001                344  IS_ODD_ERR  MOVE.B  #1, D7
000012C0  4E75                     345              RTS
000012C2                           346  
000012C2                           347  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*
000012C2                           348  * MAINDEBUG                    
000012C2                           349  * A2: STACK POINTER                                                      MAIN                                                                        MAIN
000012C2                           350  * A5: Processing address
000012C2                           351  *
000012C2                           352  * D3: USED FOR PUSHING INTO STACK
000012C2                           353  *     To push into stack => MOVE.W #DATA,D3 
000012C2                           354  *                           BSR    PUSH_STACK
000012C2                           355  *     To print stack     => BSR    PRINT_STACK 
000012C2                           356  *     To clear stack     => BSR    CLEAR_STACK
000012C2                           357  *---------------------------------------------------------------------------**---------------------------------------------------------------------------**---------------------------------------------------------------------------*  
000012C2                           358  MAIN        
000012C2                           359              *initialize stack pointer
000012C2  33FC 0000 00004B66       360              MOVE.W  #0,COUNTER
000012CA  347C 7000                361              MOVEA.W #STACK,A2
000012CE  163C 0020                362              MOVE.B  #' ',D3
000012D2  6100 2F0C                363              BSR     PUSH_STACK
000012D6  6100 2F08                364              BSR     PUSH_STACK
000012DA  6100 2F04                365              BSR     PUSH_STACK
000012DE                           366              
000012DE                           367              * clear registers for temp storage
000012DE  4280                     368              CLR.L   D0                   
000012E0  4281                     369              CLR.L   D1                   
000012E2  227C 00000000            370              MOVEA.L #0, A1                
000012E8                           371              
000012E8  220D                     372              MOVE.L  A5,D1                   * check to see if the address is fully read
000012EA  23CD 000047AE            373              MOVE.L  A5,S_ADDR_HX
000012F0  B2B9 000047B2            374              CMP.L   E_ADDR_HX,D1
000012F6  6C00 2608                375              BGE     REPEAT                  * go to repeat for user action
000012FA                           376  
000012FA  43F9 00004809            377              LEA     TMPOUTPUT,A1            * allocate storage to hold output
00001300  143C 0008                378              MOVE.B  #8,D2                   * set the output size
00001304  4EB8 1220                379              JSR     HEX2ASCII               
00001308  43F9 00004809            380              LEA     TMPOUTPUT,A1
0000130E  103C 000E                381              MOVE.B  #14,D0
00001312  4E4F                     382              TRAP    #15
00001314                           383              
00001314  4285                     384              CLR.L    D5                      * clear the processing data
00001316  3A1D                     385              MOVE.W  (A5)+,D5                 * copy the currently processing data in A5 over to D5
00001318                           386                                               * advance the current instruction pointer to the next
00001318                           387                                               * instruction in memory
00001318                           388  *----------------------------------------*
00001318                           389  * Registers          
00001318                           390  * [D1] - COPY OF D5
00001318                           391  * [D5] - DATA TO BE PROCESSED
00001318                           392  * [D6] - COUNTER FOR LINES PROCESSED
00001318                           393  *
00001318                           394  * [D4]      - ERROR FLAG BEFORE PRINTING
00001318                           395  * [STACK]   - PRINTS PROCESS DATA
00001318                           396  * [COUNTER] - KEEPS TRACK OF STACK INCREMENT
00001318                           397  *
00001318                           398  * [A1] - USED FOR JUMPING/PRINTING
00001318                           399  *
00001318                           400  *----------------------------------------*
00001318                           401  
00001318                           402              
00001318                           403              *Processing the first 4 most significant bits 
00001318  2205                     404              MOVE.L  D5,D1                    * copy the current processing data to D1
0000131A  143C 000C                405              MOVE.B  #12,D2                   * shift to right by 12 bits
0000131E  E469                     406              LSR.W   D2,D1                    * [D2] Temporarily used D2 for shifting bits
00001320  C2FC 0006                407              MULU    #6,D1                    * form offset
00001324  43F9 00001392            408              LEA     JMPTABLE,A1              * index into table
0000132A  4EB1 1000                409              JSR     0(A1,D1)                 * jump indirect with index
0000132E                           410              
0000132E                           411              *SECURED EA*
0000132E  B83C 0001                412              CMP.B   #1,D4                    * ERROR FLAG CHECK [ERROR WHEN D4 == 1]
00001332  6600 0012                413              BNE     OUTPUT_PROCESSED_DATA    * PRINTS PROCESSED OP-CODE & EA
00001336  6100 041A                414              BSR     OP_DATA                  * PRINT ERROR MESSAGE "DATA"
0000133A  6100 2F10                415              BSR     CLEAR_STACK              * CLEARS THE STACK 
0000133E  183C 0000                416              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001342  6000 0022                417              BRA     DISPLAY_30_LINES         * GO TO LAST STEP
00001346                           418             
00001346                           419  OUTPUT_PROCESSED_DATA       
00001346  163C 000D                420              MOVE.B  #$D,D3                  *carriage return
0000134A  6100 2E94                421              BSR     PUSH_STACK
0000134E  163C 000A                422              MOVE.B  #$A,D3                  *new line feed
00001352  6100 2E8C                423              BSR     PUSH_STACK
00001356  163C 0000                424              MOVE.B  #$0,D3                  *null
0000135A  6100 2E84                425              BSR     PUSH_STACK
0000135E                           426       
0000135E  6100 2E5C                427              BSR     PRINT_QUEUE
00001362  183C 0000                428              MOVE.B  #0,D4                    * RESETS [D4] ERROR FLAG
00001366                           429  DISPLAY_30_LINES
00001366                           430              * display 30 lines per page
00001366  5206                     431              ADDI.B  #1,D6
00001368  0C06 001E                432              CMPI.B  #30,D6
0000136C  6C00 0006                433              BGE     NEXTLINES
00001370  6000 FF50                434              BRA     MAIN
00001374                           435            
00001374                           436  *---------------------------------------------------------------------------*
00001374                           437  * NEXTLINES: receive input from user to print the next 30 lines
00001374                           438  *---------------------------------------------------------------------------*  
00001374  4206                     439  NEXTLINES   CLR.B   D6
00001376  43F9 00004605            440              LEA     DISP_NEXT,A1
0000137C  103C 000E                441              MOVE.B  #14,D0
00001380  4E4F                     442              TRAP    #15
00001382  43F9 000047B9            443              LEA     TMPINPUT,A1
00001388  103C 0002                444              MOVE.B  #2,D0
0000138C  4E4F                     445              TRAP    #15
0000138E  4EF8 12C2                446              JMP     MAIN
00001392                           447    
00001392                           448  *---------------------------------------------------------------------------*
00001392                           449  * JMPTABLE: OP code jump/branch table used to decode and display opcodes
00001392                           450  *---------------------------------------------------------------------------*  
00001392  4EF9 000013F2            451  JMPTABLE    JMP     OP0000  * CMPI/ORI/BTST/EORI/SUBI                       *FINISHED - 
00001398  4EF9 0000196E            452              JMP     OP0001  * MOVE.B                                        *FINISHED - 
0000139E  4EF9 000019DC            453              JMP     OP0010  * MOVE.L/MOVEA.L                                *FINISHED - 
000013A4  4EF9 00001ADA            454              JMP     OP0011  * MOVE.W/MOVEA.W                                *FINISHED - 
000013AA  4EF9 00001BD6            455              JMP     OP0100  * MOVEM/LEA/NEG/NOT/JSR/RTS                     *FINISHED - 
000013B0  4EF9 00001E2C            456              JMP     OP0101  * ADDQ                                          *FINISHED - 
000013B6  4EF9 00001FD0            457              JMP     OP0110  * BRA/Bcc (BEQ/BNE/BLT/BHI)                     *FINISHED - 
000013BC  4EF9 000020D6            458              JMP     OP0111  * MOVEQ (unassigned)                            *FINISHED - NEVER ASSIGNED
000013C2  4EF9 000020DA            459              JMP     OP1000  * DIVS                                          *FINISHED - 
000013C8  4EF9 000021E2            460              JMP     OP1001  * SUB/SUBA                                      *FINISHED - 
000013CE  4EF9 0000259E            461              JMP     OP1010  * Unassigned                                    *FINISHED - NEVER ASSIGNED
000013D4  4EF9 000025A2            462              JMP     OP1011  * CMP/EOR/CMPA                                  *FINISHED - 
000013DA  4EF9 000028A2            463              JMP     OP1100  * MULS/AND                                      *FINISHED - 
000013E0  4EF9 00002BF4            464              JMP     OP1101  * ADD/ADDA                                      *FINISHED - 
000013E6  4EF9 00002FD0            465              JMP     OP1110  * LSR/LSL/ASR/ASL/ROL/ROR                       *FINISHED - LSR/LSL
000013EC  4EF9 0000348E            466              JMP     OP1111  * Special/Reserved
000013F2                           467              
000013F2                           468  *---------------------------------------------------------------------------*
000013F2                           469  * OP0000: decode CMPI/ORI/BTST/SUBI/EORI
000013F2                           470  *---------------------------------------------------------------------------*           
000013F2                           471  OP0000                                                                                  
000013F2  4281                     472              CLR.L   D1          * to temporarily store the address to process
000013F4  4280                     473              CLR.L   D0  
000013F6  4284                     474              CLR.L   D4                 
000013F8  227C 00000000            475              MOVEA.L #0, A1                
000013FE                           476              * Check for ORI (0000 0000 xx (size) xxx (EA mode) xxx(EA reg)
000013FE                           477              * Check if bit 11,10,9,8 are 0000)
000013FE  2205                     478              MOVE.L  D5,D1
00001400  0281 00000F00            479              ANDI.L  #$0F00,D1
00001406  0C81 00000000            480              CMPI.L  #$0000,D1   * if they are 0000, it is ORI
0000140C  6700 047C                481              BEQ     OP_ORI
00001410                           482  
00001410                           483              * check for CMPI (0000 1100 xx (size) xxx (EA mode) xxx (EA reg)
00001410                           484              * check if bit 11,10,9,8 are 1100
00001410  4281                     485              CLR.L   D1
00001412  2205                     486              MOVE.L  D5,D1
00001414  0281 00000F00            487              ANDI.L  #$0F00,D1
0000141A  0C81 00000C00            488              CMPI.L  #$0C00,D1
00001420  6700 037C                489              BEQ     OP0000_CMPI
00001424                           490              
00001424                           491              * check for SUBI
00001424  4281                     492              CLR.L   D1
00001426  2205                     493              MOVE.L  D5,D1
00001428  0281 00000F00            494              ANDI.L  #$0F00,D1
0000142E  0C81 00000400            495              CMPI.L  #$0400,D1
00001434  6700 023A                496              BEQ     OP_SUBI
00001438                           497              
00001438                           498              * check for EORI
00001438  4281                     499              CLR.L   D1
0000143A  2205                     500              MOVE.L  D5,D1
0000143C  0281 00000F00            501              ANDI.L  #$0F00,D1
00001442  0C81 00000A00            502              CMPI.L  #$0A00,D1
00001448  6700 0144                503              BEQ     OP_EORI
0000144C                           504              
0000144C                           505              * check for BTST
0000144C  4281                     506              CLR.L   D1
0000144E  2205                     507              MOVE.L  D5,D1
00001450  E099                     508              ROR.L   #8,D1
00001452  0281 00000001            509              ANDI.L  #$1,D1
00001458  0C01 0001                510              CMPI.B  #$1,D1
0000145C  6700 001E                511              BEQ     OP_BTST
00001460  4281                     512              CLR.L   D1
00001462  2205                     513              MOVE.L  D5,D1
00001464  EC99                     514              ROR.L   #6,D1
00001466  0281 000003FF            515              ANDI.L  #$03FF,D1
0000146C  0C81 00000020            516              CMPI.L  #%000100000,D1
00001472  6700 0008                517              BEQ     OP_BTST
00001476                           518  
00001476                           519  
00001476                           520              * OP0000 series other than ORI/CMPI/BTST/EORI
00001476  4EF9 00001752            521              JMP     OP_DATA
0000147C                           522              
0000147C                           523  *---------------------------------------------------------------------------*
0000147C                           524  * OP_BTST: display BTST
0000147C                           525  *---------------------------------------------------------------------------* 
0000147C                           526  OP_BTST       
0000147C                           527              *FIGURE OUT IF it is : Dn,<ea> or #<data>,<ea>
0000147C                           528              *bits #8 indicates which
0000147C                           529              *0 - #immediate format
0000147C                           530              *1 - Dn format
0000147C  4281                     531              CLR.L   D1
0000147E  2205                     532              MOVE.L  D5,D1
00001480  E099                     533              ROR.L   #8,D1
00001482  0281 00000001            534              ANDI.L  #1,D1
00001488  0C01 0001                535              CMPI.B  #1,D1
0000148C  6600 0078                536              BNE     OP_BTST_IMMEDIATE
00001490                           537  
00001490                           538             
00001490                           539             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001490  13FC 0000 00004B6A       540             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001498  13FC 0002 00004B6B       541             MOVE.B   #$02,SRC_REGISTER_FORMAT
000014A0                           542             
000014A0                           543             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000014A0  13FC 00B9 00004B6D       544             MOVE.B   #$B9,GET_DST_START_END
000014A8  13FC 0020 00004B6E       545             MOVE.B   #$20,GET_SRC_START_END
000014B0                           546             
000014B0  0285 0000FE3F            547             ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000014B6  0685 00000000            548             ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
000014BC                           549              
000014BC                           550              *CLEAR D3
000014BC  4283                     551              CLR.L   D3
000014BE                           552              *LOAD STACK WITH THIS OPMODE
000014BE  6100 2D20                553              BSR     PUSH_STACK
000014C2  163C 0042                554              MOVE.B  #'B',D3
000014C6  6100 2D18                555              BSR     PUSH_STACK
000014CA  163C 0054                556              MOVE.B  #'T',D3
000014CE  6100 2D10                557              BSR     PUSH_STACK
000014D2  163C 0053                558              MOVE.B  #'S',D3
000014D6  6100 2D08                559              BSR     PUSH_STACK
000014DA  163C 0054                560              MOVE.B  #'T',D3
000014DE  6100 2D00                561              BSR     PUSH_STACK
000014E2  163C 002E                562              MOVE.B  #'.',D3
000014E6  6100 2CF8                563              BSR     PUSH_STACK
000014EA  163C 0042                564              MOVE.B  #'B',D3
000014EE  6100 2CF0                565              BSR     PUSH_STACK
000014F2                           566              
000014F2  6100 287E                567              BSR     GET_EA_EA_DEST
000014F6  163C 002C                568              MOVE.B  #',',D3
000014FA  6100 2CE4                569              BSR     PUSH_STACK
000014FE  6100 2442                570              BSR     GET_EA_EA_SRC
00001502                           571              
00001502  6000 0088                572              BRA     OP0000_RETURN_BTST
00001506                           573              
00001506                           574              
00001506                           575              *MOVE **** OR **** CMPI
00001506                           576              
00001506                           577  OP_BTST_IMMEDIATE              
00001506                           578   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001506  13FC 0000 00004B6A       579             MOVE.B   #$00,DEST_REGISTER_FORMAT
0000150E  13FC 0082 00004B6B       580             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001516                           581             
00001516                           582             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001516  13FC 00B9 00004B6D       583             MOVE.B   #$B9,GET_DST_START_END
0000151E  13FC 0020 00004B6E       584             MOVE.B   #$20,GET_SRC_START_END
00001526                           585             
00001526                           586              *CLEAR D3
00001526  4283                     587              CLR.L   D3
00001528                           588              *LOAD STACK WITH THIS OPMODE
00001528  6100 2CB6                589              BSR     PUSH_STACK
0000152C  163C 0042                590              MOVE.B  #'B',D3
00001530  6100 2CAE                591              BSR     PUSH_STACK
00001534  163C 0054                592              MOVE.B  #'T',D3
00001538  6100 2CA6                593              BSR     PUSH_STACK
0000153C  163C 0053                594              MOVE.B  #'S',D3
00001540  6100 2C9E                595              BSR     PUSH_STACK
00001544  163C 0054                596              MOVE.B  #'T',D3
00001548  6100 2C96                597              BSR     PUSH_STACK
0000154C  163C 002E                598              MOVE.B  #'.',D3
00001550  6100 2C8E                599              BSR     PUSH_STACK
00001554  163C 0042                600              MOVE.B  #'B',D3
00001558  6100 2C86                601              BSR     PUSH_STACK
0000155C                           602  
0000155C                           603  OP0000_BTST_B
0000155C                           604              *GET DATA FROM ADDQ AND PRINT #0-8
0000155C                           605              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000155C  0285 0000F03F            606              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001562  0685 000001C0            607              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001568                           608  
00001568                           609              *GRAB #IMMEDIATE DATA AS WORD SIZE
00001568                           610             * Reserved registers: A1 = Destination, D1 = Source, D2 = Size, D7 = Byte
00001568                           611             * MOVE.W    (A5)+,D1
00001568                           612             * MOVE.B  #' ',D3
00001568                           613             * BSR     PUSH_STACK
00001568                           614             * MOVE.B  #'#',D3
00001568                           615             * BSR     PUSH_STACK
00001568                           616             * BSR     HEX2ASCII2STACK
00001568                           617             * BSR     PUSH_STACK
00001568                           618              
00001568  163C 0020                619              MOVE.B  #' ',D3
0000156C  6100 2C72                620              BSR     PUSH_STACK
00001570  163C 0023                621              MOVE.B  #'#',D3
00001574  6100 2C6A                622              BSR     PUSH_STACK
00001578  6100 27F8                623              BSR     GET_EA_EA_DEST
0000157C  163C 002C                624              MOVE.B  #',',D3
00001580  6100 2C5E                625              BSR     PUSH_STACK
00001584  6100 23BC                626              BSR     GET_EA_EA_SRC
00001588  6000 0002                627              BRA     OP0000_RETURN_BTST
0000158C                           628  OP0000_RETURN_BTST
0000158C                           629              
0000158C  4E75                     630              RTS
0000158E                           631  
0000158E                           632  
0000158E                           633  *---------------------------------------------------------------------------*
0000158E                           634  * OP_EORI: decode and display EORI
0000158E                           635  *---------------------------------------------------------------------------* 
0000158E                           636  OP_EORI
0000158E                           637                         
0000158E                           638  
0000158E                           639   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000158E  13FC 0000 00004B6A       640             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001596  13FC 0080 00004B6B       641             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000159E                           642             
0000159E                           643             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000159E  13FC 00B9 00004B6D       644             MOVE.B   #$B9,GET_DST_START_END
000015A6  13FC 0020 00004B6E       645             MOVE.B   #$20,GET_SRC_START_END
000015AE                           646             
000015AE                           647              *CLEAR D3
000015AE  4283                     648              CLR.L   D3
000015B0                           649              *LOAD STACK WITH THIS OPMODE
000015B0  6100 2C2E                650              BSR     PUSH_STACK
000015B4  163C 0045                651              MOVE.B  #'E',D3
000015B8  6100 2C26                652              BSR     PUSH_STACK
000015BC  163C 004F                653              MOVE.B  #'O',D3
000015C0  6100 2C1E                654              BSR     PUSH_STACK
000015C4  163C 0052                655              MOVE.B  #'R',D3
000015C8  6100 2C16                656              BSR     PUSH_STACK
000015CC  163C 0049                657              MOVE.B  #'I',D3
000015D0  6100 2C0E                658              BSR     PUSH_STACK
000015D4  163C 002E                659              MOVE.B  #'.',D3
000015D8  6100 2C06                660              BSR     PUSH_STACK
000015DC                           661              
000015DC                           662              *FIGURE OUT SIZE*
000015DC                           663              *00 = BYTE
000015DC                           664              *01 = WORD
000015DC                           665              *10 = LONG
000015DC                           666              * BITS 7&6
000015DC                           667              
000015DC                           668              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000015DC  2205                     669              MOVE.L  D5,D1
000015DE  EC99                     670              ROR.L   #6,D1
000015E0  0281 00000003            671              ANDI.L  #$03,D1
000015E6  0C01 0000                672              CMPI.B  #%00,D1
000015EA  6700 001E                673              BEQ     OP0000_EOR_B
000015EE  0281 00000003            674              ANDI.L  #$03,D1
000015F4  0C01 0001                675              CMPI.B  #%01,D1
000015F8  6700 0028                676              BEQ     OP0000_EOR_W
000015FC  0281 00000003            677              ANDI.L  #$03,D1
00001602  0C01 0002                678              CMPI.B  #%10,D1
00001606  6700 0032                679              BEQ     OP0000_EOR_L
0000160A                           680            
0000160A                           681  OP0000_EOR_B
0000160A                           682              
0000160A  163C 0042                683              MOVE.B  #'B',D3
0000160E  6100 2BD0                684              BSR     PUSH_STACK
00001612                           685              
00001612                           686              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001612  0285 0000F03F            687              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001618  0685 000001C0            688              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000161E                           689  
0000161E                           690              
0000161E  6000 002E                691              BRA     OP0000_RETURN_EOR
00001622                           692  OP0000_EOR_W
00001622                           693              
00001622  163C 0057                694              MOVE.B  #'W',D3
00001626  6100 2BB8                695              BSR     PUSH_STACK
0000162A                           696              
0000162A                           697              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000162A  0285 0000F03F            698              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001630  0685 000001C0            699              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001636                           700  
00001636                           701              
00001636  6000 0016                702              BRA     OP0000_RETURN_EOR
0000163A                           703  OP0000_EOR_L
0000163A                           704              
0000163A  163C 004C                705              MOVE.B  #'L',D3
0000163E  6100 2BA0                706              BSR     PUSH_STACK
00001642                           707              
00001642                           708              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001642  0285 0000FE3F            709              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001648  0685 000009C0            710              ADDI.L  #%0000100111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
0000164E                           711  
0000164E                           712  
0000164E                           713  OP0000_RETURN_EOR       
0000164E  163C 0020                714              MOVE.B  #' ',D3
00001652  6100 2B8C                715              BSR     PUSH_STACK
00001656  163C 0023                716              MOVE.B  #'#',D3
0000165A  6100 2B84                717              BSR     PUSH_STACK
0000165E  6100 2712                718              BSR     GET_EA_EA_DEST
00001662  163C 002C                719              MOVE.B  #',',D3
00001666  6100 2B78                720              BSR     PUSH_STACK
0000166A  6100 22D6                721              BSR     GET_EA_EA_SRC
0000166E                           722              
0000166E  4E75                     723              RTS
00001670                           724  
00001670                           725  *---------------------------------------------------------------------------*
00001670                           726  * OP_SUBI: decode SUBI.B/.W/.L
00001670                           727  *---------------------------------------------------------------------------* 
00001670                           728  OP_SUBI
00001670                           729             
00001670                           730   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001670  13FC 0000 00004B6A       731             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001678  13FC 0080 00004B6B       732             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001680                           733             
00001680                           734             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001680  13FC 00B9 00004B6D       735             MOVE.B   #$B9,GET_DST_START_END
00001688  13FC 0020 00004B6E       736             MOVE.B   #$20,GET_SRC_START_END
00001690                           737             
00001690                           738              *CLEAR D3
00001690  4283                     739              CLR.L   D3
00001692                           740              *LOAD STACK WITH THIS OPMODE
00001692  6100 2B4C                741              BSR     PUSH_STACK
00001696  163C 0053                742              MOVE.B  #'S',D3
0000169A  6100 2B44                743              BSR     PUSH_STACK
0000169E  163C 0055                744              MOVE.B  #'U',D3
000016A2  6100 2B3C                745              BSR     PUSH_STACK
000016A6  163C 0042                746              MOVE.B  #'B',D3
000016AA  6100 2B34                747              BSR     PUSH_STACK
000016AE  163C 0049                748              MOVE.B  #'I',D3
000016B2  6100 2B2C                749              BSR     PUSH_STACK
000016B6  163C 002E                750              MOVE.B  #'.',D3
000016BA  6100 2B24                751              BSR     PUSH_STACK
000016BE                           752              
000016BE                           753              *FIGURE OUT SIZE*
000016BE                           754              *00 = BYTE
000016BE                           755              *01 = WORD
000016BE                           756              *10 = LONG
000016BE                           757              * BITS 7&6
000016BE                           758              
000016BE                           759              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000016BE  2205                     760              MOVE.L  D5,D1
000016C0  EC99                     761              ROR.L   #6,D1
000016C2  0281 00000003            762              ANDI.L  #$03,D1
000016C8  0C01 0000                763              CMPI.B  #%00,D1
000016CC  6700 001E                764              BEQ     OP0000_SUB_B
000016D0  0281 00000003            765              ANDI.L  #$03,D1
000016D6  0C01 0001                766              CMPI.B  #%01,D1
000016DA  6700 0028                767              BEQ     OP0000_SUB_W
000016DE  0281 00000003            768              ANDI.L  #$03,D1
000016E4  0C01 0002                769              CMPI.B  #%10,D1
000016E8  6700 0032                770              BEQ     OP0000_SUB_L
000016EC                           771            
000016EC                           772  OP0000_SUB_B
000016EC                           773              
000016EC  163C 0042                774              MOVE.B  #'B',D3
000016F0  6100 2AEE                775              BSR     PUSH_STACK
000016F4                           776              
000016F4                           777              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000016F4  0285 0000F03F            778              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000016FA  0685 000001C0            779              ADDI.L  #%000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001700                           780  
00001700                           781              
00001700  6000 002E                782              BRA     OP0000_RETURN_SUBI
00001704                           783  OP0000_SUB_W
00001704                           784              
00001704  163C 0057                785              MOVE.B  #'W',D3
00001708  6100 2AD6                786              BSR     PUSH_STACK
0000170C                           787              
0000170C                           788              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000170C  0285 0000F03F            789              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001712  0685 000001C0            790              ADDI.L  #%0000000111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001718                           791  
00001718                           792              
00001718  6000 0016                793              BRA     OP0000_RETURN_SUBI
0000171C                           794  OP0000_SUB_L
0000171C                           795              
0000171C  163C 004C                796              MOVE.B  #'L',D3
00001720  6100 2ABE                797              BSR     PUSH_STACK
00001724                           798              
00001724                           799              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001724  0285 0000F03F            800              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000172A  0685 000003C0            801              ADDI.L  #%0000001111000000,D5   *Add.B  BITS 8-6 TO INDICATE A "(XXX).W" Register (000) 
00001730                           802                      
00001730                           803  OP0000_RETURN_SUBI            
00001730  163C 0020                804              MOVE.B  #' ',D3
00001734  6100 2AAA                805              BSR     PUSH_STACK
00001738  163C 0023                806              MOVE.B  #'#',D3
0000173C  6100 2AA2                807              BSR     PUSH_STACK
00001740  6100 2630                808              BSR     GET_EA_EA_DEST
00001744  163C 002C                809              MOVE.B  #',',D3
00001748  6100 2A96                810              BSR     PUSH_STACK
0000174C  6100 21F4                811              BSR     GET_EA_EA_SRC
00001750                           812              
00001750  4E75                     813              RTS
00001752                           814  
00001752                           815              
00001752                           816  *---------------------------------------------------------------------------*
00001752                           817  * OP_DATA : unidentified opcode
00001752                           818  *---------------------------------------------------------------------------* 
00001752                           819  OP_DATA
00001752  4280                     820              CLR.L   D0                   
00001754  4281                     821              CLR.L   D1     
00001756  4284                     822              CLR.L   D4                    
00001758  227C 00000000            823              MOVEA.L #0, A1             
0000175E  4287                     824              CLR.L   D7
00001760  1E3C 0001                825              MOVE.B  #1,D7                   * error flag is true
00001764                           826              
00001764  43F9 000048B8            827              LEA     DISP_DATA,A1
0000176A  103C 000E                828              MOVE.B  #14,D0
0000176E  4E4F                     829              TRAP    #15
00001770                           830              
00001770  4EF9 00001776            831              JMP     EA_DATA
00001776                           832             
00001776                           833             
00001776                           834  *---------------------------------------------------------------------------*
00001776                           835  * EA_DATA
00001776                           836  *---------------------------------------------------------------------------*       
00001776  43F9 00004809            837  EA_DATA     LEA     TMPOUTPUT,A1    * load the temporarily stored output address
0000177C  2205                     838              MOVE.L  D5,D1           * transfer the processing data to D1
0000177E  7404                     839              MOVE.L  #4,D2           * set to word size
00001780  4EB8 1220                840              JSR     HEX2ASCII       * prepare output in ascii
00001784  43F9 00004B2B            841              LEA     DISP_HEX,A1     * display $ symbol
0000178A  103C 000E                842              MOVE.B  #14,D0      
0000178E  4E4F                     843              TRAP    #15
00001790  43F9 00004809            844              LEA     TMPOUTPUT,A1    * display with a new line
00001796  103C 000D                845              MOVE.B  #13,D0
0000179A  4E4F                     846              TRAP    #15
0000179C                           847  
0000179C  4E75                     848              RTS
0000179E                           849              
0000179E                           850  *---------------------------------------------------------------------------*
0000179E                           851  * OP_CMPI : decode CMPI and its size
0000179E                           852  *---------------------------------------------------------------------------*          
0000179E                           853  OP0000_CMPI
0000179E                           854  
0000179E                           855              
0000179E                           856   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000179E  13FC 0000 00004B6A       857             MOVE.B   #$00,DEST_REGISTER_FORMAT
000017A6  13FC 0082 00004B6B       858             MOVE.B   #$82,SRC_REGISTER_FORMAT
000017AE                           859             
000017AE                           860             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000017AE  13FC 00B9 00004B6D       861             MOVE.B   #$B9,GET_DST_START_END
000017B6  13FC 0020 00004B6E       862             MOVE.B   #$20,GET_SRC_START_END
000017BE                           863             
000017BE                           864              *CLEAR D3
000017BE  4283                     865              CLR.L   D3
000017C0                           866              *LOAD STACK WITH THIS OPMODE
000017C0  6100 2A1E                867              BSR     PUSH_STACK
000017C4  163C 0043                868              MOVE.B  #'C',D3
000017C8  6100 2A16                869              BSR     PUSH_STACK
000017CC  163C 004D                870              MOVE.B  #'M',D3
000017D0  6100 2A0E                871              BSR     PUSH_STACK
000017D4  163C 0050                872              MOVE.B  #'P',D3
000017D8  6100 2A06                873              BSR     PUSH_STACK
000017DC  163C 0049                874              MOVE.B  #'I',D3
000017E0  6100 29FE                875              BSR     PUSH_STACK
000017E4  163C 002E                876              MOVE.B  #'.',D3
000017E8  6100 29F6                877              BSR     PUSH_STACK
000017EC                           878              
000017EC                           879              *FIGURE OUT SIZE*
000017EC                           880              *00 = BYTE
000017EC                           881              *01 = WORD
000017EC                           882              *10 = LONG
000017EC                           883              * BITS 7&6
000017EC                           884              
000017EC                           885              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000017EC  2205                     886              MOVE.L  D5,D1
000017EE  EC99                     887              ROR.L   #6,D1
000017F0  0281 00000003            888              ANDI.L  #$03,D1
000017F6  0C01 0000                889              CMPI.B  #%00,D1
000017FA  6700 0018                890              BEQ     OP0000_CMPI_B
000017FE  0C01 0001                891              CMPI.B  #%01,D1
00001802  6700 0038                892              BEQ     OP0000_CMPI_W
00001806  0281 00000003            893              ANDI.L  #$03,D1
0000180C  0C01 0002                894              CMPI.B  #%10,D1
00001810  6700 0052                895              BEQ     OP0000_CMPI_L
00001814                           896  
00001814                           897  OP0000_CMPI_B
00001814  163C 0042                898              MOVE.B  #'B',D3
00001818  6100 29C6                899              BSR     PUSH_STACK
0000181C                           900  *GET DATA FROM ADDQ AND PRINT #0-8
0000181C                           901              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000181C  0285 0000F03F            902              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001822  0685 000001C0            903              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001828  6100 2548                904              BSR     GET_EA_EA_DEST
0000182C  163C 002C                905              MOVE.B  #',',D3
00001830  6100 29AE                906              BSR     PUSH_STACK
00001834  6100 210C                907              BSR     GET_EA_EA_SRC
00001838  6000 004E                908              BRA     OP0000_RETURN_CMPI
0000183C                           909  
0000183C                           910  OP0000_CMPI_W
0000183C  163C 0057                911              MOVE.B  #'W',D3
00001840  6100 299E                912              BSR     PUSH_STACK
00001844                           913  *GET DATA FROM ADDQ AND PRINT #0-8
00001844                           914              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001844  0285 0000F03F            915              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000184A  0685 000001C0            916              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001850  6100 2520                917              BSR     GET_EA_EA_DEST
00001854  163C 002C                918              MOVE.B  #',',D3
00001858  6100 2986                919              BSR     PUSH_STACK
0000185C  6100 20E4                920              BSR     GET_EA_EA_SRC
00001860  6000 0026                921              BRA     OP0000_RETURN_CMPI
00001864                           922  
00001864                           923  OP0000_CMPI_L
00001864  163C 004C                924              MOVE.B  #'L',D3
00001868  6100 2976                925              BSR     PUSH_STACK
0000186C                           926              *GET DATA FROM ADDQ AND PRINT #0-8
0000186C                           927              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000186C  0285 0000F03F            928              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001872  0685 000003C0            929              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001878  6100 24F8                930              BSR     GET_EA_EA_DEST
0000187C  163C 002C                931              MOVE.B  #',',D3
00001880  6100 295E                932              BSR     PUSH_STACK
00001884  6100 20BC                933              BSR     GET_EA_EA_SRC
00001888                           934              
00001888                           935  OP0000_RETURN_CMPI
00001888                           936  
00001888                           937  
00001888                           938              
00001888  4E75                     939              RTS
0000188A                           940   
0000188A                           941  *---------------------------------------------------------------------------*
0000188A                           942  * OP_ORI : decode ORI and its size
0000188A                           943  *---------------------------------------------------------------------------* 
0000188A                           944  OP_ORI      
0000188A                           945           
0000188A                           946   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000188A  13FC 0000 00004B6A       947             MOVE.B   #$00,DEST_REGISTER_FORMAT
00001892  13FC 0082 00004B6B       948             MOVE.B   #$82,SRC_REGISTER_FORMAT
0000189A                           949             
0000189A                           950             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000189A  13FC 00B9 00004B6D       951             MOVE.B   #$B9,GET_DST_START_END
000018A2  13FC 0020 00004B6E       952             MOVE.B   #$20,GET_SRC_START_END
000018AA                           953             
000018AA                           954              *CLEAR D3
000018AA  4283                     955              CLR.L   D3
000018AC                           956              *LOAD STACK WITH THIS OPMODE
000018AC  6100 2932                957              BSR     PUSH_STACK
000018B0  163C 004F                958              MOVE.B  #'O',D3
000018B4  6100 292A                959              BSR     PUSH_STACK
000018B8  163C 0052                960              MOVE.B  #'R',D3
000018BC  6100 2922                961              BSR     PUSH_STACK
000018C0  163C 0049                962              MOVE.B  #'I',D3
000018C4  6100 291A                963              BSR     PUSH_STACK
000018C8  163C 002E                964              MOVE.B  #'.',D3
000018CC  6100 2912                965              BSR     PUSH_STACK
000018D0                           966              
000018D0                           967              *FIGURE OUT SIZE*
000018D0                           968              *00 = BYTE
000018D0                           969              *01 = WORD
000018D0                           970              *10 = LONG
000018D0                           971              * BITS 7&6
000018D0                           972              
000018D0                           973              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000018D0  2205                     974              MOVE.L  D5,D1
000018D2  EC99                     975              ROR.L   #6,D1
000018D4  0281 00000003            976              ANDI.L  #$03,D1
000018DA  0C01 0000                977              CMPI.B  #%00,D1
000018DE  6700 0018                978              BEQ     OP0000_ORI_B
000018E2  0C01 0001                979              CMPI.B  #%01,D1
000018E6  6700 0038                980              BEQ     OP0000_ORI_W
000018EA  0281 00000003            981              ANDI.L  #$03,D1
000018F0  0C01 0002                982              CMPI.B  #%10,D1
000018F4  6700 0052                983              BEQ     OP0000_ORI_L
000018F8                           984  
000018F8                           985  OP0000_ORI_B
000018F8  163C 0042                986              MOVE.B  #'B',D3
000018FC  6100 28E2                987              BSR     PUSH_STACK
00001900                           988  *GET DATA FROM ADDQ AND PRINT #0-8
00001900                           989              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001900  0285 0000F03F            990              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001906  0685 000001C0            991              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000190C  6100 2464                992              BSR     GET_EA_EA_DEST
00001910  163C 002C                993              MOVE.B  #',',D3
00001914  6100 28CA                994              BSR     PUSH_STACK
00001918  6100 2028                995              BSR     GET_EA_EA_SRC
0000191C  6000 004E                996              BRA     OP0000_RETURN_ORI
00001920                           997  
00001920                           998  OP0000_ORI_W
00001920  163C 0057                999              MOVE.B  #'W',D3
00001924  6100 28BA               1000              BSR     PUSH_STACK
00001928                          1001  *GET DATA FROM ADDQ AND PRINT #0-8
00001928                          1002              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001928  0285 0000F03F           1003              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000192E  0685 000001C0           1004              ADDI.L  #$01C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
00001934  6100 243C               1005              BSR     GET_EA_EA_DEST
00001938  163C 002C               1006              MOVE.B  #',',D3
0000193C  6100 28A2               1007              BSR     PUSH_STACK
00001940  6100 2000               1008              BSR     GET_EA_EA_SRC
00001944  6000 0026               1009              BRA     OP0000_RETURN_ORI
00001948                          1010  
00001948                          1011  OP0000_ORI_L
00001948  163C 004C               1012              MOVE.B  #'L',D3
0000194C  6100 2892               1013              BSR     PUSH_STACK
00001950                          1014              *GET DATA FROM ADDQ AND PRINT #0-8
00001950                          1015              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001950  0285 0000F03F           1016              ANDI.L  #$F03F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001956  0685 000003C0           1017              ADDI.L  #$03C0,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000195C  6100 2414               1018              BSR     GET_EA_EA_DEST
00001960  163C 002C               1019              MOVE.B  #',',D3
00001964  6100 287A               1020              BSR     PUSH_STACK
00001968  6100 1FD8               1021              BSR     GET_EA_EA_SRC
0000196C                          1022              
0000196C                          1023  OP0000_RETURN_ORI
0000196C                          1024  
0000196C                          1025  
0000196C                          1026              
0000196C  4E75                    1027              RTS
0000196E                          1028  
0000196E                          1029          
0000196E                          1030  *---------------------------------------------------------------------------*
0000196E                          1031  * OP0001: MOVE.B
0000196E                          1032  *---------------------------------------------------------------------------*
0000196E                          1033  OP0001      
0000196E  4EF9 00001974           1034              JMP     OP_MOVE_B   * display MOVE.B
00001974                          1035              
00001974                          1036  *---------------------------------------------------------------------------*
00001974                          1037  * OP_MOVE_B: display MOVE_B and proceed to EA
00001974                          1038  *---------------------------------------------------------------------------*
00001974                          1039  OP_MOVE_B                                                                       
00001974                          1040             
00001974                          1041             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001974  13FC 0082 00004B6A      1042             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000197C  13FC 0000 00004B6B      1043             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001984                          1044             
00001984                          1045             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001984  13FC 00B9 00004B6D      1046             MOVE.B   #$B9,GET_DST_START_END
0000198C  13FC 0020 00004B6E      1047             MOVE.B   #$20,GET_SRC_START_END
00001994                          1048             
00001994                          1049              *CLEAR D3
00001994  4283                    1050              CLR.L   D3
00001996                          1051              *LOAD STACK WITH THIS OPMODE
00001996  6100 2848               1052              BSR     PUSH_STACK
0000199A  163C 004D               1053              MOVE.B  #'M',D3
0000199E  6100 2840               1054              BSR     PUSH_STACK
000019A2  163C 004F               1055              MOVE.B  #'O',D3
000019A6  6100 2838               1056              BSR     PUSH_STACK
000019AA  163C 0056               1057              MOVE.B  #'V',D3
000019AE  6100 2830               1058              BSR     PUSH_STACK
000019B2  163C 0045               1059              MOVE.B  #'E',D3
000019B6  6100 2828               1060              BSR     PUSH_STACK
000019BA  163C 002E               1061              MOVE.B  #'.',D3
000019BE  6100 2820               1062              BSR     PUSH_STACK
000019C2  163C 0042               1063              MOVE.B  #'B',D3
000019C6  6100 2818               1064              BSR     PUSH_STACK
000019CA                          1065              
000019CA  6100 1F76               1066              BSR     GET_EA_EA_SRC
000019CE  163C 002C               1067              MOVE.B  #',',D3
000019D2  6100 280C               1068              BSR     PUSH_STACK
000019D6  6100 239A               1069              BSR     GET_EA_EA_DEST
000019DA                          1070              
000019DA  4E75                    1071              RTS
000019DC                          1072              
000019DC                          1073             
000019DC                          1074  *---------------------------------------------------------------------------*
000019DC                          1075  * OP0010: decode MOVE.L/MOVEA.L
000019DC                          1076  *---------------------------------------------------------------------------*
000019DC                          1077  OP0010      
000019DC  183C 0002               1078              MOVE.B  #2,D4
000019E0  4280                    1079              CLR.L   D0                     
000019E2  4281                    1080              CLR.L   D1                      
000019E4  227C 00000000           1081              MOVEA.L #0, A1                 
000019EA                          1082              
000019EA  2205                    1083              MOVE.L  D5,D1
000019EC  EA99                    1084              ROR.L   #5,D1
000019EE  0281 0000000E           1085              ANDI.L  #$E,D1
000019F4  0C01 0002               1086              CMPI.B  #2,D1
000019F8  6700 0070               1087              BEQ     OP_MOVEA_L
000019FC                          1088  
000019FC  4EF9 00001A02           1089              JMP     OP_MOVE_L
00001A02                          1090             
00001A02                          1091  
00001A02                          1092  *---------------------------------------------------------------------------*
00001A02                          1093  * OP_MOVE_L: display MOVE_L and proceed to EA
00001A02                          1094  *---------------------------------------------------------------------------*
00001A02                          1095  OP_MOVE_L   
00001A02                          1096             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A02  13FC 0082 00004B6A      1097             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001A0A  13FC 0000 00004B6B      1098             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A12                          1099             
00001A12                          1100             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A12  13FC 00B9 00004B6D      1101             MOVE.B   #$B9,GET_DST_START_END
00001A1A  13FC 0020 00004B6E      1102             MOVE.B   #$20,GET_SRC_START_END
00001A22                          1103             
00001A22                          1104              *CLEAR D3
00001A22  4283                    1105              CLR.L   D3
00001A24                          1106              *LOAD STACK WITH THIS OPMODE
00001A24  6100 27BA               1107              BSR     PUSH_STACK
00001A28  163C 004D               1108              MOVE.B  #'M',D3
00001A2C  6100 27B2               1109              BSR     PUSH_STACK
00001A30  163C 004F               1110              MOVE.B  #'O',D3
00001A34  6100 27AA               1111              BSR     PUSH_STACK
00001A38  163C 0056               1112              MOVE.B  #'V',D3
00001A3C  6100 27A2               1113              BSR     PUSH_STACK
00001A40  163C 0045               1114              MOVE.B  #'E',D3
00001A44  6100 279A               1115              BSR     PUSH_STACK
00001A48  163C 002E               1116              MOVE.B  #'.',D3
00001A4C  6100 2792               1117              BSR     PUSH_STACK
00001A50  163C 004C               1118              MOVE.B  #'L',D3
00001A54  6100 278A               1119              BSR     PUSH_STACK
00001A58                          1120              
00001A58  6100 1EE8               1121              BSR     GET_EA_EA_SRC
00001A5C  163C 002C               1122              MOVE.B  #',',D3
00001A60  6100 277E               1123              BSR     PUSH_STACK
00001A64  6100 230C               1124              BSR     GET_EA_EA_DEST
00001A68                          1125              
00001A68  4E75                    1126              RTS
00001A6A                          1127  
00001A6A                          1128  
00001A6A                          1129  *---------------------------------------------------------------------------*
00001A6A                          1130  * OP_MOVEA_L: display MOVEA_L and proceed to EA
00001A6A                          1131  *---------------------------------------------------------------------------*
00001A6A                          1132  OP_MOVEA_L 
00001A6A                          1133             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001A6A  13FC 00FD 00004B6A      1134             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001A72  13FC 0000 00004B6B      1135             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001A7A                          1136             
00001A7A                          1137             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001A7A  13FC 00B9 00004B6D      1138             MOVE.B   #$B9,GET_DST_START_END
00001A82  13FC 0020 00004B6E      1139             MOVE.B   #$20,GET_SRC_START_END
00001A8A                          1140             
00001A8A                          1141              *CLEAR D3
00001A8A  4283                    1142              CLR.L   D3
00001A8C                          1143              *LOAD STACK WITH THIS OPMODE
00001A8C  6100 2752               1144              BSR     PUSH_STACK
00001A90  163C 004D               1145              MOVE.B  #'M',D3
00001A94  6100 274A               1146              BSR     PUSH_STACK
00001A98  163C 004F               1147              MOVE.B  #'O',D3
00001A9C  6100 2742               1148              BSR     PUSH_STACK
00001AA0  163C 0056               1149              MOVE.B  #'V',D3
00001AA4  6100 273A               1150              BSR     PUSH_STACK
00001AA8  163C 0045               1151              MOVE.B  #'E',D3
00001AAC  6100 2732               1152              BSR     PUSH_STACK           
00001AB0  163C 0041               1153              MOVE.B  #'A',D3
00001AB4  6100 272A               1154              BSR     PUSH_STACK
00001AB8  163C 002E               1155              MOVE.B  #'.',D3
00001ABC  6100 2722               1156              BSR     PUSH_STACK
00001AC0  163C 004C               1157              MOVE.B  #'L',D3
00001AC4  6100 271A               1158              BSR     PUSH_STACK
00001AC8                          1159              
00001AC8  6100 1E78               1160              BSR     GET_EA_EA_SRC
00001ACC  163C 002C               1161              MOVE.B  #',',D3
00001AD0  6100 270E               1162              BSR     PUSH_STACK
00001AD4  6100 229C               1163              BSR     GET_EA_EA_DEST
00001AD8                          1164              
00001AD8  4E75                    1165              RTS
00001ADA                          1166  
00001ADA                          1167              
00001ADA                          1168  *---------------------------------------------------------------------------*
00001ADA                          1169  * OP0011: decode MOVE.W/MOVEA.W
00001ADA                          1170  *---------------------------------------------------------------------------*
00001ADA                          1171  OP0011      
00001ADA  4280                    1172              CLR.L   D0                      
00001ADC  4281                    1173              CLR.L   D1  
00001ADE  4284                    1174              CLR.L   D4                   
00001AE0  227C 00000000           1175              MOVEA.L #0, A1 
00001AE6                          1176                
00001AE6  2205                    1177              MOVE.L  D5,D1
00001AE8  EC99                    1178              ROR.L   #6,D1
00001AEA  0281 00000007           1179              ANDI.L  #$07,D1
00001AF0  0C01 0001               1180              CMPI.B  #1,D1
00001AF4  6700 0070               1181              BEQ     OP_MOVEA_W
00001AF8                          1182              
00001AF8  4EF9 00001AFE           1183              JMP     OP_MOVE_W
00001AFE                          1184            
00001AFE                          1185  *---------------------------------------------------------------------------*
00001AFE                          1186  * OP_MOVE_W: display MOVE_W and proceed to EA
00001AFE                          1187  *---------------------------------------------------------------------------*
00001AFE                          1188  OP_MOVE_W   
00001AFE                          1189             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001AFE  13FC 0082 00004B6A      1190             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001B06  13FC 0000 00004B6B      1191             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B0E                          1192             
00001B0E                          1193             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B0E  13FC 00B9 00004B6D      1194             MOVE.B   #$B9,GET_DST_START_END
00001B16  13FC 0020 00004B6E      1195             MOVE.B   #$20,GET_SRC_START_END
00001B1E                          1196             
00001B1E                          1197              *CLEAR D3
00001B1E  4283                    1198              CLR.L   D3
00001B20                          1199              *LOAD STACK WITH THIS OPMODE
00001B20  6100 26BE               1200              BSR     PUSH_STACK
00001B24  163C 004D               1201              MOVE.B  #'M',D3
00001B28  6100 26B6               1202              BSR     PUSH_STACK
00001B2C  163C 004F               1203              MOVE.B  #'O',D3
00001B30  6100 26AE               1204              BSR     PUSH_STACK
00001B34  163C 0056               1205              MOVE.B  #'V',D3
00001B38  6100 26A6               1206              BSR     PUSH_STACK
00001B3C  163C 0045               1207              MOVE.B  #'E',D3
00001B40  6100 269E               1208              BSR     PUSH_STACK
00001B44  163C 002E               1209              MOVE.B  #'.',D3
00001B48  6100 2696               1210              BSR     PUSH_STACK
00001B4C  163C 0057               1211              MOVE.B  #'W',D3
00001B50  6100 268E               1212              BSR     PUSH_STACK
00001B54                          1213              
00001B54  6100 1DEC               1214              BSR     GET_EA_EA_SRC
00001B58  163C 002C               1215              MOVE.B  #',',D3
00001B5C  6100 2682               1216              BSR     PUSH_STACK
00001B60  6100 2210               1217              BSR     GET_EA_EA_DEST
00001B64                          1218              
00001B64  4E75                    1219              RTS
00001B66                          1220  
00001B66                          1221  *---------------------------------------------------------------------------*
00001B66                          1222  * OP_MOVEA_W: display MOVEA and proceed to EA
00001B66                          1223  *---------------------------------------------------------------------------*
00001B66                          1224  OP_MOVEA_W 
00001B66                          1225             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001B66  13FC 00FD 00004B6A      1226             MOVE.B   #$FD,DEST_REGISTER_FORMAT
00001B6E  13FC 0000 00004B6B      1227             MOVE.B   #$00,SRC_REGISTER_FORMAT
00001B76                          1228             
00001B76                          1229             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001B76  13FC 00B9 00004B6D      1230             MOVE.B   #$B9,GET_DST_START_END
00001B7E  13FC 0020 00004B6E      1231             MOVE.B   #$20,GET_SRC_START_END
00001B86                          1232             
00001B86                          1233              *CLEAR D3
00001B86  4283                    1234              CLR.L   D3
00001B88                          1235              *LOAD STACK WITH THIS OPMODE
00001B88  6100 2656               1236              BSR     PUSH_STACK
00001B8C  163C 004D               1237              MOVE.B  #'M',D3
00001B90  6100 264E               1238              BSR     PUSH_STACK
00001B94  163C 004F               1239              MOVE.B  #'O',D3
00001B98  6100 2646               1240              BSR     PUSH_STACK
00001B9C  163C 0056               1241              MOVE.B  #'V',D3
00001BA0  6100 263E               1242              BSR     PUSH_STACK
00001BA4  163C 0045               1243              MOVE.B  #'E',D3
00001BA8  6100 2636               1244              BSR     PUSH_STACK           
00001BAC  163C 0041               1245              MOVE.B  #'A',D3
00001BB0  6100 262E               1246              BSR     PUSH_STACK
00001BB4  163C 002E               1247              MOVE.B  #'.',D3
00001BB8  6100 2626               1248              BSR     PUSH_STACK
00001BBC  163C 0057               1249              MOVE.B  #'W',D3
00001BC0  6100 261E               1250              BSR     PUSH_STACK
00001BC4                          1251              
00001BC4  6100 1D7C               1252              BSR     GET_EA_EA_SRC
00001BC8  163C 002C               1253              MOVE.B  #',',D3
00001BCC  6100 2612               1254              BSR     PUSH_STACK
00001BD0  6100 21A0               1255              BSR     GET_EA_EA_DEST
00001BD4                          1256            
00001BD4  4E75                    1257              RTS
00001BD6                          1258  *---------------------------------------------------------------------------*
00001BD6                          1259  * OP0100: decode MOVEM/LEA/NEG/JSR/RTS/NOT
00001BD6                          1260  *---------------------------------------------------------------------------*
00001BD6                          1261  OP0100
00001BD6  4280                    1262              CLR.L   D0                      
00001BD8  4281                    1263              CLR.L   D1  
00001BDA  4284                    1264              CLR.L   D4                      
00001BDC  227C 00000000           1265              MOVEA.L #0, A1                  
00001BE2  2205                    1266              MOVE.L  D5,D1  
00001BE4                          1267              
00001BE4                          1268              * check for RTS
00001BE4  0C41 4E75               1269              CMPI.W  #$4E75,D1   * 0100 1110 0111 0101
00001BE8  6700 0228               1270              BEQ     OP_RTS
00001BEC                          1271              
00001BEC                          1272              * check for JSR     * 0100 1110 10 xxx (ea mode) xxx (ea reg)
00001BEC  4281                    1273              CLR.L   D1 
00001BEE  2205                    1274              MOVE.L  D5,D1  
00001BF0  0241 0F00               1275              ANDI.W  #$0F00,D1
00001BF4  0C41 0E00               1276              CMPI.W  #$0E00,D1
00001BF8  6700 0204               1277              BEQ     OP_JSR
00001BFC                          1278  
00001BFC                          1279              * check for NEG     * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001BFC  4281                    1280              CLR.L   D1 
00001BFE  2205                    1281              MOVE.L  D5,D1  
00001C00  0241 0F00               1282              ANDI.W  #$0F00,D1
00001C04  0C41 0400               1283              CMPI.W  #$0400,D1
00001C08  6700 00E8               1284              BEQ     OP_NEG
00001C0C                          1285              
00001C0C                          1286              * check for NOT     * 0100 0110 xx (size) xxx (ea mode) xxx (ea reg)
00001C0C  4281                    1287              CLR.L   D1 
00001C0E  2205                    1288              MOVE.L  D5,D1  
00001C10  0241 0F00               1289              ANDI.W  #$0F00,D1
00001C14  0C41 0600               1290              CMPI.W  #$0600,D1
00001C18  6700 015E               1291              BEQ     OP_NOT
00001C1C                          1292              
00001C1C                          1293              * check for LEA     * 0100 xxx (reg) 111 xxx (ea mode) xxx (ea reg)
00001C1C  4281                    1294              CLR.L   D1 
00001C1E  2205                    1295              MOVE.L  D5,D1  
00001C20  EC99                    1296              ROR.L   #6,D1
00001C22  0281 00000007           1297              ANDI.L  #7,D1
00001C28  0C81 00000007           1298              CMPI.L  #7,D1
00001C2E  6700 0054               1299              BEQ     OP_LEA
00001C32                          1300              
00001C32                          1301              * check for MOVEM   * 0100 1 x 001 x (size) xxx (ea mode) xxx (ea reg)
00001C32  4281                    1302              CLR.L   D1 
00001C34  2205                    1303              MOVE.L  D5,D1  
00001C36  EB59                    1304              ROL.W   #5,D1
00001C38  0C01 0001               1305              CMPI.B  #1,D1
00001C3C  6600 FB14               1306              BNE     OP_DATA
00001C40  E959                    1307              ROL.W   #4,D1
00001C42  0C01 0001               1308              CMPI.B  #1,D1
00001C46  6600 FB0A               1309              BNE     OP_DATA
00001C4A  E359                    1310              ROL.W   #1,D1
00001C4C  0C01 0000               1311              CMPI.B  #0,D1
00001C50  6700 000E               1312              BEQ     OP_MOVEM_W
00001C54  0C01 0001               1313              CMPI.B  #1,D1
00001C58  6700 0018               1314              BEQ     OP_MOVEM_L
00001C5C  4EF8 1752               1315              JMP     OP_DATA
00001C60                          1316  
00001C60                          1317  *---------------------------------------------------------------------------*
00001C60                          1318  * OP_MOVEM_W: display MOVEM_W
00001C60                          1319  *---------------------------------------------------------------------------*    
00001C60                          1320  OP_MOVEM_W  
00001C60  183C 0001               1321              MOVE.B  #1,D4
00001C64  43F9 00004929           1322              LEA     DISP_MOVEM_W,A1
00001C6A  103C 000E               1323              MOVE.B  #14,D0
00001C6E  4E4F                    1324              TRAP    #15
00001C70  4E75                    1325              RTS
00001C72                          1326  
00001C72                          1327  *---------------------------------------------------------------------------*
00001C72                          1328  * OP_MOVEM_L: display MOVEM_L
00001C72                          1329  *---------------------------------------------------------------------------*
00001C72                          1330  OP_MOVEM_L  
00001C72  183C 0002               1331              MOVE.B  #2,D4
00001C76  43F9 00004934           1332              LEA     DISP_MOVEM_L,A1
00001C7C  103C 000E               1333              MOVE.B  #14,D0
00001C80  4E4F                    1334              TRAP    #15
00001C82  4E75                    1335              RTS
00001C84                          1336     
00001C84                          1337  *---------------------------------------------------------------------------*
00001C84                          1338  * OP_LEA: decode and display LEA
00001C84                          1339  *---------------------------------------------------------------------------*
00001C84                          1340  OP_LEA      
00001C84  4281                    1341               CLR.L   D1       
00001C86  4284                    1342              CLR.L   D4                   
00001C88  227C 00000000           1343              MOVEA.L #0, A1              
00001C8E  2205                    1344              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00001C90                          1345              *CLEAR D3
00001C90  4283                    1346              CLR.L   D3
00001C92                          1347  
00001C92                          1348  OP_LEA_DN_EA_OR_EA_DN 
00001C92                          1349              *LOAD STACK WITH THIS OPMODE
00001C92  6100 254C               1350              BSR     PUSH_STACK
00001C96  163C 004C               1351              MOVE.B  #'L',D3
00001C9A  6100 2544               1352              BSR     PUSH_STACK
00001C9E  163C 0045               1353              MOVE.B  #'E',D3
00001CA2  6100 253C               1354              BSR     PUSH_STACK
00001CA6  163C 0041               1355              MOVE.B  #'A',D3
00001CAA  6100 2534               1356              BSR     PUSH_STACK
00001CAE  2205                    1357              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00001CB0                          1358          
00001CB0                          1359  
00001CB0                          1360  OP_PRINT_L_LEA
00001CB0                          1361                          
00001CB0                          1362              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001CB0  13FC 0000 00004B6A      1363              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00001CB8  13FC 009B 00004B6B      1364              MOVE.B   #$9B,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00001CC0                          1365             
00001CC0                          1366              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001CC0  13FC 00B9 00004B6D      1367              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00001CC8  13FC 0020 00004B6E      1368              MOVE.B   #$20,GET_SRC_START_END
00001CD0                          1369  
00001CD0                          1370              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00001CD0  0285 0000FE3F           1371              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00001CD6  0685 00000040           1372              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00001CDC                          1373  
00001CDC  6100 1C64               1374              BSR     GET_EA_EA_SRC      *GETS <ea>
00001CE0  163C 002C               1375              MOVE.B  #',',D3
00001CE4  6100 24FA               1376              BSR     PUSH_STACK           
00001CE8  6100 2088               1377              BSR     GET_EA_EA_DEST       *GETS Dn    
00001CEC                          1378  
00001CEC                          1379              
00001CEC  6000 0002               1380              BRA     OP_LEA_RETURN
00001CF0                          1381              
00001CF0                          1382  OP_LEA_RETURN
00001CF0  4E75                    1383              RTS
00001CF2                          1384              
00001CF2                          1385  
00001CF2                          1386  
00001CF2                          1387  *---------------------------------------------------------------------------*
00001CF2                          1388  * OP_NEG: decode and display NEG 
00001CF2                          1389  *---------------------------------------------------------------------------*
00001CF2                          1390  OP_NEG      * 0100 0100 xx (size) xxx (ea mode) xxx (ea reg) 
00001CF2  4281                    1391              CLR.L   D1
00001CF4  4284                    1392              CLR.L   D4
00001CF6  2205                    1393              MOVE.L  D5,D1
00001CF8                          1394              
00001CF8                          1395              *CLEAR D3
00001CF8  4283                    1396              CLR.L   D3
00001CFA                          1397              *LOAD STACK WITH THIS OPMODE
00001CFA  6100 24E4               1398              BSR     PUSH_STACK
00001CFE  163C 004E               1399              MOVE.B  #'N',D3
00001D02  6100 24DC               1400              BSR     PUSH_STACK
00001D06  163C 0045               1401              MOVE.B  #'E',D3
00001D0A  6100 24D4               1402              BSR     PUSH_STACK
00001D0E  163C 0047               1403              MOVE.B  #'G',D3
00001D12  6100 24CC               1404              BSR     PUSH_STACK
00001D16  163C 002E               1405              MOVE.B  #'.',D3
00001D1A  6100 24C4               1406              BSR     PUSH_STACK
00001D1E                          1407              
00001D1E                          1408              
00001D1E  EC99                    1409              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001D20  0281 00000007           1410              ANDI.L  #$07,D1
00001D26                          1411              
00001D26  0C01 0000               1412              CMPI.B  #0,D1
00001D2A  6700 0012               1413              BEQ     OP_NEG_B    * size is byte
00001D2E  0C01 0001               1414              CMPI.B  #1,D1
00001D32  6700 0016               1415              BEQ     OP_NEG_W    * size is word
00001D36  0C01 0002               1416              CMPI.B  #2,D1
00001D3A  6700 001A               1417              BEQ     OP_NEG_L    * size is long
00001D3E                          1418                         
00001D3E                          1419  
00001D3E                          1420  OP_NEG_B    * size is byte   
00001D3E  163C 0042               1421              MOVE.B  #'B',D3
00001D42  6100 249C               1422              BSR     PUSH_STACK
00001D46  6000 001A               1423              BRA     OP_NEG_PRINT_EA
00001D4A                          1424  
00001D4A                          1425              
00001D4A                          1426  OP_NEG_W    * size is word
00001D4A  163C 0057               1427              MOVE.B  #'W',D3
00001D4E  6100 2490               1428              BSR     PUSH_STACK
00001D52  6000 000E               1429              BRA     OP_NEG_PRINT_EA
00001D56                          1430  
00001D56                          1431              
00001D56                          1432  OP_NEG_L    * size is long
00001D56  163C 004C               1433              MOVE.B  #'L',D3
00001D5A  6100 2484               1434              BSR     PUSH_STACK
00001D5E  6000 0002               1435              BRA     OP_NEG_PRINT_EA
00001D62                          1436  
00001D62                          1437  
00001D62                          1438  OP_NEG_PRINT_EA
00001D62                          1439   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001D62  13FC 0082 00004B6B      1440             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001D6A                          1441             
00001D6A                          1442             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001D6A  13FC 0020 00004B6E      1443             MOVE.B   #$20,GET_SRC_START_END
00001D72                          1444                         
00001D72                          1445  
00001D72  6100 1BCE               1446              BSR     GET_EA_EA_SRC
00001D76                          1447              
00001D76  4E75                    1448              RTS
00001D78                          1449  
00001D78                          1450  *---------------------------------------------------------------------------*
00001D78                          1451  * OP_NOT: decode and display NOT 
00001D78                          1452  *---------------------------------------------------------------------------*
00001D78                          1453  OP_NOT
00001D78  4281                    1454              CLR.L   D1
00001D7A  4284                    1455              CLR.L   D4
00001D7C  2205                    1456              MOVE.L  D5,D1
00001D7E                          1457              
00001D7E                          1458              *CLEAR D3
00001D7E  4283                    1459              CLR.L   D3
00001D80                          1460              *LOAD STACK WITH THIS OPMODE
00001D80  6100 245E               1461              BSR     PUSH_STACK
00001D84  163C 004E               1462              MOVE.B  #'N',D3
00001D88  6100 2456               1463              BSR     PUSH_STACK
00001D8C  163C 004F               1464              MOVE.B  #'O',D3
00001D90  6100 244E               1465              BSR     PUSH_STACK
00001D94  163C 0054               1466              MOVE.B  #'T',D3
00001D98  6100 2446               1467              BSR     PUSH_STACK
00001D9C  163C 002E               1468              MOVE.B  #'.',D3
00001DA0  6100 243E               1469              BSR     PUSH_STACK
00001DA4                          1470              
00001DA4                          1471              
00001DA4  EC99                    1472              ROR.L   #6,D1       * shift bit 7,6 to bit 1,0
00001DA6  0281 00000007           1473              ANDI.L  #$07,D1
00001DAC                          1474              
00001DAC  0C01 0000               1475              CMPI.B  #0,D1
00001DB0  6700 0012               1476              BEQ     OP_NOT_B    * size is byte
00001DB4  0C01 0001               1477              CMPI.B  #1,D1
00001DB8  6700 0016               1478              BEQ     OP_NOT_W    * size is word
00001DBC  0C01 0002               1479              CMPI.B  #2,D1
00001DC0  6700 001A               1480              BEQ     OP_NOT_L    * size is long
00001DC4                          1481                         
00001DC4                          1482  
00001DC4                          1483  OP_NOT_B    * size is byte   
00001DC4  163C 0042               1484              MOVE.B  #'B',D3
00001DC8  6100 2416               1485              BSR     PUSH_STACK
00001DCC  6000 001A               1486              BRA     OP_NOT_PRINT_EA
00001DD0                          1487  
00001DD0                          1488              
00001DD0                          1489  OP_NOT_W    * size is word
00001DD0  163C 0057               1490              MOVE.B  #'W',D3
00001DD4  6100 240A               1491              BSR     PUSH_STACK
00001DD8  6000 000E               1492              BRA     OP_NOT_PRINT_EA
00001DDC                          1493  
00001DDC                          1494              
00001DDC                          1495  OP_NOT_L    * size is long
00001DDC  163C 004C               1496              MOVE.B  #'L',D3
00001DE0  6100 23FE               1497              BSR     PUSH_STACK
00001DE4  6000 0002               1498              BRA     OP_NOT_PRINT_EA
00001DE8                          1499  
00001DE8                          1500  
00001DE8                          1501  OP_NOT_PRINT_EA
00001DE8                          1502   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001DE8  13FC 0082 00004B6B      1503             MOVE.B   #$82,SRC_REGISTER_FORMAT
00001DF0                          1504             
00001DF0                          1505             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001DF0  13FC 0020 00004B6E      1506             MOVE.B   #$20,GET_SRC_START_END
00001DF8  6100 1B48               1507              BSR     GET_EA_EA_SRC
00001DFC                          1508              
00001DFC  4E75                    1509              RTS
00001DFE                          1510  
00001DFE                          1511  
00001DFE                          1512  *---------------------------------------------------------------------------*
00001DFE                          1513  * OP_JSR: display JSR     
00001DFE                          1514  *---------------------------------------------------------------------------*
00001DFE  43F9 000048E5           1515  OP_JSR      LEA     DISP_JSR,A1
00001E04  103C 000E               1516              MOVE.B  #14,D0
00001E08  4E4F                    1517              TRAP    #15
00001E0A  4EB9 00003492           1518              JSR     EA_NOSRC
00001E10                          1519  
00001E10  4E75                    1520              RTS
00001E12                          1521  
00001E12                          1522  *---------------------------------------------------------------------------*
00001E12                          1523  * OP_RTS: display RTS     
00001E12                          1524  *---------------------------------------------------------------------------* 
00001E12                          1525  OP_RTS      
00001E12  163C 0052               1526              MOVE.B #'R',D3
00001E16  6100 23C8               1527              BSR     PUSH_STACK
00001E1A  163C 0054               1528              MOVE.B #'T',D3
00001E1E  6100 23C0               1529              BSR     PUSH_STACK
00001E22  163C 0053               1530              MOVE.B #'S',D3
00001E26  6100 23B8               1531              BSR     PUSH_STACK
00001E2A  4E75                    1532              RTS
00001E2C                          1533  
00001E2C                          1534  *---------------------------------------------------------------------------*
00001E2C                          1535  * OP0101: decode ADDQ
00001E2C                          1536  *---------------------------------------------------------------------------* 
00001E2C                          1537  OP0101      
00001E2C                          1538             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00001E2C  13FC 0082 00004B6A      1539             MOVE.B   #$82,DEST_REGISTER_FORMAT
00001E34  13FC 0080 00004B6B      1540             MOVE.B   #$80,SRC_REGISTER_FORMAT
00001E3C                          1541             
00001E3C                          1542             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00001E3C  13FC 00B9 00004B6D      1543             MOVE.B   #$B9,GET_DST_START_END
00001E44  13FC 0020 00004B6E      1544             MOVE.B   #$20,GET_SRC_START_END
00001E4C                          1545             
00001E4C                          1546              *CLEAR D3
00001E4C  4283                    1547              CLR.L   D3
00001E4E                          1548              *LOAD STACK WITH THIS OPMODE
00001E4E  6100 2390               1549              BSR     PUSH_STACK
00001E52  163C 0041               1550              MOVE.B  #'A',D3
00001E56  6100 2388               1551              BSR     PUSH_STACK
00001E5A  163C 0044               1552              MOVE.B  #'D',D3
00001E5E  6100 2380               1553              BSR     PUSH_STACK
00001E62  163C 0044               1554              MOVE.B  #'D',D3
00001E66  6100 2378               1555              BSR     PUSH_STACK
00001E6A  163C 0051               1556              MOVE.B  #'Q',D3
00001E6E  6100 2370               1557              BSR     PUSH_STACK
00001E72  163C 002E               1558              MOVE.B  #'.',D3
00001E76  6100 2368               1559              BSR     PUSH_STACK
00001E7A                          1560              
00001E7A                          1561              *FIGURE OUT SIZE*
00001E7A                          1562              *00 = BYTE
00001E7A                          1563              *01 = WORD
00001E7A                          1564              *10 = LONG
00001E7A                          1565              * BITS 7&6
00001E7A                          1566              
00001E7A                          1567              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00001E7A  2205                    1568              MOVE.L  D5,D1
00001E7C  EC99                    1569              ROR.L   #6,D1
00001E7E  0281 00000003           1570              ANDI.L  #$03,D1
00001E84  0C01 0000               1571              CMPI.B  #%00,D1
00001E88  6700 001E               1572              BEQ     OP0101_ADDQ_B
00001E8C  0281 00000003           1573              ANDI.L  #$03,D1
00001E92  0C01 0001               1574              CMPI.B  #%01,D1
00001E96  6700 001C               1575              BEQ     OP0101_ADDQ_W
00001E9A  0281 00000003           1576              ANDI.L  #$03,D1
00001EA0  0C01 0002               1577              CMPI.B  #%10,D1
00001EA4  6700 001A               1578              BEQ     OP0101_ADDQ_L
00001EA8                          1579            
00001EA8                          1580  OP0101_ADDQ_B
00001EA8                          1581              
00001EA8  163C 0042               1582              MOVE.B  #'B',D3
00001EAC  6100 2332               1583              BSR     PUSH_STACK
00001EB0  6000 0016               1584              BRA     OP0101_RETURN
00001EB4                          1585  OP0101_ADDQ_W
00001EB4                          1586              
00001EB4  163C 0057               1587              MOVE.B  #'W',D3
00001EB8  6100 2326               1588              BSR     PUSH_STACK
00001EBC  6000 000A               1589              BRA     OP0101_RETURN
00001EC0                          1590  OP0101_ADDQ_L
00001EC0                          1591              
00001EC0  163C 004C               1592              MOVE.B  #'L',D3
00001EC4  6100 231A               1593              BSR     PUSH_STACK
00001EC8                          1594  OP0101_RETURN            
00001EC8                          1595  
00001EC8                          1596              
00001EC8                          1597  *GET DATA FROM ADDQ AND PRINT #0-8
00001EC8  163C 0020               1598              MOVE.B  #' ',D3
00001ECC  6100 2312               1599              BSR     PUSH_STACK
00001ED0  163C 0023               1600              MOVE.B  #'#',D3
00001ED4  6100 230A               1601              BSR     PUSH_STACK 
00001ED8                          1602  
00001ED8                          1603                       
00001ED8                          1604              *GET DATA #   
00001ED8  2205                    1605              MOVE.L  D5,D1
00001EDA  EC99                    1606              ROR.L   #6,D1            
00001EDC  E699                    1607              ROR.L   #3,D1
00001EDE  0281 00000007           1608              ANDI.L  #$07,D1
00001EE4                          1609              
00001EE4  0C01 0000               1610              CMPI.B  #%000,D1
00001EE8  6700 009A               1611              BEQ     OP0101_ADDQ_B_8
00001EEC  0C01 0001               1612              CMPI.B  #%001,D1
00001EF0  6700 003E               1613              BEQ     OP0101_ADDQ_B_1
00001EF4  0C01 0002               1614              CMPI.B  #%010,D1
00001EF8  6700 0042               1615              BEQ     OP0101_ADDQ_B_2
00001EFC  0C01 0003               1616              CMPI.B  #%011,D1
00001F00  6700 0046               1617              BEQ     OP0101_ADDQ_B_3
00001F04  0C01 0004               1618              CMPI.B  #%100,D1
00001F08  6700 004A               1619              BEQ     OP0101_ADDQ_B_4
00001F0C  0C01 0005               1620              CMPI.B  #%101,D1
00001F10  6700 004E               1621              BEQ     OP0101_ADDQ_B_5
00001F14  0C01 0006               1622              CMPI.B  #%110,D1
00001F18  6700 0052               1623              BEQ     OP0101_ADDQ_B_6
00001F1C  0C01 0007               1624              CMPI.B  #%111,D1
00001F20  6700 0056               1625              BEQ     OP0101_ADDQ_B_7
00001F24                          1626              
00001F24                          1627  OP0101_ADDQ_B_0
00001F24  163C 0030               1628              MOVE.B  #'0',D3
00001F28  6100 22B6               1629              BSR     PUSH_STACK
00001F2C  6000 005E               1630              BRA     OP0101_RETURN2            
00001F30                          1631  OP0101_ADDQ_B_1
00001F30  163C 0031               1632              MOVE.B  #'1',D3
00001F34  6100 22AA               1633              BSR     PUSH_STACK
00001F38  6000 0052               1634              BRA     OP0101_RETURN2            
00001F3C                          1635  OP0101_ADDQ_B_2
00001F3C  163C 0032               1636              MOVE.B  #'2',D3
00001F40  6100 229E               1637              BSR     PUSH_STACK
00001F44  6000 0046               1638              BRA     OP0101_RETURN2            
00001F48                          1639  OP0101_ADDQ_B_3
00001F48  163C 0033               1640              MOVE.B  #'3',D3
00001F4C  6100 2292               1641              BSR     PUSH_STACK
00001F50  6000 003A               1642              BRA     OP0101_RETURN2            
00001F54                          1643  OP0101_ADDQ_B_4
00001F54  163C 0034               1644              MOVE.B  #'4',D3
00001F58  6100 2286               1645              BSR     PUSH_STACK
00001F5C  6000 002E               1646              BRA     OP0101_RETURN2            
00001F60                          1647  OP0101_ADDQ_B_5
00001F60  163C 0035               1648              MOVE.B  #'5',D3
00001F64  6100 227A               1649              BSR     PUSH_STACK
00001F68  6000 0022               1650              BRA     OP0101_RETURN2
00001F6C                          1651  OP0101_ADDQ_B_6
00001F6C  163C 0036               1652              MOVE.B  #'6',D3
00001F70  6100 226E               1653              BSR     PUSH_STACK
00001F74  6000 0016               1654              BRA     OP0101_RETURN2
00001F78                          1655  OP0101_ADDQ_B_7
00001F78  163C 0037               1656              MOVE.B  #'7',D3
00001F7C  6100 2262               1657              BSR     PUSH_STACK
00001F80  6000 000A               1658              BRA     OP0101_RETURN2
00001F84                          1659  
00001F84                          1660  OP0101_ADDQ_B_8
00001F84  163C 0038               1661              MOVE.B  #'8',D3
00001F88  6100 2256               1662              BSR     PUSH_STACK
00001F8C                          1663              
00001F8C                          1664  OP0101_RETURN2            
00001F8C  163C 002C               1665              MOVE.B  #',',D3
00001F90  6100 224E               1666              BSR     PUSH_STACK
00001F94  6100 19AC               1667              BSR     GET_EA_EA_SRC
00001F98                          1668              
00001F98  4E75                    1669              RTS
00001F9A                          1670  
00001F9A                          1671  
00001F9A                          1672              
00001F9A                          1673  *---------------------------------------------------------------------------*
00001F9A                          1674  * OP_ADDQ: display ADDQ
00001F9A                          1675  *---------------------------------------------------------------------------*              
00001F9A                          1676  OP_ADDQ_B    * size is byte   
00001F9A  183C 0000               1677              MOVE.B  #0,D4 
00001F9E  43F9 0000493F           1678              LEA     DISP_ADDQ_B,A1
00001FA4  103C 000E               1679              MOVE.B  #14,D0
00001FA8  4E4F                    1680              TRAP    #15
00001FAA  4E75                    1681              RTS
00001FAC                          1682              
00001FAC                          1683  OP_ADDQ_W    * size is word
00001FAC  183C 0001               1684              MOVE.B  #1,D4
00001FB0  43F9 00004949           1685              LEA     DISP_ADDQ_W,A1
00001FB6  103C 000E               1686              MOVE.B  #14,D0
00001FBA  4E4F                    1687              TRAP    #15
00001FBC  4E75                    1688              RTS
00001FBE                          1689              
00001FBE                          1690  OP_ADDQ_L    * size is long
00001FBE  183C 0002               1691              MOVE.B  #2,D4
00001FC2  43F9 00004953           1692              LEA     DISP_ADDQ_L,A1
00001FC8  103C 000E               1693              MOVE.B  #14,D0
00001FCC  4E4F                    1694              TRAP    #15
00001FCE  4E75                    1695              RTS
00001FD0                          1696  
00001FD0                          1697  *---------------------------------------------------------------------------*
00001FD0                          1698  * OP0110: decode BRA/BEQ/BNE/BLT/BHI
00001FD0                          1699  *---------------------------------------------------------------------------*              
00001FD0  4280                    1700  OP0110      CLR.L   D0                  
00001FD2  4281                    1701              CLR.L   D1   
00001FD4  4284                    1702              CLR.L   D4                 
00001FD6  227C 00000000           1703              MOVEA.L #0,A1
00001FDC  2205                    1704              MOVE.L  D5, D1                
00001FDE  0281 000000FF           1705              ANDI.L  #$00FF, D1              * Get 8-bit displacement 
00001FE4  2205                    1706              MOVE.L  D5,D1                  
00001FE6  0281 00000F00           1707              ANDI.L  #$0F00,D1
00001FEC                          1708                 
00001FEC  0C41 0000               1709              CMPI.W  #$0000,D1               * Check for BRA
00001FF0  6700 0098               1710              BEQ     OP_BRA                  
00001FF4                          1711                          
00001FF4  0C41 0D00               1712              CMPI.W  #$0D00,D1               * Check for BLT
00001FF8  6700 00B6               1713              BEQ     OP_BLT      
00001FFC                          1714  
00001FFC  0C41 0700               1715              CMPI.W  #$0700,D1               * Check for BEQ
00002000  6700 0062               1716              BEQ     OP_BEQ      
00002004                          1717  
00002004  0C41 0600               1718              CMPI.W  #$0600,D1               * Check for BNE
00002008  6700 0034               1719              BEQ     OP_BNE  
0000200C                          1720              
0000200C  0C41 0200               1721              CMPI.W  #$0200,D1               * Check for BHI
00002010  6700 0006               1722              BEQ     OP_BHI
00002014                          1723  
00002014  4EF8 1752               1724              JMP     OP_DATA
00002018                          1725              
00002018  163C 0042               1726  OP_BHI      MOVE.B  #'B',D3
0000201C  6100 21C2               1727              BSR     PUSH_STACK
00002020  163C 0048               1728              MOVE.B  #'H',D3
00002024  6100 21BA               1729              BSR     PUSH_STACK
00002028  163C 0049               1730              MOVE.B  #'I',D3
0000202C  6100 21B2               1731              BSR     PUSH_STACK
00002030  163C 0009               1732              MOVE.B  #$9,D3
00002034  6100 21AA               1733              BSR     PUSH_STACK
00002038  6100 2224               1734              BSR     GET_DISPLACEMENT_ADDRESS
0000203C  4E75                    1735              RTS
0000203E                          1736  
0000203E  163C 0042               1737  OP_BNE      MOVE.B  #'B',D3
00002042  6100 219C               1738              BSR     PUSH_STACK
00002046  163C 004E               1739              MOVE.B  #'N',D3
0000204A  6100 2194               1740              BSR     PUSH_STACK
0000204E  163C 0045               1741              MOVE.B  #'E',D3
00002052  6100 218C               1742              BSR     PUSH_STACK
00002056  163C 0009               1743              MOVE.B  #$9,D3
0000205A  6100 2184               1744              BSR     PUSH_STACK
0000205E  6100 21FE               1745              BSR     GET_DISPLACEMENT_ADDRESS
00002062  4E75                    1746              RTS
00002064                          1747  
00002064  163C 0042               1748  OP_BEQ      MOVE.B  #'B',D3
00002068  6100 2176               1749              BSR     PUSH_STACK
0000206C  163C 0045               1750              MOVE.B  #'E',D3
00002070  6100 216E               1751              BSR     PUSH_STACK
00002074  163C 0051               1752              MOVE.B  #'Q',D3
00002078  6100 2166               1753              BSR     PUSH_STACK
0000207C  163C 0009               1754              MOVE.B  #$9,D3
00002080  6100 215E               1755              BSR     PUSH_STACK
00002084  6100 21D8               1756              BSR     GET_DISPLACEMENT_ADDRESS
00002088  4E75                    1757              RTS          
0000208A                          1758                          
0000208A                          1759  OP_BRA      
0000208A  163C 0042               1760              MOVE.B  #'B',D3
0000208E  6100 2150               1761              BSR     PUSH_STACK
00002092  163C 0052               1762              MOVE.B  #'R',D3
00002096  6100 2148               1763              BSR     PUSH_STACK
0000209A  163C 0041               1764              MOVE.B  #'A',D3
0000209E  6100 2140               1765              BSR     PUSH_STACK
000020A2  163C 0009               1766              MOVE.B  #$9,D3
000020A6  6100 2138               1767              BSR     PUSH_STACK
000020AA  6100 21B2               1768              BSR     GET_DISPLACEMENT_ADDRESS
000020AE                          1769              
000020AE  4E75                    1770              RTS
000020B0                          1771              
000020B0  163C 0042               1772  OP_BLT      MOVE.B  #'B',D3
000020B4  6100 212A               1773              BSR     PUSH_STACK
000020B8  163C 004C               1774              MOVE.B  #'L',D3
000020BC  6100 2122               1775              BSR     PUSH_STACK
000020C0  163C 0054               1776              MOVE.B  #'T',D3
000020C4  6100 211A               1777              BSR     PUSH_STACK
000020C8  163C 0009               1778              MOVE.B  #$9,D3
000020CC  6100 2112               1779              BSR     PUSH_STACK
000020D0  6100 218C               1780              BSR     GET_DISPLACEMENT_ADDRESS
000020D4  4E75                    1781              RTS
000020D6                          1782     
000020D6                          1783  *---------------------------------------------------------------------------*
000020D6                          1784  * OP0111 : MOVEQ not required
000020D6                          1785  *---------------------------------------------------------------------------*           
000020D6  4EF8 1752               1786  OP0111      JMP     OP_DATA
000020DA                          1787             
000020DA                          1788  *---------------------------------------------------------------------------*
000020DA                          1789  * OP1000 : decode DIVS
000020DA                          1790  *---------------------------------------------------------------------------*           
000020DA                          1791  OP1000                           
000020DA  4281                    1792              CLR.L   D1       
000020DC  4284                    1793              CLR.L   D4                   
000020DE  227C 00000000           1794              MOVEA.L #0, A1              
000020E4  2205                    1795              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000020E6                          1796              *CLEAR D3
000020E6  4283                    1797              CLR.L   D3
000020E8                          1798  
000020E8                          1799  OP1000_DIVS_DN_EA_OR_EA_DN 
000020E8                          1800              *LOAD STACK WITH THIS OPMODE
000020E8  6100 20F6               1801              BSR     PUSH_STACK
000020EC  163C 0044               1802              MOVE.B  #'D',D3
000020F0  6100 20EE               1803              BSR     PUSH_STACK
000020F4  163C 0049               1804              MOVE.B  #'I',D3
000020F8  6100 20E6               1805              BSR     PUSH_STACK
000020FC  163C 0056               1806              MOVE.B  #'V',D3
00002100  6100 20DE               1807              BSR     PUSH_STACK
00002104  163C 0053               1808              MOVE.B  #'S',D3
00002108  6100 20D6               1809              BSR     PUSH_STACK
0000210C  163C 002E               1810              MOVE.B  #'.',D3
00002110  6100 20CE               1811              BSR     PUSH_STACK
00002114                          1812              
00002114  2205                    1813              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002116                          1814              
00002116                          1815  OP1000_EA_DN_DIVS
00002116                          1816              *BITS (7 TO 6) 
00002116                          1817              *00 = .B
00002116                          1818              *01 = .W
00002116                          1819              *10 = .L 
00002116  2205                    1820              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002118  EC99                    1821              ROR.L   #6,D1
0000211A  0281 00000003           1822              ANDI.L  #$03,D1
00002120  0C81 00000003           1823              CMPI.L  #%11,D1 *EQUALS .W
00002126  6700 0014               1824              BEQ     OP1000_PRINT_W_DIVS
0000212A  0C81 00000000           1825              CMPI.L  #%00,D1 *EQUALS .L
00002130  6700 0052               1826              BEQ     OP1000_PRINT_L_DIVS
00002134                          1827              
00002134  183C 0001               1828              MOVE.B  #1,D4               *ERROR READ
00002138  6000 0092               1829              BRA     OP1000_DIVS_RETURN
0000213C                          1830  OP1000_PRINT_W_DIVS
0000213C  163C 0057               1831              MOVE.B  #'W',D3
00002140  6100 209E               1832              BSR     PUSH_STACK
00002144                          1833  
00002144                          1834              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002144  13FC 0000 00004B6A      1835              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000214C  13FC 0000 00004B6B      1836              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002154                          1837             
00002154                          1838              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002154  13FC 00B9 00004B6D      1839              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000215C  13FC 0020 00004B6E      1840              MOVE.B   #$20,GET_SRC_START_END
00002164                          1841  
00002164                          1842             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002164  0285 0000FE3F           1843              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000216A  0685 00000000           1844              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002170                          1845  
00002170                          1846              
00002170  6100 17D0               1847              BSR     GET_EA_EA_SRC      *GETS <ea>
00002174  163C 002C               1848              MOVE.B  #',',D3
00002178  6100 2066               1849              BSR     PUSH_STACK
0000217C  6100 1BF4               1850              BSR     GET_EA_EA_DEST       *GETS Dn    
00002180                          1851              
00002180  6000 004A               1852              BRA     OP1000_DIVS_RETURN
00002184                          1853  OP1000_PRINT_L_DIVS
00002184  163C 004C               1854              MOVE.B  #'L',D3
00002188  6100 2056               1855              BSR     PUSH_STACK
0000218C                          1856              
0000218C                          1857              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000218C  13FC 0000 00004B6A      1858              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002194  13FC 0000 00004B6B      1859              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000219C                          1860             
0000219C                          1861              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000219C  13FC 00B9 00004B6D      1862              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000021A4  13FC 0020 00004B6E      1863              MOVE.B   #$20,GET_SRC_START_END
000021AC                          1864  
000021AC                          1865              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000021AC  0285 0000FE3F           1866              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000021B2  0685 00000000           1867              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000021B8                          1868  
000021B8                          1869                     
000021B8  6100 1788               1870              BSR     GET_EA_EA_SRC      *GETS <ea>
000021BC  163C 002C               1871              MOVE.B  #',',D3
000021C0  6100 201E               1872              BSR     PUSH_STACK                  
000021C4  6100 1BAC               1873              BSR     GET_EA_EA_DEST       *GETS Dn    
000021C8                          1874  
000021C8                          1875              
000021C8  6000 0002               1876              BRA     OP1000_DIVS_RETURN
000021CC                          1877              
000021CC                          1878  OP1000_DIVS_RETURN
000021CC  4E75                    1879              RTS
000021CE                          1880              
000021CE                          1881  
000021CE                          1882  
000021CE                          1883  *---------------------------------------------------------------------------*
000021CE                          1884  * OP_DIVS: display DIVS and proceed to EA
000021CE                          1885  *---------------------------------------------------------------------------*  
000021CE  43F9 0000495D           1886  OP_DIVS     LEA     DISP_DIVS,A1
000021D4  103C 000E               1887              MOVE.B  #14,D0
000021D8  4E4F                    1888              TRAP    #15
000021DA  4EF9 000034A6           1889              JMP     EA_ARITH
000021E0                          1890  
000021E0  4E75                    1891              RTS
000021E2                          1892              
000021E2                          1893  *---------------------------------------------------------------------------*
000021E2                          1894  * OP1001: decode SUB/SUBA
000021E2                          1895  *---------------------------------------------------------------------------*      
000021E2                          1896  OP1001      
000021E2  4280                    1897              CLR.L   D0                  
000021E4  4281                    1898              CLR.L   D1       
000021E6  4284                    1899              CLR.L   D4                   
000021E8  227C 00000000           1900              MOVEA.L #0, A1              
000021EE  2205                    1901              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000021F0                          1902              
000021F0                          1903              *CLEAR D3
000021F0  4283                    1904              CLR.L   D3
000021F2                          1905              
000021F2                          1906              
000021F2                          1907              
000021F2                          1908              **INTEGRATING SUB.W/.L INTO THIS CODE**
000021F2  2205                    1909              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000021F4                          1910              *BITS (INDEX 8) 
000021F4                          1911              *0 = ADD.B/W/L <EA>,Dn
000021F4                          1912              *1 = ADD.B/W/L Dn,<EA> 
000021F4  EC99                    1913              ROR.L   #6,D1
000021F6  0281 00000007           1914              ANDI.L  #$07,D1                 *MASKS WITH 00000111
000021FC  0C81 00000007           1915              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002202  6700 0010               1916              BEQ     OP1001_SUBA_L            *BRANCHES TO ADDA.L
00002206  0C81 00000003           1917              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
0000220C  6700 0078               1918              BEQ     OP1001_SUBA_W           *BRANCHES TO ADDA.W
00002210  6000 00E6               1919              BRA     OP1001_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002214                          1920              
00002214                          1921  OP1001_SUBA_L
00002214                          1922              *LOAD STACK WITH THIS OPMODE
00002214  6100 1FCA               1923              BSR     PUSH_STACK
00002218  163C 0053               1924              MOVE.B  #'S',D3
0000221C  6100 1FC2               1925              BSR     PUSH_STACK
00002220  163C 0055               1926              MOVE.B  #'U',D3
00002224  6100 1FBA               1927              BSR     PUSH_STACK
00002228  163C 0042               1928              MOVE.B  #'B',D3
0000222C  6100 1FB2               1929              BSR     PUSH_STACK
00002230  163C 0041               1930              MOVE.B  #'A',D3
00002234  6100 1FAA               1931              BSR     PUSH_STACK
00002238  163C 002E               1932              MOVE.B  #'.',D3
0000223C  6100 1FA2               1933              BSR     PUSH_STACK
00002240  163C 004C               1934              MOVE.B  #'L',D3
00002244  6100 1F9A               1935              BSR     PUSH_STACK
00002248                          1936              
00002248                          1937             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002248  13FC 0000 00004B6A      1938             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002250  13FC 0000 00004B6B      1939             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002258                          1940             
00002258                          1941             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002258  13FC 00B9 00004B6D      1942             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002260  13FC 0020 00004B6E      1943             MOVE.B   #$20,GET_SRC_START_END
00002268                          1944  
00002268                          1945              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002268  0285 0000FE3F           1946              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000226E  0685 00000040           1947              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002274                          1948       
00002274                          1949              *PRINT <EA>,AN
00002274  6100 16CC               1950              BSR     GET_EA_EA_SRC       *GETS <ea>
00002278  163C 002C               1951              MOVE.B  #',',D3
0000227C  6100 1F62               1952              BSR     PUSH_STACK                     
00002280  6100 1AF0               1953              BSR     GET_EA_EA_DEST      *GETS Dn
00002284                          1954  
00002284                          1955              
00002284                          1956              
00002284  4E75                    1957              RTS
00002286                          1958  OP1001_SUBA_W
00002286                          1959              *LOAD STACK WITH THIS OPMODE
00002286  6100 1F58               1960              BSR     PUSH_STACK
0000228A  163C 0053               1961              MOVE.B  #'S',D3
0000228E  6100 1F50               1962              BSR     PUSH_STACK
00002292  163C 0055               1963              MOVE.B  #'U',D3
00002296  6100 1F48               1964              BSR     PUSH_STACK
0000229A  163C 0042               1965              MOVE.B  #'B',D3
0000229E  6100 1F40               1966              BSR     PUSH_STACK
000022A2  163C 0041               1967              MOVE.B  #'A',D3
000022A6  6100 1F38               1968              BSR     PUSH_STACK
000022AA  163C 002E               1969              MOVE.B  #'.',D3
000022AE  6100 1F30               1970              BSR     PUSH_STACK
000022B2  163C 0057               1971              MOVE.B  #'W',D3
000022B6  6100 1F28               1972              BSR     PUSH_STACK
000022BA                          1973              
000022BA                          1974             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000022BA  13FC 0000 00004B6A      1975             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000022C2  13FC 0000 00004B6B      1976             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000022CA                          1977             
000022CA                          1978             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000022CA  13FC 00B9 00004B6D      1979             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000022D2  13FC 0020 00004B6E      1980             MOVE.B   #$20,GET_SRC_START_END
000022DA                          1981  
000022DA                          1982              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000022DA  0285 0000FE3F           1983              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000022E0  0685 00000040           1984              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000022E6                          1985       
000022E6                          1986              *PRINT <EA>,AN
000022E6  6100 165A               1987              BSR     GET_EA_EA_SRC       *GETS <ea>
000022EA  163C 002C               1988              MOVE.B  #',',D3
000022EE  6100 1EF0               1989              BSR     PUSH_STACK                     
000022F2  6100 1A7E               1990              BSR     GET_EA_EA_DEST      *GETS Dn
000022F6                          1991  
000022F6  4E75                    1992              RTS
000022F8                          1993  
000022F8                          1994  OP1001_DETERMINE_DN_EA_OR_EA_DN 
000022F8                          1995              *LOAD STACK WITH THIS OPMODE
000022F8  6100 1EE6               1996              BSR     PUSH_STACK
000022FC  163C 0053               1997              MOVE.B  #'S',D3
00002300  6100 1EDE               1998              BSR     PUSH_STACK
00002304  163C 0055               1999              MOVE.B  #'U',D3
00002308  6100 1ED6               2000              BSR     PUSH_STACK
0000230C  163C 0042               2001              MOVE.B  #'B',D3
00002310  6100 1ECE               2002              BSR     PUSH_STACK
00002314  163C 002E               2003              MOVE.B  #'.',D3
00002318  6100 1EC6               2004              BSR     PUSH_STACK
0000231C                          2005              
0000231C  2205                    2006              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
0000231E                          2007              
0000231E                          2008              *BITS (INDEX 8) 
0000231E                          2009              *0 = ADD.B/W/L <EA>,Dn
0000231E                          2010              *1 = ADD.B/W/L Dn,<EA> 
0000231E  E099                    2011              ROR.L   #8,D1
00002320  0281 00000001           2012              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002326  0C81 00000000           2013              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
0000232C  6700 0102               2014              BEQ     OP1001_EA_DN
00002330                          2015              *else procede to Dn_EA
00002330                          2016              
00002330                          2017  OP1001_DN_EA
00002330                          2018              *BITS (7 TO 6) 
00002330                          2019              *00 = .B
00002330                          2020              *01 = .W
00002330                          2021              *10 = .L 
00002330  2205                    2022              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002332  EC99                    2023              ROR.L   #6,D1
00002334  0281 00000003           2024              ANDI.L  #$03,D1
0000233A  0C81 00000000           2025              CMPI.L  #$00,D1 *EQUALS .B
00002340  6700 0016               2026              BEQ     OP1001_PRINT_B2
00002344  0C81 00000001           2027              CMPI.L  #$01,D1 *EQUALS .W
0000234A  6700 0054               2028              BEQ     OP1001_PRINT_W2
0000234E  0C81 00000002           2029              CMPI.L  #$02,D1 *EQUALS .L
00002354  6700 0092               2030              BEQ     OP1001_PRINT_L2
00002358                          2031  OP1001_PRINT_B2
00002358                          2032              *PUSH 'B'
00002358  163C 0042               2033              MOVE.B  #'B',D3
0000235C  6100 1E82               2034              BSR     PUSH_STACK
00002360                          2035             
00002360                          2036              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002360  13FC 0000 00004B6A      2037             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002368  13FC 0083 00004B6B      2038             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002370                          2039             
00002370                          2040             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002370  13FC 00B9 00004B6D      2041             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002378  13FC 0020 00004B6E      2042             MOVE.B   #$20,GET_SRC_START_END
00002380                          2043  
00002380                          2044              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002380  0285 0000FE3F           2045              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002386  0685 00000040           2046              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000238C                          2047       
0000238C  6100 19E4               2048              BSR     GET_EA_EA_DEST      *GETS Dn
00002390  163C 002C               2049              MOVE.B  #',',D3
00002394  6100 1E4A               2050              BSR     PUSH_STACK                     
00002398  6100 15A8               2051              BSR     GET_EA_EA_SRC       *GETS <ea>
0000239C                          2052  
0000239C                          2053              
0000239C  6000 0BA4               2054              BRA     OP1101_ADD_RETURN
000023A0                          2055  OP1001_PRINT_W2
000023A0  163C 0057               2056              MOVE.B  #'W',D3
000023A4  6100 1E3A               2057              BSR     PUSH_STACK
000023A8                          2058  
000023A8                          2059              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023A8  13FC 0000 00004B6A      2060              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023B0  13FC 0083 00004B6B      2061              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000023B8                          2062             
000023B8                          2063              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000023B8  13FC 00B9 00004B6D      2064              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000023C0  13FC 0020 00004B6E      2065              MOVE.B   #$20,GET_SRC_START_END
000023C8                          2066  
000023C8                          2067              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000023C8  0285 0000FE3F           2068              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000023CE  0685 00000040           2069              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
000023D4                          2070  
000023D4                          2071        
000023D4  6100 199C               2072              BSR     GET_EA_EA_DEST      *GETS Dn
000023D8  163C 002C               2073              MOVE.B  #',',D3
000023DC  6100 1E02               2074              BSR     PUSH_STACK               
000023E0  6100 1560               2075              BSR     GET_EA_EA_SRC       *GETS <ea>       
000023E4                          2076  
000023E4                          2077  
000023E4                          2078  
000023E4  6000 0B5C               2079              BRA     OP1101_ADD_RETURN
000023E8                          2080  OP1001_PRINT_L2 
000023E8  163C 004C               2081              MOVE.B  #'L',D3
000023EC  6100 1DF2               2082              BSR     PUSH_STACK
000023F0                          2083              
000023F0                          2084              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000023F0  13FC 0000 00004B6A      2085              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000023F8  13FC 0083 00004B6B      2086              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002400                          2087             
00002400                          2088              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002400  13FC 00B9 00004B6D      2089              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002408  13FC 0020 00004B6E      2090              MOVE.B   #$20,GET_SRC_START_END
00002410                          2091  
00002410                          2092             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002410  0285 0000FE3F           2093              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002416  0685 00000040           2094              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000241C                          2095  
0000241C                          2096               
0000241C  6100 1954               2097              BSR     GET_EA_EA_DEST       *GETS Dn
00002420  163C 002C               2098              MOVE.B  #',',D3
00002424  6100 1DBA               2099              BSR     PUSH_STACK          
00002428  6100 1518               2100              BSR     GET_EA_EA_SRC        *GETS <ea>
0000242C                          2101  
0000242C  6000 0B14               2102              BRA     OP1101_ADD_RETURN
00002430                          2103              
00002430                          2104  OP1001_EA_DN           
00002430                          2105              *BITS (7 TO 6) 
00002430                          2106              *00 = .B
00002430                          2107              *01 = .W
00002430                          2108              *10 = .L 
00002430  2205                    2109              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002432  EC99                    2110              ROR.L   #6,D1
00002434  0281 00000003           2111              ANDI.L  #$03,D1
0000243A  0C81 00000000           2112              CMPI.L  #$00,D1 *EQUALS .B
00002440  6700 0016               2113              BEQ     OP1001_PRINT_B
00002444  0C81 00000001           2114              CMPI.L  #$01,D1 *EQUALS .W
0000244A  6700 0054               2115              BEQ     OP1001_PRINT_W
0000244E  0C81 00000002           2116              CMPI.L  #$02,D1 *EQUALS .L
00002454  6700 0092               2117              BEQ     OP1001_PRINT_L
00002458                          2118  OP1001_PRINT_B
00002458  163C 0042               2119              MOVE.B  #'B',D3
0000245C  6100 1D82               2120              BSR     PUSH_STACK
00002460                          2121                
00002460                          2122              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002460  13FC 0000 00004B6A      2123              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002468  13FC 0002 00004B6B      2124              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002470                          2125             
00002470                          2126              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002470  13FC 00B9 00004B6D      2127              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002478  13FC 0020 00004B6E      2128              MOVE.B   #$20,GET_SRC_START_END
00002480                          2129  
00002480                          2130             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002480  0285 0000FE3F           2131              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002486  0685 00000040           2132              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
0000248C                          2133  
0000248C                          2134              
0000248C  6100 14B4               2135              BSR     GET_EA_EA_SRC      *GETS <ea>
00002490  163C 002C               2136              MOVE.B  #',',D3
00002494  6100 1D4A               2137              BSR     PUSH_STACK          
00002498  6100 18D8               2138              BSR     GET_EA_EA_DEST       *GETS Dn
0000249C                          2139              
0000249C  6000 0AA4               2140              BRA     OP1101_ADD_RETURN
000024A0                          2141  OP1001_PRINT_W
000024A0  163C 0057               2142              MOVE.B  #'W',D3
000024A4  6100 1D3A               2143              BSR     PUSH_STACK
000024A8                          2144  
000024A8                          2145              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024A8  13FC 0000 00004B6A      2146              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024B0  13FC 0000 00004B6B      2147              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
000024B8                          2148             
000024B8                          2149              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000024B8  13FC 00B9 00004B6D      2150              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
000024C0  13FC 0020 00004B6E      2151              MOVE.B   #$20,GET_SRC_START_END
000024C8                          2152  
000024C8                          2153             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000024C8  0285 0000FE3F           2154              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000024CE  0685 00000040           2155              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
000024D4                          2156  
000024D4                          2157              
000024D4  6100 146C               2158              BSR     GET_EA_EA_SRC      *GETS <ea>
000024D8  163C 002C               2159              MOVE.B  #',',D3
000024DC  6100 1D02               2160              BSR     PUSH_STACK
000024E0  6100 1890               2161              BSR     GET_EA_EA_DEST       *GETS Dn    
000024E4                          2162              
000024E4  6000 004A               2163              BRA     OP1001_ADD_RETURN
000024E8                          2164  OP1001_PRINT_L 
000024E8  163C 004C               2165              MOVE.B  #'L',D3
000024EC  6100 1CF2               2166              BSR     PUSH_STACK
000024F0                          2167              
000024F0                          2168              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000024F0  13FC 0000 00004B6A      2169              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
000024F8  13FC 0000 00004B6B      2170              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002500                          2171             
00002500                          2172              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002500  13FC 00B9 00004B6D      2173              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002508  13FC 0020 00004B6E      2174              MOVE.B   #$20,GET_SRC_START_END
00002510                          2175  
00002510                          2176              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002510  0285 0000FE3F           2177              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002516  0685 00000040           2178              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
0000251C                          2179  
0000251C                          2180                     
0000251C  6100 1424               2181              BSR     GET_EA_EA_SRC      *GETS <ea>
00002520  163C 002C               2182              MOVE.B  #',',D3
00002524  6100 1CBA               2183              BSR     PUSH_STACK                  
00002528  6100 1848               2184              BSR     GET_EA_EA_DEST       *GETS Dn    
0000252C                          2185  
0000252C                          2186              
0000252C  6000 0002               2187              BRA     OP1001_ADD_RETURN
00002530                          2188              
00002530                          2189  OP1001_ADD_RETURN
00002530  4E75                    2190              RTS
00002532                          2191  
00002532                          2192    
00002532                          2193  *---------------------------------------------------------------------------*
00002532                          2194  * OP_SUB: display SUB and proceed to EA
00002532                          2195  *---------------------------------------------------------------------------*            
00002532  43F9 00004965           2196  OP_SUB_B    LEA     DISP_SUB_B,A1
00002538  103C 000E               2197              MOVE.B  #14,D0
0000253C  4E4F                    2198              TRAP    #15
0000253E  183C 0000               2199              MOVE.B  #0,D4
00002542  4EF9 000034F2           2200              JMP     EA_GEN
00002548                          2201  
00002548  4E75                    2202              RTS
0000254A                          2203  
0000254A  43F9 0000496E           2204  OP_SUB_W    LEA     DISP_SUB_W,A1
00002550  103C 000E               2205              MOVE.B  #14,D0
00002554  4E4F                    2206              TRAP    #15
00002556  183C 0001               2207              MOVE.B  #1,D4
0000255A  4EF9 000034F2           2208              JMP     EA_GEN
00002560                          2209  
00002560  4E75                    2210              RTS
00002562                          2211  
00002562  43F9 00004977           2212  OP_SUB_L    LEA     DISP_SUB_L,A1
00002568  103C 000E               2213              MOVE.B  #14,D0
0000256C  4E4F                    2214              TRAP    #15
0000256E  183C 0002               2215              MOVE.B  #2,D4
00002572  4EF9 000034F2           2216              JMP     EA_GEN
00002578                          2217  
00002578  4E75                    2218              RTS
0000257A                          2219  
0000257A                          2220  *---------------------------------------------------------------------------*
0000257A                          2221  * OP_SUBA: display SUBA
0000257A                          2222  *---------------------------------------------------------------------------*  
0000257A  43F9 0000499E           2223  OP_SUBA_W   LEA     DISP_SUBA_W,A1
00002580  103C 000E               2224              MOVE.B  #14,D0
00002584  4E4F                    2225              TRAP    #15
00002586  183C 0001               2226              MOVE.B  #1,D4
0000258A  4E75                    2227              RTS
0000258C                          2228  
0000258C  43F9 000049A8           2229  OP_SUBA_L   LEA     DISP_SUBA_L,A1
00002592  103C 000E               2230              MOVE.B  #14,D0
00002596  4E4F                    2231              TRAP    #15
00002598  183C 0002               2232              MOVE.B  #2,D4
0000259C  4E75                    2233              RTS         
0000259E                          2234  *---------------------------------------------------------------------------*
0000259E                          2235  * OP1010 : unassigned
0000259E                          2236  *---------------------------------------------------------------------------*           
0000259E  4EF8 1752               2237  OP1010      JMP     OP_DATA
000025A2                          2238              
000025A2                          2239  *---------------------------------------------------------------------------*
000025A2                          2240  * OP1011 : decode CMP/EOR/CMPA
000025A2                          2241  *---------------------------------------------------------------------------*           
000025A2  4280                    2242  OP1011      CLR.L   D0                
000025A4  4281                    2243              CLR.L   D1            
000025A6  4284                    2244              CLR.L   D4                   
000025A8  227C 00000000           2245              MOVEA.L #0, A1               
000025AE  2205                    2246              MOVE.L  D5,D1
000025B0  EA99                    2247              ROR.L   #5,D1
000025B2  0281 0000000E           2248              ANDI.L  #$E,D1
000025B8  0C01 0000               2249              CMPI.B  #$0,D1
000025BC  6700 003E               2250              BEQ     OP1011_CMP
000025C0  0C01 0002               2251              CMPI.B  #$2,D1
000025C4  6700 0036               2252              BEQ     OP1011_CMP
000025C8  0C01 0004               2253              CMPI.B  #$4,D1
000025CC  6700 002E               2254              BEQ     OP1011_CMP
000025D0  0C01 0008               2255              CMPI.B  #$8,D1
000025D4  6700 0178               2256              BEQ     OP1011_EOR
000025D8  0C01 000A               2257              CMPI.B  #$A,D1
000025DC  6700 0170               2258              BEQ     OP1011_EOR
000025E0  0C01 000C               2259              CMPI.B  #$C,D1
000025E4  6700 0168               2260              BEQ     OP1011_EOR  
000025E8  0C01 0006               2261              CMPI.B  #$6,D1
000025EC  6700 00C0               2262              BEQ     OP1011_CMPA
000025F0  0C01 000E               2263              CMPI.B  #$E,D1
000025F4  6700 00B8               2264              BEQ     OP1011_CMPA 
000025F8                          2265  
000025F8  4EF8 1752               2266              JMP     OP_DATA          
000025FC                          2267  
000025FC                          2268  
000025FC                          2269  
000025FC                          2270  
000025FC                          2271  OP1011_CMP
000025FC                          2272             
000025FC                          2273   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000025FC  13FC 0082 00004B6A      2274             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002604  13FC 0000 00004B6B      2275             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000260C                          2276             
0000260C                          2277             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000260C  13FC 00B9 00004B6D      2278             MOVE.B   #$B9,GET_DST_START_END
00002614  13FC 0020 00004B6E      2279             MOVE.B   #$20,GET_SRC_START_END
0000261C                          2280             
0000261C                          2281              *CLEAR D3
0000261C  4283                    2282              CLR.L   D3
0000261E                          2283              *LOAD STACK WITH THIS OPMODE
0000261E  6100 1BC0               2284              BSR     PUSH_STACK
00002622  163C 0043               2285              MOVE.B  #'C',D3
00002626  6100 1BB8               2286              BSR     PUSH_STACK
0000262A  163C 004D               2287              MOVE.B  #'M',D3
0000262E  6100 1BB0               2288              BSR     PUSH_STACK
00002632  163C 0050               2289              MOVE.B  #'P',D3
00002636  6100 1BA8               2290              BSR     PUSH_STACK
0000263A  163C 002E               2291              MOVE.B  #'.',D3
0000263E  6100 1BA0               2292              BSR     PUSH_STACK
00002642                          2293              
00002642                          2294              *FIGURE OUT SIZE*
00002642                          2295              *00 = BYTE
00002642                          2296              *01 = WORD
00002642                          2297              *10 = LONG
00002642                          2298              * BITS 7&6
00002642                          2299              
00002642                          2300              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002642  2205                    2301              MOVE.L  D5,D1
00002644  EC99                    2302              ROR.L   #6,D1
00002646  0281 00000003           2303              ANDI.L  #$03,D1
0000264C  0C01 0000               2304              CMPI.B  #%00,D1
00002650  6700 001E               2305              BEQ     OP1011_CMP_B
00002654  0281 00000003           2306              ANDI.L  #$03,D1
0000265A  0C01 0001               2307              CMPI.B  #%01,D1
0000265E  6700 001C               2308              BEQ     OP1011_CMP_W
00002662  0281 00000003           2309              ANDI.L  #$03,D1
00002668  0C01 0002               2310              CMPI.B  #%10,D1
0000266C  6700 001A               2311              BEQ     OP1011_CMP_L
00002670                          2312            
00002670                          2313  OP1011_CMP_B
00002670                          2314              
00002670  163C 0042               2315              MOVE.B  #'B',D3
00002674  6100 1B6A               2316              BSR     PUSH_STACK
00002678  6000 0016               2317              BRA     OP1011_RETURN_CMP  
0000267C                          2318  OP1011_CMP_W
0000267C                          2319              
0000267C  163C 0057               2320              MOVE.B  #'W',D3
00002680  6100 1B5E               2321              BSR     PUSH_STACK
00002684  6000 000A               2322              BRA     OP1011_RETURN_CMP  
00002688                          2323  OP1011_CMP_L
00002688                          2324              
00002688  163C 004C               2325              MOVE.B  #'L',D3
0000268C  6100 1B52               2326              BSR     PUSH_STACK
00002690                          2327  OP1011_RETURN_CMP            
00002690                          2328  
00002690                          2329              
00002690                          2330  *GET DATA FROM ADDQ AND PRINT #0-8
00002690                          2331       
00002690                          2332              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002690  0285 0000FE3F           2333              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002696  0685 00000000           2334              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000269C                          2335  
0000269C  6100 12A4               2336              BSR     GET_EA_EA_SRC
000026A0  163C 002C               2337              MOVE.B  #',',D3
000026A4  6100 1B3A               2338              BSR     PUSH_STACK
000026A8  6100 16C8               2339              BSR     GET_EA_EA_DEST
000026AC                          2340              
000026AC  4E75                    2341              RTS
000026AE                          2342              
000026AE                          2343  
000026AE                          2344  
000026AE                          2345  OP1011_CMPA
000026AE                          2346              
000026AE                          2347   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000026AE  13FC 0080 00004B6A      2348             MOVE.B   #$80,DEST_REGISTER_FORMAT
000026B6  13FC 0000 00004B6B      2349             MOVE.B   #$00,SRC_REGISTER_FORMAT
000026BE                          2350             
000026BE                          2351             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
000026BE  13FC 00B9 00004B6D      2352             MOVE.B   #$B9,GET_DST_START_END
000026C6  13FC 0020 00004B6E      2353             MOVE.B   #$20,GET_SRC_START_END
000026CE                          2354             
000026CE                          2355              *CLEAR D3
000026CE  4283                    2356              CLR.L   D3
000026D0                          2357              *LOAD STACK WITH THIS OPMODE
000026D0  6100 1B0E               2358              BSR     PUSH_STACK
000026D4  163C 0043               2359              MOVE.B  #'C',D3
000026D8  6100 1B06               2360              BSR     PUSH_STACK
000026DC  163C 004D               2361              MOVE.B  #'M',D3
000026E0  6100 1AFE               2362              BSR     PUSH_STACK
000026E4  163C 0050               2363              MOVE.B  #'P',D3
000026E8  6100 1AF6               2364              BSR     PUSH_STACK
000026EC  163C 0041               2365              MOVE.B  #'A',D3
000026F0  6100 1AEE               2366              BSR     PUSH_STACK
000026F4  163C 002E               2367              MOVE.B  #'.',D3
000026F8  6100 1AE6               2368              BSR     PUSH_STACK
000026FC                          2369              
000026FC                          2370              *FIGURE OUT SIZE*
000026FC                          2371              *00 = BYTE
000026FC                          2372              *01 = WORD
000026FC                          2373              *10 = LONG
000026FC                          2374              * BITS 7&6
000026FC                          2375              
000026FC                          2376              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
000026FC  2205                    2377              MOVE.L  D5,D1
000026FE  EC99                    2378              ROR.L   #6,D1
00002700  0281 00000003           2379              ANDI.L  #$03,D1
00002706  0C01 0001               2380              CMPI.B  #%01,D1
0000270A  6700 0010               2381              BEQ     OP1011_CMPA_W
0000270E  0281 00000003           2382              ANDI.L  #$03,D1
00002714  0C01 0002               2383              CMPI.B  #%10,D1
00002718  6700 000E               2384              BEQ     OP1011_CMPA_L
0000271C                          2385  OP1011_CMPA_W
0000271C                          2386              
0000271C  163C 0057               2387              MOVE.B  #'W',D3
00002720  6100 1ABE               2388              BSR     PUSH_STACK
00002724  6000 000A               2389              BRA     OP1011_RETURN_CMPA 
00002728                          2390  OP1011_CMPA_L
00002728                          2391              
00002728  163C 004C               2392              MOVE.B  #'L',D3
0000272C  6100 1AB2               2393              BSR     PUSH_STACK
00002730                          2394  OP1011_RETURN_CMPA            
00002730                          2395  
00002730                          2396              
00002730                          2397  *GET DATA FROM ADDQ AND PRINT #0-8
00002730                          2398       
00002730                          2399              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002730  0285 0000FE3F           2400              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002736  0685 00000040           2401              ADDI.L  #$0040,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (000) 
0000273C                          2402  
0000273C  6100 1204               2403              BSR     GET_EA_EA_SRC
00002740  163C 002C               2404              MOVE.B  #',',D3
00002744  6100 1A9A               2405              BSR     PUSH_STACK
00002748  6100 1628               2406              BSR     GET_EA_EA_DEST
0000274C                          2407              
0000274C  4E75                    2408              RTS
0000274E                          2409  
0000274E                          2410  OP1011_EOR
0000274E                          2411  
0000274E                          2412   *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000274E  13FC 0082 00004B6A      2413             MOVE.B   #$82,DEST_REGISTER_FORMAT
00002756  13FC 0080 00004B6B      2414             MOVE.B   #$80,SRC_REGISTER_FORMAT
0000275E                          2415             
0000275E                          2416             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000275E  13FC 00B9 00004B6D      2417             MOVE.B   #$B9,GET_DST_START_END
00002766  13FC 0020 00004B6E      2418             MOVE.B   #$20,GET_SRC_START_END
0000276E                          2419             
0000276E                          2420              *CLEAR D3
0000276E  4283                    2421              CLR.L   D3
00002770                          2422              *LOAD STACK WITH THIS OPMODE
00002770  6100 1A6E               2423              BSR     PUSH_STACK
00002774  163C 0045               2424              MOVE.B  #'E',D3
00002778  6100 1A66               2425              BSR     PUSH_STACK
0000277C  163C 004F               2426              MOVE.B  #'O',D3
00002780  6100 1A5E               2427              BSR     PUSH_STACK
00002784  163C 0052               2428              MOVE.B  #'R',D3
00002788  6100 1A56               2429              BSR     PUSH_STACK
0000278C  163C 002E               2430              MOVE.B  #'.',D3
00002790  6100 1A4E               2431              BSR     PUSH_STACK
00002794                          2432              
00002794                          2433              *FIGURE OUT SIZE*
00002794                          2434              *00 = BYTE
00002794                          2435              *01 = WORD
00002794                          2436              *10 = LONG
00002794                          2437              * BITS 7&6
00002794                          2438              
00002794                          2439              *COMPARE TO SEE IF IT IS BYTE/WORD/LONG SIZE
00002794  2205                    2440              MOVE.L  D5,D1
00002796  EC99                    2441              ROR.L   #6,D1
00002798  0281 00000003           2442              ANDI.L  #$03,D1
0000279E  0C01 0000               2443              CMPI.B  #%00,D1
000027A2  6700 001E               2444              BEQ     OP1011_EOR_B
000027A6  0281 00000003           2445              ANDI.L  #$03,D1
000027AC  0C01 0001               2446              CMPI.B  #%01,D1
000027B0  6700 001C               2447              BEQ     OP1011_EOR_W
000027B4  0281 00000003           2448              ANDI.L  #$03,D1
000027BA  0C01 0002               2449              CMPI.B  #%10,D1
000027BE  6700 001A               2450              BEQ     OP1011_EOR_L
000027C2                          2451            
000027C2                          2452  OP1011_EOR_B
000027C2                          2453              
000027C2  163C 0042               2454              MOVE.B  #'B',D3
000027C6  6100 1A18               2455              BSR     PUSH_STACK
000027CA  6000 0016               2456              BRA     OP1011_RETURN
000027CE                          2457  OP1011_EOR_W
000027CE                          2458              
000027CE  163C 0057               2459              MOVE.B  #'W',D3
000027D2  6100 1A0C               2460              BSR     PUSH_STACK
000027D6  6000 000A               2461              BRA     OP1011_RETURN
000027DA                          2462  OP1011_EOR_L
000027DA                          2463              
000027DA  163C 004C               2464              MOVE.B  #'L',D3
000027DE  6100 1A00               2465              BSR     PUSH_STACK
000027E2                          2466  OP1011_RETURN            
000027E2                          2467  
000027E2                          2468              
000027E2                          2469  *GET DATA FROM ADDQ AND PRINT #0-8
000027E2                          2470       
000027E2                          2471              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
000027E2  0285 0000FE3F           2472              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
000027E8  0685 00000000           2473              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000027EE                          2474  
000027EE  6100 1582               2475              BSR     GET_EA_EA_DEST
000027F2  163C 002C               2476              MOVE.B  #',',D3
000027F6  6100 19E8               2477              BSR     PUSH_STACK
000027FA  6100 1146               2478              BSR     GET_EA_EA_SRC
000027FE                          2479              
000027FE  4E75                    2480              RTS
00002800                          2481              
00002800                          2482              
00002800                          2483              
00002800                          2484              
00002800                          2485  
00002800                          2486  *---------------------------------------------------------------------------*
00002800                          2487  * OP_CMPA: display CMPA 
00002800                          2488  *---------------------------------------------------------------------------
00002800  43F9 000049E8           2489  OP_CMPA_W   LEA     DISP_CMPA_W,A1
00002806  103C 000E               2490              MOVE.B  #14,D0
0000280A  4E4F                    2491              TRAP    #15
0000280C  183C 0001               2492              MOVE.B  #1,D4
00002810  4E75                    2493              RTS
00002812                          2494  
00002812  43F9 000049F2           2495  OP_CMPA_L   LEA     DISP_CMPA_L,A1
00002818  103C 000E               2496              MOVE.B  #14,D0
0000281C  4E4F                    2497              TRAP    #15
0000281E  183C 0002               2498              MOVE.B  #2,D4
00002822  4E75                    2499              RTS
00002824                          2500  
00002824                          2501  *---------------------------------------------------------------------------*
00002824                          2502  * OP_CMP: display CMP and proceed to EA
00002824                          2503  *---------------------------------------------------------------------------*  
00002824  43F9 000049CD           2504  OP_CMP_B    LEA     DISP_CMP_B,A1
0000282A  103C 000E               2505              MOVE.B  #14,D0
0000282E  4E4F                    2506              TRAP    #15
00002830  183C 0000               2507              MOVE.B  #0,D4
00002834  4EF9 000034F2           2508              JMP     EA_GEN
0000283A                          2509  
0000283A  4E75                    2510              RTS
0000283C                          2511              
0000283C  43F9 000049D6           2512  OP_CMP_W    LEA     DISP_CMP_W,A1
00002842  103C 000E               2513              MOVE.B  #14,D0
00002846  4E4F                    2514              TRAP    #15
00002848  183C 0001               2515              MOVE.B  #1,D4
0000284C  4EF9 000034F2           2516              JMP     EA_GEN
00002852                          2517  
00002852  4E75                    2518              RTS
00002854                          2519              
00002854  43F9 000049DF           2520  OP_CMP_L    LEA     DISP_CMP_L,A1
0000285A  103C 000E               2521              MOVE.B  #14,D0
0000285E  4E4F                    2522              TRAP    #15
00002860  183C 0002               2523              MOVE.B  #2,D4
00002864  4EF9 000034F2           2524              JMP     EA_GEN
0000286A                          2525  
0000286A  4E75                    2526              RTS
0000286C                          2527              
0000286C                          2528  *---------------------------------------------------------------------------*
0000286C                          2529  * OP_EOR: display EOR
0000286C                          2530  *---------------------------------------------------------------------------*  
0000286C  43F9 000049B2           2531  OP_EOR_B    LEA     DISP_EOR_B,A1
00002872  103C 000E               2532              MOVE.B  #14,D0
00002876  4E4F                    2533              TRAP    #15
00002878  183C 0000               2534              MOVE.B  #0,D4
0000287C  4E75                    2535              RTS
0000287E                          2536              
0000287E  43F9 000049BB           2537  OP_EOR_W    LEA     DISP_EOR_W,A1
00002884  103C 000E               2538              MOVE.B  #14,D0
00002888  4E4F                    2539              TRAP    #15
0000288A  183C 0001               2540              MOVE.B  #1,D4
0000288E  4E75                    2541              RTS
00002890                          2542              
00002890  43F9 000049C4           2543  OP_EOR_L    LEA     DISP_EOR_L,A1
00002896  103C 000E               2544              MOVE.B  #14,D0
0000289A  4E4F                    2545              TRAP    #15
0000289C  183C 0002               2546              MOVE.B  #2,D4
000028A0  4E75                    2547              RTS    
000028A2                          2548  
000028A2                          2549  *---------------------------------------------------------------------------*
000028A2                          2550  * OP1100: Decode and display MULS/AND and proceed to EA
000028A2                          2551  *---------------------------------------------------------------------------* 
000028A2  4280                    2552  OP1100      CLR.L   D0                 
000028A4  4281                    2553              CLR.L   D1    
000028A6  4284                    2554              CLR.L   D4                
000028A8  227C 00000000           2555              MOVEA.L #0, A1        
000028AE  2205                    2556              MOVE.L  D5,D1
000028B0  EA89                    2557              LSR.L   #5,D1
000028B2  0281 0000000E           2558              ANDI.L  #$E,D1
000028B8  0C41 000E               2559              CMPI.W  #$E,D1
000028BC  6700 0006               2560              BEQ     OP_MULS
000028C0  6000 00F6               2561              BRA     OP1100_DETERMINE_DN_EA_OR_EA_DN 
000028C4                          2562  
000028C4                          2563  OP_MULS                      
000028C4  4281                    2564              CLR.L   D1       
000028C6  4284                    2565              CLR.L   D4                   
000028C8  227C 00000000           2566              MOVEA.L #0, A1              
000028CE  2205                    2567              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
000028D0                          2568              *CLEAR D3
000028D0  4283                    2569              CLR.L   D3
000028D2                          2570  
000028D2                          2571  OP1100_MULS_DN_EA_OR_EA_DN 
000028D2                          2572              *LOAD STACK WITH THIS OPMODE
000028D2  6100 190C               2573              BSR     PUSH_STACK
000028D6  163C 004D               2574              MOVE.B  #'M',D3
000028DA  6100 1904               2575              BSR     PUSH_STACK
000028DE  163C 0055               2576              MOVE.B  #'U',D3
000028E2  6100 18FC               2577              BSR     PUSH_STACK
000028E6  163C 004C               2578              MOVE.B  #'L',D3
000028EA  6100 18F4               2579              BSR     PUSH_STACK
000028EE  163C 0053               2580              MOVE.B  #'S',D3
000028F2  6100 18EC               2581              BSR     PUSH_STACK
000028F6  163C 002E               2582              MOVE.B  #'.',D3
000028FA  6100 18E4               2583              BSR     PUSH_STACK
000028FE                          2584              
000028FE  2205                    2585              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002900                          2586              
00002900                          2587  OP1100_EA_DN_MULS           
00002900                          2588              *BITS (7 TO 6) 
00002900                          2589              *00 = .B
00002900                          2590              *01 = .W
00002900                          2591              *10 = .L 
00002900  2205                    2592              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002902  EC99                    2593              ROR.L   #6,D1
00002904  0281 00000003           2594              ANDI.L  #$03,D1
0000290A  0C81 00000003           2595              CMPI.L  #%11,D1 *EQUALS .W
00002910  6700 0014               2596              BEQ     OP1100_PRINT_W_MULS
00002914  0C81 00000000           2597              CMPI.L  #%00,D1 *EQUALS .L
0000291A  6700 0052               2598              BEQ     OP1100_PRINT_L_MULS
0000291E                          2599              
0000291E  183C 0001               2600              MOVE.B  #1,D4               *ERROR READ
00002922  6000 0092               2601              BRA     OP1100_MULS_RETURN
00002926                          2602  OP1100_PRINT_W_MULS
00002926  163C 0057               2603              MOVE.B  #'W',D3
0000292A  6100 18B4               2604              BSR     PUSH_STACK
0000292E                          2605  
0000292E                          2606              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000292E  13FC 0000 00004B6A      2607              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002936  13FC 0000 00004B6B      2608              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
0000293E                          2609             
0000293E                          2610              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000293E  13FC 00B9 00004B6D      2611              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002946  13FC 0020 00004B6E      2612              MOVE.B   #$20,GET_SRC_START_END
0000294E                          2613  
0000294E                          2614             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
0000294E  0285 0000FE3F           2615              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002954  0685 00000000           2616              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
0000295A                          2617  
0000295A                          2618              
0000295A  6100 0FE6               2619              BSR     GET_EA_EA_SRC      *GETS <ea>
0000295E  163C 002C               2620              MOVE.B  #',',D3
00002962  6100 187C               2621              BSR     PUSH_STACK
00002966  6100 140A               2622              BSR     GET_EA_EA_DEST       *GETS Dn    
0000296A                          2623              
0000296A  6000 004A               2624              BRA     OP1100_MULS_RETURN
0000296E                          2625  OP1100_PRINT_L_MULS 
0000296E  163C 004C               2626              MOVE.B  #'L',D3
00002972  6100 186C               2627              BSR     PUSH_STACK
00002976                          2628              
00002976                          2629              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002976  13FC 0000 00004B6A      2630              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
0000297E  13FC 0000 00004B6B      2631              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002986                          2632             
00002986                          2633              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002986  13FC 00B9 00004B6D      2634              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
0000298E  13FC 0020 00004B6E      2635              MOVE.B   #$20,GET_SRC_START_END
00002996                          2636  
00002996                          2637              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002996  0285 0000FE3F           2638              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
0000299C  0685 00000000           2639              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
000029A2                          2640  
000029A2                          2641                     
000029A2  6100 0F9E               2642              BSR     GET_EA_EA_SRC      *GETS <ea>
000029A6  163C 002C               2643              MOVE.B  #',',D3
000029AA  6100 1834               2644              BSR     PUSH_STACK                  
000029AE  6100 13C2               2645              BSR     GET_EA_EA_DEST       *GETS Dn    
000029B2                          2646  
000029B2                          2647              
000029B2  6000 0002               2648              BRA     OP1100_MULS_RETURN
000029B6                          2649              
000029B6                          2650  OP1100_MULS_RETURN
000029B6  4E75                    2651              RTS
000029B8                          2652              
000029B8                          2653  
000029B8                          2654  
000029B8                          2655  
000029B8                          2656  
000029B8                          2657  
000029B8                          2658  
000029B8                          2659  
000029B8                          2660  
000029B8                          2661  
000029B8                          2662  
000029B8                          2663  
000029B8                          2664  
000029B8                          2665  OP1100_DETERMINE_DN_EA_OR_EA_DN 
000029B8                          2666              *LOAD STACK WITH THIS OPMODE
000029B8  4283                    2667              CLR.L   D3
000029BA  6100 1824               2668              BSR     PUSH_STACK
000029BE  163C 0041               2669              MOVE.B  #'A',D3
000029C2  6100 181C               2670              BSR     PUSH_STACK
000029C6  163C 004E               2671              MOVE.B  #'N',D3
000029CA  6100 1814               2672              BSR     PUSH_STACK
000029CE  163C 0044               2673              MOVE.B  #'D',D3
000029D2  6100 180C               2674              BSR     PUSH_STACK
000029D6  163C 002E               2675              MOVE.B  #'.',D3
000029DA  6100 1804               2676              BSR     PUSH_STACK
000029DE                          2677              
000029DE  2205                    2678              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
000029E0                          2679              
000029E0                          2680              *BITS (INDEX 8) 
000029E0                          2681              *0 = ADD.B/W/L <EA>,Dn
000029E0                          2682              *1 = ADD.B/W/L Dn,<EA> 
000029E0  E099                    2683              ROR.L   #8,D1
000029E2  0281 00000001           2684              ANDI.L  #$01,D1     *MASKS WITH 00000001
000029E8  0C81 00000000           2685              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
000029EE  6700 0102               2686              BEQ     OP1100_EA_DN
000029F2                          2687              *else procede to Dn_EA
000029F2                          2688              
000029F2                          2689  OP1100_DN_EA
000029F2                          2690              *BITS (7 TO 6) 
000029F2                          2691              *00 = .B
000029F2                          2692              *01 = .W
000029F2                          2693              *10 = .L 
000029F2  2205                    2694              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
000029F4  EC99                    2695              ROR.L   #6,D1
000029F6  0281 00000003           2696              ANDI.L  #$03,D1
000029FC  0C81 00000000           2697              CMPI.L  #$00,D1 *EQUALS .B
00002A02  6700 0016               2698              BEQ     OP1100_PRINT_B2
00002A06  0C81 00000001           2699              CMPI.L  #$01,D1 *EQUALS .W
00002A0C  6700 0054               2700              BEQ     OP1100_PRINT_W2
00002A10  0C81 00000002           2701              CMPI.L  #$02,D1 *EQUALS .L
00002A16  6700 0092               2702              BEQ     OP1100_PRINT_L2
00002A1A                          2703  OP1100_PRINT_B2
00002A1A                          2704              *PUSH 'B'
00002A1A  163C 0042               2705              MOVE.B  #'B',D3
00002A1E  6100 17C0               2706              BSR     PUSH_STACK
00002A22                          2707             
00002A22                          2708              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A22  13FC 0000 00004B6A      2709             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A2A  13FC 0083 00004B6B      2710             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A32                          2711             
00002A32                          2712             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A32  13FC 00B9 00004B6D      2713             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A3A  13FC 0020 00004B6E      2714             MOVE.B   #$20,GET_SRC_START_END
00002A42                          2715  
00002A42                          2716              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A42  0285 0000FE3F           2717              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A48  0685 00000000           2718              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002A4E                          2719       
00002A4E  6100 1322               2720              BSR     GET_EA_EA_DEST      *GETS Dn
00002A52  163C 002C               2721              MOVE.B  #',',D3
00002A56  6100 1788               2722              BSR     PUSH_STACK                     
00002A5A  6100 0EE6               2723              BSR     GET_EA_EA_SRC       *GETS <ea>
00002A5E                          2724  
00002A5E                          2725              
00002A5E  6000 0192               2726              BRA     OP1100_AND_RETURN
00002A62                          2727  OP1100_PRINT_W2
00002A62  163C 0057               2728              MOVE.B  #'W',D3
00002A66  6100 1778               2729              BSR     PUSH_STACK
00002A6A                          2730  
00002A6A                          2731              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002A6A  13FC 0000 00004B6A      2732              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002A72  13FC 0083 00004B6B      2733              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002A7A                          2734             
00002A7A                          2735              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002A7A  13FC 00B9 00004B6D      2736              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002A82  13FC 0020 00004B6E      2737              MOVE.B   #$20,GET_SRC_START_END
00002A8A                          2738  
00002A8A                          2739              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002A8A  0285 0000FE3F           2740              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002A90  0685 00000000           2741              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A An Register (001) 
00002A96                          2742  
00002A96                          2743        
00002A96  6100 12DA               2744              BSR     GET_EA_EA_DEST      *GETS Dn
00002A9A  163C 002C               2745              MOVE.B  #',',D3
00002A9E  6100 1740               2746              BSR     PUSH_STACK               
00002AA2  6100 0E9E               2747              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002AA6                          2748  
00002AA6                          2749  
00002AA6                          2750  
00002AA6  6000 049A               2751              BRA     OP1101_ADD_RETURN
00002AAA                          2752  OP1100_PRINT_L2 
00002AAA  163C 004C               2753              MOVE.B  #'L',D3
00002AAE  6100 1730               2754              BSR     PUSH_STACK
00002AB2                          2755              
00002AB2                          2756              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002AB2  13FC 0000 00004B6A      2757              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002ABA  13FC 0083 00004B6B      2758              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002AC2                          2759             
00002AC2                          2760              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002AC2  13FC 00B9 00004B6D      2761              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002ACA  13FC 0020 00004B6E      2762              MOVE.B   #$20,GET_SRC_START_END
00002AD2                          2763  
00002AD2                          2764             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002AD2  0285 0000FE3F           2765              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002AD8  0685 00000000           2766              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002ADE                          2767  
00002ADE                          2768               
00002ADE  6100 1292               2769              BSR     GET_EA_EA_DEST       *GETS Dn
00002AE2  163C 002C               2770              MOVE.B  #',',D3
00002AE6  6100 16F8               2771              BSR     PUSH_STACK          
00002AEA  6100 0E56               2772              BSR     GET_EA_EA_SRC        *GETS <ea>
00002AEE                          2773  
00002AEE  6000 0102               2774              BRA     OP1100_AND_RETURN
00002AF2                          2775              
00002AF2                          2776  OP1100_EA_DN           
00002AF2                          2777              *BITS (7 TO 6) 
00002AF2                          2778              *00 = .B
00002AF2                          2779              *01 = .W
00002AF2                          2780              *10 = .L 
00002AF2  2205                    2781              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002AF4  EC99                    2782              ROR.L   #6,D1
00002AF6  0281 00000003           2783              ANDI.L  #$03,D1
00002AFC  0C81 00000000           2784              CMPI.L  #$00,D1 *EQUALS .B
00002B02  6700 0016               2785              BEQ     OP1100_PRINT_B
00002B06  0C81 00000001           2786              CMPI.L  #$01,D1 *EQUALS .W
00002B0C  6700 0054               2787              BEQ     OP1100_PRINT_W
00002B10  0C81 00000002           2788              CMPI.L  #$02,D1 *EQUALS .L
00002B16  6700 0092               2789              BEQ     OP1100_PRINT_L
00002B1A                          2790  OP1100_PRINT_B
00002B1A  163C 0042               2791              MOVE.B  #'B',D3
00002B1E  6100 16C0               2792              BSR     PUSH_STACK
00002B22                          2793                
00002B22                          2794              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B22  13FC 0000 00004B6A      2795              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B2A  13FC 0002 00004B6B      2796              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B32                          2797             
00002B32                          2798              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B32  13FC 00B9 00004B6D      2799              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B3A  13FC 0020 00004B6E      2800              MOVE.B   #$20,GET_SRC_START_END
00002B42                          2801  
00002B42                          2802             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B42  0285 0000FE3F           2803              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B48  0685 00000000           2804              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "AN" Register (001) 
00002B4E                          2805  
00002B4E                          2806              
00002B4E  6100 0DF2               2807              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B52  163C 002C               2808              MOVE.B  #',',D3
00002B56  6100 1688               2809              BSR     PUSH_STACK          
00002B5A  6100 1216               2810              BSR     GET_EA_EA_DEST       *GETS Dn
00002B5E                          2811              
00002B5E  6000 03E2               2812              BRA     OP1101_ADD_RETURN
00002B62                          2813  OP1100_PRINT_W
00002B62  163C 0057               2814              MOVE.B  #'W',D3
00002B66  6100 1678               2815              BSR     PUSH_STACK
00002B6A                          2816  
00002B6A                          2817              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002B6A  13FC 0000 00004B6A      2818              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002B72  13FC 0002 00004B6B      2819              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002B7A                          2820             
00002B7A                          2821              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002B7A  13FC 00B9 00004B6D      2822              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002B82  13FC 0020 00004B6E      2823              MOVE.B   #$20,GET_SRC_START_END
00002B8A                          2824  
00002B8A                          2825             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002B8A  0285 0000FE3F           2826              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002B90  0685 00000000           2827              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002B96                          2828  
00002B96                          2829              
00002B96  6100 0DAA               2830              BSR     GET_EA_EA_SRC      *GETS <ea>
00002B9A  163C 002C               2831              MOVE.B  #',',D3
00002B9E  6100 1640               2832              BSR     PUSH_STACK
00002BA2  6100 11CE               2833              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BA6                          2834              
00002BA6  6000 F988               2835              BRA     OP1001_ADD_RETURN
00002BAA                          2836  OP1100_PRINT_L 
00002BAA  163C 004C               2837              MOVE.B  #'L',D3
00002BAE  6100 1630               2838              BSR     PUSH_STACK
00002BB2                          2839              
00002BB2                          2840              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002BB2  13FC 0000 00004B6A      2841              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002BBA  13FC 0002 00004B6B      2842              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002BC2                          2843             
00002BC2                          2844              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002BC2  13FC 00B9 00004B6D      2845              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002BCA  13FC 0020 00004B6E      2846              MOVE.B   #$20,GET_SRC_START_END
00002BD2                          2847  
00002BD2                          2848              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002BD2  0285 0000FE3F           2849              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002BD8  0685 00000000           2850              ADDI.L  #%0000000000000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002BDE                          2851  
00002BDE                          2852                     
00002BDE  6100 0D62               2853              BSR     GET_EA_EA_SRC      *GETS <ea>
00002BE2  163C 002C               2854              MOVE.B  #',',D3
00002BE6  6100 15F8               2855              BSR     PUSH_STACK                  
00002BEA  6100 1186               2856              BSR     GET_EA_EA_DEST       *GETS Dn    
00002BEE                          2857  
00002BEE                          2858              
00002BEE  6000 0002               2859              BRA     OP1100_AND_RETURN
00002BF2                          2860              
00002BF2                          2861  OP1100_AND_RETURN
00002BF2  4E75                    2862              RTS
00002BF4                          2863  
00002BF4                          2864  
00002BF4                          2865  *---------------------------------------------------------------------------*
00002BF4                          2866  * OP1101: Decode ADD/ADDA
00002BF4                          2867  *---------------------------------------------------------------------------* 
00002BF4  4280                    2868  OP1101      CLR.L   D0                  
00002BF6  4281                    2869              CLR.L   D1       
00002BF8  4284                    2870              CLR.L   D4                   
00002BFA  227C 00000000           2871              MOVEA.L #0, A1              
00002C00  2205                    2872              MOVE.L  D5,D1       *DATA TO BE PROCESS IN [D1], TRY TO GET OPMODE AND DETERMINE .B/.W/.L
00002C02                          2873              
00002C02                          2874              *CLEAR D3
00002C02  4283                    2875              CLR.L   D3
00002C04                          2876              
00002C04                          2877              
00002C04                          2878              
00002C04                          2879              **INTEGRATING ADDA.W/.L INTO THIS CODE**
00002C04  2205                    2880              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002C06                          2881              *BITS (INDEX 8) 
00002C06                          2882              *0 = ADD.B/W/L <EA>,Dn
00002C06                          2883              *1 = ADD.B/W/L Dn,<EA> 
00002C06  EC99                    2884              ROR.L   #6,D1
00002C08  0281 00000007           2885              ANDI.L  #$07,D1                 *MASKS WITH 00000111
00002C0E  0C81 00000007           2886              CMPI.L  #$07,D1                 *IF EQUALS <ea>,Dn
00002C14  6700 0010               2887              BEQ     OP1101_ADDA_L            *BRANCHES TO ADDA.L
00002C18  0C81 00000003           2888              CMPI.L  #$03,D1                 *IF EQUALS <ea>,Dn
00002C1E  6700 0078               2889              BEQ     OP1101_ADDA_W           *BRANCHES TO ADDA.W
00002C22  6000 00E6               2890              BRA     OP1101_DETERMINE_DN_EA_OR_EA_DN         *ELSE CHECK ADD.B/.W/.L
00002C26                          2891              
00002C26                          2892  OP1101_ADDA_L
00002C26                          2893              *LOAD STACK WITH THIS OPMODE
00002C26  6100 15B8               2894              BSR     PUSH_STACK
00002C2A  163C 0041               2895              MOVE.B  #'A',D3
00002C2E  6100 15B0               2896              BSR     PUSH_STACK
00002C32  163C 0044               2897              MOVE.B  #'D',D3
00002C36  6100 15A8               2898              BSR     PUSH_STACK
00002C3A  163C 0044               2899              MOVE.B  #'D',D3
00002C3E  6100 15A0               2900              BSR     PUSH_STACK
00002C42  163C 0041               2901              MOVE.B  #'A',D3
00002C46  6100 1598               2902              BSR     PUSH_STACK
00002C4A  163C 002E               2903              MOVE.B  #'.',D3
00002C4E  6100 1590               2904              BSR     PUSH_STACK
00002C52  163C 004C               2905              MOVE.B  #'L',D3
00002C56  6100 1588               2906              BSR     PUSH_STACK
00002C5A                          2907              
00002C5A                          2908             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002C5A  13FC 0000 00004B6A      2909             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002C62  13FC 0000 00004B6B      2910             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002C6A                          2911             
00002C6A                          2912             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002C6A  13FC 00B9 00004B6D      2913             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002C72  13FC 0020 00004B6E      2914             MOVE.B   #$20,GET_SRC_START_END
00002C7A                          2915  
00002C7A                          2916              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002C7A  0285 0000FE3F           2917              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002C80  0685 00000040           2918              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002C86                          2919       
00002C86                          2920              *PRINT <EA>,AN
00002C86  6100 0CBA               2921              BSR     GET_EA_EA_SRC       *GETS <ea>
00002C8A  163C 002C               2922              MOVE.B  #',',D3
00002C8E  6100 1550               2923              BSR     PUSH_STACK                     
00002C92  6100 10DE               2924              BSR     GET_EA_EA_DEST      *GETS Dn
00002C96                          2925  
00002C96                          2926              
00002C96                          2927              
00002C96  4E75                    2928              RTS
00002C98                          2929  OP1101_ADDA_W
00002C98                          2930              *LOAD STACK WITH THIS OPMODE
00002C98  6100 1546               2931              BSR     PUSH_STACK
00002C9C  163C 0041               2932              MOVE.B  #'A',D3
00002CA0  6100 153E               2933              BSR     PUSH_STACK
00002CA4  163C 0044               2934              MOVE.B  #'D',D3
00002CA8  6100 1536               2935              BSR     PUSH_STACK
00002CAC  163C 0044               2936              MOVE.B  #'D',D3
00002CB0  6100 152E               2937              BSR     PUSH_STACK
00002CB4  163C 0041               2938              MOVE.B  #'A',D3
00002CB8  6100 1526               2939              BSR     PUSH_STACK
00002CBC  163C 002E               2940              MOVE.B  #'.',D3
00002CC0  6100 151E               2941              BSR     PUSH_STACK
00002CC4  163C 0057               2942              MOVE.B  #'W',D3
00002CC8  6100 1516               2943              BSR     PUSH_STACK
00002CCC                          2944              
00002CCC                          2945             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002CCC  13FC 0000 00004B6A      2946             MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002CD4  13FC 0000 00004B6B      2947             MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002CDC                          2948             
00002CDC                          2949             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002CDC  13FC 00B9 00004B6D      2950             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002CE4  13FC 0020 00004B6E      2951             MOVE.B   #$20,GET_SRC_START_END
00002CEC                          2952  
00002CEC                          2953              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002CEC  0285 0000FE3F           2954              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002CF2  0685 00000040           2955              ADDI.L  #%0000000001000000,D5   *Add.B  BITS 8-6 TO INDICATE A "An" Register (001) 
00002CF8                          2956       
00002CF8                          2957              *PRINT <EA>,AN
00002CF8  6100 0C48               2958              BSR     GET_EA_EA_SRC       *GETS <ea>
00002CFC  163C 002C               2959              MOVE.B  #',',D3
00002D00  6100 14DE               2960              BSR     PUSH_STACK                     
00002D04  6100 106C               2961              BSR     GET_EA_EA_DEST      *GETS Dn
00002D08                          2962  
00002D08  4E75                    2963              RTS
00002D0A                          2964  
00002D0A                          2965  OP1101_DETERMINE_DN_EA_OR_EA_DN 
00002D0A                          2966              *LOAD STACK WITH THIS OPMODE
00002D0A  6100 14D4               2967              BSR     PUSH_STACK
00002D0E  163C 0041               2968              MOVE.B  #'A',D3
00002D12  6100 14CC               2969              BSR     PUSH_STACK
00002D16  163C 0044               2970              MOVE.B  #'D',D3
00002D1A  6100 14C4               2971              BSR     PUSH_STACK
00002D1E  163C 0044               2972              MOVE.B  #'D',D3
00002D22  6100 14BC               2973              BSR     PUSH_STACK
00002D26  163C 002E               2974              MOVE.B  #'.',D3
00002D2A  6100 14B4               2975              BSR     PUSH_STACK
00002D2E                          2976              
00002D2E  2205                    2977              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]      
00002D30                          2978              
00002D30                          2979              *BITS (INDEX 8) 
00002D30                          2980              *0 = ADD.B/W/L <EA>,Dn
00002D30                          2981              *1 = ADD.B/W/L Dn,<EA> 
00002D30  E099                    2982              ROR.L   #8,D1
00002D32  0281 00000001           2983              ANDI.L  #$01,D1     *MASKS WITH 00000001
00002D38  0C81 00000000           2984              CMPI.L  #$00,D1     *IF EQUALS <ea>,Dn
00002D3E  6700 0102               2985              BEQ     OP1101_EA_DN
00002D42                          2986              *else procede to Dn_EA
00002D42                          2987              
00002D42                          2988  OP1101_DN_EA
00002D42                          2989              *BITS (7 TO 6) 
00002D42                          2990              *00 = .B
00002D42                          2991              *01 = .W
00002D42                          2992              *10 = .L 
00002D42  2205                    2993              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002D44  EC99                    2994              ROR.L   #6,D1
00002D46  0281 00000003           2995              ANDI.L  #$03,D1
00002D4C  0C81 00000000           2996              CMPI.L  #$00,D1 *EQUALS .B
00002D52  6700 0016               2997              BEQ     OP1101_PRINT_B2
00002D56  0C81 00000001           2998              CMPI.L  #$01,D1 *EQUALS .W
00002D5C  6700 0054               2999              BEQ     OP1101_PRINT_W2
00002D60  0C81 00000002           3000              CMPI.L  #$02,D1 *EQUALS .L
00002D66  6700 0092               3001              BEQ     OP1101_PRINT_L2
00002D6A                          3002  OP1101_PRINT_B2
00002D6A                          3003              *PUSH 'B'
00002D6A  163C 0042               3004              MOVE.B  #'B',D3
00002D6E  6100 1470               3005              BSR     PUSH_STACK
00002D72                          3006             
00002D72                          3007              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002D72  13FC 0002 00004B6A      3008             MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002D7A  13FC 0083 00004B6B      3009             MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002D82                          3010             
00002D82                          3011             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002D82  13FC 00B9 00004B6D      3012             MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002D8A  13FC 0020 00004B6E      3013             MOVE.B   #$20,GET_SRC_START_END
00002D92                          3014  
00002D92                          3015              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002D92  0285 0000FE3F           3016              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002D98  0685 00000000           3017              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002D9E                          3018       
00002D9E  6100 0FD2               3019              BSR     GET_EA_EA_DEST      *GETS Dn
00002DA2  163C 002C               3020              MOVE.B  #',',D3
00002DA6  6100 1438               3021              BSR     PUSH_STACK                     
00002DAA  6100 0B96               3022              BSR     GET_EA_EA_SRC       *GETS <ea>
00002DAE                          3023  
00002DAE                          3024              
00002DAE  6000 0192               3025              BRA     OP1101_ADD_RETURN
00002DB2                          3026  OP1101_PRINT_W2
00002DB2  163C 0057               3027              MOVE.B  #'W',D3
00002DB6  6100 1428               3028              BSR     PUSH_STACK
00002DBA                          3029  
00002DBA                          3030              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002DBA  13FC 0000 00004B6A      3031              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002DC2  13FC 0083 00004B6B      3032              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002DCA                          3033             
00002DCA                          3034              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002DCA  13FC 00B9 00004B6D      3035              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002DD2  13FC 0020 00004B6E      3036              MOVE.B   #$20,GET_SRC_START_END
00002DDA                          3037  
00002DDA                          3038              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002DDA  0285 0000FE3F           3039              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002DE0  0685 00000000           3040              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002DE6                          3041  
00002DE6                          3042        
00002DE6  6100 0F8A               3043              BSR     GET_EA_EA_DEST      *GETS Dn
00002DEA  163C 002C               3044              MOVE.B  #',',D3
00002DEE  6100 13F0               3045              BSR     PUSH_STACK               
00002DF2  6100 0B4E               3046              BSR     GET_EA_EA_SRC       *GETS <ea>       
00002DF6                          3047  
00002DF6                          3048  
00002DF6                          3049  
00002DF6  6000 014A               3050              BRA     OP1101_ADD_RETURN
00002DFA                          3051  OP1101_PRINT_L2 
00002DFA  163C 004C               3052              MOVE.B  #'L',D3
00002DFE  6100 13E0               3053              BSR     PUSH_STACK
00002E02                          3054              
00002E02                          3055              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E02  13FC 0000 00004B6A      3056              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E0A  13FC 0083 00004B6B      3057              MOVE.B   #$83,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E12                          3058             
00002E12                          3059              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E12  13FC 00B9 00004B6D      3060              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E1A  13FC 0020 00004B6E      3061              MOVE.B   #$20,GET_SRC_START_END
00002E22                          3062  
00002E22                          3063             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E22  0285 0000FE3F           3064              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E28  0685 00000000           3065              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E2E                          3066  
00002E2E                          3067               
00002E2E  6100 0F42               3068              BSR     GET_EA_EA_DEST       *GETS Dn
00002E32  163C 002C               3069              MOVE.B  #',',D3
00002E36  6100 13A8               3070              BSR     PUSH_STACK          
00002E3A  6100 0B06               3071              BSR     GET_EA_EA_SRC        *GETS <ea>
00002E3E                          3072  
00002E3E  6000 0102               3073              BRA     OP1101_ADD_RETURN
00002E42                          3074              
00002E42                          3075  OP1101_EA_DN           
00002E42                          3076              *BITS (7 TO 6) 
00002E42                          3077              *00 = .B
00002E42                          3078              *01 = .W
00002E42                          3079              *10 = .L 
00002E42  2205                    3080              MOVE.L  D5,D1       *GET CLEAN COPY OF DATA INTO [D1]  
00002E44  EC99                    3081              ROR.L   #6,D1
00002E46  0281 00000003           3082              ANDI.L  #$03,D1
00002E4C  0C81 00000000           3083              CMPI.L  #$00,D1 *EQUALS .B
00002E52  6700 0016               3084              BEQ     OP1101_PRINT_B
00002E56  0C81 00000001           3085              CMPI.L  #$01,D1 *EQUALS .W
00002E5C  6700 0054               3086              BEQ     OP1101_PRINT_W
00002E60  0C81 00000002           3087              CMPI.L  #$02,D1 *EQUALS .L
00002E66  6700 0092               3088              BEQ     OP1101_PRINT_L
00002E6A                          3089  OP1101_PRINT_B
00002E6A  163C 0042               3090              MOVE.B  #'B',D3
00002E6E  6100 1370               3091              BSR     PUSH_STACK
00002E72                          3092                
00002E72                          3093              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002E72  13FC 0002 00004B6A      3094              MOVE.B   #$02,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002E7A  13FC 0002 00004B6B      3095              MOVE.B   #$02,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002E82                          3096             
00002E82                          3097              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002E82  13FC 00B9 00004B6D      3098              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002E8A  13FC 0020 00004B6E      3099              MOVE.B   #$20,GET_SRC_START_END
00002E92                          3100  
00002E92                          3101             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002E92  0285 0000FE3F           3102              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002E98  0685 00000000           3103              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002E9E                          3104  
00002E9E                          3105              
00002E9E  6100 0AA2               3106              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EA2  163C 002C               3107              MOVE.B  #',',D3
00002EA6  6100 1338               3108              BSR     PUSH_STACK          
00002EAA  6100 0EC6               3109              BSR     GET_EA_EA_DEST       *GETS Dn
00002EAE                          3110              
00002EAE  6000 0092               3111              BRA     OP1101_ADD_RETURN
00002EB2                          3112  OP1101_PRINT_W
00002EB2  163C 0057               3113              MOVE.B  #'W',D3
00002EB6  6100 1328               3114              BSR     PUSH_STACK
00002EBA                          3115  
00002EBA                          3116              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002EBA  13FC 0000 00004B6A      3117              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002EC2  13FC 0000 00004B6B      3118              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002ECA                          3119             
00002ECA                          3120              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002ECA  13FC 00B9 00004B6D      3121              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002ED2  13FC 0020 00004B6E      3122              MOVE.B   #$20,GET_SRC_START_END
00002EDA                          3123  
00002EDA                          3124             *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002EDA  0285 0000FE3F           3125              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002EE0  0685 00000000           3126              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002EE6                          3127  
00002EE6                          3128              
00002EE6  6100 0A5A               3129              BSR     GET_EA_EA_SRC      *GETS <ea>
00002EEA  163C 002C               3130              MOVE.B  #',',D3
00002EEE  6100 12F0               3131              BSR     PUSH_STACK
00002EF2  6100 0E7E               3132              BSR     GET_EA_EA_DEST       *GETS Dn    
00002EF6                          3133              
00002EF6  6000 004A               3134              BRA     OP1101_ADD_RETURN
00002EFA                          3135  OP1101_PRINT_L 
00002EFA  163C 004C               3136              MOVE.B  #'L',D3
00002EFE  6100 12E0               3137              BSR     PUSH_STACK
00002F02                          3138              
00002F02                          3139              *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00002F02  13FC 0000 00004B6A      3140              MOVE.B   #$00,DEST_REGISTER_FORMAT               *doesn't allow An in either dest or src formats
00002F0A  13FC 0000 00004B6B      3141              MOVE.B   #$00,SRC_REGISTER_FORMAT                *THIS IS WHAT ARE THE POSSIBLE EA,EA
00002F12                          3142             
00002F12                          3143              *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00002F12  13FC 00B9 00004B6D      3144              MOVE.B   #$B9,GET_DST_START_END                  *THIS IS THE WHERE WE CAN FIND REGISTER NUMBERS
00002F1A  13FC 0020 00004B6E      3145              MOVE.B   #$20,GET_SRC_START_END
00002F22                          3146  
00002F22                          3147              *CHANGE D5 SO THAT BITS 5-3(source mode) REFLECT  <Dn mode> for get_ea_ea format
00002F22  0285 0000FE3F           3148              ANDI.L  #$FE3F,D5   *inverse mask bits 8-6 with 1111(F[15]) 1110(E[14]) 0011(3) 1111(F[15]), TO REPLACE OPMODE WITH DN-MODE
00002F28  0685 00000000           3149              ADDI.L  #$0000,D5   *Add.B  BITS 8-6 TO INDICATE A Dn Register (000) 
00002F2E                          3150  
00002F2E                          3151                     
00002F2E  6100 0A12               3152              BSR     GET_EA_EA_SRC      *GETS <ea>
00002F32  163C 002C               3153              MOVE.B  #',',D3
00002F36  6100 12A8               3154              BSR     PUSH_STACK                  
00002F3A  6100 0E36               3155              BSR     GET_EA_EA_DEST       *GETS Dn    
00002F3E                          3156  
00002F3E                          3157              
00002F3E  6000 0002               3158              BRA     OP1101_ADD_RETURN
00002F42                          3159              
00002F42                          3160  OP1101_ADD_RETURN
00002F42  4E75                    3161              RTS
00002F44                          3162              
00002F44                          3163              *ADDW
00002F44  0C01 0006               3164              CMPI.B  #$6,D1
00002F48  6700 0056               3165              BEQ     OP_ADDA_W
00002F4C  0C01 000E               3166              CMPI.B  #$E,D1
00002F50  6700 0066               3167              BEQ     OP_ADDA_L 
00002F54                          3168  
00002F54  4EF8 1752               3169              JMP     OP_DATA  
00002F58                          3170            
00002F58                          3171  *---------------------------------------------------------------------------*
00002F58                          3172  * OP_ADD: display ADD and proceed to EA
00002F58                          3173  *---------------------------------------------------------------------------*  
00002F58  43F9 00004A21           3174  OP_ADD_B    LEA     DISP_ADD_B,A1
00002F5E  103C 000E               3175              MOVE.B  #14,D0
00002F62  4E4F                    3176              TRAP    #15
00002F64  183C 0000               3177              MOVE.B  #0,D4
00002F68  4EF9 000034F2           3178              JMP     EA_GEN
00002F6E                          3179  
00002F6E  4E75                    3180              RTS
00002F70                          3181  
00002F70  43F9 00004A2A           3182  OP_ADD_W    LEA     DISP_ADD_W,A1
00002F76  103C 000E               3183              MOVE.B  #14,D0
00002F7A  4E4F                    3184              TRAP    #15
00002F7C  183C 0001               3185              MOVE.B  #1,D4
00002F80  4EF9 000034F2           3186              JMP     EA_GEN
00002F86                          3187  
00002F86  4E75                    3188              RTS
00002F88                          3189  
00002F88  43F9 00004A33           3190  OP_ADD_L    LEA     DISP_ADD_L,A1
00002F8E  103C 000E               3191              MOVE.B  #14,D0
00002F92  4E4F                    3192              TRAP    #15
00002F94  183C 0002               3193              MOVE.B  #2,D4
00002F98  4EF9 000034F2           3194              JMP     EA_GEN
00002F9E                          3195  
00002F9E  4E75                    3196              RTS
00002FA0                          3197  
00002FA0                          3198  *---------------------------------------------------------------------------*
00002FA0                          3199  * OP_ADDA: display ADDA and proceed to EA
00002FA0                          3200  *---------------------------------------------------------------------------*  
00002FA0  43F9 00004A3C           3201  OP_ADDA_W   LEA     DISP_ADDA_W,A1
00002FA6  103C 000E               3202              MOVE.B  #14,D0
00002FAA  4E4F                    3203              TRAP    #15
00002FAC  183C 0001               3204              MOVE.B  #1,D4
00002FB0  4EF9 000034F2           3205              JMP     EA_GEN
00002FB6                          3206  
00002FB6  4E75                    3207              RTS
00002FB8                          3208  
00002FB8  43F9 00004A46           3209  OP_ADDA_L   LEA     DISP_ADDA_L,A1
00002FBE  103C 000E               3210              MOVE.B  #14,D0
00002FC2  4E4F                    3211              TRAP    #15
00002FC4  183C 0002               3212              MOVE.B  #2,D4
00002FC8  4EF9 000034F2           3213              JMP     EA_GEN
00002FCE                          3214  
00002FCE  4E75                    3215              RTS
00002FD0                          3216              
00002FD0                          3217  *---------------------------------------------------------------------------*
00002FD0                          3218  * OP1110: LSR/LSL/ASR/ASL/ROL/ROR
00002FD0                          3219  *---------------------------------------------------------------------------* 
00002FD0  4280                    3220  OP1110      CLR.L   D0                  
00002FD2  4281                    3221              CLR.L   D1   
00002FD4  4284                    3222              CLR.L   D4                   
00002FD6  227C 00000000           3223              MOVEA.L #0, A1                 
00002FDC  2205                    3224              MOVE.L  D5,D1
00002FDE                          3225              
00002FDE                          3226              *1)CHECK FOR MEMORY ROTATE/SHIFT FIRST
00002FDE  2205                    3227              MOVE.L  D5,D1                   *RESET
00002FE0  0281 0000FEC0           3228              ANDI.L  #%1111111011000000,D1
00002FE6  0C81 0000E0C0           3229              CMPI.L  #%1110000011000000,D1
00002FEC  6700 0276               3230              BEQ     OP_ASX                  *ASX
00002FF0                          3231  
00002FF0                          3232              
00002FF0  0281 0000FEC0           3233              ANDI.L  #%1111111011000000,D1
00002FF6  0C81 0000E6C0           3234              CMPI.L  #%1110011011000000,D1
00002FFC  6700 0480               3235              BEQ     OP_ROX                  *ROX
00003000                          3236  
00003000  2205                    3237              MOVE.L  D5,D1                   *RESET
00003002  0281 0000FEC0           3238              ANDI.L  #%1111111011000000,D1
00003008  0C81 0000E2C0           3239              CMPI.L  #%1110001011000000,D1
0000300E  6700 003A               3240              BEQ     OP_LSX                  *LSX
00003012                          3241  
00003012                          3242    
00003012                          3243              *2) CHECK FOR REGISTER SHIFTS
00003012  2205                    3244              MOVE.L  D5,D1                   *RESET
00003014  0281 0000F018           3245              ANDI.L  #%1111000000011000,D1
0000301A  0C81 0000E008           3246              CMPI.L  #%1110000000001000,D1
00003020  6700 0028               3247              BEQ     OP_LSX                  *LSX
00003024                          3248  
00003024                          3249              
00003024  2205                    3250              MOVE.L  D5,D1                   *RESET
00003026  0281 0000F018           3251              ANDI.L  #%1111000000011000,D1
0000302C  0C81 0000E000           3252              CMPI.L  #%1110000000000000,D1
00003032  6700 0230               3253              BEQ     OP_ASX                  *ASX
00003036                          3254  
00003036                          3255              
00003036  2205                    3256              MOVE.L  D5,D1                   *RESET
00003038  0281 0000F018           3257              ANDI.L  #%1111000000011000,D1
0000303E  0C81 0000E018           3258              CMPI.L  #%1110000000011000,D1
00003044  6700 0438               3259              BEQ     OP_ROX                  *ROX
00003048                          3260  
00003048                          3261  
00003048                          3262                          
00003048                          3263  OP1110_RETURN       
00003048  4E75                    3264              RTS
0000304A                          3265  
0000304A                          3266  
0000304A                          3267  *---------------------------------------------------------------------------*
0000304A                          3268  * OP_LSR: decode and display LSR
0000304A                          3269  *---------------------------------------------------------------------------*        
0000304A                          3270  OP_LSX     
0000304A  163C 004C               3271              MOVE.B  #'L',D3
0000304E  6100 1190               3272              BSR     PUSH_STACK
00003052  163C 0053               3273              MOVE.B  #'S',D3
00003056  6100 1188               3274              BSR     PUSH_STACK
0000305A                          3275              
0000305A                          3276              *FIND IF ITS RIGHT OR LEFT DIR
0000305A  2205                    3277              MOVE.L  D5,D1                   *RESET
0000305C  0281 00000100           3278              ANDI.L  #%0000000100000000,D1
00003062  0C81 00000000           3279              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
00003068  6700 000E               3280              BEQ     OP_LSX_R      
0000306C  163C 004C               3281              MOVE.B  #'L',D3
00003070  6100 116E               3282              BSR     PUSH_STACK
00003074  6000 000A               3283              BRA     OP_LSX_DIR
00003078                          3284  OP_LSX_R           
00003078  163C 0052               3285              MOVE.B  #'R',D3
0000307C  6100 1162               3286              BSR     PUSH_STACK
00003080                          3287              
00003080                          3288  OP_LSX_DIR
00003080  163C 002E               3289              MOVE.B  #'.',D3
00003084  6100 115A               3290              BSR     PUSH_STACK
00003088                          3291  
00003088                          3292              *FIND SIZE OF OPCODE
00003088  2205                    3293              MOVE.L  D5,D1                   *RESET
0000308A  0281 000000C0           3294              ANDI.L  #%0000000011000000,D1
00003090  0C81 00000080           3295              CMPI.L  #%0000000010000000,D1            *L
00003096  6700 0016               3296              BEQ     OP_LSX_L
0000309A  0C81 00000040           3297              CMPI.L  #%0000000001000000,D1            *W
000030A0  6700 0018               3298              BEQ     OP_LSX_W  
000030A4  0C81 00000000           3299              CMPI.L  #%0000000000000000,D1            *W
000030AA  6700 001A               3300              BEQ     OP_LSX_B       
000030AE                          3301                                      *OTHERWISE B    
000030AE                          3302              
000030AE                          3303  OP_LSX_L
000030AE  163C 004C               3304              MOVE.B  #'L',D3
000030B2  6100 112C               3305              BSR     PUSH_STACK
000030B6  6000 001A               3306              BRA     OP_LSX_CHECK_FORMAT 
000030BA                          3307  OP_LSX_W
000030BA  163C 0057               3308              MOVE.B  #'W',D3
000030BE  6100 1120               3309              BSR     PUSH_STACK
000030C2  6000 000E               3310              BRA     OP_LSX_CHECK_FORMAT 
000030C6                          3311  OP_LSX_B
000030C6  163C 0042               3312              MOVE.B  #'B',D3
000030CA  6100 1114               3313              BSR     PUSH_STACK
000030CE  6000 0002               3314              BRA     OP_LSX_CHECK_FORMAT 
000030D2                          3315                        
000030D2                          3316  OP_LSX_CHECK_FORMAT              
000030D2                          3317              * CHECKS IF ITS A MEMORY SHIFT FORMAT
000030D2  2205                    3318              MOVE.L  D5,D1                   *RESET
000030D4  0281 0000FEC0           3319              ANDI.L  #%1111111011000000,D1
000030DA  0C81 0000E2C0           3320              CMPI.L  #%1110001011000000,D1
000030E0  6700 0156               3321              BEQ     OP_LSX_MEMORY           
000030E4                          3322              
000030E4                          3323              *ELSE ITS REGISTER
000030E4                          3324  OP_LSX_REGISTER
000030E4                          3325             *TODO
000030E4                          3326             *CHECK IF ITS INTERMEDIATE OR REGISTER
000030E4  2205                    3327             MOVE.L  D5,D1                   *RESET
000030E6  EA99                    3328             ROR.L   #5,D1 
000030E8  0281 00000001           3329             ANDI.L  #1,D1
000030EE  0C81 00000000           3330             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
000030F4  6700 003E               3331             BEQ     OP_LSX_INTERMEDIATE
000030F8                          3332             *ELSE ITS DATA REGISTER
000030F8                          3333  
000030F8                          3334             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
000030F8  13FC 0082 00004B6A      3335             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003100  13FC 0000 00004B6B      3336             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003108                          3337             
00003108                          3338             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003108  13FC 00B9 00004B6D      3339             MOVE.B   #$B9,GET_DST_START_END
00003110  13FC 0020 00004B6E      3340             MOVE.B   #$20,GET_SRC_START_END
00003118                          3341             
00003118                          3342             *SETS BOTH SRC/DEST MODES TO "Dn"
00003118  0285 0000FE07           3343             ANDI.L   #%1111111000000111,D5
0000311E  0685 00000000           3344             ADDI.L   #%0000000000000000,D5
00003124                          3345             
00003124                          3346              *CLEAR D3
00003124  4283                    3347              CLR.L   D3
00003126                          3348           
00003126  163C 002C               3349              MOVE.B  #',',D3
0000312A  6100 10B4               3350              BSR     PUSH_STACK
0000312E  6100 0812               3351              BSR     GET_EA_EA_SRC
00003132                          3352              
00003132  4E75                    3353              RTS
00003134                          3354  
00003134                          3355  OP_LSX_INTERMEDIATE
00003134                          3356             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003134  13FC 0082 00004B6A      3357             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000313C  13FC 0000 00004B6B      3358             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003144                          3359             
00003144                          3360             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003144  13FC 00B9 00004B6D      3361             MOVE.B   #$B9,GET_DST_START_END
0000314C  13FC 0020 00004B6E      3362             MOVE.B   #$20,GET_SRC_START_END
00003154                          3363             
00003154                          3364             *SETS BOTH SRC/DEST MODES TO "Dn"
00003154  0285 0000FE07           3365             ANDI.L   #%1111111000000111,D5
0000315A  0685 00000000           3366             ADDI.L   #%0000000000000000,D5
00003160                          3367             
00003160                          3368              *CLEAR D3
00003160  4283                    3369              CLR.L   D3
00003162                          3370             
00003162                          3371  *-------------------------grabbing #immediate data-----------------------*
00003162                          3372  
00003162                          3373  *GET DATA FROM ADDQ AND PRINT #0-8
00003162  163C 0020               3374              MOVE.B  #' ',D3
00003166  6100 1078               3375              BSR     PUSH_STACK
0000316A  163C 0023               3376              MOVE.B  #'#',D3
0000316E  6100 1070               3377              BSR     PUSH_STACK 
00003172                          3378  
00003172                          3379                       
00003172                          3380              *GET DATA #   
00003172  2205                    3381              MOVE.L  D5,D1
00003174  EC99                    3382              ROR.L   #6,D1            
00003176  E699                    3383              ROR.L   #3,D1
00003178  0281 00000007           3384              ANDI.L  #$07,D1
0000317E                          3385              
0000317E  0C01 0000               3386              CMPI.B  #%000,D1
00003182  6700 003A               3387              BEQ     OP_LSX_0
00003186  0C01 0001               3388              CMPI.B  #%001,D1
0000318A  6700 003E               3389              BEQ     OP_LSX_1
0000318E  0C01 0002               3390              CMPI.B  #%010,D1
00003192  6700 0042               3391              BEQ     OP_LSX_2
00003196  0C01 0003               3392              CMPI.B  #%011,D1
0000319A  6700 0046               3393              BEQ     OP_LSX_3
0000319E  0C01 0004               3394              CMPI.B  #%100,D1
000031A2  6700 004A               3395              BEQ     OP_LSX_4
000031A6  0C01 0005               3396              CMPI.B  #%101,D1
000031AA  6700 004E               3397              BEQ     OP_LSX_5
000031AE  0C01 0006               3398              CMPI.B  #%110,D1
000031B2  6700 0052               3399              BEQ     OP_LSX_6
000031B6  0C01 0007               3400              CMPI.B  #%111,D1
000031BA  6700 0056               3401              BEQ     OP_LSX_7
000031BE                          3402              
000031BE                          3403  OP_LSX_0
000031BE  163C 0030               3404              MOVE.B  #'0',D3
000031C2  6100 101C               3405              BSR     PUSH_STACK
000031C6  6000 005E               3406              BRA     OP_LSX_AFTER_IMMEDIATE            
000031CA                          3407  OP_LSX_1
000031CA  163C 0031               3408              MOVE.B  #'1',D3
000031CE  6100 1010               3409              BSR     PUSH_STACK
000031D2  6000 0052               3410              BRA     OP_LSX_AFTER_IMMEDIATE            
000031D6                          3411  OP_LSX_2
000031D6  163C 0032               3412              MOVE.B  #'2',D3
000031DA  6100 1004               3413              BSR     PUSH_STACK
000031DE  6000 0046               3414              BRA     OP_LSX_AFTER_IMMEDIATE            
000031E2                          3415  OP_LSX_3
000031E2  163C 0033               3416              MOVE.B  #'3',D3
000031E6  6100 0FF8               3417              BSR     PUSH_STACK
000031EA  6000 003A               3418              BRA     OP_LSX_AFTER_IMMEDIATE            
000031EE                          3419  OP_LSX_4
000031EE  163C 0034               3420              MOVE.B  #'4',D3
000031F2  6100 0FEC               3421              BSR     PUSH_STACK
000031F6  6000 002E               3422              BRA     OP_LSX_AFTER_IMMEDIATE           
000031FA                          3423  OP_LSX_5
000031FA  163C 0035               3424              MOVE.B  #'5',D3
000031FE  6100 0FE0               3425              BSR     PUSH_STACK
00003202  6000 0022               3426              BRA     OP_LSX_AFTER_IMMEDIATE
00003206                          3427  OP_LSX_6
00003206  163C 0036               3428              MOVE.B  #'6',D3
0000320A  6100 0FD4               3429              BSR     PUSH_STACK
0000320E  6000 0016               3430              BRA     OP_LSX_AFTER_IMMEDIATE
00003212                          3431  OP_LSX_7
00003212  163C 0037               3432              MOVE.B  #'7',D3
00003216  6100 0FC8               3433              BSR     PUSH_STACK
0000321A  6000 000A               3434              BRA     OP_LSX_AFTER_IMMEDIATE
0000321E                          3435  
0000321E                          3436  OP_LSX_8
0000321E  163C 0038               3437              MOVE.B  #'8',D3
00003222  6100 0FBC               3438              BSR     PUSH_STACK
00003226                          3439              
00003226                          3440  OP_LSX_AFTER_IMMEDIATE            
00003226                          3441  
00003226                          3442  *-------------------------grabbing #immediate data-----------------------*
00003226                          3443  
00003226  163C 002C               3444              MOVE.B  #',',D3
0000322A  6100 0FB4               3445              BSR     PUSH_STACK
0000322E  6100 0712               3446              BSR     GET_EA_EA_SRC
00003232                          3447              
00003232  4E75                    3448              RTS
00003234                          3449  
00003234  6000 002A               3450              BRA     OP_LSX_RETURN
00003238                          3451              
00003238                          3452              
00003238                          3453  OP_LSX_MEMORY
00003238                          3454             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003238  13FC 0083 00004B6B      3455             MOVE.B   #$83,SRC_REGISTER_FORMAT
00003240                          3456             
00003240                          3457             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003240  13FC 00B9 00004B6D      3458             MOVE.B   #$B9,GET_DST_START_END
00003248  13FC 0020 00004B6E      3459             MOVE.B   #$20,GET_SRC_START_END
00003250                          3460             
00003250                          3461             *pop previous thing out
00003250  6100 0F96               3462             BSR      POP_STACK
00003254                          3463             
00003254                          3464             *print w
00003254  163C 0057               3465             MOVE.B  #'W',D3
00003258  6100 0F86               3466             BSR     PUSH_STACK
0000325C  6100 06E4               3467             BSR     GET_EA_EA_SRC
00003260                          3468  
00003260                          3469  OP_LSX_RETURN
00003260  6000 FDE6               3470              BRA     OP1110_RETURN  
00003264                          3471              
00003264                          3472  *---------------------------------------------------------------------------*
00003264                          3473  * OP_LSR: decode and display LSR IMMEDIATE/REGISTER
00003264                          3474  *---------------------------------------------------------------------------*        
00003264                          3475  OP_ASX
00003264  163C 0041               3476              MOVE.B  #'A',D3
00003268  6100 0F76               3477              BSR     PUSH_STACK
0000326C  163C 0053               3478              MOVE.B  #'S',D3
00003270  6100 0F6E               3479              BSR     PUSH_STACK
00003274                          3480              
00003274                          3481              *FIND IF ITS RIGHT OR LEFT DIR
00003274  2205                    3482              MOVE.L  D5,D1                   *RESET
00003276  0281 00000100           3483              ANDI.L  #%0000000100000000,D1
0000327C  0C81 00000000           3484              CMPI.L  #%0000000000000000,D1   * RIGHT CHECK
00003282  6700 FDF4               3485              BEQ     OP_LSX_R      
00003286  163C 004C               3486              MOVE.B  #'L',D3
0000328A  6100 0F54               3487              BSR     PUSH_STACK
0000328E  6000 000A               3488              BRA     OP_ASX_DIR
00003292                          3489  OP_ASX_R           
00003292  163C 0052               3490              MOVE.B  #'R',D3
00003296  6100 0F48               3491              BSR     PUSH_STACK
0000329A                          3492              
0000329A                          3493  OP_ASX_DIR
0000329A  163C 002E               3494              MOVE.B  #'.',D3
0000329E  6100 0F40               3495              BSR     PUSH_STACK
000032A2                          3496  
000032A2                          3497              *FIND SIZE OF OPCODE
000032A2  2205                    3498              MOVE.L  D5,D1                   *RESET
000032A4  0281 000000C0           3499              ANDI.L  #%0000000011000000,D1
000032AA  0C81 00000080           3500              CMPI.L  #%0000000010000000,D1            *L
000032B0  6700 0016               3501              BEQ     OP_ASX_L
000032B4  0C81 00000040           3502              CMPI.L  #%0000000001000000,D1            *W
000032BA  6700 0018               3503              BEQ     OP_ASX_W  
000032BE  0C81 00000000           3504              CMPI.L  #%0000000000000000,D1            *W
000032C4  6700 001A               3505              BEQ     OP_ASX_B       
000032C8                          3506                                      *OTHERWISE B    
000032C8                          3507              
000032C8                          3508  OP_ASX_L
000032C8  163C 004C               3509              MOVE.B  #'L',D3
000032CC  6100 0F12               3510              BSR     PUSH_STACK
000032D0  6000 001A               3511              BRA     OP_ASX_CHECK_FORMAT 
000032D4                          3512  OP_ASX_W
000032D4  163C 0057               3513              MOVE.B  #'W',D3
000032D8  6100 0F06               3514              BSR     PUSH_STACK
000032DC  6000 000E               3515              BRA     OP_ASX_CHECK_FORMAT 
000032E0                          3516  OP_ASX_B
000032E0  163C 0042               3517              MOVE.B  #'B',D3
000032E4  6100 0EFA               3518              BSR     PUSH_STACK
000032E8  6000 0002               3519              BRA     OP_ASX_CHECK_FORMAT 
000032EC                          3520                        
000032EC                          3521  OP_ASX_CHECK_FORMAT              
000032EC                          3522              * CHECKS IF ITS A MEMORY SHIFT FORMAT
000032EC  2205                    3523              MOVE.L  D5,D1                   *RESET
000032EE  0281 0000FEC0           3524              ANDI.L  #%1111111011000000,D1
000032F4  0C81 0000E2C0           3525              CMPI.L  #%1110001011000000,D1
000032FA  6700 0156               3526              BEQ     OP_ASX_MEMORY           
000032FE                          3527              
000032FE                          3528              *ELSE ITS REGISTER
000032FE                          3529  OP_ASX_REGISTER
000032FE                          3530             *TODO
000032FE                          3531             *CHECK IF ITS INTERMEDIATE OR REGISTER
000032FE  2205                    3532             MOVE.L  D5,D1                   *RESET
00003300  EA99                    3533             ROR.L   #5,D1 
00003302  0281 00000001           3534             ANDI.L  #1,D1
00003308  0C81 00000000           3535             CMPI.L  #0,D1                    * 1=DATA REGISTER 0= INTERMEDIATE(1-7)
0000330E  6700 003E               3536             BEQ     OP_ASX_INTERMEDIATE
00003312                          3537             *ELSE ITS DATA REGISTER
00003312                          3538  
00003312                          3539             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003312  13FC 0082 00004B6A      3540             MOVE.B   #$82,DEST_REGISTER_FORMAT
0000331A  13FC 0000 00004B6B      3541             MOVE.B   #$00,SRC_REGISTER_FORMAT
00003322                          3542             
00003322                          3543             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
00003322  13FC 00B9 00004B6D      3544             MOVE.B   #$B9,GET_DST_START_END
0000332A  13FC 0020 00004B6E      3545             MOVE.B   #$20,GET_SRC_START_END
00003332                          3546             
00003332                          3547             *SETS BOTH SRC/DEST MODES TO "Dn"
00003332  0285 0000FE07           3548             ANDI.L   #%1111111000000111,D5
00003338  0685 00000000           3549             ADDI.L   #%0000000000000000,D5
0000333E                          3550             
0000333E                          3551              *CLEAR D3
0000333E  4283                    3552              CLR.L   D3
00003340                          3553           
00003340  163C 002C               3554              MOVE.B  #',',D3
00003344  6100 0E9A               3555              BSR     PUSH_STACK
00003348  6100 05F8               3556              BSR     GET_EA_EA_SRC
0000334C                          3557              
0000334C  4E75                    3558              RTS
0000334E                          3559  
0000334E                          3560  OP_ASX_INTERMEDIATE
0000334E                          3561             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
0000334E  13FC 0082 00004B6A      3562             MOVE.B   #$82,DEST_REGISTER_FORMAT
00003356  13FC 0000 00004B6B      3563             MOVE.B   #$00,SRC_REGISTER_FORMAT
0000335E                          3564             
0000335E                          3565             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000335E  13FC 00B9 00004B6D      3566             MOVE.B   #$B9,GET_DST_START_END
00003366  13FC 0020 00004B6E      3567             MOVE.B   #$20,GET_SRC_START_END
0000336E                          3568             
0000336E                          3569             *SETS BOTH SRC/DEST MODES TO "Dn"
0000336E  0285 0000FE07           3570             ANDI.L   #%1111111000000111,D5
00003374  0685 00000000           3571             ADDI.L   #%0000000000000000,D5
0000337A                          3572             
0000337A                          3573              *CLEAR D3
0000337A  4283                    3574              CLR.L   D3
0000337C                          3575             
0000337C                          3576  *-------------------------grabbing #immediate data-----------------------*
0000337C                          3577  
0000337C                          3578  *GET DATA FROM ADDQ AND PRINT #0-8
0000337C  163C 0020               3579              MOVE.B  #' ',D3
00003380  6100 0E5E               3580              BSR     PUSH_STACK
00003384  163C 0023               3581              MOVE.B  #'#',D3
00003388  6100 0E56               3582              BSR     PUSH_STACK 
0000338C                          3583  
0000338C                          3584                       
0000338C                          3585              *GET DATA #   
0000338C  2205                    3586              MOVE.L  D5,D1
0000338E  EC99                    3587              ROR.L   #6,D1            
00003390  E699                    3588              ROR.L   #3,D1
00003392  0281 00000007           3589              ANDI.L  #$07,D1
00003398                          3590              
00003398  0C01 0000               3591              CMPI.B  #%000,D1
0000339C  6700 003A               3592              BEQ     OP_ASX_0
000033A0  0C01 0001               3593              CMPI.B  #%001,D1
000033A4  6700 003E               3594              BEQ     OP_ASX_1
000033A8  0C01 0002               3595              CMPI.B  #%010,D1
000033AC  6700 0042               3596              BEQ     OP_ASX_2
000033B0  0C01 0003               3597              CMPI.B  #%011,D1
000033B4  6700 0046               3598              BEQ     OP_ASX_3
000033B8  0C01 0004               3599              CMPI.B  #%100,D1
000033BC  6700 004A               3600              BEQ     OP_ASX_4
000033C0  0C01 0005               3601              CMPI.B  #%101,D1
000033C4  6700 004E               3602              BEQ     OP_ASX_5
000033C8  0C01 0006               3603              CMPI.B  #%110,D1
000033CC  6700 0052               3604              BEQ     OP_ASX_6
000033D0  0C01 0007               3605              CMPI.B  #%111,D1
000033D4  6700 0056               3606              BEQ     OP_ASX_7
000033D8                          3607              
000033D8                          3608  OP_ASX_0
000033D8  163C 0030               3609              MOVE.B  #'0',D3
000033DC  6100 0E02               3610              BSR     PUSH_STACK
000033E0  6000 FE44               3611              BRA     OP_LSX_AFTER_IMMEDIATE            
000033E4                          3612  OP_ASX_1
000033E4  163C 0031               3613              MOVE.B  #'1',D3
000033E8  6100 0DF6               3614              BSR     PUSH_STACK
000033EC  6000 FE38               3615              BRA     OP_LSX_AFTER_IMMEDIATE            
000033F0                          3616  OP_ASX_2
000033F0  163C 0032               3617              MOVE.B  #'2',D3
000033F4  6100 0DEA               3618              BSR     PUSH_STACK
000033F8  6000 FE2C               3619              BRA     OP_LSX_AFTER_IMMEDIATE            
000033FC                          3620  OP_ASX_3
000033FC  163C 0033               3621              MOVE.B  #'3',D3
00003400  6100 0DDE               3622              BSR     PUSH_STACK
00003404  6000 FE20               3623              BRA     OP_LSX_AFTER_IMMEDIATE            
00003408                          3624  OP_ASX_4
00003408  163C 0034               3625              MOVE.B  #'4',D3
0000340C  6100 0DD2               3626              BSR     PUSH_STACK
00003410  6000 FE14               3627              BRA     OP_LSX_AFTER_IMMEDIATE           
00003414                          3628  OP_ASX_5
00003414  163C 0035               3629              MOVE.B  #'5',D3
00003418  6100 0DC6               3630              BSR     PUSH_STACK
0000341C  6000 FE08               3631              BRA     OP_LSX_AFTER_IMMEDIATE
00003420                          3632  OP_ASX_6
00003420  163C 0036               3633              MOVE.B  #'6',D3
00003424  6100 0DBA               3634              BSR     PUSH_STACK
00003428  6000 FDFC               3635              BRA     OP_LSX_AFTER_IMMEDIATE
0000342C                          3636  OP_ASX_7
0000342C  163C 0037               3637              MOVE.B  #'7',D3
00003430  6100 0DAE               3638              BSR     PUSH_STACK
00003434  6000 FDF0               3639              BRA     OP_LSX_AFTER_IMMEDIATE
00003438                          3640  
00003438                          3641  OP_ASX_8
00003438  163C 0038               3642              MOVE.B  #'8',D3
0000343C  6100 0DA2               3643              BSR     PUSH_STACK
00003440                          3644              
00003440                          3645  OP_ASX_AFTER_IMMEDIATE            
00003440                          3646  
00003440                          3647  *-------------------------grabbing #immediate data-----------------------*
00003440                          3648  
00003440  163C 002C               3649              MOVE.B  #',',D3
00003444  6100 0D9A               3650              BSR     PUSH_STACK
00003448  6100 04F8               3651              BSR     GET_EA_EA_SRC
0000344C                          3652              
0000344C  4E75                    3653              RTS
0000344E                          3654  
0000344E  6000 002A               3655              BRA     OP_ASX_RETURN
00003452                          3656              
00003452                          3657              
00003452                          3658  OP_ASX_MEMORY
00003452                          3659             *INITIALIZE EA FORMAT STANDARDS: IF AN,(AN),-(AN)...ETC COULD BE USED
00003452  13FC 0083 00004B6B      3660             MOVE.B   #$83,SRC_REGISTER_FORMAT
0000345A                          3661             
0000345A                          3662             *INITIALIZE WHERE TO FIND REGISTER NUMBERS
0000345A  13FC 00B9 00004B6D      3663             MOVE.B   #$B9,GET_DST_START_END
00003462  13FC 0020 00004B6E      3664             MOVE.B   #$20,GET_SRC_START_END
0000346A                          3665             
0000346A                          3666             *pop previous thing out
0000346A  6100 0D7C               3667             BSR      POP_STACK
0000346E                          3668             
0000346E                          3669             *print w
0000346E  163C 0057               3670             MOVE.B  #'W',D3
00003472  6100 0D6C               3671             BSR     PUSH_STACK
00003476  6100 04CA               3672             BSR     GET_EA_EA_SRC
0000347A                          3673  
0000347A                          3674  OP_ASX_RETURN
0000347A  6000 FBCC               3675              BRA     OP1110_RETURN 
0000347E                          3676      
0000347E                          3677  *---------------------------------------------------------------------------*
0000347E                          3678  * OP_ROX: decode and display LSR IMMEDIATE/REGISTER
0000347E                          3679  *---------------------------------------------------------------------------*        
0000347E                          3680  OP_ROX
0000347E                          3681  
0000347E  43F9 00004ABC           3682              LEA     DISP_ROR_B,A1
00003484  103C 000E               3683              MOVE.B  #14,D0
00003488  4E4F                    3684              TRAP    #15
0000348A                          3685  
0000348A  6000 FBBC               3686              BRA     OP1110_RETURN  
0000348E                          3687  
0000348E                          3688  
0000348E                          3689  
0000348E                          3690  
0000348E                          3691  
0000348E                          3692  
0000348E                          3693  
0000348E                          3694  
0000348E                          3695  
0000348E                          3696  
0000348E                          3697  
0000348E                          3698  
0000348E                          3699  
0000348E                          3700  
0000348E                          3701  
0000348E                          3702  
0000348E                          3703  
0000348E                          3704  
0000348E                          3705  
0000348E                          3706  
0000348E                          3707  
0000348E                          3708  
0000348E                          3709              
0000348E                          3710  *---------------------------------------------------------------------------*
0000348E                          3711  * OP1111 : Special reserved
0000348E                          3712  *---------------------------------------------------------------------------*           
0000348E  4EF8 1752               3713  OP1111      JMP     OP_DATA
00003492                          3714  
00003492                          3715  *---------------------------------------------------------------------------*
00003492                          3716  * EA_NOSRC: decode and display effective addresses for NEG/JSR
00003492                          3717  *---------------------------------------------------------------------------*
00003492                          3718  EA_NOSRC    
00003492  4EB9 00003550           3719              JSR     SRC_MODE
00003498  43F9 000047B6           3720              LEA     ENDLINE_M,A1
0000349E  103C 000E               3721              MOVE.B  #14,D0
000034A2  4E4F                    3722              TRAP    #15
000034A4  4E75                    3723              RTS
000034A6                          3724              
000034A6                          3725  *---------------------------------------------------------------------------*
000034A6                          3726  * EA_ARITH: decode and display effective addresses for DIVS/MULS
000034A6                          3727  *---------------------------------------------------------------------------*
000034A6                          3728  EA_ARITH
000034A6  4EB9 00003550           3729              JSR     SRC_MODE
000034AC  43F9 00004B30           3730              LEA     DISP_D,A1
000034B2  103C 000E               3731              MOVE.B  #14,D0
000034B6  4E4F                    3732              TRAP    #15
000034B8  4EB9 000037DC           3733              JSR     DEST_REGISTER
000034BE  43F9 000047B6           3734              LEA     ENDLINE_M,A1
000034C4  103C 000E               3735              MOVE.B  #14,D0
000034C8  4E4F                    3736              TRAP    #15
000034CA  4E75                    3737              RTS
000034CC                          3738              
000034CC                          3739  *---------------------------------------------------------------------------*
000034CC                          3740  * EA_MOVEA: decode and display effective addresses for MOVEA/LEA
000034CC                          3741  *---------------------------------------------------------------------------*
000034CC                          3742  EA_MOVEA
000034CC  4EB9 00003550           3743              JSR     SRC_MODE
000034D2  43F9 00004B41           3744              LEA     DISP_AOP,A1
000034D8  103C 000E               3745              MOVE.B  #14,D0
000034DC  4E4F                    3746              TRAP    #15
000034DE  4EB9 000037DC           3747              JSR     DEST_REGISTER
000034E4  43F9 00004B3F           3748              LEA     DISP_CP,A1
000034EA  103C 000D               3749              MOVE.B  #13,D0
000034EE  4E4F                    3750              TRAP    #15
000034F0  4E75                    3751              RTS
000034F2                          3752              
000034F2                          3753  *---------------------------------------------------------------------------*
000034F2                          3754  * EA_GEN: decode and display effective addresses for MOVE
000034F2                          3755  *---------------------------------------------------------------------------*
000034F2                          3756  EA_GEN          
000034F2                          3757              * retrieve/display source mode/register
000034F2  4EB9 00003550           3758              JSR     SRC_MODE
000034F8                          3759              
000034F8                          3760              * retrieve/display destination mode/register
000034F8  4EB9 0000350C           3761              JSR     DEST_MODE
000034FE                          3762              
000034FE  43F9 000047B6           3763              LEA     ENDLINE_M,A1
00003504  103C 000E               3764              MOVE.B  #14,D0
00003508  4E4F                    3765              TRAP    #15
0000350A                          3766              
0000350A  4E75                    3767              RTS
0000350C                          3768  
0000350C                          3769  *---------------------------------------------------------------------------*
0000350C                          3770  * DEST_MODE: decode and display destination mode (bit 8 - 6)
0000350C                          3771  *---------------------------------------------------------------------------*           
0000350C                          3772  DEST_MODE   
0000350C                          3773              * clear registers to store temp data
0000350C  4280                    3774              CLR.L   D0                      
0000350E  4281                    3775              CLR.L   D1                      
00003510  207C 00000000           3776              MOVEA.L #0, A0                  
00003516  227C 00000000           3777              MOVEA.L #0, A1                  
0000351C  2205                    3778              MOVE.L  D5,D1
0000351E  EC89                    3779              LSR.L   #6,D1
00003520  0281 00000007           3780              ANDI.L  #$7,D1
00003526  0C01 0000               3781              CMPI.B  #0,D1   * Dn
0000352A  6700 0082               3782              BEQ     D_MODE000
0000352E  0C01 0002               3783              CMPI.B  #2,D1   * (An)
00003532  6700 00C2               3784              BEQ     D_MODE010
00003536  0C01 0003               3785              CMPI.B  #3,D1   * (An)+
0000353A  6700 011A               3786              BEQ     D_MODE011
0000353E  0C01 0004               3787              CMPI.B  #4,D1   * -(An)
00003542  6700 0132               3788              BEQ     D_MODE100
00003546  0C01 0007               3789              CMPI.B  #7,D1  * abs
0000354A  6700 017C               3790              BEQ     D_MODE111 
0000354E  4E75                    3791              RTS
00003550                          3792  
00003550                          3793  *---------------------------------------------------------------------------*
00003550                          3794  * SRC_MODE: decode and display source mode (bit 5 - 3)
00003550                          3795  *---------------------------------------------------------------------------*  
00003550                          3796  SRC_MODE    
00003550                          3797              * clear registers to store temp data
00003550  4280                    3798              CLR.L   D0                      
00003552  4281                    3799              CLR.L   D1                      
00003554  207C 00000000           3800              MOVEA.L #0, A0                  
0000355A  227C 00000000           3801              MOVEA.L #0, A1                  
00003560  2205                    3802              MOVE.L  D5,D1
00003562  E489                    3803              LSR.L   #2,D1
00003564  0281 0000000E           3804              ANDI.L  #$E,D1
0000356A                          3805              
0000356A  0C01 0000               3806              CMPI.B  #0,D1   * Dn
0000356E  6700 002A               3807              BEQ     MODE000
00003572  0C01 0002               3808              CMPI.B  #2,D1   * An 
00003576  6700 004A               3809              BEQ     MODE001
0000357A  0C01 0004               3810              CMPI.B  #4,D1   * (An)
0000357E  6700 0056               3811              BEQ     MODE010
00003582  0C01 0006               3812              CMPI.B  #6,D1   * (An)+
00003586  6700 008E               3813              BEQ     MODE011
0000358A  0C01 0008               3814              CMPI.B  #8,D1   * -(An)
0000358E  6700 00A6               3815              BEQ     MODE100
00003592  0C01 000F               3816              CMPI.B  #15,D1  * abs/immediate
00003596  6700 00FE               3817              BEQ     MODE111 
0000359A                          3818        
0000359A                          3819  *---------------------------------------------------------------------------*
0000359A                          3820  * MODE000: decode and display source mode Dn
0000359A                          3821  *---------------------------------------------------------------------------*           
0000359A                          3822  MODE000     *Dn
0000359A  43F9 00004B30           3823              LEA     DISP_D,A1
000035A0  103C 000E               3824              MOVE.B  #14,D0
000035A4  4E4F                    3825              TRAP    #15
000035A6  4EB9 00003838           3826              JSR     SRC_REGISTER
000035AC  4E75                    3827              RTS
000035AE                          3828  
000035AE                          3829  *---------------------------------------------------------------------------*
000035AE                          3830  * D_MODE000: decode and display dest mode Dn
000035AE                          3831  *---------------------------------------------------------------------------*
000035AE                          3832  D_MODE000     *Dn
000035AE  43F9 00004B30           3833              LEA     DISP_D,A1
000035B4  103C 000E               3834              MOVE.B  #14,D0
000035B8  4E4F                    3835              TRAP    #15
000035BA  4EB9 000037DC           3836              JSR     DEST_REGISTER
000035C0  4E75                    3837              RTS
000035C2                          3838  
000035C2                          3839  *---------------------------------------------------------------------------*
000035C2                          3840  * MODE001: decode and display source mode An
000035C2                          3841  *---------------------------------------------------------------------------* 
000035C2                          3842  MODE001 *An
000035C2  43F9 00004B35           3843              LEA     DISP_A,A1
000035C8  103C 000E               3844              MOVE.B  #14,D0
000035CC  4E4F                    3845              TRAP    #15
000035CE  4EB9 00003838           3846              JSR     SRC_REGISTER
000035D4                          3847          
000035D4  4E75                    3848              RTS
000035D6                          3849  
000035D6                          3850  *---------------------------------------------------------------------------*
000035D6                          3851  * MODE010: decode and display source mode (An)
000035D6                          3852  *---------------------------------------------------------------------------*    
000035D6                          3853  MODE010 *(An)
000035D6  43F9 00004B41           3854              LEA     DISP_AOP,A1  *display (A
000035DC  103C 000E               3855              MOVE.B  #14,D0
000035E0  4E4F                    3856              TRAP    #15
000035E2                          3857  
000035E2  4EB9 00003838           3858              JSR     SRC_REGISTER * display register
000035E8                          3859  
000035E8  43F9 00004B3F           3860              LEA     DISP_CP,A1   *display )
000035EE  103C 000E               3861              MOVE.B  #14,D0
000035F2  4E4F                    3862              TRAP    #15
000035F4                          3863              
000035F4  4E75                    3864              RTS
000035F6                          3865  
000035F6                          3866  *---------------------------------------------------------------------------*
000035F6                          3867  * D_MODE010: decode and display dest mode (An)
000035F6                          3868  *---------------------------------------------------------------------------*
000035F6                          3869  D_MODE010 *(An)
000035F6  43F9 00004B41           3870              LEA     DISP_AOP,A1  *display (A
000035FC  103C 000E               3871              MOVE.B  #14,D0
00003600  4E4F                    3872              TRAP    #15
00003602                          3873     
00003602  4EB9 000037DC           3874              JSR     DEST_REGISTER * display register
00003608                          3875  
00003608  43F9 00004B3F           3876              LEA     DISP_CP,A1   *display )
0000360E  103C 000E               3877              MOVE.B  #14,D0
00003612  4E4F                    3878              TRAP    #15
00003614                          3879              
00003614  4E75                    3880              RTS
00003616                          3881  
00003616                          3882  *---------------------------------------------------------------------------*
00003616                          3883  * MODE011: decode and display source mode (An)+
00003616                          3884  *---------------------------------------------------------------------------*
00003616                          3885  MODE011 *(An)+
00003616  43F9 00004B41           3886              LEA     DISP_AOP,A1      *display (A
0000361C  103C 000E               3887              MOVE.B  #14,D0
00003620  4E4F                    3888              TRAP    #15
00003622                          3889              
00003622  4EB9 00003838           3890              JSR     SRC_REGISTER    * display register
00003628                          3891  
00003628  43F9 00004B4E           3892              LEA     DISP_POST,A1    *display )+
0000362E  103C 000E               3893              MOVE.B  #14,D0
00003632  4E4F                    3894              TRAP    #15
00003634                          3895              
00003634  4E75                    3896              RTS
00003636                          3897              
00003636                          3898  *---------------------------------------------------------------------------*
00003636                          3899  * MODE100: decode and display source mode -(An)
00003636                          3900  *---------------------------------------------------------------------------*
00003636                          3901  MODE100 *-(An)
00003636  43F9 00004B47           3902              LEA     DISP_PRE,A1    *display -(A
0000363C  103C 000E               3903              MOVE.B  #14,D0
00003640  4E4F                    3904              TRAP    #15
00003642                          3905  
00003642  4EB9 00003838           3906              JSR     SRC_REGISTER    *display register
00003648                          3907  
00003648  43F9 00004B3F           3908              LEA     DISP_CP,A1   *display )
0000364E  103C 000E               3909              MOVE.B  #14,D0
00003652  4E4F                    3910              TRAP    #15
00003654                          3911              
00003654  4E75                    3912              RTS
00003656                          3913  
00003656                          3914  *---------------------------------------------------------------------------*
00003656                          3915  * D_MODE011: decode and display dest mode (An)+
00003656                          3916  *---------------------------------------------------------------------------*
00003656                          3917  D_MODE011 *(An)+
00003656  43F9 00004B41           3918              LEA     DISP_AOP,A1      *display (A
0000365C  103C 000E               3919              MOVE.B  #14,D0
00003660  4E4F                    3920              TRAP    #15
00003662                          3921  
00003662  4EB9 000037DC           3922              JSR     DEST_REGISTER    * display register
00003668                          3923  
00003668  43F9 00004B4E           3924              LEA     DISP_POST,A1    *display )+
0000366E  103C 000E               3925              MOVE.B  #14,D0
00003672  4E4F                    3926              TRAP    #15
00003674                          3927              
00003674  4E75                    3928              RTS
00003676                          3929              
00003676                          3930  *---------------------------------------------------------------------------*
00003676                          3931  * D_MODE100: decode and display dest mode -(An)
00003676                          3932  *---------------------------------------------------------------------------*            
00003676                          3933  D_MODE100 *-(An)
00003676  43F9 00004B47           3934              LEA     DISP_PRE,A1    *display -(A
0000367C  103C 000E               3935              MOVE.B  #14,D0
00003680  4E4F                    3936              TRAP    #15
00003682                          3937              
00003682  4EB9 000037DC           3938              JSR     DEST_REGISTER    *display register
00003688                          3939  
00003688  43F9 00004B3F           3940              LEA     DISP_CP,A1   *display )
0000368E  103C 000E               3941              MOVE.B  #14,D0
00003692  4E4F                    3942              TRAP    #15
00003694                          3943              
00003694  4E75                    3944              RTS
00003696                          3945  
00003696                          3946  *---------------------------------------------------------------------------*
00003696                          3947  * MODE111: decode and display source mode absolute/immediate
00003696                          3948  *---------------------------------------------------------------------------*
00003696                          3949  MODE111     * abs/immediate
00003696                          3950              * clear registers to store temp data
00003696  4280                    3951              CLR.L   D0                      
00003698  4281                    3952              CLR.L   D1                      
0000369A  207C 00000000           3953              MOVEA.L #0, A0                  
000036A0  227C 00000000           3954              MOVEA.L #0, A1                  
000036A6  2205                    3955              MOVE.L  D5,D1
000036A8                          3956              
000036A8                          3957              * retrieve source register for MODE 111
000036A8  E389                    3958              LSL.L   #1,D1   * shift the bits to left by 1
000036AA  0281 0000000E           3959              ANDI.L  #$E,D1  * mask the first 4 bits 
000036B0  0C01 0000               3960              CMPI.B  #0, D1  * if it's 0000, absolute word address
000036B4  6700 003E               3961              BEQ     WORDMODE
000036B8  0C01 0002               3962              CMPI.B  #2, D1  * if it's 0010, absolute long address
000036BC  6700 0062               3963              BEQ     LONGMODE
000036C0  0C01 0008               3964              CMPI.B  #8, D1  * if it's 1000, immediate data
000036C4  6700 0086               3965              BEQ     IMMEDIATE
000036C8                          3966       
000036C8                          3967  *---------------------------------------------------------------------------*
000036C8                          3968  * D_MODE111: decode and display dest mode absolute/immediate
000036C8                          3969  *---------------------------------------------------------------------------*           
000036C8                          3970  D_MODE111   * abs
000036C8                          3971              * clear registers to store temp data
000036C8  4280                    3972              CLR.L   D0                      
000036CA  4281                    3973              CLR.L   D1                      
000036CC  207C 00000000           3974              MOVEA.L #0, A0                  
000036D2  227C 00000000           3975              MOVEA.L #0, A1                  
000036D8  2205                    3976              MOVE.L  D5,D1
000036DA                          3977              
000036DA                          3978              * retrieve dest register for MODE 111
000036DA  EC89                    3979              LSR.L   #6,D1   * shift the bits to right by 6
000036DC  E689                    3980              LSR.L   #3,D1   * shift the bits to right by extra 3
000036DE  0201 0001               3981              ANDI.B  #1,D1   * mask the first 2 bits 
000036E2  0C01 0000               3982              CMPI.B  #0, D1  * if it's 000, absolute word address
000036E6  6700 000C               3983              BEQ     WORDMODE
000036EA  0C01 0001               3984              CMPI.B  #1, D1  * if it's 001, absolute long address
000036EE  6700 0030               3985              BEQ     LONGMODE
000036F2                          3986              *JSR     OP_DATA *not sure..
000036F2  4E75                    3987              RTS
000036F4                          3988  
000036F4                          3989  
000036F4                          3990  *---------------------------------------------------------------------------*
000036F4                          3991  * WORDMODE: absolute word address
000036F4                          3992  *---------------------------------------------------------------------------*
000036F4  43F9 00004B2B           3993  WORDMODE    LEA     DISP_HEX,A1
000036FA  103C 000E               3994              MOVE.B  #14,D0
000036FE  4E4F                    3995              TRAP    #15
00003700                          3996              
00003700  4285                    3997              CLR.L   D5
00003702  3A1D                    3998              MOVE.W  (A5)+,D5
00003704                          3999              
00003704  43F9 00004809           4000              LEA     TMPOUTPUT,A1
0000370A  2205                    4001              MOVE.L  D5,D1
0000370C  7404                    4002              MOVE.L  #4,D2       *move word size 4
0000370E  4EB8 1220               4003              JSR     HEX2ASCII
00003712  43F9 00004809           4004              LEA     TMPOUTPUT,A1
00003718  103C 000E               4005              MOVE.B  #14,D0
0000371C  4E4F                    4006              TRAP    #15
0000371E                          4007              
0000371E  4E75                    4008              RTS
00003720                          4009  
00003720                          4010  *---------------------------------------------------------------------------*
00003720                          4011  * LONGMODE: absolute long address
00003720                          4012  *---------------------------------------------------------------------------*
00003720  43F9 00004B2B           4013  LONGMODE    LEA     DISP_HEX,A1
00003726  103C 000E               4014              MOVE.B  #14,D0
0000372A  4E4F                    4015              TRAP    #15
0000372C                          4016              
0000372C  4285                    4017              CLR.L   D5
0000372E  2A1D                    4018              MOVE.L  (A5)+,D5
00003730                          4019              
00003730  43F9 00004809           4020              LEA     TMPOUTPUT,A1
00003736  2205                    4021              MOVE.L  D5,D1
00003738  7408                    4022              MOVE.L  #8,D2           *move longword size 8
0000373A  4EB8 1220               4023              JSR     HEX2ASCII
0000373E  43F9 00004809           4024              LEA     TMPOUTPUT,A1
00003744  103C 000E               4025              MOVE.B  #14,D0
00003748  4E4F                    4026              TRAP    #15
0000374A                          4027              
0000374A  4E75                    4028              RTS
0000374C                          4029  
0000374C                          4030  
0000374C                          4031  *---------------------------------------------------------------------------*
0000374C                          4032  * IMMEDIATE: immediate address
0000374C                          4033  *---------------------------------------------------------------------------*
0000374C  43F9 00004B51           4034  IMMEDIATE   LEA     DISP_LB,A1
00003752  103C 000E               4035              MOVE.B  #14,D0
00003756  4E4F                    4036              TRAP    #15
00003758  43F9 00004B2B           4037              LEA     DISP_HEX,A1
0000375E  103C 000E               4038              MOVE.B  #14,D0
00003762  4E4F                    4039              TRAP    #15
00003764                          4040              
00003764                          4041              * check for size
00003764  0C04 0000               4042              CMPI.B  #0,D4
00003768  6700 0012               4043              BEQ     IMMD_B
0000376C  0C04 0001               4044              CMPI.B  #1,D4
00003770  6700 002A               4045              BEQ     IMMD_W
00003774  0C04 0002               4046              CMPI.B  #2,D4
00003778  6700 0042               4047              BEQ     IMMD_L
0000377C                          4048  
0000377C                          4049  IMMD_B
0000377C  4285                    4050              CLR.L   D5
0000377E  3A1D                    4051              MOVE.W  (A5)+,D5
00003780                          4052              
00003780  43F9 00004809           4053              LEA     TMPOUTPUT,A1
00003786  2205                    4054              MOVE.L  D5,D1
00003788  7402                    4055              MOVE.L  #2,D2
0000378A  4EB8 1220               4056              JSR     HEX2ASCII
0000378E  43F9 00004809           4057              LEA     TMPOUTPUT,A1
00003794  103C 000E               4058              MOVE.B  #14,D0
00003798  4E4F                    4059              TRAP    #15
0000379A  4E75                    4060              RTS
0000379C                          4061              
0000379C                          4062  IMMD_W
0000379C  4285                    4063              CLR.L   D5
0000379E  3A1D                    4064              MOVE.W  (A5)+,D5
000037A0                          4065              
000037A0  43F9 00004809           4066              LEA     TMPOUTPUT,A1
000037A6  2205                    4067              MOVE.L  D5,D1
000037A8  7404                    4068              MOVE.L  #4,D2
000037AA  4EB8 1220               4069              JSR     HEX2ASCII
000037AE  43F9 00004809           4070              LEA     TMPOUTPUT,A1
000037B4  103C 000E               4071              MOVE.B  #14,D0
000037B8  4E4F                    4072              TRAP    #15
000037BA  4E75                    4073              RTS
000037BC                          4074              
000037BC                          4075  
000037BC                          4076  IMMD_L
000037BC  4285                    4077              CLR.L   D5
000037BE  3A1D                    4078              MOVE.W  (A5)+,D5
000037C0                          4079              
000037C0  43F9 00004809           4080              LEA     TMPOUTPUT,A1
000037C6  2205                    4081              MOVE.L  D5,D1
000037C8  7408                    4082              MOVE.L  #8,D2
000037CA  4EB8 1220               4083              JSR     HEX2ASCII
000037CE  43F9 00004809           4084              LEA     TMPOUTPUT,A1
000037D4  103C 000E               4085              MOVE.B  #14,D0
000037D8  4E4F                    4086              TRAP    #15
000037DA  4E75                    4087              RTS
000037DC                          4088  
000037DC                          4089  
000037DC                          4090  *---------------------------------------------------------------------------*
000037DC                          4091  * DEST_REGISTER: decode and display destination register (bit 11 - 9)
000037DC                          4092  *---------------------------------------------------------------------------*
000037DC                          4093  DEST_REGISTER
000037DC                          4094              * clear registers to store temp data
000037DC  4280                    4095              CLR.L   D0                      
000037DE  4281                    4096              CLR.L   D1                      
000037E0  207C 00000000           4097              MOVEA.L #0, A0                  
000037E6  227C 00000000           4098              MOVEA.L #0, A1 
000037EC                          4099              
000037EC  2205                    4100              MOVE.L  D5,D1
000037EE  EC89                    4101              LSR.L   #6,D1
000037F0  E689                    4102              LSR.L   #3,D1
000037F2  0281 00000007           4103              ANDI.L  #7,D1
000037F8                          4104              
000037F8  0C01 0000               4105              CMPI.B  #0,D1
000037FC  6700 0092               4106              BEQ     REG_0
00003800  0C01 0001               4107              CMPI.B  #1,D1
00003804  6700 0098               4108              BEQ     REG_1
00003808  0C01 0002               4109              CMPI.B  #2,D1
0000380C  6700 009E               4110              BEQ     REG_2
00003810  0C01 0003               4111              CMPI.B  #3,D1
00003814  6700 00A4               4112              BEQ     REG_3
00003818  0C01 0004               4113              CMPI.B  #4,D1
0000381C  6700 00AA               4114              BEQ     REG_4
00003820  0C01 0005               4115              CMPI.B  #5,D1
00003824  6700 00B0               4116              BEQ     REG_5
00003828  0C01 0006               4117              CMPI.B  #6,D1
0000382C  6700 00B6               4118              BEQ     REG_6
00003830  0C01 0007               4119              CMPI.B  #7,D1
00003834  6700 00BC               4120              BEQ     REG_7
00003838                          4121  
00003838                          4122  *---------------------------------------------------------------------------*
00003838                          4123  * SRC_REGISTER: decode and display source register (bit 2 - 0)
00003838                          4124  *---------------------------------------------------------------------------*           
00003838                          4125  SRC_REGISTER 
00003838                          4126              * clear registers to store temp data
00003838  4280                    4127              CLR.L   D0                      
0000383A  4281                    4128              CLR.L   D1                      
0000383C  207C 00000000           4129              MOVEA.L #0, A0                  
00003842  227C 00000000           4130              MOVEA.L #0, A1                  
00003848                          4131              
00003848  2205                    4132              MOVE.L  D5,D1   * temp store the processing data
0000384A  0281 00000007           4133              ANDI.L  #7,D1   * mask the first 4 bits with 0111
00003850                          4134              
00003850  0C01 0000               4135              CMPI.B  #0,D1
00003854  6700 003A               4136              BEQ     REG_0
00003858  0C01 0001               4137              CMPI.B  #1,D1
0000385C  6700 0040               4138              BEQ     REG_1
00003860  0C01 0002               4139              CMPI.B  #2,D1
00003864  6700 0046               4140              BEQ     REG_2
00003868  0C01 0003               4141              CMPI.B  #3,D1
0000386C  6700 004C               4142              BEQ     REG_3
00003870  0C01 0004               4143              CMPI.B  #4,D1
00003874  6700 0052               4144              BEQ     REG_4
00003878  0C01 0005               4145              CMPI.B  #5,D1
0000387C  6700 0058               4146              BEQ     REG_5
00003880  0C01 0006               4147              CMPI.B  #6,D1
00003884  6700 005E               4148              BEQ     REG_6
00003888  0C01 0007               4149              CMPI.B  #7,D1
0000388C  6700 0064               4150              BEQ     REG_7
00003890                          4151  
00003890                          4152  *---------------------------------------------------------------------------*
00003890                          4153  * REG_0 ~ REG_7: display register 0 to 7
00003890                          4154  *---------------------------------------------------------------------------*
00003890  43F9 00004B56           4155  REG_0       LEA     DISP_0,A1
00003896  103C 000E               4156              MOVE.B  #14,D0
0000389A  4E4F                    4157              TRAP    #15
0000389C  4E75                    4158              RTS
0000389E                          4159              
0000389E  43F9 00004B58           4160  REG_1       LEA     DISP_1,A1
000038A4  103C 000E               4161              MOVE.B  #14,D0
000038A8  4E4F                    4162              TRAP    #15
000038AA  4E75                    4163              RTS
000038AC                          4164              
000038AC                          4165  
000038AC  43F9 00004B5A           4166  REG_2       LEA     DISP_2,A1
000038B2  103C 000E               4167              MOVE.B  #14,D0
000038B6  4E4F                    4168              TRAP    #15
000038B8  4E75                    4169              RTS
000038BA                          4170            
000038BA  43F9 00004B5C           4171  REG_3       LEA     DISP_3,A1
000038C0  103C 000E               4172              MOVE.B  #14,D0
000038C4  4E4F                    4173              TRAP    #15
000038C6  4E75                    4174              RTS
000038C8                          4175              
000038C8  43F9 00004B5E           4176  REG_4       LEA     DISP_4,A1
000038CE  103C 000E               4177              MOVE.B  #14,D0
000038D2  4E4F                    4178              TRAP    #15
000038D4  4E75                    4179              RTS
000038D6                          4180              
000038D6  43F9 00004B60           4181  REG_5       LEA     DISP_5,A1
000038DC  103C 000E               4182              MOVE.B  #14,D0
000038E0  4E4F                    4183              TRAP    #15
000038E2  4E75                    4184              RTS
000038E4                          4185              
000038E4  43F9 00004B62           4186  REG_6       LEA     DISP_6,A1
000038EA  103C 000E               4187              MOVE.B  #14,D0
000038EE  4E4F                    4188              TRAP    #15
000038F0  4E75                    4189              RTS
000038F2                          4190              
000038F2  43F9 00004B64           4191  REG_7       LEA     DISP_7,A1
000038F8  103C 000E               4192              MOVE.B  #14,D0
000038FC  4E4F                    4193              TRAP    #15
000038FE  4E75                    4194              RTS
00003900                          4195              
00003900                          4196  *---------------------------------------------------------------------------*
00003900                          4197  * REPEAT : Ask user whether they wish to run the program again
00003900                          4198  *---------------------------------------------------------------------------*           
00003900  4246                    4199  REPEAT      CLR.W   D6                      * Reset D6 (Loop Count)
00003902  43F9 0000462F           4200              LEA     REPEATMSG,A1
00003908  103C 000E               4201              MOVE.B  #14,D0
0000390C  4E4F                    4202              TRAP    #15
0000390E                          4203              
0000390E  43F9 000047B9           4204              LEA     TMPINPUT,A1             * allocate space to temp store user input
00003914  103C 0002               4205              MOVE.B  #2,D0
00003918  4E4F                    4206              TRAP    #15
0000391A                          4207  
0000391A  0C01 0001               4208              CMPI.B  #1,D1                   * check for length of user input
0000391E  66E0                    4209              BNE     REPEAT                  * return to the beginning of the function if unequal
00003920                          4210              
00003920  0C11 0059               4211              CMPI.B  #$59,(A1)               * compare the input with Y    
00003924  6700 D6E4               4212              BEQ     PROGLP                  * repeat the program
00003928                          4213              
00003928  0C11 0079               4214              CMPI.B  #$79,(A1)               * compare the input with y    
0000392C  6700 D6DC               4215              BEQ     PROGLP                  * repeat the program
00003930                          4216              
00003930  0C11 004E               4217              CMPI.B  #$4E,(A1)               * compare the input with N    
00003934  6700 098C               4218              BEQ     TERMINATE               * finish program
00003938                          4219              
00003938  0C11 006E               4220              CMPI.B  #$6E,(A1)               * compare the input with n    
0000393C  6700 0984               4221              BEQ     TERMINATE               * finish program
00003940                          4222              
00003940  60BE                    4223              BRA     REPEAT                  * invalid input/repeat the function
00003942                          4224  
00003942                          4225  *---------------------------------------------------------------------------*
00003942                          4226  * EA DECODING INTERFACE
00003942                          4227  * [A0] - RESERVED FOR USE
00003942                          4228  * [D2] - RESERVED FOR USE
00003942                          4229  * RETURNS - ERROR FLAG IF FAILED TO PUSH SRC EA INTO STACK
00003942                          4230  *---------------------------------------------------------------------------*
00003942                          4231  GET_EA_EA_SRC
00003942                          4232      *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003942                          4233      
00003942                          4234      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003942  2405                    4235      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003944  E68A                    4236      LSR.L   #3,D2                           * [D2] Temporarily used D2 for shifting bits            *TODO: DYNAMIC FOR ANY LOCATION OF SOURCE
00003946  23C2 00004B7C           4237      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
0000394C  7407                    4238      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
0000394E  C5B9 00004B7C           4239      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003954                          4240                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003954                          4241      
00003954                          4242      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003954                          4243      *DESTINATION REGISTER FORMAT STANDARD         *
00003954                          4244      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003954                          4245      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003954                          4246      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003954                          4247      *0 - Dn                                       *
00003954                          4248      *1 - An                                       *
00003954                          4249      *2 - (An)                                     *
00003954                          4250      *3 - (An)+                                    *
00003954                          4251      *4 - -(An)                                    *
00003954                          4252      *5 - (XXX).W                                  *
00003954                          4253      *6 - (XXX).L                                  *
00003954                          4254      *7 - #<data>                                  *
00003954                          4255      ***********************************************
00003954                          4256      
00003954                          4257      *** Check if source ...  <ea> = Dn
00003954                          4258  CHECK0    
00003954  41F9 00004B6C           4259            LEA     TEMP_REGISTER_FORMAT,A0
0000395A  1439 00004B6B           4260            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003960  1082                    4261            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003962  0239 0001 00004B6C      4262            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
0000396A  0C39 0001 00004B6C      4263            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003972  6700 006A               4264            BEQ     CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003976  0CB9 00000000 00004B7C  4265            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003980  6600 005C               4266            BNE     CHECK1
00003984                          4267            
00003984                          4268            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003984  163C 0020               4269            MOVE.B    #' ',D3
00003988  6100 0856               4270            BSR       PUSH_STACK
0000398C  163C 0044               4271            MOVE.B    #'D',D3
00003990  6100 084E               4272            BSR       PUSH_STACK
00003994                          4273  
00003994                          4274            *FIND REGISTER NUMBER END LOCATION*  
00003994  13F9 00004B6E 00004B74  4275            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
0000399E  0239 000F 00004B74      4276            AND.B   #$0F,VAR_BYTE_END
000039A6                          4277            
000039A6                          4278            *GET INDEX OF THE END OF SRC REGISTER NUMBER
000039A6  23C5 00004B78           4279            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
000039AC  1439 00004B74           4280            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000039B2                          4281            
000039B2                          4282            *INTITIALIZE FOR BIT SHIFTING
000039B2  41F9 00004B78           4283            LEA     VAR_TEMP_CLEANCOPY,A0
000039B8  2639 00004B78           4284            MOVE.L  VAR_TEMP_CLEANCOPY,D3
000039BE                          4285  LOOP_SHIFTING
000039BE  0C02 0000               4286            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000039C2  6700 0008               4287            BEQ     MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000039C6  E24B                    4288            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000039C8  5302                    4289            SUB.B   #1,D2                     *DECREMENT COUNTER
000039CA  60F2                    4290            BRA     LOOP_SHIFTING             *CONTINUE SHIFTING
000039CC                          4291  MASKING_NEXT
000039CC  C6BC 00000007           4292            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
000039D2  0603 0030               4293            ADD.B   #$30,D3                   *CONVERT TO CHAR
000039D6  6100 0808               4294            BSR     PUSH_STACK                *PUSH TO STACK
000039DA                          4295            
000039DA  6000 0394               4296            BRA     GET_SRC_SUCCESS           *RETURN          
000039DE                          4297            
000039DE                          4298            
000039DE                          4299            *** Check if source ...  <ea> = An
000039DE  41F9 00004B6C           4300  CHECK1    LEA     TEMP_REGISTER_FORMAT,A0
000039E4  1439 00004B6B           4301            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000039EA  1082                    4302            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000039EC  0239 0002 00004B6C      4303            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
000039F4  0C39 0002 00004B6C      4304            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
000039FC  6700 006A               4305            BEQ     CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003A00  0CB9 00000001 00004B7C  4306            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003A0A  6600 005C               4307            BNE     CHECK2
00003A0E                          4308            
00003A0E                          4309            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003A0E  163C 0020               4310            MOVE.B    #' ',D3
00003A12  6100 07CC               4311            BSR       PUSH_STACK
00003A16  163C 0041               4312            MOVE.B    #'A',D3
00003A1A  6100 07C4               4313            BSR       PUSH_STACK
00003A1E                          4314  
00003A1E                          4315            
00003A1E                          4316            *FIND REGISTER NUMBER END LOCATION*  
00003A1E  13F9 00004B6E 00004B74  4317            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003A28  0239 000F 00004B74      4318            AND.B   #$0F,VAR_BYTE_END
00003A30                          4319            
00003A30                          4320            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003A30  23C5 00004B78           4321            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003A36  1439 00004B74           4322            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003A3C                          4323            
00003A3C                          4324            *INTITIALIZE FOR BIT SHIFTING
00003A3C  41F9 00004B78           4325            LEA     VAR_TEMP_CLEANCOPY,A0
00003A42  2639 00004B78           4326            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003A48                          4327  LOOP_SHIFTING1
00003A48  0C02 0000               4328            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003A4C  6700 0008               4329            BEQ     MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003A50  E24B                    4330            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003A52  5302                    4331            SUB.B   #1,D2                     *DECREMENT COUNTER
00003A54  60F2                    4332            BRA     LOOP_SHIFTING1             *CONTINUE SHIFTING
00003A56                          4333  MASKING_NEXT1
00003A56  C6BC 00000007           4334            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003A5C  0603 0030               4335            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003A60  6100 077E               4336            BSR     PUSH_STACK                *PUSH TO STACK
00003A64                          4337            
00003A64  6000 030A               4338            BRA     GET_SRC_SUCCESS                   *RETURN 
00003A68                          4339            
00003A68                          4340            
00003A68                          4341            
00003A68                          4342            
00003A68                          4343            *** Check if source ...  <ea> = (An)       
00003A68  41F9 00004B6C           4344  CHECK2    LEA     TEMP_REGISTER_FORMAT,A0
00003A6E  1439 00004B6B           4345            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003A74  1082                    4346            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003A76  0239 0004 00004B6C      4347            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003A7E  0C39 0004 00004B6C      4348            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003A86  6700 007A               4349            BEQ     CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003A8A  0CB9 00000002 00004B7C  4350            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003A94  6600 006C               4351            BNE     CHECK3
00003A98                          4352            
00003A98                          4353            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003A98  163C 0020               4354            MOVE.B    #' ',D3
00003A9C  6100 0742               4355            BSR       PUSH_STACK
00003AA0  163C 0028               4356            MOVE.B    #'(',D3
00003AA4  6100 073A               4357            BSR       PUSH_STACK
00003AA8  163C 0041               4358            MOVE.B    #'A',D3
00003AAC  6100 0732               4359            BSR       PUSH_STACK
00003AB0                          4360  
00003AB0                          4361            
00003AB0                          4362            *FIND REGISTER NUMBER END LOCATION*  
00003AB0  13F9 00004B6E 00004B74  4363            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003ABA  0239 000F 00004B74      4364            AND.B   #$0F,VAR_BYTE_END
00003AC2                          4365            
00003AC2                          4366            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003AC2  23C5 00004B78           4367            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003AC8  1439 00004B74           4368            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003ACE                          4369            
00003ACE                          4370            *INTITIALIZE FOR BIT SHIFTING
00003ACE  41F9 00004B78           4371            LEA     VAR_TEMP_CLEANCOPY,A0
00003AD4  2639 00004B78           4372            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003ADA                          4373  LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003ADA  0C02 0000               4374            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003ADE  6700 0008               4375            BEQ     MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003AE2  E24B                    4376            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003AE4  5302                    4377            SUB.B   #1,D2                     *DECREMENT COUNTER
00003AE6  60F2                    4378            BRA     LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003AE8                          4379  MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003AE8  0283 00000007           4380            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003AEE  0603 0030               4381            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003AF2  6100 06EC               4382            BSR     PUSH_STACK                *PUSH TO STACK
00003AF6                          4383            
00003AF6  163C 0029               4384            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003AFA  6100 06E4               4385            BSR       PUSH_STACK
00003AFE                          4386            
00003AFE  6000 0270               4387            BRA     GET_SRC_SUCCESS                   *RETURN 
00003B02                          4388  
00003B02                          4389            
00003B02                          4390            
00003B02                          4391                      
00003B02                          4392  *** Check if source ...  <ea> = (An)+       
00003B02  41F9 00004B6C           4393  CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003B08  1439 00004B6B           4394            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003B0E  1082                    4395            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003B10  0239 0008 00004B6C      4396            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003B18  0C39 0008 00004B6C      4397            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003B20  6700 0082               4398            BEQ     CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003B24  0CB9 00000003 00004B7C  4399            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003B2E  6600 0074               4400            BNE     CHECK4
00003B32                          4401            
00003B32                          4402            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003B32  163C 0020               4403            MOVE.B    #' ',D3
00003B36  6100 06A8               4404            BSR       PUSH_STACK
00003B3A  163C 0028               4405            MOVE.B    #'(',D3
00003B3E  6100 06A0               4406            BSR       PUSH_STACK
00003B42  163C 0041               4407            MOVE.B    #'A',D3
00003B46  6100 0698               4408            BSR       PUSH_STACK
00003B4A                          4409  
00003B4A                          4410            
00003B4A                          4411            *FIND REGISTER NUMBER END LOCATION*  
00003B4A  13F9 00004B6E 00004B74  4412            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003B54  0239 000F 00004B74      4413            ANDI.B   #$0F,VAR_BYTE_END
00003B5C                          4414            
00003B5C                          4415            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003B5C  23C5 00004B78           4416            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003B62  1439 00004B74           4417            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003B68                          4418            
00003B68                          4419            *INTITIALIZE FOR BIT SHIFTING
00003B68  41F9 00004B78           4420            LEA     VAR_TEMP_CLEANCOPY,A0
00003B6E  2639 00004B78           4421            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003B74                          4422            
00003B74                          4423  LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003B74  0C02 0000               4424            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003B78  6700 0008               4425            BEQ     MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003B7C  E24B                    4426            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003B7E  5302                    4427            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003B80  60F2                    4428            BRA     LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003B82                          4429                                               *change: NAME OF LABEL*
00003B82                          4430  MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003B82  0283 00000007           4431            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003B88  0603 0030               4432            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003B8C  6100 0652               4433            BSR     PUSH_STACK                *PUSH TO STACK
00003B90                          4434            
00003B90  163C 0029               4435            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003B94  6100 064A               4436            BSR       PUSH_STACK
00003B98  163C 002B               4437            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003B9C  6100 0642               4438            BSR       PUSH_STACK
00003BA0                          4439            
00003BA0  6000 01CE               4440            BRA       GET_SRC_SUCCESS                   *RETURN 
00003BA4                          4441  
00003BA4                          4442            
00003BA4                          4443            
00003BA4                          4444                      
00003BA4                          4445            *** Check if source ...  <ea> = -(An)       
00003BA4  41F9 00004B6C           4446  CHECK4    LEA     TEMP_REGISTER_FORMAT,A0
00003BAA  1439 00004B6B           4447            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003BB0  1082                    4448            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003BB2  0239 0010 00004B6C      4449            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003BBA  0C39 0010 00004B6C      4450            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003BC2  6700 0082               4451            BEQ     CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003BC6  0CB9 00000004 00004B7C  4452            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003BD0  6600 0074               4453            BNE     CHECK7
00003BD4                          4454            
00003BD4                          4455            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003BD4  163C 0020               4456            MOVE.B    #' ',D3
00003BD8  6100 0606               4457            BSR       PUSH_STACK
00003BDC  163C 002D               4458            MOVE.B    #'-',D3
00003BE0  6100 05FE               4459            BSR       PUSH_STACK
00003BE4  163C 0028               4460            MOVE.B    #'(',D3
00003BE8  6100 05F6               4461            BSR       PUSH_STACK
00003BEC  163C 0041               4462            MOVE.B    #'A',D3
00003BF0  6100 05EE               4463            BSR       PUSH_STACK
00003BF4                          4464  
00003BF4                          4465            
00003BF4                          4466            *FIND REGISTER NUMBER END LOCATION*  
00003BF4  13F9 00004B6E 00004B74  4467            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003BFE  0239 000F 00004B74      4468            AND.B   #$0F,VAR_BYTE_END
00003C06                          4469            
00003C06                          4470            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C06  23C5 00004B78           4471            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C0C  1439 00004B74           4472            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C12                          4473            
00003C12                          4474            *INTITIALIZE FOR BIT SHIFTING
00003C12  41F9 00004B78           4475            LEA     VAR_TEMP_CLEANCOPY,A0
00003C18  2639 00004B78           4476            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003C1E                          4477            
00003C1E                          4478  LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
00003C1E  0C02 0000               4479            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C22  6700 0008               4480            BEQ     MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003C26  E24B                    4481            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C28  5302                    4482            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003C2A  60F2                    4483            BRA     LOOP_SHIFTING4            *CONTINUE SHIFTING 
00003C2C                          4484                                               *change: NAME OF LABEL*
00003C2C                          4485  MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
00003C2C  0283 00000007           4486            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003C32  0603 0030               4487            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003C36  6100 05A8               4488            BSR     PUSH_STACK                *PUSH TO STACK
00003C3A                          4489            
00003C3A  163C 0029               4490            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003C3E  6100 05A0               4491            BSR       PUSH_STACK
00003C42                          4492            
00003C42  6000 012C               4493            BRA     GET_SRC_SUCCESS                   *RETURN
00003C46                          4494            
00003C46                          4495                      
00003C46                          4496            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00003C46  0CB9 00000007 00004B7C  4497  CHECK7    CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00003C50  6600 011A               4498            BNE     GET_SRC_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00003C54                          4499                   
00003C54                          4500            *NEXT: (MODE == 111) 
00003C54                          4501            *NOW: CHECK FOR SRC REGISTER 
00003C54                          4502                  *(000 = (xxx).W)
00003C54                          4503                  *(001 = (xxx).L)
00003C54                          4504                  *(010 = #<data>)
00003C54                          4505                  
00003C54                          4506            *FIND REGISTER NUMBER END LOCATION*  
00003C54  13F9 00004B6E 00004B74  4507            MOVE.B  GET_SRC_START_END, VAR_BYTE_END * GET ENDING INDEX
00003C5E  0239 000F 00004B74      4508            AND.B   #$0F,VAR_BYTE_END
00003C66                          4509            
00003C66                          4510            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003C66  23C5 00004B78           4511            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003C6C  1439 00004B74           4512            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003C72                          4513            
00003C72                          4514            *INTITIALIZE FOR BIT SHIFTING
00003C72  41F9 00004B78           4515            LEA     VAR_TEMP_CLEANCOPY,A0
00003C78  2C39 00004B78           4516            MOVE.L  VAR_TEMP_CLEANCOPY,D6
00003C7E                          4517  SRC_LOOP_SHIFTING
00003C7E  0C02 0000               4518            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003C82  6700 0008               4519            BEQ     SRC_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003C86  E24E                    4520            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003C88  5302                    4521            SUB.B   #1,D2                     *DECREMENT COUNTER
00003C8A  60F2                    4522            BRA     SRC_LOOP_SHIFTING             *CONTINUE SHIFTING
00003C8C                          4523  SRC_MASKING_NEXT
00003C8C  CCBC 00000007           4524            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
00003C92                          4525           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
00003C92                          4526           
00003C92                          4527  CHECK_WORD  
00003C92  41F9 00004B6C           4528            LEA     TEMP_REGISTER_FORMAT,A0
00003C98  1439 00004B6B           4529            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003C9E  1082                    4530            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CA0  0239 0020 00004B6C      4531            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
00003CA8  0C39 0020 00004B6C      4532            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CB0  6700 0026               4533            BEQ     CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003CB4  0C06 0000               4534            CMPI.B  #0,D6                          
00003CB8  6600 001E               4535            BNE     CHECK_LONG 
00003CBC                          4536            
00003CBC                          4537            *IT IS A WORD AT THIS POINT*
00003CBC                          4538            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003CBC  163C 0020               4539            MOVE.B    #' ',D3
00003CC0  6100 051E               4540            BSR       PUSH_STACK
00003CC4  163C 0024               4541            MOVE.B    #'$',D3
00003CC8  6100 0516               4542            BSR       PUSH_STACK
00003CCC  321D                    4543            MOVE.W    (A5)+,D1
00003CCE  7404                    4544            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003CD0  6100 D590               4545            BSR       HEX2ASCII2STACK
00003CD4  6000 009A               4546            BRA     GET_SRC_SUCCESS
00003CD8                          4547  
00003CD8                          4548  CHECK_LONG
00003CD8  41F9 00004B6C           4549            LEA     TEMP_REGISTER_FORMAT,A0
00003CDE  1439 00004B6B           4550            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003CE4  1082                    4551            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003CE6  0239 0040 00004B6C      4552            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003CEE  0C39 0040 00004B6C      4553            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003CF6  6700 002E               4554            BEQ     CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003CFA  0C06 0001               4555            CMPI.B  #1,D6                          
00003CFE  6600 0026               4556            BNE     CHECK_IMMEDIATE  
00003D02                          4557  
00003D02                          4558            *IT IS A WORD AT THIS POINT*
00003D02                          4559            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003D02  163C 0020               4560            MOVE.B    #' ',D3
00003D06  6100 04D8               4561            BSR       PUSH_STACK
00003D0A  163C 0024               4562            MOVE.B    #'$',D3
00003D0E  6100 04D0               4563            BSR       PUSH_STACK
00003D12  321D                    4564            MOVE.W    (A5)+,D1
00003D14  7404                    4565            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003D16  6100 D54A               4566            BSR       HEX2ASCII2STACK
00003D1A  321D                    4567            MOVE.W    (A5)+,D1
00003D1C  7404                    4568            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003D1E  6100 D542               4569            BSR       HEX2ASCII2STACK
00003D22  6000 004C               4570            BRA     GET_SRC_SUCCESS
00003D26                          4571            
00003D26                          4572  CHECK_IMMEDIATE
00003D26  41F9 00004B6C           4573            LEA     TEMP_REGISTER_FORMAT,A0
00003D2C  1439 00004B6B           4574            MOVE.B  SRC_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D32  1082                    4575            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D34  0239 0080 00004B6C      4576            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
00003D3C  0C39 0080 00004B6C      4577            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003D44  6700 0026               4578            BEQ     GET_SRC_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00003D48  0C06 0004               4579            CMPI.B  #4,D6                          
00003D4C  6600 001E               4580            BNE     GET_SRC_FAILED 
00003D50                          4581  
00003D50                          4582            *IT IS A WORD AT THIS POINT*
00003D50                          4583            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003D50  163C 0020               4584            MOVE.B    #' ',D3
00003D54  6100 048A               4585            BSR       PUSH_STACK
00003D58  163C 0023               4586            MOVE.B    #'#',D3
00003D5C  6100 0482               4587            BSR       PUSH_STACK
00003D60  321D                    4588            MOVE.W    (A5)+,D1
00003D62  7404                    4589            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00003D64  6100 D4FC               4590            BSR       HEX2ASCII2STACK
00003D68  6000 0006               4591            BRA     GET_SRC_SUCCESS
00003D6C                          4592            
00003D6C                          4593  GET_SRC_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
00003D6C  7801                    4594            MOVE.L #1,D4
00003D6E  4E75                    4595            RTS
00003D70                          4596  GET_SRC_SUCCESS 
00003D70  4E75                    4597            RTS
00003D72                          4598                                 
00003D72                          4599      
00003D72                          4600  
00003D72                          4601  
00003D72                          4602  
00003D72                          4603  
00003D72                          4604  
00003D72                          4605  
00003D72                          4606  GET_EA_EA_DEST
00003D72                          4607  *PRECONDITION: 16 BIT DECODE DATA MUST BE IN REGISTER [D5]*
00003D72                          4608      
00003D72                          4609      *DETERMINE ADDRESS MODE OF EA WITH THE MODE CODE 
00003D72  2405                    4610      MOVE.L  D5,D2                           * CLEAN COPY TO D2
00003D74  EC8A                    4611      LSR.L   #6,D2                           * [D2] Temporarily used D2 for shifting bits                *TODO: DYNAMIC MODE LOCATION
00003D76  23C2 00004B7C           4612      MOVE.L  D2,VAR_LONG_ADDRESS_MODE_CHECK  * BITS SHIFTED
00003D7C  7407                    4613      MOVE.L  #7,D2                           * SETTING UP MASKING FOR BITS (0-2)
00003D7E  C5B9 00004B7C           4614      AND.L   D2,VAR_LONG_ADDRESS_MODE_CHECK  * MASKED VARIABLE HOLDING ADDRESS MODE TO COMPARE
00003D84                          4615                                              * [COMPARE] MODE WITH POSSIBLE ADDRESS MODES
00003D84                          4616      
00003D84                          4617      *MUST SET DESTINATION_REGISTER_FORMAT BEFORE CALLING GET_EA_EA_SRC
00003D84                          4618      *DESTINATION REGISTER FORMAT STANDARD         *
00003D84                          4619      *WHEN BIT = 1(INVALID ADDRESS MODE)           *
00003D84                          4620      *WHEN BIT = 0(VALID ADDRESS MODE)             *
00003D84                          4621      *BIT LOCATIONS 0-7 INDICATE ADDRESS MODES     *
00003D84                          4622      *0 - Dn                                       *
00003D84                          4623      *1 - An                                       *
00003D84                          4624      *2 - (An)                                     *
00003D84                          4625      *3 - (An)+                                    *
00003D84                          4626      *4 - -(An)                                    *
00003D84                          4627      *5 - (XXX).W                                  *
00003D84                          4628      *6 - (XXX).L                                  *
00003D84                          4629      *7 - #<data>                                  *
00003D84                          4630      ***********************************************
00003D84                          4631      
00003D84                          4632      *** Check if source ...  <ea> = Dn
00003D84                          4633  DEST_CHECK0    
00003D84  41F9 00004B6C           4634            LEA     TEMP_REGISTER_FORMAT,A0
00003D8A  1439 00004B6A           4635            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003D90  1082                    4636            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003D92  0239 0001 00004B6C      4637            AND.B   #$01,TEMP_REGISTER_FORMAT                           * MASKS 0000 0001 
00003D9A  0C39 0001 00004B6C      4638            CMPI.B   #$01,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000001) THAN INVALID ADDRESSMODE 
00003DA2  6700 006A               4639            BEQ     DEST_CHECK1                                              * SINCE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003DA6  0CB9 00000000 00004B7C  4640            CMPI.L     #0,VAR_LONG_ADDRESS_MODE_CHECK                      * (Dn) - COMPARE MODES TO SEE IF IT IS THIS MODE
00003DB0  6600 005C               4641            BNE     DEST_CHECK1
00003DB4                          4642            
00003DB4                          4643            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003DB4  163C 0020               4644            MOVE.B    #' ',D3
00003DB8  6100 0426               4645            BSR       PUSH_STACK
00003DBC  163C 0044               4646            MOVE.B    #'D',D3
00003DC0  6100 041E               4647            BSR       PUSH_STACK
00003DC4                          4648  
00003DC4                          4649            *FIND REGISTER NUMBER END LOCATION*  
00003DC4  13F9 00004B6D 00004B74  4650            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003DCE  0239 000F 00004B74      4651            AND.B   #$0F,VAR_BYTE_END
00003DD6                          4652            
00003DD6                          4653            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003DD6  23C5 00004B78           4654            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003DDC  1439 00004B74           4655            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003DE2                          4656            
00003DE2                          4657            *INTITIALIZE FOR BIT SHIFTING
00003DE2  41F9 00004B78           4658            LEA     VAR_TEMP_CLEANCOPY,A0
00003DE8  2639 00004B78           4659            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003DEE                          4660  DEST_LOOP_SHIFTING
00003DEE  0C02 0000               4661            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003DF2  6700 0008               4662            BEQ     DEST_MASKING_NEXT              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003DF6  E24B                    4663            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003DF8  5302                    4664            SUB.B   #1,D2                     *DECREMENT COUNTER
00003DFA  60F2                    4665            BRA     DEST_LOOP_SHIFTING             *CONTINUE SHIFTING
00003DFC                          4666  DEST_MASKING_NEXT
00003DFC  C6BC 00000007           4667            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003E02  0603 0030               4668            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003E06  6100 03D8               4669            BSR     PUSH_STACK                *PUSH TO STACK
00003E0A                          4670            
00003E0A  6000 0394               4671            BRA     GET_DST_SUCCESS           *RETURN          
00003E0E                          4672            
00003E0E                          4673            
00003E0E                          4674            *** Check if source ...  <ea> = An
00003E0E                          4675  DEST_CHECK1    
00003E0E  41F9 00004B6C           4676            LEA     TEMP_REGISTER_FORMAT,A0
00003E14  1439 00004B6A           4677            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003E1A  1082                    4678            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003E1C  0239 0002 00004B6C      4679            AND.B   #$02,TEMP_REGISTER_FORMAT                           * MASKS 0000 0010 
00003E24  0C39 0002 00004B6C      4680            CMP.B   #$02,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE 
00003E2C  6700 006A               4681            BEQ     DEST_CHECK2                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON
00003E30  0CB9 00000001 00004B7C  4682            CMPI.L  #1,VAR_LONG_ADDRESS_MODE_CHECK                      * An - COMPARE MODES TO SEE IF IT IS THIS MODE
00003E3A  6600 005C               4683            BNE     DEST_CHECK2
00003E3E                          4684            
00003E3E                          4685            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00003E3E  163C 0020               4686            MOVE.B    #' ',D3
00003E42  6100 039C               4687            BSR       PUSH_STACK
00003E46  163C 0041               4688            MOVE.B    #'A',D3
00003E4A  6100 0394               4689            BSR       PUSH_STACK
00003E4E                          4690  
00003E4E                          4691            
00003E4E                          4692            *FIND REGISTER NUMBER END LOCATION*  
00003E4E  13F9 00004B6D 00004B74  4693            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003E58  0239 000F 00004B74      4694            AND.B   #$0F,VAR_BYTE_END
00003E60                          4695            
00003E60                          4696            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003E60  23C5 00004B78           4697            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003E66  1439 00004B74           4698            MOVE.B  VAR_BYTE_END,D2           *PUT END LOCATION INTO D2
00003E6C                          4699            
00003E6C                          4700            *INTITIALIZE FOR BIT SHIFTING
00003E6C  41F9 00004B78           4701            LEA     VAR_TEMP_CLEANCOPY,A0
00003E72  2639 00004B78           4702            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003E78                          4703  DEST_LOOP_SHIFTING1
00003E78  0C02 0000               4704            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003E7C  6700 0008               4705            BEQ     DEST_MASKING_NEXT1              *IF SHIFTING FINISHED MOVE ON TO MASKING 
00003E80  E24B                    4706            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003E82  5302                    4707            SUB.B   #1,D2                     *DECREMENT COUNTER
00003E84  60F2                    4708            BRA     DEST_LOOP_SHIFTING1             *CONTINUE SHIFTING
00003E86                          4709  DEST_MASKING_NEXT1
00003E86  C6BC 00000007           4710            AND.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003E8C  0603 0030               4711            ADD.B   #$30,D3                   *CONVERT TO CHAR
00003E90  6100 034E               4712            BSR     PUSH_STACK                *PUSH TO STACK
00003E94                          4713            
00003E94  6000 030A               4714            BRA     GET_DST_SUCCESS                   *RETURN 
00003E98                          4715            
00003E98                          4716            
00003E98                          4717            
00003E98                          4718            
00003E98                          4719            *** Check if source ...  <ea> = (An)       
00003E98                          4720  DEST_CHECK2    
00003E98  41F9 00004B6C           4721            LEA     TEMP_REGISTER_FORMAT,A0
00003E9E  1439 00004B6A           4722            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003EA4  1082                    4723            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003EA6  0239 0004 00004B6C      4724            ANDI.B   #$04,TEMP_REGISTER_FORMAT                           * MASKS 0000 0100                                                       *change <SRC>*
00003EAE  0C39 0004 00004B6C      4725            CMPI.B   #$04,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000100) THAN INVALID ADDRESSMODE       *change <SRC>*
00003EB6  6700 007A               4726            BEQ     DEST_CHECK3                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003EBA  0CB9 00000002 00004B7C  4727            CMPI.L   #2,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)  COMPARE MODES TO SEE IF IT IS THIS MODE                                                                *change: checkx++*
00003EC4  6600 006C               4728            BNE     DEST_CHECK3
00003EC8                          4729            
00003EC8                          4730            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003EC8  163C 0020               4731            MOVE.B    #' ',D3
00003ECC  6100 0312               4732            BSR       PUSH_STACK
00003ED0  163C 0028               4733            MOVE.B    #'(',D3
00003ED4  6100 030A               4734            BSR       PUSH_STACK
00003ED8  163C 0041               4735            MOVE.B    #'A',D3
00003EDC  6100 0302               4736            BSR       PUSH_STACK
00003EE0                          4737  
00003EE0                          4738            
00003EE0                          4739            *FIND REGISTER NUMBER END LOCATION*  
00003EE0  13F9 00004B6D 00004B74  4740            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003EEA  0239 000F 00004B74      4741            AND.B   #$0F,VAR_BYTE_END
00003EF2                          4742            
00003EF2                          4743            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003EF2  23C5 00004B78           4744            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003EF8  1439 00004B74           4745            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003EFE                          4746            
00003EFE                          4747            *INTITIALIZE FOR BIT SHIFTING
00003EFE  41F9 00004B78           4748            LEA     VAR_TEMP_CLEANCOPY,A0
00003F04  2639 00004B78           4749            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003F0A                          4750  DEST_LOOP_SHIFTING2                                                                                              *change: NAME OF LABEL*
00003F0A  0C02 0000               4751            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003F0E  6700 0008               4752            BEQ     DEST_MASKING_NEXT2             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003F12  E24B                    4753            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003F14  5302                    4754            SUB.B   #1,D2                     *DECREMENT COUNTER
00003F16  60F2                    4755            BRA     DEST_LOOP_SHIFTING2            *CONTINUE SHIFTING                                              *change: NAME OF LABEL*
00003F18                          4756  DEST_MASKING_NEXT2                                                                                               *change: NAME OF LABEL*
00003F18  0283 00000007           4757            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003F1E  0603 0030               4758            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003F22  6100 02BC               4759            BSR     PUSH_STACK                *PUSH TO STACK
00003F26                          4760            
00003F26  163C 0029               4761            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003F2A  6100 02B4               4762            BSR       PUSH_STACK
00003F2E                          4763            
00003F2E  6000 0270               4764            BRA     GET_DST_SUCCESS                   *RETURN 
00003F32                          4765  
00003F32                          4766            
00003F32                          4767            
00003F32                          4768                      
00003F32                          4769  *** Check if source ...  <ea> = (An)+       
00003F32  41F9 00004B6C           4770  DEST_CHECK3    LEA     TEMP_REGISTER_FORMAT,A0
00003F38  1439 00004B6A           4771            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003F3E  1082                    4772            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003F40  0239 0008 00004B6C      4773            ANDI.B  #$08,TEMP_REGISTER_FORMAT                           * MASKS 0000 1000                                                     *change <SRC>*
00003F48  0C39 0008 00004B6C      4774            CMPI.B  #$08,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 00000010) THAN INVALID ADDRESSMODE       *change <SRC>*
00003F50  6700 0082               4775            BEQ     DEST_CHECK4                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003F54  0CB9 00000003 00004B7C  4776            CMPI.L  #3,VAR_LONG_ADDRESS_MODE_CHECK                      * (An)+ - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00003F5E  6600 0074               4777            BNE     DEST_CHECK4
00003F62                          4778            
00003F62                          4779            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00003F62  163C 0020               4780            MOVE.B    #' ',D3
00003F66  6100 0278               4781            BSR       PUSH_STACK
00003F6A  163C 0028               4782            MOVE.B    #'(',D3
00003F6E  6100 0270               4783            BSR       PUSH_STACK
00003F72  163C 0041               4784            MOVE.B    #'A',D3
00003F76  6100 0268               4785            BSR       PUSH_STACK
00003F7A                          4786  
00003F7A                          4787            
00003F7A                          4788            *FIND REGISTER NUMBER END LOCATION*  
00003F7A  13F9 00004B6D 00004B74  4789            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
00003F84  0239 000F 00004B74      4790            ANDI.B   #$0F,VAR_BYTE_END
00003F8C                          4791            
00003F8C                          4792            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00003F8C  23C5 00004B78           4793            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
00003F92  1439 00004B74           4794            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00003F98                          4795            
00003F98                          4796            *INTITIALIZE FOR BIT SHIFTING
00003F98  41F9 00004B78           4797            LEA     VAR_TEMP_CLEANCOPY,A0
00003F9E  2639 00004B78           4798            MOVE.L  VAR_TEMP_CLEANCOPY,D3
00003FA4                          4799            
00003FA4                          4800  DEST_LOOP_SHIFTING3                                                                                              *change: NAME OF LABEL*
00003FA4  0C02 0000               4801            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00003FA8  6700 0008               4802            BEQ     DEST_MASKING_NEXT3             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00003FAC  E24B                    4803            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00003FAE  5302                    4804            SUBI.B   #1,D2                     *DECREMENT COUNTER
00003FB0  60F2                    4805            BRA     DEST_LOOP_SHIFTING3            *CONTINUE SHIFTING 
00003FB2                          4806                                               *change: NAME OF LABEL*
00003FB2                          4807  DEST_MASKING_NEXT3                                                                                               *change: NAME OF LABEL*
00003FB2  0283 00000007           4808            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00003FB8  0603 0030               4809            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00003FBC  6100 0222               4810            BSR     PUSH_STACK                *PUSH TO STACK
00003FC0                          4811            
00003FC0  163C 0029               4812            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003FC4  6100 021A               4813            BSR       PUSH_STACK
00003FC8  163C 002B               4814            MOVE.B    #'+',D3                 *FINISH PUSHING LAST ')' INTO STACK
00003FCC  6100 0212               4815            BSR       PUSH_STACK
00003FD0                          4816            
00003FD0  6000 01CE               4817            BRA       GET_DST_SUCCESS                   *RETURN 
00003FD4                          4818  
00003FD4                          4819            
00003FD4                          4820            
00003FD4                          4821                      
00003FD4                          4822            *** Check if source ...  <ea> = -(An)       
00003FD4                          4823  DEST_CHECK4    
00003FD4  41F9 00004B6C           4824            LEA     TEMP_REGISTER_FORMAT,A0
00003FDA  1439 00004B6A           4825            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00003FE0  1082                    4826            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00003FE2  0239 0010 00004B6C      4827            ANDI.B  #$10,TEMP_REGISTER_FORMAT                           * MASKS 0001 0000                                                     *change <SRC>*
00003FEA  0C39 0010 00004B6C      4828            CMPI.B  #$10,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0001 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00003FF2  6700 0082               4829            BEQ     DEST_CHECK7                                              * THE REGISTER FORMAT DOES NOT ALLOW "Dn" -> SO MOVE ON               *change: checkx++*
00003FF6  0CB9 00000004 00004B7C  4830            CMPI.L  #4,VAR_LONG_ADDRESS_MODE_CHECK                      * -(An) - COMPARE MODES TO SEE IF IT IS THIS MODE                                                                  *change: checkx++*
00004000  6600 0074               4831            BNE     DEST_CHECK7
00004004                          4832            
00004004                          4833            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"                                            *change CHARS TO PUSH*
00004004  163C 0020               4834            MOVE.B    #' ',D3
00004008  6100 01D6               4835            BSR       PUSH_STACK
0000400C  163C 002D               4836            MOVE.B    #'-',D3
00004010  6100 01CE               4837            BSR       PUSH_STACK
00004014  163C 0028               4838            MOVE.B    #'(',D3
00004018  6100 01C6               4839            BSR       PUSH_STACK
0000401C  163C 0041               4840            MOVE.B    #'A',D3
00004020  6100 01BE               4841            BSR       PUSH_STACK
00004024                          4842  
00004024                          4843            
00004024                          4844            *FIND REGISTER NUMBER END LOCATION*  
00004024  13F9 00004B6D 00004B74  4845            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000402E  0239 000F 00004B74      4846            AND.B   #$0F,VAR_BYTE_END
00004036                          4847            
00004036                          4848            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00004036  23C5 00004B78           4849            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000403C  1439 00004B74           4850            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
00004042                          4851            
00004042                          4852            *INTITIALIZE FOR BIT SHIFTING
00004042  41F9 00004B78           4853            LEA     VAR_TEMP_CLEANCOPY,A0
00004048  2639 00004B78           4854            MOVE.L  VAR_TEMP_CLEANCOPY,D3
0000404E                          4855            
0000404E                          4856  DEST_LOOP_SHIFTING4                                                                                              *change: NAME OF LABEL*
0000404E  0C02 0000               4857            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
00004052  6700 0008               4858            BEQ     DEST_MASKING_NEXT4             *IF SHIFTING FINISHED MOVE ON TO MASKING                        *change: NAME OF LABEL*
00004056  E24B                    4859            LSR     #1,D3                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
00004058  5302                    4860            SUBI.B   #1,D2                     *DECREMENT COUNTER
0000405A  60F2                    4861            BRA     DEST_LOOP_SHIFTING4            *CONTINUE SHIFTING 
0000405C                          4862                                               *change: NAME OF LABEL*
0000405C                          4863  DEST_MASKING_NEXT4                                                                                               *change: NAME OF LABEL*
0000405C  0283 00000007           4864            ANDI.L   #7,D3                     *MASK, ONLY NEED 0-2 BIT INDEXES
00004062  0603 0030               4865            ADDI.B   #$30,D3                   *CONVERT TO CHAR
00004066  6100 0178               4866            BSR     PUSH_STACK                *PUSH TO STACK
0000406A                          4867            
0000406A  163C 0029               4868            MOVE.B    #')',D3                 *FINISH PUSHING LAST ')' INTO STACK
0000406E  6100 0170               4869            BSR       PUSH_STACK
00004072                          4870            
00004072  6000 012C               4871            BRA     GET_DST_SUCCESS                   *RETURN
00004076                          4872            
00004076                          4873                      
00004076                          4874            *** Check if source ...  <ea> = (XXX).W or (XXX).L or #<data>
00004076                          4875  DEST_CHECK7    
00004076  0CB9 00000007 00004B7C  4876            CMPI.L  #7,VAR_LONG_ADDRESS_MODE_CHECK                      *IF (MODE != 111)
00004080  6600 011A               4877            BNE     GET_DST_FAILED                                      *THAN BRANCH TO UNCESSFULL SRC MODE READ
00004084                          4878                   
00004084                          4879            *NEXT: (MODE == 111) 
00004084                          4880            *NOW: CHECK FOR SRC REGISTER 
00004084                          4881                  *(000 = (xxx).W)
00004084                          4882                  *(001 = (xxx).L)
00004084                          4883                  *(010 = #<data>)
00004084                          4884                  
00004084                          4885            *FIND REGISTER NUMBER END LOCATION*  
00004084  13F9 00004B6D 00004B74  4886            MOVE.B  GET_DST_START_END, VAR_BYTE_END * GET ENDING INDEX
0000408E  0239 000F 00004B74      4887            AND.B   #$0F,VAR_BYTE_END
00004096                          4888            
00004096                          4889            *GET INDEX OF THE END OF SRC REGISTER NUMBER
00004096  23C5 00004B78           4890            MOVE.L  D5,VAR_TEMP_CLEANCOPY     *COPY DATA
0000409C  1439 00004B74           4891            MOVE.B  VAR_BYTE_END,D2          *PUT END LOCATION INTO D2
000040A2                          4892            
000040A2                          4893            *INTITIALIZE FOR BIT SHIFTING
000040A2  41F9 00004B78           4894            LEA     VAR_TEMP_CLEANCOPY,A0
000040A8  2C39 00004B78           4895            MOVE.L  VAR_TEMP_CLEANCOPY,D6
000040AE                          4896  DEST_LOOP_SHIFTING7
000040AE  0C02 0000               4897            CMPI.B   #0,D2                     *D2 - ACTS AS COUNTER TO HOW MANY SHIFTS TAKE PLACE
000040B2  6700 0008               4898            BEQ     DEST_MASKING_NEXT7              *IF SHIFTING FINISHED MOVE ON TO MASKING 
000040B6  E24E                    4899            LSR     #1,D6                     *SHIFT VAR_TEMP_CLEANCOPY UNTIL REGISTER IS COMPLETED
000040B8  5302                    4900            SUB.B   #1,D2                     *DECREMENT COUNTER
000040BA  60F2                    4901            BRA     DEST_LOOP_SHIFTING7             *CONTINUE SHIFTING
000040BC                          4902  DEST_MASKING_NEXT7
000040BC  CCBC 00000007           4903            AND.L   #7,D6                     *MASK, ONLY NEED 0-2 BIT INDEXES 
000040C2                          4904           *D3 - REGISTER NUMBER NEEDED TO CHECK WHICH W/L/#<DATA>*
000040C2                          4905            
000040C2                          4906  DEST_CHECK_WORD  
000040C2  41F9 00004B6C           4907            LEA     TEMP_REGISTER_FORMAT,A0
000040C8  1439 00004B6A           4908            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
000040CE  1082                    4909            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
000040D0  0239 0020 00004B6C      4910            ANDI.B  #$20,TEMP_REGISTER_FORMAT                           * MASKS 0010 0000                                                     *change <SRC>*
000040D8  0C39 0020 00004B6C      4911            CMPI.B  #$20,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0010 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
000040E0  6700 0026               4912            BEQ     DEST_CHECK_LONG                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
000040E4  0C06 0000               4913            CMPI.B  #0,D6                                                   *COMPARE REGISTER NUMBER WITH (000 == 000) FOR WORD
000040E8  6600 001E               4914            BNE     DEST_CHECK_LONG                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).W" -> SO MOVE ON       
000040EC                          4915            *IT IS A WORD AT THIS POINT*
000040EC                          4916            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
000040EC  163C 0020               4917            MOVE.B    #' ',D3
000040F0  6100 00EE               4918            BSR       PUSH_STACK
000040F4  163C 0024               4919            MOVE.B    #'$',D3
000040F8  6100 00E6               4920            BSR       PUSH_STACK
000040FC  321D                    4921            MOVE.W    (A5)+,D1
000040FE  7404                    4922            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00004100  6100 D160               4923            BSR       HEX2ASCII2STACK
00004104  6000 009A               4924            BRA       GET_DST_SUCCESS
00004108                          4925  
00004108                          4926  DEST_CHECK_LONG
00004108  41F9 00004B6C           4927            LEA     TEMP_REGISTER_FORMAT,A0
0000410E  1439 00004B6A           4928            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00004114  1082                    4929            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00004116  0239 0040 00004B6C      4930            ANDI.B  #$40,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000411E  0C39 0040 00004B6C      4931            CMPI.B  #$40,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00004126  6700 002E               4932            BEQ     DEST_CHECK_IMMEDIATE                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
0000412A  0C06 0001               4933            CMPI.B  #1,D6                                                   *COMPARE REGISTER NUMBER WITH (001 == 001) FOR WORD
0000412E  6600 0026               4934            BNE     DEST_CHECK_IMMEDIATE                                      * THE REGISTER NUMBER DOESN'T MATCH "(XXX).L" -> SO MOVE ON 
00004132                          4935            *IT IS A WORD AT THIS POINT*
00004132                          4936            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00004132  163C 0020               4937            MOVE.B    #' ',D3
00004136  6100 00A8               4938            BSR       PUSH_STACK
0000413A  163C 0024               4939            MOVE.B    #'$',D3
0000413E  6100 00A0               4940            BSR       PUSH_STACK
00004142  321D                    4941            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
00004144  7404                    4942            MOVE.L    #4,D2           * SETS SIZE = 4 FOR CONVERSION TO ASCII
00004146  6100 D11A               4943            BSR       HEX2ASCII2STACK
0000414A  321D                    4944            MOVE.W    (A5)+,D1        * GET NEXT WORD INTO STACK
0000414C  7404                    4945            MOVE.L    #4,D2          
0000414E  6100 D112               4946            BSR       HEX2ASCII2STACK
00004152  6000 004C               4947            BRA     GET_DST_SUCCESS
00004156                          4948            
00004156                          4949  DEST_CHECK_IMMEDIATE
00004156  41F9 00004B6C           4950            LEA     TEMP_REGISTER_FORMAT,A0
0000415C  1439 00004B6A           4951            MOVE.B  DEST_REGISTER_FORMAT, D2                             *COPY FORMAT TO TEMP VARIABLE
00004162  1082                    4952            MOVE.B  D2, (A0)                                            *COPY FORMAT TO TEMP VARIABLE
00004164  0239 0080 00004B6C      4953            ANDI.B  #$80,TEMP_REGISTER_FORMAT                           * MASKS 0100 0000                                                     *change <SRC>*
0000416C  0C39 0080 00004B6C      4954            CMPI.B  #$80,TEMP_REGISTER_FORMAT                           * IF(TEMP_REGISTER_FORMAT == 0100 0000) THAN INVALID ADDRESSMODE       *change <SRC>*
00004174  6700 0026               4955            BEQ     GET_DST_FAILED                                      * THE REGISTER FORMAT DOES NOT ALLOW "(XXX).W" -> SO MOVE ON               *change: checkx++*
00004178  0C06 0004               4956            CMPI.B  #4,D6                                               * COMPARE REGISTER NUMBER WITH (010 == 010) FOR WORD
0000417C  6600 001E               4957            BNE     GET_DST_FAILED                                      * THE REGISTER NUMBER DOESN'T MATCH "#<DATA>" -> SO MOVE ON 
00004180                          4958            
00004180                          4959            *IT IS A WORD AT THIS POINT*
00004180                          4960            *PUSH "Dn" INTO STACK, BUT FIND MAKE SURE TO FIND "n"
00004180  163C 0020               4961            MOVE.B    #' ',D3
00004184  6100 005A               4962            BSR       PUSH_STACK
00004188  163C 0023               4963            MOVE.B    #'#',D3
0000418C  6100 0052               4964            BSR       PUSH_STACK
00004190  321D                    4965            MOVE.W    (A5)+,D1
00004192  7404                    4966            MOVE.L    #4,D2           *SIZE INITIALIZED FOR CONVERSION
00004194  6100 D0CC               4967            BSR       HEX2ASCII2STACK
00004198  6000 0006               4968            BRA       GET_DST_SUCCESS
0000419C                          4969            
0000419C                          4970  GET_DST_FAILED    *SEND ERROR FLAG THAN CLEAN ALL REGISTERS/VARIABLES THAN PRINT OP_DATA
0000419C  7801                    4971            MOVE.L #1,D4
0000419E  4E75                    4972            RTS
000041A0                          4973  GET_DST_SUCCESS 
000041A0  4E75                    4974            RTS
000041A2                          4975  
000041A2                          4976  
000041A2                          4977  *---------------------------------------------------------------------------*
000041A2                          4978  * STACK/QUEUE INTERFACE
000041A2                          4979  *---------------------------------------------------------------------------*
000041A2                          4980  PRINT_STACK
000041A2  0C39 0000 00004B66      4981            CMP.B     #0,COUNTER
000041AA  6700 000E               4982            BEQ       PRINT_STACK_RETURN             *CHECK IF LOOP IS FINISHED
000041AE                          4983            
000041AE                          4984  PRINT_STACK_HELPER
000041AE  6100 0038               4985            BSR      POP_STACK          *PRINTS ADDRESS
000041B2  103C 0006               4986            MOVE.B   #6,D0              *Display single character in D1.B. 
000041B6  4E4F                    4987            TRAP     #15             *ACTIVATES PRINT
000041B8                          4988  
000041B8  60E8                    4989            BRA       PRINT_STACK
000041BA                          4990  PRINT_STACK_RETURN
000041BA  4E75                    4991            RTS
000041BC                          4992            
000041BC                          4993            
000041BC                          4994  PRINT_QUEUE
000041BC  0C39 0000 00004B66      4995            CMP.B     #0,COUNTER
000041C4  6700 0018               4996            BEQ       PRINT_QUEUE_RETURN             *CHECK IF LOOP IS FINISHED
000041C8                          4997            
000041C8                          4998  PRINT_QUEUE_HELPER
000041C8  33F9 00004B66 00004B68  4999            MOVE.W   COUNTER,QUEUE_COUNTER
000041D2  6100 0022               5000            BSR      POP_FRONT          *PRINTS ADDRESS
000041D6  103C 0006               5001            MOVE.B   #6,D0              *Display single character in D1.B. 
000041DA  4E4F                    5002            TRAP     #15             *ACTIVATES PRINT
000041DC                          5003  
000041DC  60DE                    5004            BRA       PRINT_QUEUE
000041DE                          5005  PRINT_QUEUE_RETURN
000041DE  4E75                    5006            RTS
000041E0                          5007            
000041E0                          5008  *PUSHES.W CONTENTS OF [D3] INTO STACK          
000041E0                          5009  PUSH_STACK
000041E0  1503                    5010              MOVE.B  D3,-(A2)
000041E2  6100 0058               5011              BSR     INCREMENT
000041E6  4E75                    5012              RTS
000041E8                          5013  *POPS.W TOP OF STACK INTO [D1], SO ITS READY TO PRINT WITH TRAP 15
000041E8                          5014  *         MOVE.W   (A2)+,D1           *PRINTS ADDRESS
000041E8                          5015  *         MOVE.B   #15,D0             *PRINTS ACCORDING TO D2 BASE VALUE
000041E8                          5016  *         MOVE.B   #16,D2             *PRINTS BASED 16 NUMBER
000041E8                          5017  *         TRAP        #15             *ACTIVATES PRINT
000041E8                          5018  POP_STACK
000041E8  BECA                    5019              CMPA.W   A2,SP            *CHECKS IF THERE IS ANYTHING TO PUSH
000041EA  6700 0008               5020              BEQ     POP_RETURN        *IF NOTHING TO PUSH THAN JUST RETURN
000041EE  121A                    5021              MOVE.B  (A2)+,D1 
000041F0  6100 0052               5022              BSR     DECREMENT
000041F4                          5023  POP_RETURN
000041F4  4E75                    5024              RTS 
000041F6                          5025        
000041F6                          5026  *USE [A4] AS SECOND POINTER IN SHIFTING      
000041F6  0C39 0000 00004B68      5027  POP_FRONT   CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
000041FE  6700 0030               5028              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
00004202                          5029              
00004202                          5030              
00004202                          5031              *POSITION THE POINTERS A[4] RIGHT BEHIND A[2] WHICH IS RIGHT BEHIND STACK
00004202  347C 7000               5032              MOVEA.W #STACK,A2   *START A2 AT STACK
00004206  0622 0000               5033              ADD.B   #0,-(A2)    *SHIFT A2 TO THE BOTTOM OF THE STACK
0000420A  384A                    5034              MOVEA.W A2,A4     *START A4 RIGHT ABOVE A2
0000420C  0624 0000               5035              ADD.B   #0,-(A4)  *leash one more higher in stack (a4)
00004210  1212                    5036              MOVE.B  (A2),D1     *POP CONTENTS INTO D1
00004212                          5037  POP_SHIFT_LOOP
00004212  0C39 0000 00004B68      5038              CMP.B   #0,QUEUE_COUNTER            *CHECKS IF
0000421A  6700 0014               5039              BEQ     POP_FRONT_RETURN            *END LOOP ONCE COUNTER REACHES ZERO
0000421E  1494                    5040              MOVE.B  (A4),(A2)   *SHIFT CONTENT DOWN THE STACK
00004220  0624 0000               5041              ADD.B   #0,-(A4)
00004224  0622 0000               5042              ADD.B   #0,-(A2) *SHIFT POINTERS DOWN THE STACK
00004228  5339 00004B68           5043              SUB.B   #1,QUEUE_COUNTER *DECREMENT INTERNAL QUEUE COUNTER
0000422E                          5044              
0000422E  60E2                    5045              BRA     POP_SHIFT_LOOP
00004230                          5046                          
00004230                          5047  POP_FRONT_RETURN 
00004230                          5048              *RESET A2 BACK TO SP
00004230  347C 7000               5049              MOVEA.W #STACK,A2    
00004234  5339 00004B66           5050              SUB.B   #1,COUNTER *DECREMENT STACK COUNTER       
0000423A  4E75                    5051              RTS   
0000423C                          5052  
0000423C                          5053  INCREMENT
0000423C  5239 00004B66           5054              ADD.B   #1, COUNTER
00004242  4E75                    5055              RTS           
00004244                          5056  DECREMENT
00004244  5339 00004B66           5057              SUB.B   #1, COUNTER
0000424A  4E75                    5058              RTS           
0000424C                          5059  CLEAR_STACK
0000424C  0C39 0000 00004B66      5060              CMP.B     #0,COUNTER
00004254  6700 0006               5061              BEQ       CLEAR_RETURN
00004258  618E                    5062              BSR       POP_STACK
0000425A  60F0                    5063              BRA       CLEAR_STACK
0000425C                          5064   
0000425C                          5065  CLEAR_RETURN
0000425C  4E75                    5066              RTS    
0000425E                          5067              
0000425E                          5068  *---------------------------------------------------------------------------*
0000425E                          5069  * 8/16/32-bit Address getter
0000425E                          5070  *---------------------------------------------------------------------------*
0000425E                          5071  *get displacement value from bits 0 to 8
0000425E                          5072  *if displacement is not $00, than it is 8 otherwise check for word
0000425E                          5073  *if displacement is not $FF, than it is a long
0000425E                          5074  *add the displacement to the current address being processed + a word
0000425E                          5075  *place results into D3, so that it can be pushed to stack
0000425E                          5076  GET_DISPLACEMENT_ADDRESS
0000425E  2805                    5077              MOVE.L  D5,D4                   * COPIES DATA INTO D6
00004260  0286 000000FF           5078              ANDI.L  #$00FF,D6               * MASKS DATA
00004266  0C84 00000000           5079              CMPI.L  #$00,D4                 * COMPARES DATA IF IT IS WORD
0000426C  6700 0022               5080              BEQ     GET_DISPLACEMENT_WORD
00004270  0C84 000000FF           5081              CMPI.L  #$FF,D4                 * COMPARES DATA IF IT IS LONG
00004276  6700 0030               5082              BEQ     GET_DISPLACEMENT_LONG
0000427A                          5083              
0000427A  2E3C 00000100           5084              MOVE.L  #$100,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00004280  9E04                    5085              SUB.B   D4,D7
00004282                          5086              
00004282  280D                    5087              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
00004284  9807                    5088              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
00004286  7404                    5089              MOVE.L  #4,D2
00004288  2204                    5090              MOVE.L  D4,D1  
0000428A  6100 CFD6               5091              BSR     HEX2ASCII2STACK
0000428E  4E75                    5092              RTS
00004290                          5093              
00004290                          5094  GET_DISPLACEMENT_WORD
00004290  2E3C 000000FF           5095              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
00004296  9E04                    5096              SUB.B   D4,D7
00004298                          5097              
00004298  280D                    5098              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
0000429A  9807                    5099              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
0000429C  7404                    5100              MOVE.L  #4,D2
0000429E  2604                    5101              MOVE.L  D4,D3
000042A0  2204                    5102              MOVE.L  D4,D1
000042A2  6100 CFBE               5103              BSR     HEX2ASCII2STACK
000042A6  4E75                    5104              RTS     
000042A8                          5105  GET_DISPLACEMENT_LONG   
000042A8  2E3C 000000FF           5106              MOVE.L  #$FF,D7                 *FILL D7 WITH FF SO THAT IT CAN BE SUBTRACTED BY THE DISPLACEMENT GIVING US THE REAL DISPLACEMENT
000042AE  9E04                    5107              SUB.B   D4,D7
000042B0                          5108              
000042B0  280D                    5109              MOVE.L  A5,D4                   * PC+2 ADDRESS INTO D6
000042B2  9807                    5110              SUB.B   D7,D4                   * SUBTRACT "DISPLACEMENT + 2 " TO GET THE ORIGINAL ADDRESS BEING BRANCH TO
000042B4  7408                    5111              MOVE.L  #8,D2
000042B6  2604                    5112              MOVE.L  D4,D3                   * PREPARE TO PUSH
000042B8  2204                    5113              MOVE.L  D4,D1
000042BA  6100 CFA6               5114              BSR     HEX2ASCII2STACK
000042BE                          5115  
000042BE  4284                    5116              CLR.L   D4
000042C0  4E75                    5117              RTS
000042C2                          5118  
000042C2                          5119  *---------------------------------------------------------------------------*
000042C2                          5120  * TERMINATE
000042C2                          5121  *---------------------------------------------------------------------------*
000042C2                          5122  TERMINATE   
000042C2  43F9 00004672           5123              LEA     FINMSG,A1
000042C8  103C 000E               5124              MOVE.B  #14,D0
000042CC  4E4F                    5125              TRAP    #15
000042CE                          5126  
000042CE  103C 0009               5127              MOVE.B  #9,D0
000042D2  4E4F                    5128              TRAP    #15
000042D4                          5129  
000042D4                          5130  *---------------------------------------------------------------------------*
000042D4                          5131  * Data storage                                                 
000042D4                          5132  *---------------------------------------------------------------------------*  
000042D4                          5133  WELCOME
000042D4= 20 20 20 20 20 20 ...   5134              DC.B '                         ___     ___ ___        ___   ___ ___                 ',CR,LF
00004324= 3D 3D 3D 3D 3D 20 ...   5135              DC.B '=====           \  /\  /|___|   |   |   ||\  /||___    | |   |           =====',CR,LF
00004374= 3D 3D 3D 3D 3D 20 ...   5136              DC.B '=====            \/  \/ |___|___|___|___|| \/ ||___    | |___|           =====',CR,LF
000043C4                          5137      
000043C4= 20 20 20 20 20 20 ...   5138              DC.B '                        ___ ___ ___  ___      ___                             ',CR,LF
00004414= 20 20 20 20 20 20 ...   5139              DC.B '                       |     | |___)|    |   |___                             ',CR,LF 
00004464= 20 20 20 20 20 20 ...   5140              DC.B '                       |___ _|_|\___|___ |___|___                             ',CR,LF
000044B4                          5141      
000044B4= 20 20 20 20 20 20 ...   5142              DC.B '           __  ___ ___   _   ___  ___  ___        ___      ___ ___            ',CR,LF
00004504= 3D 3D 3D 3D 3D 20 ...   5143              DC.B '=====     |  \  | |___  /_\ |___ |___ |___ |\  /||___||   |___|___)      =====',CR,LF 
00004554= 3D 3D 3D 3D 3D 20 ...   5144              DC.B '=====     |__/ _|_ ___|/   \ ___| ___||___ | \/ ||___||___|___|\___      =====',CR,LF,CR,LF,CR,LF,0
000045A9                          5145  
000045A9                          5146  PROMPT_START
000045A9= 50 6C 65 61 73 65 ...   5147              DC.B    'Please enter a hexadecimal starting address.',CR,LF,0
000045D8                          5148      
000045D8                          5149  PROMPT_END
000045D8= 50 6C 65 61 73 65 ...   5150              DC.B    'Please enter a hexadecimal ending address.',CR,LF,0
00004605= 0D 0A 48 69 74 20 ...   5151  DISP_NEXT   DC.B    CR,LF,'Hit Enter to print the next 30 lines.',CR,LF,0            
0000462F= 57 6F 75 6C 64 20 ...   5152  REPEATMSG   DC.B    'Would you like to run again? Press Y to continue or N to finish.',CR,LF,0
00004672= 54 68 61 6E 6B 20 ...   5153  FINMSG      DC.B    'Thank you for using Circle Disassembler.',CR,LF,0
0000469D= 45 72 72 6F 72 3A ...   5154  ERRMSG_1    DC.B    'Error: Invalid Input Address',CR,LF,0
000046BC= 45 72 72 6F 72 3A ...   5155  ERRMSG_3    DC.B    'Error: Invalid Input Address (Odd)',CR,LF,0
000046E1= 45 72 72 6F 72 3A ...   5156  ERRMSG_5    DC.B    'Error: Invalid Input Address (start > end)',CR,LF,0
0000470E                          5157  
0000470E                          5158  VR_S_ADDR   DS.B    80                      * allocate storage space for the starting address
0000475E                          5159  VR_E_ADDR   DS.B    80                      * allocate storage space for the ending address
000047AE                          5160  S_ADDR_HX   DS.L    1                       * allocate storage space for the starting address in hex
000047B2                          5161  E_ADDR_HX   DS.L    1                       * allocate storage space for the ending address in hex
000047B6= 0D 0A 00                5162  ENDLINE_M   DC.B    CR,LF,0
000047B9                          5163  TMPINPUT    DS.B    80                      * temp store user input
00004809                          5164  TMPOUTPUT   DS.B    80                      * temp store prog output
00004859= 20 20 20 4F 52 49 ...   5165  DISP_ORI_B  DC.B    '   ORI.B',0
00004862= 20 20 20 4F 52 49 ...   5166  DISP_ORI_W  DC.B    '   ORI.W',0
0000486B= 20 20 20 4F 52 49 ...   5167  DISP_ORI_L  DC.B    '   ORI.L',0
00004874= 20 20 20 45 4F 52 ...   5168  DISP_EORI_B  DC.B    '   EORI.B',0
0000487E= 20 20 20 45 4F 52 ...   5169  DISP_EORI_W  DC.B    '   EORI.W',0
00004888= 20 20 20 45 4F 52 ...   5170  DISP_EORI_L  DC.B    '   EORI.L',0
00004892= 20 20 20 42 54 53 ...   5171  DISP_BTST   DC.B    '   BTST',0
0000489A= 20 20 20 43 4D 50 ...   5172  DISP_CMPI_B  DC.B    '   CMPI.B',0
000048A4= 20 20 20 43 4D 50 ...   5173  DISP_CMPI_W  DC.B    '   CMPI.W',0
000048AE= 20 20 20 43 4D 50 ...   5174  DISP_CMPI_L  DC.B    '   CMPI.L',0
000048B8= 20 20 20 44 41 54 ...   5175  DISP_DATA   DC.B    '   DATA',0
000048C0= 20 20 20 4D 4F 56 ...   5176  DISP_MOVE_B DC.B    '   MOVE.B',0
000048CA= 20 20 20 4D 4F 56 ...   5177  DISP_MOVE_W DC.B    '   MOVE.W',0
000048D4= 20 20 20 4D 4F 56 ...   5178  DISP_MOVE_L DC.B    '   MOVE.L',0
000048DE= 20 20 20 52 54 53 00    5179  DISP_RTS    DC.B    '   RTS',0
000048E5= 20 20 20 4A 53 52 00    5180  DISP_JSR    DC.B    '   JSR',0
000048EC= 20 20 20 4E 45 47 ...   5181  DISP_NEG_B    DC.B    '   NEG.B',0
000048F5= 20 20 20 4E 45 47 ...   5182  DISP_NEG_W    DC.B    '   NEG.W',0
000048FE= 20 20 20 4E 45 47 ...   5183  DISP_NEG_L    DC.B    '   NEG.L',0
00004907= 20 20 20 4E 4F 54 ...   5184  DISP_NOT_B  DC.B    '   NOT.B',0
00004910= 20 20 20 4E 4F 54 ...   5185  DISP_NOT_W  DC.B    '   NOT.W',0
00004919= 20 20 20 4E 4F 54 ...   5186  DISP_NOT_L  DC.B    '   NOT.L',0
00004922= 20 20 20 4C 45 41 00    5187  DISP_LEA    DC.B    '   LEA',0
00004929= 20 20 20 4D 4F 56 ...   5188  DISP_MOVEM_W    DC.B    '   MOVEM.W',0
00004934= 20 20 20 4D 4F 56 ...   5189  DISP_MOVEM_L    DC.B    '   MOVEM.L',0
0000493F= 20 20 20 41 44 44 ...   5190  DISP_ADDQ_B DC.B    '   ADDQ.B',0
00004949= 20 20 20 41 44 44 ...   5191  DISP_ADDQ_W DC.B    '   ADDQ.W',0
00004953= 20 20 20 41 44 44 ...   5192  DISP_ADDQ_L DC.B    '   ADDQ.L',0
0000495D= 20 20 20 44 49 56 ...   5193  DISP_DIVS   DC.B    '   DIVS',0
00004965= 20 20 20 53 55 42 ...   5194  DISP_SUB_B  DC.B    '   SUB.B',0
0000496E= 20 20 20 53 55 42 ...   5195  DISP_SUB_W  DC.B    '   SUB.W',0
00004977= 20 20 20 53 55 42 ...   5196  DISP_SUB_L  DC.B    '   SUB.L',0
00004980= 20 20 20 53 55 42 ...   5197  DISP_SUBI_B  DC.B    '   SUBI.B',0
0000498A= 20 20 20 53 55 42 ...   5198  DISP_SUBI_W  DC.B    '   SUBI.W',0
00004994= 20 20 20 53 55 42 ...   5199  DISP_SUBI_L  DC.B    '   SUBI.L',0
0000499E= 20 20 20 53 55 42 ...   5200  DISP_SUBA_W  DC.B    '   SUBA.W',0
000049A8= 20 20 20 53 55 42 ...   5201  DISP_SUBA_L  DC.B    '   SUBA.L',0
000049B2= 20 20 20 45 4F 52 ...   5202  DISP_EOR_B  DC.B    '   EOR.B',0
000049BB= 20 20 20 45 4F 52 ...   5203  DISP_EOR_W  DC.B    '   EOR.W',0
000049C4= 20 20 20 45 4F 52 ...   5204  DISP_EOR_L  DC.B    '   EOR.L',0
000049CD= 20 20 20 43 4D 50 ...   5205  DISP_CMP_B  DC.B    '   CMP.B',0
000049D6= 20 20 20 43 4D 50 ...   5206  DISP_CMP_W  DC.B    '   CMP.W',0
000049DF= 20 20 20 43 4D 50 ...   5207  DISP_CMP_L  DC.B    '   CMP.L',0
000049E8= 20 20 20 43 4D 50 ...   5208  DISP_CMPA_W  DC.B    '   CMPA.W',0
000049F2= 20 20 20 43 4D 50 ...   5209  DISP_CMPA_L  DC.B    '   CMPA.L',0
000049FC= 20 20 20 4D 55 4C ...   5210  DISP_MULS_W DC.B    '   MULS.W',0
00004A06= 20 20 20 41 4E 44 ...   5211  DISP_AND_B  DC.B    '   AND.B',0
00004A0F= 20 20 20 41 4E 44 ...   5212  DISP_AND_W  DC.B    '   AND.W',0
00004A18= 20 20 20 41 4E 44 ...   5213  DISP_AND_L  DC.B    '   AND.L',0
00004A21= 20 20 20 41 44 44 ...   5214  DISP_ADD_B  DC.B    '   ADD.B',0
00004A2A= 20 20 20 41 44 44 ...   5215  DISP_ADD_W  DC.B    '   ADD.W',0
00004A33= 20 20 20 41 44 44 ...   5216  DISP_ADD_L  DC.B    '   ADD.L',0
00004A3C= 20 20 20 41 44 44 ...   5217  DISP_ADDA_W DC.B    '   ADDA.W',0
00004A46= 20 20 20 41 44 44 ...   5218  DISP_ADDA_L DC.B    '   ADDA.L',0
00004A50= 20 20 20 4C 53 52 ...   5219  DISP_LSR_B  DC.B    '   LSR.B',0
00004A59= 20 20 20 4C 53 4C ...   5220  DISP_LSL_B  DC.B    '   LSL.B',0
00004A62= 20 20 20 4C 53 52 ...   5221  DISP_LSR_W  DC.B    '   LSR.W',0
00004A6B= 20 20 20 4C 53 4C ...   5222  DISP_LSL_W  DC.B    '   LSL.W',0
00004A74= 20 20 20 4C 53 52 ...   5223  DISP_LSR_L  DC.B    '   LSR.L',0
00004A7D= 20 20 20 4C 53 4C ...   5224  DISP_LSL_L  DC.B    '   LSL.L',0
00004A86= 20 20 20 41 53 52 ...   5225  DISP_ASR_B  DC.B    '   ASR.B',0
00004A8F= 20 20 20 41 53 4C ...   5226  DISP_ASL_B  DC.B    '   ASL.B',0
00004A98= 20 20 20 41 53 52 ...   5227  DISP_ASR_W  DC.B    '   ASR.W',0
00004AA1= 20 20 20 41 53 4C ...   5228  DISP_ASL_W  DC.B    '   ASL.W',0
00004AAA= 20 20 20 41 53 52 ...   5229  DISP_ASR_L  DC.B    '   ASR.L',0
00004AB3= 20 20 20 41 53 4C ...   5230  DISP_ASL_L  DC.B    '   ASL.L',0
00004ABC= 20 20 20 52 4F 52 ...   5231  DISP_ROR_B  DC.B    '   ROR.B',0
00004AC5= 20 20 20 52 4F 4C ...   5232  DISP_ROL_B  DC.B    '   ROL.B',0
00004ACE= 20 20 20 52 4F 52 ...   5233  DISP_ROR_W  DC.B    '   ROR.W',0
00004AD7= 20 20 20 52 4F 4C ...   5234  DISP_ROL_W  DC.B    '   ROL.W',0
00004AE0= 20 20 20 52 4F 52 ...   5235  DISP_ROR_L  DC.B    '   ROR.L',0
00004AE9= 20 20 20 52 4F 4C ...   5236  DISP_ROL_L  DC.B    '   ROL.L',0
00004AF2= 20 20 20 42 52 41 00    5237  DISP_BRA    DC.B    '   BRA',0
00004AF9= 20 20 20 42 4C 54 00    5238  DISP_BLT    DC.B    '   BLT',0
00004B00= 20 20 20 42 45 51 00    5239  DISP_BEQ    DC.B    '   BEQ',0
00004B07= 20 20 20 42 4E 45 00    5240  DISP_BNE    DC.B    '   BNE',0
00004B0E= 20 20 20 42 48 49 00    5241  DISP_BHI    DC.B    '   BHI',0
00004B15= 20 20 20 4D 4F 56 ...   5242  DISP_MOVEA_W    DC.B    '   MOVEA.W',0
00004B20= 20 20 20 4D 4F 56 ...   5243  DISP_MOVEA_L    DC.B    '   MOVEA.L',0
00004B2B                          5244  
00004B2B= 20 20 20 24 00          5245  DISP_HEX     DC.B    '   $',0
00004B30= 20 20 20 44 00          5246  DISP_D  DC.B    '   D',0
00004B35= 20 20 20 41 00          5247  DISP_A  DC.B    '   A',0
00004B3A= 20 20 20 28 00          5248  DISP_OP  DC.B    '   (',0
00004B3F= 29 00                   5249  DISP_CP  DC.B   ')',0
00004B41= 20 20 20 28 41 00       5250  DISP_AOP  DC.B    '   (A',0
00004B47                          5251  
00004B47= 20 20 20 2D 28 41 00    5252  DISP_PRE    DC.B    '   -(A',0
00004B4E= 29 2B 00                5253  DISP_POST   DC.B    ')+',0
00004B51= 20 20 20 23 00          5254  DISP_LB DC.B    '   #',0
00004B56= 30 00                   5255  DISP_0  DC.B    '0',0
00004B58= 31 00                   5256  DISP_1  DC.B    '1',0
00004B5A= 32 00                   5257  DISP_2  DC.B    '2',0
00004B5C= 33 00                   5258  DISP_3  DC.B    '3',0
00004B5E= 34 00                   5259  DISP_4  DC.B    '4',0
00004B60= 35 00                   5260  DISP_5  DC.B    '5',0
00004B62= 36 00                   5261  DISP_6  DC.B    '6',0
00004B64= 37 00                   5262  DISP_7  DC.B    '7',0
00004B66                          5263  
00004B66                          5264  *STACK INTERFACE VARIABLES*
00004B66                          5265  COUNTER         DS.W    1
00004B68                          5266  QUEUE_COUNTER   DS.W    1
00004B6A                          5267  
00004B6A                          5268  *EA DECODING INTERFACE VARIABLES* 
00004B6A                          5269  DEST_REGISTER_FORMAT    DS.B    1           *all address modes acceptable standard
00004B6B                          5270  SRC_REGISTER_FORMAT  DS.B    1           *all address modes acceptable standard
00004B6C                          5271  TEMP_REGISTER_FORMAT    DS.B    1           *place holder for masking other register formats
00004B6D                          5272  
00004B6D                          5273  *FORMAT OF WHERE TO GET THE EA BY THE ENDING BIT AND STARTING BIT
00004B6D                          5274  * WORD + WORD = LONG
00004B6D                          5275  * (STARTING BIT) + (ENDING BIT) = 2 HEX CHAR
00004B6D                          5276  * A              + F            = AF         <= EXAMPLE
00004B6D                          5277  *(10TH BIT)      + (15TH BIT)   = CHECK BITS 15 THROUGH 10
00004B6D                          5278  GET_DST_START_END    DS.B    1
00004B6E                          5279  GET_SRC_START_END    DS.B    1
00004B6F                          5280  
00004B6F                          5281  *STORES THE START + END BITS HERE (FROM ABOVE)
00004B70                          5282  VAR_BYTE_START      DS.L    1
00004B74                          5283  VAR_BYTE_END        DS.L    1
00004B78                          5284  VAR_TEMP_CLEANCOPY  DS.L    1
00004B7C                          5285  
00004B7C                          5286  VAR_LONG_ADDRESS_MODE_CHECK        DS.L    1       *holds the bits 0-2 in long form
00004B80                          5287  
00004B80                          5288  *MORE FOR STACK USAGE*
00004B80= 2C 00                   5289  DISP_COMMA  DC.B    ',',0
00004B82= 20 20 20 00             5290  DISP_INDENT  DC.B    '   ',0
00004B86                          5291  
00004B86                          5292  *NEXT WORD POINTER: FOR IDENTIFING (xxx).W or (xxx).L*
00004B86                          5293  POINTER_WORD    DS.W       1
00004B88                          5294  
00004B88                          5295  
00004B88                          5296  
00004B88                          5297  *---------------------------------------------------------------------------*
00004B88                          5298  * Ends program
00004B88                          5299  *---------------------------------------------------------------------------*
00004B88                          5300              END    START                    * last line of source

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
ASC2HXLP            1156
ASC2HXLP2STACK      11BE
ASCII2HEX           1150
ASCII2HEX2STACK     11B8
ASC_ERR             11B2
ASC_ERR2STACK       121A
ASC_LOW             1194
ASC_LOW2STACK       11FC
ASC_NUM             11A4
ASC_NUM2STACK       120C
ASC_SFT             11AC
ASC_SFT2STACK       1214
ASC_UPP             119C
ASC_UPP2STACK       1204
CHECK0              3954
CHECK1              39DE
CHECK2              3A68
CHECK3              3B02
CHECK4              3BA4
CHECK7              3C46
CHECK_IMMEDIATE     3D26
CHECK_LONG          3CD8
CHECK_WORD          3C92
CLEAR_RETURN        425C
CLEAR_STACK         424C
COUNTER             4B66
CR                  D
DECREMENT           4244
DEST_CHECK0         3D84
DEST_CHECK1         3E0E
DEST_CHECK2         3E98
DEST_CHECK3         3F32
DEST_CHECK4         3FD4
DEST_CHECK7         4076
DEST_CHECK_IMMEDIATE  4156
DEST_CHECK_LONG     4108
DEST_CHECK_WORD     40C2
DEST_LOOP_SHIFTING  3DEE
DEST_LOOP_SHIFTING1  3E78
DEST_LOOP_SHIFTING2  3F0A
DEST_LOOP_SHIFTING3  3FA4
DEST_LOOP_SHIFTING4  404E
DEST_LOOP_SHIFTING7  40AE
DEST_MASKING_NEXT   3DFC
DEST_MASKING_NEXT1  3E86
DEST_MASKING_NEXT2  3F18
DEST_MASKING_NEXT3  3FB2
DEST_MASKING_NEXT4  405C
DEST_MASKING_NEXT7  40BC
DEST_MODE           350C
DEST_REGISTER       37DC
DEST_REGISTER_FORMAT  4B6A
DISPLAY_30_LINES    1366
DISP_0              4B56
DISP_1              4B58
DISP_2              4B5A
DISP_3              4B5C
DISP_4              4B5E
DISP_5              4B60
DISP_6              4B62
DISP_7              4B64
DISP_A              4B35
DISP_ADDA_L         4A46
DISP_ADDA_W         4A3C
DISP_ADDQ_B         493F
DISP_ADDQ_L         4953
DISP_ADDQ_W         4949
DISP_ADD_B          4A21
DISP_ADD_L          4A33
DISP_ADD_W          4A2A
DISP_AND_B          4A06
DISP_AND_L          4A18
DISP_AND_W          4A0F
DISP_AOP            4B41
DISP_ASL_B          4A8F
DISP_ASL_L          4AB3
DISP_ASL_W          4AA1
DISP_ASR_B          4A86
DISP_ASR_L          4AAA
DISP_ASR_W          4A98
DISP_BEQ            4B00
DISP_BHI            4B0E
DISP_BLT            4AF9
DISP_BNE            4B07
DISP_BRA            4AF2
DISP_BTST           4892
DISP_CMPA_L         49F2
DISP_CMPA_W         49E8
DISP_CMPI_B         489A
DISP_CMPI_L         48AE
DISP_CMPI_W         48A4
DISP_CMP_B          49CD
DISP_CMP_L          49DF
DISP_CMP_W          49D6
DISP_COMMA          4B80
DISP_CP             4B3F
DISP_D              4B30
DISP_DATA           48B8
DISP_DIVS           495D
DISP_EORI_B         4874
DISP_EORI_L         4888
DISP_EORI_W         487E
DISP_EOR_B          49B2
DISP_EOR_L          49C4
DISP_EOR_W          49BB
DISP_HEX            4B2B
DISP_INDENT         4B82
DISP_JSR            48E5
DISP_LB             4B51
DISP_LEA            4922
DISP_LSL_B          4A59
DISP_LSL_L          4A7D
DISP_LSL_W          4A6B
DISP_LSR_B          4A50
DISP_LSR_L          4A74
DISP_LSR_W          4A62
DISP_MOVEA_L        4B20
DISP_MOVEA_W        4B15
DISP_MOVEM_L        4934
DISP_MOVEM_W        4929
DISP_MOVE_B         48C0
DISP_MOVE_L         48D4
DISP_MOVE_W         48CA
DISP_MULS_W         49FC
DISP_NEG_B          48EC
DISP_NEG_L          48FE
DISP_NEG_W          48F5
DISP_NEXT           4605
DISP_NOT_B          4907
DISP_NOT_L          4919
DISP_NOT_W          4910
DISP_OP             4B3A
DISP_ORI_B          4859
DISP_ORI_L          486B
DISP_ORI_W          4862
DISP_POST           4B4E
DISP_PRE            4B47
DISP_ROL_B          4AC5
DISP_ROL_L          4AE9
DISP_ROL_W          4AD7
DISP_ROR_B          4ABC
DISP_ROR_L          4AE0
DISP_ROR_W          4ACE
DISP_RTS            48DE
DISP_SUBA_L         49A8
DISP_SUBA_W         499E
DISP_SUBI_B         4980
DISP_SUBI_L         4994
DISP_SUBI_W         498A
DISP_SUB_B          4965
DISP_SUB_L          4977
DISP_SUB_W          496E
D_MODE000           35AE
D_MODE010           35F6
D_MODE011           3656
D_MODE100           3676
D_MODE111           36C8
EA_ARITH            34A6
EA_DATA             1776
EA_GEN              34F2
EA_MOVEA            34CC
EA_NOSRC            3492
ENDLINE_M           47B6
END_ADDR            109C
ERRMSG_1            469D
ERRMSG_3            46BC
ERRMSG_5            46E1
ERROR_1             1100
ERROR_2             1110
ERROR_3             1120
ERROR_4             1130
ERROR_5             1140
E_ADDR_HX           47B2
FINMSG              4672
GET_DISPLACEMENT_ADDRESS  425E
GET_DISPLACEMENT_LONG  42A8
GET_DISPLACEMENT_WORD  4290
GET_DST_FAILED      419C
GET_DST_START_END   4B6D
GET_DST_SUCCESS     41A0
GET_EA_EA_DEST      3D72
GET_EA_EA_SRC       3942
GET_SRC_FAILED      3D6C
GET_SRC_START_END   4B6E
GET_SRC_SUCCESS     3D70
HEX2ASCII           1220
HEX2ASCII2STACK     1262
HEX_CHAR            124E
HEX_CONT            1252
HEX_LOOP            1234
IMMD_B              377C
IMMD_L              37BC
IMMD_W              379C
IMMEDIATE           374C
INCREMENT           423C
INTRO               1028
IS_ODD              12A6
IS_ODD_ERR          12BC
JMPTABLE            1392
LF                  A
LONGMODE            3720
LOOP_SHIFTING       39BE
LOOP_SHIFTING1      3A48
LOOP_SHIFTING2      3ADA
LOOP_SHIFTING3      3B74
LOOP_SHIFTING4      3C1E
MAIN                12C2
MASKING_NEXT        39CC
MASKING_NEXT1       3A56
MASKING_NEXT2       3AE8
MASKING_NEXT3       3B82
MASKING_NEXT4       3C2C
MODE000             359A
MODE001             35C2
MODE010             35D6
MODE011             3616
MODE100             3636
MODE111             3696
NEXTLINES           1374
OP0000              13F2
OP0000_BTST_B       155C
OP0000_CMPI         179E
OP0000_CMPI_B       1814
OP0000_CMPI_L       1864
OP0000_CMPI_W       183C
OP0000_EOR_B        160A
OP0000_EOR_L        163A
OP0000_EOR_W        1622
OP0000_ORI_B        18F8
OP0000_ORI_L        1948
OP0000_ORI_W        1920
OP0000_RETURN_BTST  158C
OP0000_RETURN_CMPI  1888
OP0000_RETURN_EOR   164E
OP0000_RETURN_ORI   196C
OP0000_RETURN_SUBI  1730
OP0000_SUB_B        16EC
OP0000_SUB_L        171C
OP0000_SUB_W        1704
OP0001              196E
OP0010              19DC
OP0011              1ADA
OP0100              1BD6
OP0101              1E2C
OP0101_ADDQ_B       1EA8
OP0101_ADDQ_B_0     1F24
OP0101_ADDQ_B_1     1F30
OP0101_ADDQ_B_2     1F3C
OP0101_ADDQ_B_3     1F48
OP0101_ADDQ_B_4     1F54
OP0101_ADDQ_B_5     1F60
OP0101_ADDQ_B_6     1F6C
OP0101_ADDQ_B_7     1F78
OP0101_ADDQ_B_8     1F84
OP0101_ADDQ_L       1EC0
OP0101_ADDQ_W       1EB4
OP0101_RETURN       1EC8
OP0101_RETURN2      1F8C
OP0110              1FD0
OP0111              20D6
OP1000              20DA
OP1000_DIVS_DN_EA_OR_EA_DN  20E8
OP1000_DIVS_RETURN  21CC
OP1000_EA_DN_DIVS   2116
OP1000_PRINT_L_DIVS  2184
OP1000_PRINT_W_DIVS  213C
OP1001              21E2
OP1001_ADD_RETURN   2530
OP1001_DETERMINE_DN_EA_OR_EA_DN  22F8
OP1001_DN_EA        2330
OP1001_EA_DN        2430
OP1001_PRINT_B      2458
OP1001_PRINT_B2     2358
OP1001_PRINT_L      24E8
OP1001_PRINT_L2     23E8
OP1001_PRINT_W      24A0
OP1001_PRINT_W2     23A0
OP1001_SUBA_L       2214
OP1001_SUBA_W       2286
OP1010              259E
OP1011              25A2
OP1011_CMP          25FC
OP1011_CMPA         26AE
OP1011_CMPA_L       2728
OP1011_CMPA_W       271C
OP1011_CMP_B        2670
OP1011_CMP_L        2688
OP1011_CMP_W        267C
OP1011_EOR          274E
OP1011_EOR_B        27C2
OP1011_EOR_L        27DA
OP1011_EOR_W        27CE
OP1011_RETURN       27E2
OP1011_RETURN_CMP   2690
OP1011_RETURN_CMPA  2730
OP1100              28A2
OP1100_AND_RETURN   2BF2
OP1100_DETERMINE_DN_EA_OR_EA_DN  29B8
OP1100_DN_EA        29F2
OP1100_EA_DN        2AF2
OP1100_EA_DN_MULS   2900
OP1100_MULS_DN_EA_OR_EA_DN  28D2
OP1100_MULS_RETURN  29B6
OP1100_PRINT_B      2B1A
OP1100_PRINT_B2     2A1A
OP1100_PRINT_L      2BAA
OP1100_PRINT_L2     2AAA
OP1100_PRINT_L_MULS  296E
OP1100_PRINT_W      2B62
OP1100_PRINT_W2     2A62
OP1100_PRINT_W_MULS  2926
OP1101              2BF4
OP1101_ADDA_L       2C26
OP1101_ADDA_W       2C98
OP1101_ADD_RETURN   2F42
OP1101_DETERMINE_DN_EA_OR_EA_DN  2D0A
OP1101_DN_EA        2D42
OP1101_EA_DN        2E42
OP1101_PRINT_B      2E6A
OP1101_PRINT_B2     2D6A
OP1101_PRINT_L      2EFA
OP1101_PRINT_L2     2DFA
OP1101_PRINT_W      2EB2
OP1101_PRINT_W2     2DB2
OP1110              2FD0
OP1110_RETURN       3048
OP1111              348E
OP_ADDA_L           2FB8
OP_ADDA_W           2FA0
OP_ADDQ_B           1F9A
OP_ADDQ_L           1FBE
OP_ADDQ_W           1FAC
OP_ADD_B            2F58
OP_ADD_L            2F88
OP_ADD_W            2F70
OP_ASX              3264
OP_ASX_0            33D8
OP_ASX_1            33E4
OP_ASX_2            33F0
OP_ASX_3            33FC
OP_ASX_4            3408
OP_ASX_5            3414
OP_ASX_6            3420
OP_ASX_7            342C
OP_ASX_8            3438
OP_ASX_AFTER_IMMEDIATE  3440
OP_ASX_B            32E0
OP_ASX_CHECK_FORMAT  32EC
OP_ASX_DIR          329A
OP_ASX_INTERMEDIATE  334E
OP_ASX_L            32C8
OP_ASX_MEMORY       3452
OP_ASX_R            3292
OP_ASX_REGISTER     32FE
OP_ASX_RETURN       347A
OP_ASX_W            32D4
OP_BEQ              2064
OP_BHI              2018
OP_BLT              20B0
OP_BNE              203E
OP_BRA              208A
OP_BTST             147C
OP_BTST_IMMEDIATE   1506
OP_CMPA_L           2812
OP_CMPA_W           2800
OP_CMP_B            2824
OP_CMP_L            2854
OP_CMP_W            283C
OP_DATA             1752
OP_DIVS             21CE
OP_EORI             158E
OP_EOR_B            286C
OP_EOR_L            2890
OP_EOR_W            287E
OP_JSR              1DFE
OP_LEA              1C84
OP_LEA_DN_EA_OR_EA_DN  1C92
OP_LEA_RETURN       1CF0
OP_LSX              304A
OP_LSX_0            31BE
OP_LSX_1            31CA
OP_LSX_2            31D6
OP_LSX_3            31E2
OP_LSX_4            31EE
OP_LSX_5            31FA
OP_LSX_6            3206
OP_LSX_7            3212
OP_LSX_8            321E
OP_LSX_AFTER_IMMEDIATE  3226
OP_LSX_B            30C6
OP_LSX_CHECK_FORMAT  30D2
OP_LSX_DIR          3080
OP_LSX_INTERMEDIATE  3134
OP_LSX_L            30AE
OP_LSX_MEMORY       3238
OP_LSX_R            3078
OP_LSX_REGISTER     30E4
OP_LSX_RETURN       3260
OP_LSX_W            30BA
OP_MOVEA_L          1A6A
OP_MOVEA_W          1B66
OP_MOVEM_L          1C72
OP_MOVEM_W          1C60
OP_MOVE_B           1974
OP_MOVE_L           1A02
OP_MOVE_W           1AFE
OP_MULS             28C4
OP_NEG              1CF2
OP_NEG_B            1D3E
OP_NEG_L            1D56
OP_NEG_PRINT_EA     1D62
OP_NEG_W            1D4A
OP_NOT              1D78
OP_NOT_B            1DC4
OP_NOT_L            1DDC
OP_NOT_PRINT_EA     1DE8
OP_NOT_W            1DD0
OP_ORI              188A
OP_PRINT_L_LEA      1CB0
OP_ROX              347E
OP_RTS              1E12
OP_SUBA_L           258C
OP_SUBA_W           257A
OP_SUBI             1670
OP_SUB_B            2532
OP_SUB_L            2562
OP_SUB_W            254A
OUTPUT_PROCESSED_DATA  1346
POINTER_WORD        4B86
POP_FRONT           41F6
POP_FRONT_RETURN    4230
POP_RETURN          41F4
POP_SHIFT_LOOP      4212
POP_STACK           41E8
PRINT_QUEUE         41BC
PRINT_QUEUE_HELPER  41C8
PRINT_QUEUE_RETURN  41DE
PRINT_STACK         41A2
PRINT_STACK_HELPER  41AE
PRINT_STACK_RETURN  41BA
PROGLP              100A
PROMPT_END          45D8
PROMPT_START        45A9
PUSH_STACK          41E0
QUEUE_COUNTER       4B68
REG_0               3890
REG_1               389E
REG_2               38AC
REG_3               38BA
REG_4               38C8
REG_5               38D6
REG_6               38E4
REG_7               38F2
REPEAT              3900
REPEATMSG           462F
RETURN              11B6
RETURN2STACK        121E
SRC_LOOP_SHIFTING   3C7E
SRC_MASKING_NEXT    3C8C
SRC_MODE            3550
SRC_REGISTER        3838
SRC_REGISTER_FORMAT  4B6B
STACK               7000
STACK_HEX_CHAR      1290
STACK_HEX_CONT      1294
STACK_HEX_LOOP      1276
START               1004
START_ADDR          104A
S_ADDR_HX           47AE
TEMP_REGISTER_FORMAT  4B6C
TERMINATE           42C2
TESTING             1036
TMPINPUT            47B9
TMPOUTPUT           4809
VAR_BYTE_END        4B74
VAR_BYTE_START      4B70
VAR_LONG_ADDRESS_MODE_CHECK  4B7C
VAR_TEMP_CLEANCOPY  4B78
VR_E_ADDR           475E
VR_S_ADDR           470E
WELCOME             42D4
WORDMODE            36F4
